import
	collection.mut-set: add has? new-mut-set
	io.net.tcp-server: close-client start-tcp-server stop
	io.print: print
	io.process: exit-code
	posix.errno: errno
	posix.extra-types: fd-t
	posix.stdio: perror
	posix.unistd: write
	sys.epoll: epoll-event

main fut exit-code(args arr str) unsafe summon
	assert: args.size == 1
	port = args at 0

	assert: size-of<epoll-event> == 12

	closed-clients = new-mut-set<fd-t>

	| WARN: Leaks memory if server is not stopped.
	server = port start-tcp-server \client-fd chunk
		if closed-clients has? client-fd not
			s = chunk as-str
			print: "got chunk (" + chunk.size.to-str + " bytes) on " + client-fd.to-str
			drop: s
			| TODO: this actually does not belong here..
			response = ok-response
			wrote = client-fd write response.data.ptr-cast<byte, char>, response.size
			if wrote == -1
				print: "ERRNO IS: " + errno.to-str
				perror: "WRITE ERR\0".data

			print: "WROTE: " + wrote.to-str + " bytes to " + client-fd.to-str
			print: "Response size: " + response.size.to-str
			assert: wrote == response.size.to-int
			client-fd close-client
			print: "Closed client on " + client-fd.to-str
			closed-clients add client-fd
		else
			print: "ignoring chunk from closed client " + client-fd.to-str
		void resolved

	print: "will stop after 10 seconds"
	ignore-me <- 10000 delay-msec
	drop: ignore-me
	print: "stopping..."
	ignore-me-2 <- server.stop call-ref
	drop: ignore-me-2
	print: "done"
	0 resolved

ok-response str() noctx
	"HTTP/1.1 200 OK Feelin' Fine\nShoop: Da Woop\n\nHello, internet world!\n"
