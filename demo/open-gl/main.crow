import
	crow/cell: *, as-const-ptr, as-mut-ptr, cell, new
	crow/col/private/arr-low-level: begin-ptr, subscript
	crow/c-types: c-int
	crow/io/duration: msec
	crow/io/print: out, print
	crow/col/iter: again, again-or-stop, stop
	crow/io/time: get-monotime-msec, repeat-interval
	crow/math/mat: *, I, mat3-32, rotation, to-array
	crow/math/trig: pi
	crow/math/vec: +, -, *, new, right, up, vec2-32, vec3-32
	crow/private/runtime: cur-thread-id
	crow/ptr: ==, as-any-const-ptr, to-const-ptr, null, ptr-cast, size-of
	OpenGL/gl:
		glActiveTexture, glBindBuffer, glBindTexture, glBufferData, glBufferSubData, glClear,
		glClearColor, glCullFace, glDeleteBuffers, glDrawArrays, glEnable,
		glEnableVertexAttribArray, gl-ext, glGenBuffers, glGetError, glGetUniformLocation,
		glUniform1i, glUniformMatrix3fv, glUseProgram, glVertexAttribPointer, new
	OpenGL/headers:
		==, GL_ARRAY_BUFFER, GL_BACK, GL_COLOR_BUFFER_BIT, GL_CULL_FACE, GL_FLOAT, GLint,
		GL_NO_ERROR, GL_STATIC_DRAW, GL_TEXTURE0, GL_TEXTURE_2D, GL_TRIANGLES, GLuint, to-str
	SDL2/SDL:
		SDL_GetError, SDL_Init, SDL_INIT_VIDEO, SDL_Quit
	SDL2/SDL_events:
		==, SDL_Event, SDL_PollEvent, SDL_PumpEvents, SDL_Quit, type
	SDL2/SDL_keyboard: SDL_GetKeyboardState
	SDL2/SDL_scancode: SDL_NUM_SCANCODES, SDL_SCANCODE_RETURN, to-nat32
	SDL2/SDL_video:
		|, SDL_CreateWindow, SDL_DestroyWindow, SDL_GL_CONTEXT_PROFILE_ES, SDL_GL_CreateContext,
		SDL_GL_DeleteContext, SDL_GL_DOUBLEBUFFER, SDL_GL_CONTEXT_MAJOR_VERSION,
		SDL_GL_CONTEXT_MINOR_VERSION, SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_LoadLibrary,
		SDL_GL_SetAttribute, SDL_GL_SwapWindow, SDL_Window, SDL_WINDOW_OPENGL,
		SDL_WINDOWPOS_UNDEFINED, SDL_WINDOW_SHOWN, to-int32
	./shader: shader-prog-destroy, shader-prog-load
	./texture: load-texture-from-bmp, free-texture
	./crow.bmp as crow-bmp arr nat8
	./fragment.frag.essl as fragment-shader str
	./vertex.vert.essl as vertex-shader str

main fut nat(_ arr str) summon trusted
	SDL_INIT_VIDEO.SDL_Init handle-sdl-error "SDL_INIT_VIDEO"

	# TODO: is this redundant?
	# This should be done after initializing the video driver, but before creating any OpenGL windows.
	if false
		"C:\\Windows\\System32\\opengl32.dll" .SDL_GL_LoadLibrary handle-sdl-error "SDL_GL_LoadLibrary"
	# Same bad results as the builtin driver..
	#if false
	#	"C:\\Users\\User\\code\\crow\\opengl32.dll".SDL_GL_LoadLibrary handle-sdl-error "SDL_GL_LoadLibrary"

	SDL_GL_CONTEXT_PROFILE_MASK SDL_GL_SetAttribute SDL_GL_CONTEXT_PROFILE_ES.to-int32 handle-sdl-error "set GL ES"
	SDL_GL_CONTEXT_MAJOR_VERSION SDL_GL_SetAttribute 3 handle-sdl-error "set major version"
	SDL_GL_CONTEXT_MINOR_VERSION SDL_GL_SetAttribute 0 handle-sdl-error "set minor version"
	SDL_GL_DOUBLEBUFFER SDL_GL_SetAttribute 1 handle-sdl-error "set double buffer"

	wflags = SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN
	window = "crube" SDL_CreateWindow SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 960, 720, wflags
	if window.as-any-const-ptr == null
		"SDL_CreateWindow" fail-sdl-error

	context = window SDL_GL_CreateContext
	if context.as-any-const-ptr == null
		"SDL_GL_CreateContext" fail-sdl-error

	gl gl-ext = ()
	shader-prog = gl shader-prog-load vertex-shader, fragment-shader

	gl gl-check-error "after shader-prog"
	gl glUseProgram shader-prog

	tex-sampler-uniform-loc = gl glGetUniformLocation shader-prog, "texSampler"
	gl gl-check-error "after tex-sampler-uniform-loc"
	assert tex-sampler-uniform-loc >= 0
	gl glUniform1i tex-sampler-uniform-loc, 0
	gl gl-check-error "after glUniform1i"

	rotation-uniform-loc = gl glGetUniformLocation shader-prog, "rotation"
	gl gl-check-error "after rotation-uniform-loc"
	assert tex-sampler-uniform-loc >= 0
	gl glUniform1i tex-sampler-uniform-loc, 0
	gl gl-check-error "after glUniform1i"
	gl glUniformMatrix3fv rotation-uniform-loc, 1, false, I::mat3-32.to-array.begin-ptr
	gl gl-check-error "after set rotation-uniform-loc"

	texture = gl load-texture-from-bmp crow-bmp.to-list

	vertices arr vertex = make-cube
	triangle-vbo = gl vbo-create vertices
	forbid triangle-vbo == 0

	renderer renderer = gl, cur-thread-id, window, shader-prog, vertices, triangle-vbo, texture, rotation-uniform-loc
	renderer set-up-renderer

	<- 25.msec repeat-interval () => renderer main-loop-body

	# SDL_DestroyWindow hangs on Windows if called from a different thread
	renderer.render-thread-id run-with-thread-id () =>
		# TODO: use 'finally'
		gl free-texture texture
		gl vbo-free triangle-vbo
		gl shader-prog-destroy shader-prog
		context SDL_GL_DeleteContext
		window SDL_DestroyWindow
		SDL_Quit
		()

.make-cube arr vertex()
	front = I.cube-side ~~ (up rotation pi / 2 cube-side) ~~ (right rotation pi / 2 cube-side)
	back vertex[] = () join for xs : front groups-of 3
		# Change order so that the triangles have reverse winding
		xs[1].invert, xs[0].invert, xs[2].invert
	for v : front ~~ back to-array
		v.pos, v.normal, (v.pos + (1, 1, 1)) * 0.5, v.tex-coord

.cube-side vertex[](mat mat3-32)
	t0 vec2-32 = 0.0, 1.0
	t1 vec2-32 = 1.0, 1.0
	t2 vec2-32 = 0.0, 0.0
	t3 vec2-32 = 1.0, 0.0
	n vec3-32 = 0, 0, -1
	black vec3-32 = 0, 0, 0
	dl vertex = (-1, -1, -1), n, black, t0
	dr vertex = (1, -1, -1), n, black, t1
	ul vertex = (-1, 1, -1), n, black, t2
	ur vertex = (1, 1, -1), n, black, t3
	(dl, dr, ul, ul, dr, ur) apply mat

.apply vertex[](a vertex[], m mat3-32)
	for x : a
		m * x.pos, m * x.normal, x.color, x.tex-coord

.vertex record extern by-val
	pos vec3-32
	normal vec3-32
	color vec3-32
	tex-coord vec2-32

.invert vertex(a vertex)
	-a.pos, -a.normal, a.color, a.tex-coord

.renderer record mut
	gl gl-ext
	# OpenGL only allows renders on the same thread.
	render-thread-id nat
	window SDL_Window
	shader-prog GLuint
	vertices arr vertex
	triangle-vbo GLuint
	texture GLuint
	rotation-uniform-loc GLint

.set-up-renderer void(renderer renderer) unsafe summon
	gl = renderer gl
	gl glEnable GL_CULL_FACE
	gl glCullFace GL_BACK

	gl glUseProgram renderer.shader-prog

	gl glBindBuffer GL_ARRAY_BUFFER, renderer.triangle-vbo
	gl glBufferSubData GL_ARRAY_BUFFER, 0, renderer.vertices.size-bytes.to-int64, renderer.vertices.begin-ptr.ptr-cast
	stride = size-of@<vertex> to-int32
	# pos
	gl glVertexAttribPointer 0, 3, GL_FLOAT, false, stride, 0.to-const-ptr
	gl glEnableVertexAttribArray 0
	# normal
	# TODO: should not need parentheses
	gl glVertexAttribPointer 1, 3, GL_FLOAT, false, stride, (size-of@<vec3-32>).to-const-ptr
	gl glEnableVertexAttribArray 1
	# color
	gl glVertexAttribPointer 2, 3, GL_FLOAT, false, stride, (2 * size-of@<vec3-32>).to-const-ptr
	gl glEnableVertexAttribArray 2
	# tex-coord
	gl glVertexAttribPointer 3, 2, GL_FLOAT, false, stride, (3 * size-of@<vec3-32>).to-const-ptr
	gl glEnableVertexAttribArray 3

	gl glActiveTexture GL_TEXTURE0
	gl glBindTexture GL_TEXTURE_2D, renderer.texture

.main-loop-body fut again-or-stop(renderer renderer) summon trusted
	SDL_PumpEvents
	if look-for-quit-event
		stop,
	else
		key-states-ptr = null SDL_GetKeyboardState
		key-states = key-states-ptr[0 .. SDL_NUM_SCANCODES.to-nat32.to-nat64]
		if key-states[SDL_SCANCODE_RETURN.to-nat32 to-nat64] != 0
			out print "return is pressed"
		<- renderer.render-thread-id run-with-thread-id () =>
			renderer render
		again,
.render void(renderer renderer) summon unsafe
	gl = renderer gl
	gl glClearColor 0.5, 0.5, 0.5, 1
	gl glClear GL_COLOR_BUFFER_BIT

	t = get-monotime-msec.to-float32 * 0.0003::float32
	mat mat3-32 = (0.5::float32) * ((1, 2, 3) rotation t)
	gl glUniformMatrix3fv renderer.rotation-uniform-loc, 1, false, mat.to-array.begin-ptr

	gl glDrawArrays GL_TRIANGLES, 0, renderer.vertices.size.to-int32
	gl gl-check-error "after render"

	renderer.window SDL_GL_SwapWindow

.run-with-thread-id<a> fut a(thread-id nat, cb act a()) unsafe is-sendable<a>
	if cur-thread-id == thread-id
		cb[],
	else
		<- delay
		thread-id run-with-thread-id cb

.look-for-quit-event bool() summon
	e = SDL_Event
	e.SDL_PollEvent != 0 && (e.type == SDL_Quit || look-for-quit-event)

.handle-sdl-error void(err c-int, description str) summon trusted
	unless err == 0
		description fail-sdl-error

.fail-sdl-error void(description str) summon trusted
	throw "sdl error in {description}: {SDL_GetError}"
	SDL_Quit

.vbo-create GLuint(gl gl-ext, vertices arr vertex) summon unsafe
	vbo-cell cell GLuint = 0,
	n-buffers = 1 to-int32
	gl glGenBuffers n-buffers, vbo-cell.as-mut-ptr
	vbo = *vbo-cell
	gl glBindBuffer GL_ARRAY_BUFFER, vbo
	gl glBufferData GL_ARRAY_BUFFER, vertices.size-bytes.to-int64, vertices.begin-ptr.ptr-cast, GL_STATIC_DRAW
	gl glBindBuffer GL_ARRAY_BUFFER, 0
	err = gl glGetError
	unless err == GL_NO_ERROR
		gl glDeleteBuffers n-buffers, vbo-cell.as-const-ptr
		throw "Creating VBO failed: Code {err}"
	vbo

size-bytes nat(vertices arr vertex) unsafe
	vertices.size * size-of@<vertex>

.vbo-free void(gl gl-ext, vbo GLuint) summon unsafe
	gl glDeleteBuffers 1, &vbo

.gl-check-error void(gl gl-ext, desc str) summon
	err = gl glGetError
	assert err == GL_NO_ERROR : "Gl error at {desc}: code {err}"
