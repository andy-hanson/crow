import
	io: check-errno-if-not-zero connect-to-uri exit-code print uri
	openssl
		err-clear-error openssl-init-ssl ssl ssl-connect ssl-ctx ssl-ctx-new ssl-load-error-strings
		ssl-new ssl-set-fd tls-client-method
	posix: fd-t sigignore sigpipe

main fut exit-code(args arr str) summon
	print: "Hello ya world!"
	test-uri
	0 resolved

test-uri void() summon
	my-uri = "https://www.duckduckgo.com:80/some-thing"
	match my-uri parse-uri
	as none
		print: "did not parse"
	as some s
		uri = s.value
		uri test-get
		| print: "host: " + uri.host
		| print: "path and query: " + uri.path-and-query
		| print: "port: " + uri.port.to-str

split-with-splitter<?t> record
	before arr ?t
	at ?t
	after arr ?t

split<?t> record
	before arr ?t
	after arr ?t

| TODO: ->UTILS
split-at-first opt split-with-splitter<?t>(a arr ?t, pred fun-mut1 bool ?t)
	idx <- a find-index pred
	| TODO: parens should be unnecessary
	some: split-with-splitter<?t>: (a slice-up-to idx), (a at idx), (a slice-after idx)

| If splitter is not present, right part is empty
try-split split ?t(a arr ?t, pred fun-mut1 bool ?t)
	match a find-index pred
	as none
		split<?t>: a, empty-arr
	as some s
		idx = s.value
		split<?t>: (a slice-up-to idx), (a slice-after idx)

| If splitter is not present, right part is empty
try-split-from-right split ?t(a arr ?t, pred fun-mut1 bool ?t)
	match a find-rindex pred
	as none
		split<?t>: a, empty-arr
	as some s
		index = s.value
		split<?t>: (a slice-up-to index), (a slice-after index)

| nghttp2-session-callbacks-new foo() extern<"nghttp2_session_callbacks_new"> noctx summon
| nghttp2-session-client-new foo() extern<"nghttp2_session_client"> noctx summon
| nghttp2-session-callbacks-del foo() extern<"nghttp2_session_callbacks_del"> noctx summon
| nghttp2-submit-settings foo() extern<"nghttp2_submit_settings"> noctx summon
| nghttp2-session-want-read foo() extern<"nghttp2_session_want_read"> noctx summon
| nghttp2-session-want-write foo() extern<"nghttp2_session_want_write"> noctx summon
| nghttp2-session-del foo() extern<"nghttp2_session_del"> noctx summon



request record mut
	host c-str
	path c-str
	hostport c-str
	stream-id int32
	port nat16

test-get void(u uri) trusted summon
	| act = zero as<by-val<sigaction>>
	| act = new<by-val<sigaction>>
	|	sa-handler. sig-ign
	|	sa-flags. zero
	|	sa-restorer. null
	|	sa-mask. zero
	| sigpipe act

	| Ignore SIGPIPE errors (WARN: This has a global effect!)
	check-errno-if-not-zero: sigpipe sigignore

	| ssl-load-error-strings
	i = openssl-init-ssl: 0, null.as-ref
	assert: i == 0

	fd = u connect-to-uri

	ssl-ctx = tls-client-method ssl-ctx-new
	forbid: ssl-ctx.as-any-ptr null?
	ssl = ssl-ctx ssl-new
	forbid: ssl.as-any-ptr null?

	ssl ssl-handshake fd

	todo

ssl-handshake void(ssl ssl, fd fd-t) summon
	err = ssl ssl-set-fd fd
	| TODO: handle errors
	forbid: err == 0
	err-clear-error
	rv = ssl ssl-connect
	| TODO: handle other return values
	assert: rv == 1



| ALGORITHM:
| eat 'https://'
| eat up to `:/?#`
| if saw `:`, eat up to `/`
| if saw `/`, eat up to `?`

| BETTER: do it in reverse
| Parse off '#' from right
| Parse off '?' from right
| Then parse the *first* '/'
| Then take a ':' from the left part
parse-uri opt uri(uri str)
	| Must start with https
	after-https <- uri try-remove-str-start "https://"

	host-and-port-split-path-and-query-and-hash = after-https try-split {it == "/"}
	host-and-port = host-and-port-split-path-and-query-and-hash before
	path-and-query-and-hash = host-and-port-split-path-and-query-and-hash after

	host-split-port = host-and-port try-split {it == ":"}
	host = host-split-port before
	port-str = host-split-port after
	port = port-str.literal as<nat16>

	path-and-query-split-after-hash = path-and-query-and-hash try-split-from-right {it == "#"}
	path-and-query = path-and-query-split-after-hash before
	after-hash = path-and-query-split-after-hash after

	| TODO: not bothering to split out query for now.

	some: uri: host, port, path-and-query, after-hash

try-remove-str-start opt str(a str, b str)
	if a starts-with? b
		a slice-starting-at b.size some
	else
		none
