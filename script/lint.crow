import
	crow/col/set: in, set, to-list, to-set
	crow/col/mut-set: ~=, for-loop, move-to-list, move-to-set, mut-set, new, to-mut-set, try-remove
	crow/io/file: read-file
	crow/io/print: err, print
	crow/io/process: shell-exec
	../site-src/search-dir-recursive: search-dir-recursive

main fut nat(_ array str) summon
	files = all-files
	failures = files lint-files
	for x : failures
		err print x
	failures.size,

.lint-files str[](files file[]) summon
	failures str mut[] = ()
	all-imports = files get-all-imports
	for file : files
		for public-export : file.members public
			unless public-export in all-imports || public-export in excluded-public
				failures ~= "{file path} export not used: {public-export}"
	for file : files
		for private-member : file.members private
			if file.uses[private-member]! < 2
				failures ~= "{file path} private member not used: {private-member}"
	for file : files
		failures lint-imports-in-file file
	failures move-to-list

.get-all-imports set sym(files file[])
	(for file : files; file.imports to-list).flatten to-set

.excluded-public sym[]()
	"derefConstantPointer", "diffSymbols", "main"

.file record
	path str
	members members
	imports set sym
	uses nat[sym]

.members record
	public sym[]
	private sym[]

all-files file[]() summon
	for path : "src" search-dir-recursive
		path get-file

.get-file file(path str) summon
	imports-and-rest = path.read-file find-imports
	path, path.get-members, imports-and-rest.imports, imports-and-rest.rest.get-uses

.get-members members(path str) summon
	stdout = "dub run dscanner -- --ctags {path}" shell-exec

	public mut-set sym = ()
	private mut-set sym = ()

	look-for = "!_TAG_PROGRAM_URL	https://github.com/dlang-community/D-Scanner/\n"
	rest = (stdout try-split-once look-for)!.b
	for line : rest lines
		unless line == "" || line contains-substr "enum:" || line contains-substr "struct:"
			name = line.try-split-once-by-whitespace!.a str-to-sym
			if line contains-substr "access:public"
				public ~= name
			elif line contains-substr "access:private"
				private ~= name
			else
				unless path == "src/wasm.d" || name in excluded-unknown-access
					throw "Unexpected non-public, non-private member {name} in {path}"

	public.move-to-list, private.move-to-list

# for some reason, dscanner doesn't give non-nested unions like Converter64 access:private
.excluded-unknown-access sym[]()
	"Converter32", "Converter64", "DCValue", "DoubleToUlong", "StackDict2Key", "StackDict2Value"

.imports-and-rest record
	imports set sym
	rest str

.find-imports imports-and-rest(a str)
	() find-imports-recur a, a
.find-imports-recur imports-and-rest(res mut-set sym, since-last-import str, a str)
	if pair ?= a try-split-once "import "
		if pair.a ends-with "\n" || pair.a ends-with "\n\t"
			rest = pair b
			after-colon = (rest try-split-once ":")!.b
			split-semi = (after-colon try-split-once ";")!
			for word : split-semi.a words
				res ~= word
			res find-imports-recur split-semi.b, split-semi.b
		else
			# This is an 'import' in a nested scope; don't count it
			# (since we want only imports at top of file, not later on)
			res find-imports-recur since-last-import, pair.b
	else
		res.move-to-set, since-last-import

.get-uses nat[sym](a str)
	res nat mut[sym] = ()
	for x : a words
		res[x] := (res[x] ?? 0) + 1
	res move-to-dict

words record
	inner str
.words words(a str)
	a,
.for-loop void(a words, cb act void(sym))
	word char8 mut[] = ()
	for x : a.inner char8s
		if x is-identifier-char
			word ~= x
		else
			unless word is-empty
				cb[word.move-to-list.str str-to-sym]
	unless word is-empty
		cb[word.move-to-list.str str-to-sym]

.is-identifier-char bool(a char8)
	"a"::char8 <= a && a <= "z" || "A"::char8 <= a && a <= "Z" || "0"::char8 <= a && a <= "9" || a == "_"

.lint-imports-in-file void(failures str mut[], a file)
	not-used = a.imports to-mut-set
	a.uses each-key x =>
		_ = not-used try-remove x
		()
	for x : not-used
		failures ~= "{a path}: unused import {x}"
