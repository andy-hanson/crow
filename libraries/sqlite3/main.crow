import
	crow/c-types: c-int
	./headers:
		==, |, enum-members, sqlite3-pointer, sqlite3_close, sqlite3_exec, sqlite3_free, SQLITE_OK,
		SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, sqlite3_open_v2

sqlite3 record force-sendable
	raw sqlite3-pointer

.open-sqlite3 record
	db-path string
open-sqlite3 open-sqlite3(db-path string)
	db-path,
with-block<a> a^(a open-sqlite3, cb ref a(sqlite3)) summon trusted is-sendable<a>
	db mut sqlite3-pointer = null::any-mut-pointer.pointer-cast-to-extern
	# Create empty file if not exist


	err = a.db-path.to-c-string sqlite3_open_v2 &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, null
	assert err == SQLITE_OK
	res <- cb[(db,)]
	err2 = db sqlite3_close
	assert err2 == SQLITE_OK
	res,

run void(db sqlite3, command string) summon
	for _, _ : db query command
		()

db-query record mut
	db sqlite3
	query string
query db-query(db sqlite3, query string)
	db, query

for-loop void(a db-query, f act void(string[], string[])) summon
	a query-internal (columns, values) =>
		f[columns, values]
		continue

for-loop<out> out[](a db-query, f act out(string[], string[])) summon
	with out : build-list
		for columns, values : a
			out ~= f[columns, values]

.query-internal void(a db-query, cb-row act break-or-continue void(string[], string[])) summon trusted
	error-message mut c-string = null
	ctx callback-ctx = cb-row,
	ctx-ptr = (&ctx)::callback-ctx* as-any-mut-pointer
	err = a.db.raw sqlite3_exec a.query.to-c-string, &callback, ctx-ptr, &error-message
	# TODO: if err == SQLITE_ABORT, callback returned non-0
	if err != SQLITE_OK
		error-string = error-message to-string
		error-message.as-any-mut-pointer sqlite3_free
		throw "ERROR {err.enum-to-string}: {error-string}"

.callback-ctx record by-val mut
	cb-row act break-or-continue void(string[], string[])

.callback c-int(ctx-pointer any-mut-pointer, argc c-int, argv c-string*, col-name c-string*) summon unsafe
	ctx callback-ctx = *(ctx-pointer.as-const.pointer-cast::callback-ctx*)
	column-names string[] = for i : 0 .. argc.to-nat64
		col-name[i] to-string
	values string[] = for i : 0 .. argc.to-nat64
		argv[i] to-string
	match ctx.cb-row[column-names, values]
	as loop-break _
		1
	as loop-continue
		0
