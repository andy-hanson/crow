import
	crow/col/iter: again, again-or-stop
	crow/col/mut-arr: ~=, move-to-list, mut-arr, new
	crow/c-types: c-int
	crow/ptr:
		*, any-mut-ptr, as-any-mut-ptr, as-const, const-ptr, null, ptr-cast, ptr-cast-to-extern,
		subscript
	crow/str-util: to-c-str, to-str
	./headers:
		==, |, enum-members, sqlite3-ptr, sqlite3_close, sqlite3_exec, sqlite3_free, SQLITE_OK,
		SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, sqlite3_open_v2

sqlite3 record force-sendable
	raw sqlite3-ptr

.open-sqlite3 record
	db-path str
open-sqlite3 open-sqlite3(db-path str)
	db-path,
with-block<a> fut a(a open-sqlite3, cb ref a(sqlite3)) summon trusted is-sendable<a>
	db mut sqlite3-ptr = null::any-mut-ptr.ptr-cast-to-extern
	# Create empty file if not exist


	err = a.db-path.to-c-str sqlite3_open_v2 &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, null
	assert err == SQLITE_OK
	res <- cb[(db,)]
	err2 = db sqlite3_close
	assert err2 == SQLITE_OK
	res,

query list<list<str>>(db sqlite3, command str) summon
	res list<str> mut[] = ()
	db run command, (_, values) =>
		res ~= values
		again
	res move-to-list

run void(db sqlite3, command str) summon
	db run command, (_, _) => again

###
cb takes column names and values for a single row.
###
run void(db sqlite3, command str, cb-row act again-or-stop(list str, list str)) summon trusted
	error-message mut c-str = null
	ctx callback-ctx = cb-row,
	err = db.raw sqlite3_exec command.to-c-str, &callback, (&ctx)::callback-ctx*.as-any-mut-ptr, &error-message
	# TODO: if err == SQLITE_ABORT, callback returned non-0
	if err != SQLITE_OK
		error-str = error-message to-str
		error-message.as-any-mut-ptr sqlite3_free
		throw "ERROR {err.enum-to-str}: {error-str}"

.callback-ctx record by-val mut
	cb-row act again-or-stop(list str, list str)

.callback c-int(ctx-ptr any-mut-ptr, argc c-int, argv c-str*, col-name c-str*) summon unsafe
	ctx callback-ctx = *(ctx-ptr.as-const.ptr-cast::callback-ctx*)
	column-names list str = for i : 0 .. argc.to-nat64
		col-name[i] to-str
	values list str = for i : 0 .. argc.to-nat64
		argv[i] to-str
	match ctx.cb-row[column-names, values]
	as again
		0
	as stop
		1
