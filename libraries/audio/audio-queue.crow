import
	crow/private/thread-utils: acquire, init, lock, release, uninit
	./audio: new, playing-sound
	./sound: ==, format, new, samples, sound, sound-format, to-string

audio-queue record force-sendable by-ref
	format sound-format
	.lock-by-val by-val lock
	# All sounds normalized to `format`
	.playing entry mut[]

.lock lock(a audio-queue) noctx unsafe
	&a.lock-by-val

new audio-queue(format sound-format) trusted
	res audio-queue = format, uninit, ()
	res.lock init
	res

.entry record by-ref force-sendable
	samples array float32
	cur mut float32*
	looping bool

.reset-position void(a entry)
	a.cur := a.samples begin-pointer

.is-over bool(a entry) noctx trusted
	!a.looping && a.cur == a.samples.end-pointer

clear void(a audio-queue) noctx trusted
	a.lock acquire
	a.playing clear
	a.lock release

play playing-sound(a audio-queue, sound sound)
	a play-common sound, false

play-loop playing-sound(a audio-queue, sound sound)
	a play-common sound, true

# This locks the queue, so make sure 'out' isn't huge
pull void(a audio-queue, out mut-array float32) noctx unsafe
	out fill 0
	a.lock acquire
	a.playing.begin-pointer each-playing a.playing.end-pointer, out
	a.lock release

.each-playing void(cur entry mut*, end entry mut*, out mut-array float32) noctx unsafe
	if cur != end
		*cur add-to out
		cur + 1 each-playing end, out
	else
		()

.add-to void(a entry, out mut-array float32) noctx unsafe
	n-remaining = a.samples.end-pointer - a.cur
	if n-remaining > out.size
		end = a.cur + out.size
		out add (a.cur .. end).as-array
		a.cur := end
	else
		out-mid = out.begin-pointer + n-remaining
		(out.begin-pointer .. out-mid).as-mut-array add (a.cur .. a.samples.end-pointer).as-array
		if a looping
			a.cur := a.samples begin-pointer
			a add-to (out-mid .. out.end-pointer).as-mut-array
		else
			a.cur := a.samples end-pointer

.add void(a mut-array float32, b array float32) noctx unsafe
	assert a.size == b.size
	out mut = a begin-pointer
	read mut = b begin-pointer
	until out == a.end-pointer
		*out := *out + *read
		out := out + 1
		read := read + 1
	assert read == b.end-pointer

.play-common playing-sound(a audio-queue, sound sound, looping bool) trusted
	assert sound.format == a.format : "sound format mismatch: expected {a format}, got {sound format}"
	a.lock acquire
	# Can't use 'set-filter' in 'noctx' code, so do it here
	a.playing.filter := x => !x.is-over
	entry entry = sound.samples, sound.samples.begin-pointer, looping
	a.playing ~= entry
	a.lock release
	reset fun void() = () =>
		entry reset-position 
	set-playing fun void(bool) = desired =>
		a set-playing entry, desired
	reset, set-playing

.set-playing void(a audio-queue, entry entry, desired bool) trusted
	a.lock acquire
	is-playing mut bool = false
	# Can't use 'set-filter' in 'noctx' code, so do it here
	a.playing.filter := x =>
		if x is-over
			false
		elif x ref-eq entry
			is-playing := true
			desired
		else
			true
	if desired && !is-playing
		a.playing ~= entry
	a.lock release

test
	format sound-format = 2, 44100
	a audio-queue = format,
	sound sound = format, (1, 2, 3, 4, 5, 6, 7, 8)
	buf mut-array float32 = 0, 0, 0
	a pull buf
	buf.to-array is (0, 0, 0)
	_ = a play sound
	a pull buf
	buf.to-array is (1, 2, 3)
	a pull buf
	buf.to-array is (4, 5, 6)
	a pull buf
	buf.to-array is (7, 8, 0)
	a pull buf
	buf.to-array is (0, 0, 0)
