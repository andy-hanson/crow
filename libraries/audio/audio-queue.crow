import
	crow/cell: *, cell, new, set-deref
	crow/col/mut-array: begin-ptr, end-ptr, fill, mut-array, mut-array-from-begin-end, new, size, to-array
	crow/col/private/array-low-level: array-from-begin-end, begin-ptr, end-ptr
	crow/private/thread-utils: acquire, init, lock, release, uninit
	crow/ptr: ==, +, -, *, by-val, const-ptr, mut-ptr, ref-eq, set-deref
	./audio: new, playing-sound
	./sound: ==, format, new, samples, sound, sound-format, to-str

audio-queue record force-sendable by-ref
	format sound-format
	.lock-by-val by-val lock
	# All sounds normalized to `format`
	.playing entry mut[]

.lock lock(a audio-queue) noctx unsafe
	&a.lock-by-val

new audio-queue(format sound-format) trusted
	res audio-queue = format, uninit, ()
	res.lock init
	res

.entry record by-ref force-sendable
	samples array float32
	cur mut float32*
	looping bool

.reset-position void(a entry)
	a.cur := a.samples begin-ptr

.is-over bool(a entry) noctx trusted
	!a.looping && a.cur == a.samples.end-ptr

clear void(a audio-queue) noctx trusted
	a.lock acquire
	a.playing clear
	a.lock release

play playing-sound(a audio-queue, sound sound)
	a play-common sound, false

play-loop playing-sound(a audio-queue, sound sound)
	a play-common sound, true

# This locks the queue, so make sure 'out' isn't huge
pull void(a audio-queue, out mut-array float32) noctx unsafe
	out fill 0
	a.lock acquire
	a.playing.begin-ptr each-playing a.playing.end-ptr, out
	a.lock release

.each-playing void(cur entry mut*, end entry mut*, out mut-array float32) noctx unsafe
	if cur != end
		*cur add-to out
		cur + 1 each-playing end, out
	else
		()

.add-to void(a entry, out mut-array float32) noctx unsafe
	n-remaining = a.samples.end-ptr - a.cur
	if n-remaining > out.size
		end = a.cur + out.size
		out add (a.cur array-from-begin-end end)
		a.cur := end
	else
		out-mid = out.begin-ptr + n-remaining
		out.begin-ptr mut-array-from-begin-end out-mid add (a.cur array-from-begin-end a.samples.end-ptr)
		if a looping
			a.cur := a.samples begin-ptr
			a add-to (out-mid mut-array-from-begin-end out.end-ptr)
		else
			a.cur := a.samples end-ptr

.add void(a mut-array float32, b array float32) noctx unsafe
	assert a.size == b.size
	a.begin-ptr add-recur a.end-ptr, b.begin-ptr
.add-recur void(out float32 mut*, out-end float32 mut*, read float32*) noctx unsafe
	unless out == out-end
		*out := *out + *read
		out + 1 add-recur out-end, read + 1

.play-common playing-sound(a audio-queue, sound sound, looping bool) trusted
	assert sound.format == a.format : "sound format mismatch: expected {a format}, got {sound format}"
	a.lock acquire
	# Can't use 'set-filter' in 'noctx' code, so do it here
	a.playing.filter := x => !x.is-over
	entry entry = sound.samples, sound.samples.begin-ptr, looping
	a.playing ~= entry
	a.lock release
	reset fun void() = () =>
		entry reset-position 
	set-playing fun void(bool) = desired =>
		a set-playing entry, desired
	reset, set-playing

.set-playing void(a audio-queue, entry entry, desired bool) trusted
	a.lock acquire
	is-playing cell bool = false,
	# Can't use 'set-filter' in 'noctx' code, so do it here
	a.playing.filter := x =>
		if x is-over
			false
		elif x ref-eq entry
			*is-playing := true
			desired
		else
			true
	if desired && !*is-playing
		a.playing ~= entry
	a.lock release

test
	format sound-format = 2, 44100
	a audio-queue = format,
	sound sound = format, (1, 2, 3, 4, 5, 6, 7, 8)
	buf mut-array float32 = 0, 0, 0
	a pull buf
	buf.to-array is (0, 0, 0)
	_ = a play sound
	a pull buf
	buf.to-array is (1, 2, 3)
	a pull buf
	buf.to-array is (4, 5, 6)
	a pull buf
	buf.to-array is (7, 8, 0)
	a pull buf
	buf.to-array is (0, 0, 0)

.== bool(a array float32, b array float32)
	a array-equal b, (x, y) => x == y
