import
	crow/c-types: c-int
	crow/private/alloc: unmanaged-alloc, unmanaged-free
	SDL2/SDL: SDL_Init, SDL_INIT_AUDIO, SDL_Quit
	SDL2/SDL_audio:
		AUDIO_F32, new, SDL_AudioSpec, SDL_CloseAudioDevice, SDL_OpenAudioDevice,
		SDL_PauseAudioDevice
	./audio: audio, new
	./audio-queue: audio-queue, clear, new, play, play-loop, pull
	./sound: n-channels, new, sample-rate, sound-format

start-sdl-audio audio() summon
	trusted
		err = SDL_INIT_AUDIO SDL_Init
		assert err == 0

		samples nat16 = 4096
		format sound-format = 2, 48000
		queue audio-queue = format, 
		write-ctx write-ctx mut* = (queue,) unmanaged-alloc

		sr int32 = format.sample-rate to
		nc nat8 = format.n-channels to
		aspec SDL_AudioSpec = sr, AUDIO_F32, nc, 0, samples, 0, 0, &audio-cb, write-ctx.pointer-cast
		desired SDL_AudioSpec = aspec
		obtained mut SDL_AudioSpec = ()
		device = null SDL_OpenAudioDevice 0, &desired, &obtained, 0
		forbid device == 0

		device SDL_PauseAudioDevice 0

		shut-down far void() = () =>
			device SDL_CloseAudioDevice
			SDL_Quit
			write-ctx unmanaged-free
			# Make sure GC keeps this alive
			_ = queue
		format, (() => queue clear), (x => queue play x), (x => queue play-loop x), shut-down

-write-ctx record mut by-val
	queue audio-queue

-audio-cb void(userdata any-mut-pointer, stream nat8 mut*, len c-int) bare, unsafe
	queue = (userdata.pointer-cast::write-ctx mut*)->queue
	floats float32 mut-array = stream[0 .. len.to] cast-mut-array
	queue pull floats
