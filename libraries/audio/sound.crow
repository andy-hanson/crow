no-std
import
	crow/bool: &&, bool
	crow/col/arr: arr, size, subscript
	crow/col/arr-util: map, make-arr
	crow/compare: >
	crow/exception: assert, throw
	crow/misc: new, void
	crow/number: ==, <=>, +, *, /, %, float32, nat64, round-down-to-multiple
	crow/str: literal, str
	crow/str-conv: finish, interp, to-str, with-str, with-value

# Represents a single sound.
sound record
	.ignore void
	format sound-format
	samples float32[]

new sound(format sound-format, samples float32[])
	nc = format n-channels
	ns = samples size
	unless ns % nc == 0
		"Number of samples ({ns}) must be a multiple of number of channels ({nc})" throw
	res = (), format, samples
	_ = res ignore
	res

sound-format record
	n-channels nat64
	# `samples` contains `n-channels * sample-rate` samples per second
	sample-rate nat64

samples-per-second nat64(a sound-format)
	a.n-channels * a.sample-rate

== bool(a sound-format, b sound-format)
	a.n-channels == b.n-channels && a.sample-rate == b.sample-rate

to-str str(a sound-format)
	"{a n-channels}Ã—{a sample-rate}Hz"

* sound(a sound, b float32)
	a.format, a.samples map x => x * b

with-sample-rate sound(a sound, new-sample-rate nat64)
	# TODO: use interpolation
	assert: new-sample-rate > 0
	n-channels = a.format n-channels
	old-sample-rate = a.format sample-rate
	new-n-samples = a.samples.size * new-sample-rate / old-sample-rate round-down-to-multiple n-channels
	new-samples float32[] = new-n-samples make-arr i =>
		channel = i % n-channels
		out-frame = i / n-channels
		in-frame = out-frame * old-sample-rate / new-sample-rate
		a.samples[in-frame * n-channels + channel]
	(n-channels, new-sample-rate), new-samples
