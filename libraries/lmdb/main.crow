###
Wrapper library for LMDB to make it slightly more crow-friendly.

For the raw library, import from `lmdb/headers` instead of `lmdb`.
###

import
	crow/c-types: err-t, u-int
	crow/io/file: make-directory, path-exists
	crow/serialize: from-bytes, serialize, to-4-bytes, to-8-bytes
	./headers:
		MDB_BAD_DBI, MDB_BAD_RSLOT, MDB_BAD_TXN, MDB_BAD_VALSIZE, MDB_CORRUPTED, MDB_CREATE,
		MDB_cursor, mdb_cursor_close, MDB_CURSOR_FULL, mdb_cursor_get, mdb_cursor_open, MDB_dbi,
		mdb_dbi_close, mdb_dbi_open, MDB_DBS_FULL, MDB_env, mdb_env_close, mdb_env_create,
		mdb_env_open, mdb_env_set_mapsize, mdb_env_set_maxdbs, MDB_FIRST, mdb_get, MDB_GET_CURRENT,
		MDB_INCOMPATIBLE, MDB_INTEGERKEY, MDB_INVALID, MDB_KEYEXIST, MDB_MAP_FULL, MDB_MAP_RESIZED,
		MDB_NEXT, MDB_NOOVERWRITE, MDB_NOTFOUND, MDB_PAGE_FULL, MDB_PAGE_NOTFOUND, MDB_PANIC,
		mdb_put, MDB_RDONLY, MDB_READERS_FULL, mdb_stat, MDB_SUCCESS, MDB_TLS_FULL, MDB_txn,
		mdb_txn_abort, mdb_txn_begin, mdb_txn_commit, MDB_TXN_FULL, MDB_val, MDB_VERSION_MISMATCH,
		ms_branch_pages, ms_depth, ms_entries, ms_leaf_pages, ms_overflow_pages, ms_psize, mv_data,
		mv_size, new

region env

# LMDB environment.
lmdb-env record mut
	-env MDB_env mut*

-open-lmdb-env record
	db-dir string
	create-if-not-exists bool
open-lmdb-env open-lmdb-env(db-dir string, create-if-not-exists bool)
	db-dir, create-if-not-exists
# Calls `open-env`, then `f`, then `close-env` (in a `finally`).
with-block[t] t^(options open-lmdb-env, f act t^(lmdb-env)) summon, t shared
	trusted
		env = options open-env
		with : (() => env.close-env,) future-finally
			f[env]

-open-env lmdb-env(options open-lmdb-env) summon, unsafe
	env mut MDB_env mut* = null
	(&env).mdb_env_create check-lmdb-error
	env mdb_env_set_maxdbs 50 check-lmdb-error
	mapsize = 1024 * 1024 * 100000
	env mdb_env_set_mapsize mapsize check-lmdb-error

	db-dir = options db-dir
	if options.create-if-not-exists && !db-dir.path-exists
		info log "Creating database directory {db-dir}"
		db-dir make-directory

	err = env mdb_env_open db-dir.to, 0, 0o666
	unless err == 0
		env mdb_env_close
		err check-lmdb-error
	env,

-close-env void(env lmdb-env) summon, unsafe
	env.env mdb_env_close

region lmdb-key

###
Keys in LMDB can be nat32, nat64, or string.

Don't implement this spec for other types, since LMDB really only supports a few types.
###
lmdb-key[k] spec k key
	# NOTE: Parameter is a dummy, don't actually use it
	lmdb-key-flags u-int(_ k)
	# Don't use `serialize`, because lmdb expects integers to be fixed size
	to-lmdb-key nat8[](key k)
	from-lmdb-key k(a nat8[])

lmdb-key-flags u-int(_ nat64)
	MDB_INTEGERKEY
lmdb-key-flags u-int(_ nat32)
	MDB_INTEGERKEY
lmdb-key-flags u-int(_ string)
	0

to-lmdb-key nat8[](key nat64)
	key to-8-bytes
to-lmdb-key nat8[](key nat32)
	key to-4-bytes
to-lmdb-key nat8[](key string)
	key to-bytes

from-lmdb-key nat64(a nat8[])
	a from-bytes
from-lmdb-key nat32(a nat8[])
	a from-bytes
from-lmdb-key string(a nat8[])
	a from-bytes

region db

# Single database (key-value store).
lmdb-db[k, v] record mut
	-dbi MDB_dbi

database[k, v] record mut
	env lmdb-env
	db-name string
database[k, v] (k, v) database(env lmdb-env, db-name string)
	env, db-name

with-block[t, k, v] t^(
	a (k, v) database,
	f act t^((k, v) lmdb-db),
) summon, t shared, k lmdb-key, v serialize
	trusted
		db (k, v) lmdb-db = a open-db
		with : (() => (a.env close-db db),) future-finally
			f[db]

-open-db[k, v] (k, v) lmdb-db(a (k, v) database) summon, unsafe, k lmdb-key, v serialize
	transaction mut MDB_txn mut* = null
	a.env.env mdb_txn_begin null, 0, &transaction check-lmdb-error

	dbi mut MDB_dbi = zeroed
	mdb-flags = MDB_CREATE | zeroed::k.lmdb-key-flags
	transaction mdb_dbi_open a.db-name.to, mdb-flags, &dbi check-lmdb-error

	transaction.mdb_txn_commit check-lmdb-error
	dbi,

-close-db[k, v] void(env lmdb-env, db (k, v) lmdb-db) summon, unsafe
	env.env mdb_dbi_close db.dbi

region transaction

# LMDB transaction.
lmdb-txn record mut
	-txn MDB_txn mut*

read-transaction record mut
	env lmdb-env
###
Open a read-only transaction, then call `f`, then commit the transaction.

Aborts the transaction iff `f` throws an exception.
###
read-transaction read-transaction(env lmdb-env)
	env,
with-block[t] t(a read-transaction, f act t(lmdb-txn)) summon
	a.env with-transaction MDB_RDONLY, txn =>
		f[txn], transaction-abort

write-transaction record mut
	env lmdb-env
# Like `write-transaction`, but the transaction can perform writes.
write-transaction write-transaction(env lmdb-env)
	env,
with-block[t] t(a write-transaction, f act t(lmdb-txn)) summon
	with txn : a.env abortable-write-transaction
		f[txn], transaction-commit

transaction-result enum
	transaction-abort
	transaction-commit

abortable-write-transaction record mut
	env lmdb-env
# Like `with-write-transaction`, but `f` returns a pair of the result and whether to commit the transaction.
abortable-write-transaction abortable-write-transaction(env lmdb-env)
	env,
with-block[t] t(a abortable-write-transaction, f act (t, transaction-result)(lmdb-txn)) summon
	a.env with-transaction 0, f

-with-transaction[t] t(env lmdb-env, mdb-flags u-int, f act (t, transaction-result)(lmdb-txn)) summon
	trusted
		transaction mut MDB_txn mut* = null
		env.env mdb_txn_begin null, mdb-flags, &transaction check-lmdb-error
		(() => transaction mdb_txn_abort) do-if-error () =>
			pair = f[transaction,]
			match pair.b
			as transaction-abort
				transaction mdb_txn_abort
			as transaction-commit
				transaction.mdb_txn_commit check-lmdb-error
			pair a

region get / set

###
Gets the value associated with a key.
Returns an empty option iff `key` is not in `db`.
###
get[k, v] v?(txn lmdb-txn, db (k, v) lmdb-db, key k) summon, k lmdb-key, v serialize
	# TODO: this check should be unnecessary...
	unless (txn count db) == 0
		lmdb-key = key to-lmdb-key
		forbid lmdb-key is-empty : "empty key is not allowed"
		trusted
			key-val = lmdb-key val-of-bytes
			value mut = empty-val
			err = txn.txn mdb_get db.dbi, &key-val, &value
			unless err == MDB_NOTFOUND
				err check-lmdb-error
				# TODO:PERF For some v types, the copy in 'bytes-of-val' is unnecessary.
				value.bytes-of-val.from-bytes,

###
Associates the value with the key.
This may add the key or overwrite the value if the key is already in the database.
###
set[k, v] void(txn lmdb-txn, db (k, v) lmdb-db, key k, value v) summon, k lmdb-key, v serialize
	txn put-inner db, key, value, 0 check-lmdb-error

# Like `set`, but throws if `key` is already in the `db`.
add[k, v] void(txn lmdb-txn, db (k, v) lmdb-db, key k, value v) summon, k lmdb-key, v serialize
	unless txn try-add db, key, value
		throw "key already exists"

###
If `key` is already in `db`, returns `false`.
Else, adds the `key` and `value` and returns `true`.
###
try-add[k, v] bool(txn lmdb-txn, db (k, v) lmdb-db, key k, value v) summon, k lmdb-key, v serialize
	err = txn put-inner db, key, value, MDB_NOOVERWRITE
	unless err == MDB_KEYEXIST
		err check-lmdb-error
		true

-put-inner[k, v] err-t(
	txn lmdb-txn,
	db (k, v) lmdb-db,
	key k,
	value v,
	mdb-flags u-int,
) summon, k lmdb-key, v serialize
	trusted
		key-val = key.to-lmdb-key val-of-bytes
		value-val = value.to-bytes val-of-bytes
		txn.txn mdb_put db.dbi, &key-val, &value-val, mdb-flags

region stat

lmdb_stat record
	psize nat
	depth nat
	branch-pages nat
	leaf-pages nat
	overflow-pages nat
	entries nat

to string(a lmdb_stat)
	# TODO: Use """ string
	x = "	psize = {a psize}\n	depth = {a depth}\n	branch-pages = {a branch-pages}"
	y = "	leaf-pages = {a leaf-pages}\n	overflow-pages = {a overflow-pages}"
	z = "	entries = {a entries}"
	"lmdb_stat:\n{x}\n{y}\n{z}"

# Get statistics about `db`.
stat[k, v] lmdb_stat(txn lmdb-txn, db (k, v) lmdb-db) summon
	trusted
		s mut mdb_stat = ()
		txn.txn mdb_stat db.dbi, &s check-lmdb-error
		psize nat64 = s.ms_psize to
		depth nat64 = s.ms_depth to
		psize, depth, s.ms_branch_pages, s.ms_leaf_pages, s.ms_overflow_pages, s.ms_entries

###
Get the number of entries in `db`.
(This just uses `stat`.)
###
count[k, v] nat(txn lmdb-txn, db (k, v) lmdb-db) summon
	txn stat db entries

region iteration

each[k, v] record mut
	txn lmdb-txn
	db (k, v) lmdb-db
each[k, v] (k, v) each(txn lmdb-txn, db (k, v) lmdb-db)
	txn, db

size[k, v] nat64(a (k, v) each) summon
	a.txn count a.db

# Calls `f` for each key-value pair in `db`.
iterate[k, v] bool(a (k, v) each, f act bool(k, v)) summon, k lmdb-key, v serialize
	trusted a.txn with-cursor a.db, cursor =>
		key mut = empty-val
		value mut = empty-val
		cursor mdb_cursor_get &key, &value, MDB_FIRST check-lmdb-error
		loop
			cursor mdb_cursor_get &key, &value, MDB_GET_CURRENT check-lmdb-error
			if f[key.bytes-of-val.from-lmdb-key, value.bytes-of-val.from-bytes]
				break true
			else
				value := empty-val
				err = cursor mdb_cursor_get &key, &value, MDB_NEXT
				if err == MDB_NOTFOUND
					break false
				else
					err check-lmdb-error
					continue

###
`db0` and `db1` shuld have exactly the same keys.
Iterates `db0` and `db1` in order, calling `f` with each key and with the values from both dbs.
Returns an array of the results.
###
zip[out, k, v0, v1] out[](
	txn lmdb-txn,
	db0 (k, v0) lmdb-db,
	db1 (k, v1) lmdb-db,
	f act out(k, v0, v1),
) summon, k lmdb-key, v0 serialize, v1 serialize
	db0-count = txn count db0
	db1-count = txn count db1
	assert db0-count == db1-count
	unless db0-count == 0
		with out : db0-count build
			txn zip-non-empty db0, db1, (key, value0, value1) =>
				out ~= f[key, value0, value1]

-zip-non-empty[k, v0, v1] void(
	txn lmdb-txn,
	db0 (k, v0) lmdb-db,
	db1 (k, v1) lmdb-db,
	f act void(k, v0, v1),
) summon, k lmdb-key, v0 serialize, v1 serialize
	trusted txn with-cursor db0, cursor0 =>
		txn with-cursor db1, cursor1 =>
			empty mut = empty-val
			cursor0 mdb_cursor_get &empty, &empty, MDB_FIRST check-lmdb-error
			cursor1 mdb_cursor_get &empty, &empty, MDB_FIRST check-lmdb-error
			cursor0 zip-inner cursor1, f
-zip-inner[k, v0, v1] void(
	cursor0 MDB_cursor mut*,
	cursor1 MDB_cursor mut*,
	f act void(k, v0, v1),
) summon, unsafe, k lmdb-key, v0 serialize, v1 serialize
	loop
		key0-val mut = empty-val
		value0-val mut = empty-val
		cursor0 mdb_cursor_get &key0-val, &value0-val, MDB_GET_CURRENT check-lmdb-error
		key0 k = key0-val.bytes-of-val from-lmdb-key
		value0 v0 = value0-val.bytes-of-val from-bytes
		key1-val mut = empty-val
		value1-val mut = empty-val
		cursor1 mdb_cursor_get &key1-val, &value1-val, MDB_GET_CURRENT check-lmdb-error
		key1 k = key1-val.bytes-of-val.from-lmdb-key
		value1 v1 = value1-val.bytes-of-val.from-bytes
		assert key0 == key1
		f[key0, value0, value1]
		empty mut = empty-val
		err0 = cursor0 mdb_cursor_get &empty, &empty, MDB_NEXT
		err1 = cursor1 mdb_cursor_get &empty, &empty, MDB_NEXT
		if err0 == MDB_NOTFOUND || err1 == MDB_NOTFOUND
			assert err0 == MDB_NOTFOUND && err1 == MDB_NOTFOUND
			break
		else
			err0 check-lmdb-error
			err1 check-lmdb-error
			continue

-with-cursor[t, k, v] t(txn lmdb-txn, db (k, v) lmdb-db, f act t(MDB_cursor mut*)) summon, unsafe
	cursor mut MDB_cursor mut* = null
	open-err = txn.txn mdb_cursor_open db.dbi, &cursor
	with : (() => cursor mdb_cursor_close) finally
		open-err check-lmdb-error
		f[cursor]

-empty-val MDB_val() unsafe
	0, null

-val-of-bytes MDB_val(a nat8[]) unsafe
	array nat8 array = a to
	array.size, array.begin-pointer.as-mut

-bytes-of-val nat8[](a MDB_val) unsafe
	a.mv_data .. a.mv_data + a.mv_size as-list

-check-lmdb-error void(a err-t)
	assert a == MDB_SUCCESS : "LMDB error code: {a} ({a error-name})"

-error-name string(a err-t)
	# TODO: convert to enum then enum to string
	if a == MDB_KEYEXIST
		"MDB_KEYEXIST"
	elif a == MDB_NOTFOUND
		"MDB_NOTFOUND"
	elif a == MDB_PAGE_NOTFOUND
		"MDB_PAGE_NOTFOUND"
	elif a == MDB_CORRUPTED
		"MDB_CORRUPTED"
	elif a == MDB_PANIC
		"MDB_PANIC"
	elif a == MDB_VERSION_MISMATCH
		"MDB_VERSION_MISMATCH"
	elif a == MDB_INVALID
		"MDB_INVALID"
	elif a == MDB_MAP_FULL
		"MDB_MAP_FULL"
	elif a == MDB_DBS_FULL
		"MDB_DBS_FULL"
	elif a == MDB_READERS_FULL
		"MDB_READERS_FULL"
	elif a == MDB_TLS_FULL
		"MDB_TLS_FULL"
	elif a == MDB_TXN_FULL
		"MDB_txn-full"
	elif a == MDB_CURSOR_FULL
		"MDB_CURSOR_FULL"
	elif a == MDB_PAGE_FULL
		"MDB_PAGE_FULL"
	elif a == MDB_MAP_RESIZED
		"MDB_MAP_RESIZED"
	elif a == MDB_INCOMPATIBLE
		"MDB_INCOMPATIBLE"
	elif a == MDB_BAD_RSLOT
		"MDB_BAD_RSLOT"
	elif a == MDB_BAD_TXN
		"MDB_BAD_TXN"
	elif a == MDB_BAD_VALSIZE
		"MDB_BAD_VALSIZE"
	elif a == MDB_BAD_DBI
		"MDB_BAD_DBI"
	else
		"{a}"
