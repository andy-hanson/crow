###
Wrapper library for LMDB to make it slightly more crow-friendly.

For the raw library, import from `lmdb/headers` instead of `lmdb`.
###

import
	crow/bits: |
	crow/cell: *, cell, new
	crow/col/mut-array:
		begin-pointer, cast-immutable, end-pointer, mut-array, mut-array-from-begin-end, to-array,
		uninitialized-mut-array
	crow/col/private/array-low-level: begin-pointer
	crow/c-types: u-int
	crow/extra-types: err-t
	crow/io/file: make-directory, path-exists
	crow/log: info, log
	crow/pointer: ==, +, as-mut, mut-pointer, null, pointer-cast-to-extern, set-deref, zeroed
	crow/serialize: from-bytes, serialize, to-4-bytes, to-8-bytes
	./headers:
		MDB_BAD_DBI, MDB_BAD_RSLOT, MDB_BAD_TXN, MDB_BAD_VALSIZE, MDB_CORRUPTED, MDB_CREATE,
		MDB_cursor, mdb_cursor_close, MDB_CURSOR_FULL, mdb_cursor_get, mdb_cursor_open, MDB_dbi,
		mdb_dbi_close, mdb_dbi_open, MDB_DBS_FULL, MDB_env, mdb_env_close, mdb_env_create,
		mdb_env_open, mdb_env_set_mapsize, mdb_env_set_maxdbs, MDB_FIRST, mdb_get, MDB_GET_CURRENT,
		MDB_INCOMPATIBLE, MDB_INTEGERKEY, MDB_INVALID, MDB_KEYEXIST, MDB_MAP_FULL, MDB_MAP_RESIZED,
		MDB_NEXT, MDB_NOOVERWRITE, MDB_NOTFOUND, MDB_PAGE_FULL, MDB_PAGE_NOTFOUND, MDB_PANIC,
		mdb_put, MDB_RDONLY, MDB_READERS_FULL, mdb_stat, MDB_SUCCESS, MDB_TLS_FULL, MDB_txn,
		mdb_txn_abort, mdb_txn_begin, mdb_txn_commit, MDB_TXN_FULL, MDB_val, MDB_VERSION_MISMATCH,
		ms_branch_pages, ms_depth, ms_entries, ms_leaf_pages, ms_overflow_pages, ms_psize, mv_data,
		mv_size, new

region env

# LMDB environment.
lmdb-env record mut
	.env MDB_env

.open-lmdb-env record
	db-dir string
	create-if-not-exists bool
open-lmdb-env open-lmdb-env(db-dir string, create-if-not-exists bool)
	db-dir, create-if-not-exists
# Calls `open-env`, then `f`, then `close-env` (in a `finally`).
with-block<a> a^(options open-lmdb-env, f act a^(lmdb-env)) trusted summon is-sendable<a>
	env = options open-env
	with : (() => env.close-env,) future-finally
		f[env]

.open-env lmdb-env(options open-lmdb-env) unsafe summon
	env-cell cell MDB_env = null-extern-pointer,
	env-cell.mdb_env_create check-lmdb-error
	env = *env-cell
	env mdb_env_set_maxdbs 50 check-lmdb-error
	mapsize = 1024 * 1024 * 100000
	env mdb_env_set_mapsize mapsize check-lmdb-error

	db-dir = options db-dir
	if options.create-if-not-exists && !db-dir.path-exists
		info log "Creating database directory {db-dir}"
		db-dir make-directory

	err = env mdb_env_open db-dir.to-c-string, 0, 0o666
	unless err == 0
		env mdb_env_close
		err check-lmdb-error
	env,

.close-env void(env lmdb-env) unsafe summon
	env.env mdb_env_close

region lmdb-key

###
Keys in LMDB can be nat32, nat64, or string.

Don't implement this spec for other types, since LMDB really only supports a few types.
###
lmdb-key<k> spec
	== bool(a k, b k)
	# NOTE: Parameter is a dummy, don't actually use it
	lmdb-key-flags u-int(_ k)
	# Don't use `serialize`, because lmdb expects integers to be fixed size
	to-lmdb-key nat8[](key k)
	from-lmdb-key k(a nat8[])

lmdb-key-flags u-int(_ nat64)
	MDB_INTEGERKEY
lmdb-key-flags u-int(_ nat32)
	MDB_INTEGERKEY
lmdb-key-flags u-int(_ string)
	0

to-lmdb-key nat8[](key nat64)
	key to-8-bytes
to-lmdb-key nat8[](key nat32)
	key to-4-bytes
to-lmdb-key nat8[](key string)
	key to-bytes

from-lmdb-key nat64(a nat8[])
	a from-bytes
from-lmdb-key nat32(a nat8[])
	a from-bytes
from-lmdb-key string(a nat8[])
	a from-bytes

# TODO:MOVE
# And make sure `a` is actually an extern pointer type
.null-extern-pointer<a> a() unsafe
	p nat8 mut* = null
	p pointer-cast-to-extern

region db

# Single database (key-value store).
lmdb-db<k, v> record mut
	.dbi MDB_dbi

database<k, v> record mut
	env lmdb-env
	db-name string
database<k, v> database<k, v>(env lmdb-env, db-name string)
	env, db-name

with-block<a, k, v> a^(
	a database<k, v>,
	f act a^(lmdb-db<k, v>),
) trusted summon is-sendable<a> lmdb-key<k> serialize<v>
	db lmdb-db<k, v> = a open-db
	with : (() => (a.env close-db db),) future-finally
		f[db]

.open-db<k, v> lmdb-db<k, v>(a database<k, v>) unsafe summon lmdb-key<k> serialize<v>
	transaction-cell cell MDB_txn = null-extern-pointer,
	a.env.env mdb_txn_begin null-extern-pointer, 0, transaction-cell check-lmdb-error
	transaction = *transaction-cell

	dbi-cell cell MDB_dbi = zeroed,
	mdb-flags = MDB_CREATE | zeroed::k.lmdb-key-flags
	transaction mdb_dbi_open a.db-name.to-c-string, mdb-flags, dbi-cell check-lmdb-error

	transaction.mdb_txn_commit check-lmdb-error
	*dbi-cell,

.close-db<k, v> void(env lmdb-env, db lmdb-db<k, v>) unsafe summon
	env.env mdb_dbi_close db.dbi

region transaction

# LMDB transaction.
lmdb-txn record mut
	.txn MDB_txn

read-transaction record mut
	env lmdb-env
###
Open a read-only transaction, then call `f`, then commit the transaction.

Aborts the transaction iff `f` throws an exception.
###
read-transaction read-transaction(env lmdb-env)
	env,
with-block<a> a(a read-transaction, f act a(lmdb-txn)) trusted summon
	a.env with-transaction MDB_RDONLY, txn =>
		f[txn], transaction-abort

write-transaction record mut
	env lmdb-env
# Like `write-transaction`, but the transaction can perform writes.
write-transaction write-transaction(env lmdb-env)
	env,
with-block<a> a(a write-transaction, f act a(lmdb-txn)) trusted summon
	with txn : a.env abortable-write-transaction
		f[txn], transaction-commit

transaction-result enum
	transaction-abort
	transaction-commit

abortable-write-transaction record mut
	env lmdb-env
# Like `with-write-transaction`, but `f` returns a pair of the result and whether to commit the transaction.
abortable-write-transaction abortable-write-transaction(env lmdb-env)
	env,
with-block<a> a(a abortable-write-transaction, f act (a, transaction-result)(lmdb-txn)) trusted summon
	a.env with-transaction 0, f

.with-transaction<a> a(env lmdb-env, mdb-flags u-int, f act (a, transaction-result)(lmdb-txn)) unsafe summon
	transaction-cell cell MDB_txn = null-extern-pointer,
	env.env mdb_txn_begin null-extern-pointer, mdb-flags, transaction-cell check-lmdb-error
	transaction = *transaction-cell
	(() => transaction mdb_txn_abort) do-if-error () =>
		pair = f[(transaction,)]
		match pair.b
		as transaction-abort
			transaction mdb_txn_abort
		as transaction-commit
			transaction.mdb_txn_commit check-lmdb-error
		pair a

region get / set

###
Gets the value associated with a key.
Returns an empty option iff `key` is not in `db`.
###
get<k, v> v?(txn lmdb-txn, db lmdb-db<k, v>, key k) trusted summon lmdb-key<k> serialize<v>
	value = empty-val
	# TODO: this check should be unnecessary...
	unless (txn count db) == 0
		lmdb-key = key to-lmdb-key
		forbid lmdb-key is-empty : "empty key is not allowed"
		err = txn.txn mdb_get db.dbi, lmdb-key.val-of-bytes, value
		unless err == MDB_NOTFOUND
			err check-lmdb-error
			# TODO:PERF For some v types, the copy in 'bytes-of-val' is unnecessary.
			value.bytes-of-val.from-bytes,

###
Associates the value with the key.
This may add the key or overwrite the value if the key is already in the database.
###
set<k, v> void(txn lmdb-txn, db lmdb-db<k, v>, key k, value v) summon lmdb-key<k> serialize<v>
	txn put-inner db, key, value, 0 check-lmdb-error

# Like `set`, but throws if `key` is already in the `db`.
add<k, v> void(txn lmdb-txn, db lmdb-db<k, v>, key k, value v) summon lmdb-key<k> serialize<v>
	unless txn try-add db, key, value
		throw "key already exists"

###
If `key` is already in `db`, returns `false`.
Else, adds the `key` and `value` and returns `true`.
###
try-add<k, v> bool(txn lmdb-txn, db lmdb-db<k, v>, key k, value v) summon lmdb-key<k> serialize<v>
	err = txn put-inner db, key, value, MDB_NOOVERWRITE
	unless err == MDB_KEYEXIST
		err check-lmdb-error
		true

.put-inner<k, v> err-t(
	txn lmdb-txn,
	db lmdb-db<k, v>,
	key k,
	value v,
	mdb-flags u-int,
) trusted summon lmdb-key<k> serialize<v>
	txn.txn mdb_put db.dbi, key.to-lmdb-key.val-of-bytes, value.to-bytes.val-of-bytes, mdb-flags

region stat

lmdb_stat record
	psize nat
	depth nat
	branch-pages nat
	leaf-pages nat
	overflow-pages nat
	entries nat

to-string string(a lmdb_stat)
	# TODO: Use """ string
	x = "	psize = {a psize}\n	depth = {a depth}\n	branch-pages = {a branch-pages}"
	y = "	leaf-pages = {a leaf-pages}\n	overflow-pages = {a overflow-pages}"
	z = "	entries = {a entries}"
	"lmdb_stat:\n{x}\n{y}\n{z}"

# Get statistics about `db`.
stat<k, v> lmdb_stat(txn lmdb-txn, db lmdb-db<k, v>) trusted summon
	s mdb_stat = 0, 0, 0, 0, 0, 0
	txn.txn mdb_stat db.dbi, s check-lmdb-error
	psize = s.ms_psize to-nat64
	depth = s.ms_depth to-nat64
	psize, depth, s.ms_branch_pages, s.ms_leaf_pages, s.ms_overflow_pages, s.ms_entries

###
Get the number of entries in `db`.
(This just uses `stat`.)
###
count<k, v> nat(txn lmdb-txn, db lmdb-db<k, v>) summon
	txn stat db entries

region iteration

fold<a, k, v> a(acc a, txn lmdb-txn, db lmdb-db<k, v>, f act a(a, k, v)) trusted summon lmdb-key<k> serialize<v>
	txn with-cursor db, cursor =>
		cursor mdb_cursor_get empty-val, empty-val, MDB_FIRST check-lmdb-error
		acc fold-recur cursor, f
.fold-recur<a, k, v> a(acc a, cursor MDB_cursor, f act a(a, k, v)) unsafe summon lmdb-key<k> serialize<v>
	key = empty-val
	value = empty-val
	cursor mdb_cursor_get key, value, MDB_GET_CURRENT check-lmdb-error
	new-acc = f[acc, key.bytes-of-val.from-lmdb-key, value.bytes-of-val.from-bytes]
	err = cursor mdb_cursor_get empty-val, empty-val, MDB_NEXT
	if err == MDB_NOTFOUND
		new-acc
	else
		err check-lmdb-error
		new-acc fold-recur cursor, f

each<k, v> record mut
	txn lmdb-txn
	db lmdb-db<k, v>
each<k, v> each<k, v>(txn lmdb-txn, db lmdb-db<k, v>)
	txn, db
# Calls `f` for each key-value pair in `db`.
for-loop<k, v> void(a each<k, v>, f act void(k, v)) summon lmdb-key<k> serialize<v>
	() fold a.txn, a.db, (_, key, value) => f[key, value]
# Calls `f` for each key-value pair in `db` and returns an array of the results.
for-loop<out, k, v> out[](a each<k, v>, f act out(k, v)) trusted summon lmdb-key<k> serialize<v>
	out mut-array out = a.txn count a.db uninitialized-mut-array
	end = out.begin-pointer fold a.txn, a.db, (cur, key, value) =>
		*cur := f[key, value]
		cur + 1
	assert end == out.end-pointer
	out.cast-immutable to-list

###
`db0` and `db1` shuld have exactly the same keys.
Iterates `db0` and `db1` in order, calling `f` with each key and with the values from both dbs.
Returns an array of the results.
###
zip<out, k, v0, v1> out[](
	txn lmdb-txn,
	db0 lmdb-db<k, v0>,
	db1 lmdb-db<k, v1>,
	f act out(k, v0, v1),
) trusted summon is-data<k> lmdb-key<k> serialize<v0> serialize<v1>
	db0-count = txn count db0
	db1-count = txn count db1
	assert db0-count == db1-count
	unless db0-count == 0
		res mut-array out = db0-count uninitialized-mut-array
		end = res.begin-pointer zip-fold-non-empty txn, db0, db1, (cur, key, value0, value1) =>
			*cur := f[key, value0, value1]
			cur + 1
		assert end == res.end-pointer
		res.cast-immutable to-list

# Like `zip`, but passes along an accumulator.
zip-fold<a, k, v0, v1> a(
	acc a,
	txn lmdb-txn,
	db0 lmdb-db<k, v0>,
	db1 lmdb-db<k, v1>,
	f act a(a, k, v0, v1),
) trusted summon is-data<k> lmdb-key<k> serialize<v0> serialize<v1>
	db0-count = txn count db0
	db1-count = txn count db1
	assert db0-count == db1-count
	if db0-count == 0
		acc
	else
		acc zip-fold-non-empty txn, db0, db1, f

.zip-fold-non-empty<a, k, v0, v1> a(
	acc a,
	txn lmdb-txn,
	db0 lmdb-db<k, v0>,
	db1 lmdb-db<k, v1>,
	f act a(a, k, v0, v1),
) trusted summon is-data<k> lmdb-key<k> serialize<v0> serialize<v1>
	txn with-cursor db0, cursor0 =>
		txn with-cursor db1, cursor1 =>
			cursor0 mdb_cursor_get empty-val, empty-val, MDB_FIRST check-lmdb-error
			cursor1 mdb_cursor_get empty-val, empty-val, MDB_FIRST check-lmdb-error
			acc zip-fold-recur cursor0, cursor1, f
.zip-fold-recur<a, k, v0, v1> a(
	acc a,
	cursor0 MDB_cursor,
	cursor1 MDB_cursor,
	f act a(a, k, v0, v1),
) unsafe summon is-data<k> lmdb-key<k> serialize<v0> serialize<v1>
	key0-val = empty-val
	value0-val = empty-val
	cursor0 mdb_cursor_get key0-val, value0-val, MDB_GET_CURRENT check-lmdb-error
	key0 k = key0-val.bytes-of-val from-lmdb-key
	value0 v0 = value0-val.bytes-of-val from-bytes
	key1-val = empty-val
	value1-val = empty-val
	cursor1 mdb_cursor_get key1-val, value1-val, MDB_GET_CURRENT check-lmdb-error
	key1 k = key1-val.bytes-of-val.from-lmdb-key
	value1 v1 = value1-val.bytes-of-val.from-bytes
	assert key0 == key1
	new-acc = f[acc, key0, value0, value1]
	err0 = cursor0 mdb_cursor_get empty-val, empty-val, MDB_NEXT
	err1 = cursor1 mdb_cursor_get empty-val, empty-val, MDB_NEXT
	if err0 == MDB_NOTFOUND || err1 == MDB_NOTFOUND
		assert err0 == MDB_NOTFOUND && err1 == MDB_NOTFOUND
		new-acc
	else
		err0 check-lmdb-error
		err1 check-lmdb-error
		new-acc zip-fold-recur cursor0, cursor1, f

.with-cursor<a, k, v> a(txn lmdb-txn, db lmdb-db<k, v>, f act a(MDB_cursor)) unsafe summon
	cursor-cell cell MDB_cursor = null-extern-pointer,
	open-err = txn.txn mdb_cursor_open db.dbi, cursor-cell
	cursor = *cursor-cell
	with : (() => cursor mdb_cursor_close) finally
		open-err check-lmdb-error
		f[cursor]

.empty-val MDB_val() unsafe
	0, null

.val-of-bytes MDB_val(a nat8[]) unsafe
	array = a to-array
	array.size, array.begin-pointer.as-mut

.bytes-of-val nat8[](a MDB_val) unsafe
	(a.mv_data mut-array-from-begin-end a.mv_data + a.mv_size).to-array to-list

.check-lmdb-error void(a err-t)
	assert a == MDB_SUCCESS : "LMDB error code: {a} ({a error-name})"

.error-name string(a err-t)
	if a == MDB_KEYEXIST
		"MDB_KEYEXIST"
	elif a == MDB_NOTFOUND
		"MDB_NOTFOUND"
	elif a == MDB_PAGE_NOTFOUND
		"MDB_PAGE_NOTFOUND"
	elif a == MDB_CORRUPTED
		"MDB_CORRUPTED"
	elif a == MDB_PANIC
		"MDB_PANIC"
	elif a == MDB_VERSION_MISMATCH
		"MDB_VERSION_MISMATCH"
	elif a == MDB_INVALID
		"MDB_INVALID"
	elif a == MDB_MAP_FULL
		"MDB_MAP_FULL"
	elif a == MDB_DBS_FULL
		"MDB_DBS_FULL"
	elif a == MDB_READERS_FULL
		"MDB_READERS_FULL"
	elif a == MDB_TLS_FULL
		"MDB_TLS_FULL"
	elif a == MDB_TXN_FULL
		"MDB_txn-full"
	elif a == MDB_CURSOR_FULL
		"MDB_CURSOR_FULL"
	elif a == MDB_PAGE_FULL
		"MDB_PAGE_FULL"
	elif a == MDB_MAP_RESIZED
		"MDB_MAP_RESIZED"
	elif a == MDB_INCOMPATIBLE
		"MDB_INCOMPATIBLE"
	elif a == MDB_BAD_RSLOT
		"MDB_BAD_RSLOT"
	elif a == MDB_BAD_TXN
		"MDB_BAD_TXN"
	elif a == MDB_BAD_VALSIZE
		"MDB_BAD_VALSIZE"
	elif a == MDB_BAD_DBI
		"MDB_BAD_DBI"
	else
		a to-string
