import
	.bootstrap: ==, <=, bool, drop, nat, none, opt, some, value, void
	.cell: cell, get, set
	.exceptions: assert, forbid
	.number-utils: +
	.ptr: subscript

# TODO: Depend on a spec, then move to cell.crow
get-and-incr nat(c cell nat)
	res = c get
	c set: res + 1
	res

cell-incr void(c cell nat)
	c.get-and-incr drop

cell-add void(c cell nat, n nat)
	c set: c.get + n

# TODO: ALIAS
iterator<?t> record mut
	get-next act opt ?t()

next opt ?t(i iterator ?t)
	i.get-next[]

# Iterator that can be started over from the beginning.
stream<?t> record mut
	get-iter act iterator ?t()

iter iterator ?t(s stream ?t)
	s.get-iter[]

iter<?t, ?e> spec
	iter iterator ?e(t ?t)

to-stream<?t, ?e> stream ?e(t ?t) iter<?t, ?e>
	{t iter} stream

iter iterator nat(r arrow<nat, nat>)
	# TODO: should not need a type argument here
	n = r.from cell<nat>
	iterator: \
		if n.get >= r.to
			none
		else
			n.get-and-incr some

each void(s stream ?t, f act void(?t))
	s.iter each-recur f

.each-recur void(i iterator ?t, f act void(?t))
	match i next
	as none
		void
	as some s
		f[s.value]
		i each-recur f

filter stream ?t(in stream ?t, pred act bool(?t))
	stream: \
		itr = in iter
		{itr filter-recur pred} iterator

.filter-recur opt ?t(i iterator ?t, pred act bool(?t))
	match i next
	as none
		none
	as some s
		v = s.value
		if pred[v]
			v some
		else
			# This one didn't satisfy the predicate, but keep trying until we get one or each the end
			i filter-recur pred
