no-std
import
	.bool: bool
	.cell: cell, set-subscript, subscript
	.compare: >=
	.fun: subscript
	.misc: arrow, from, to, void
	.number: +, nat
	.opt: none, opt, some, value

# TODO: ALIAS
iterator<?t> record mut
	get-next act opt ?t()

next opt ?t(i iterator ?t)
	i.get-next[]

# Iterator that can be started over from the beginning.
stream<?t> record mut
	get-iter act iterator ?t()

iter iterator ?t(s stream ?t)
	s.get-iter[]

iter<?t, ?e> spec
	iter iterator ?e(t ?t)

to-stream<?t, ?e> stream ?e(t ?t) iter<?t, ?e>
	{t iter} stream

iter iterator nat(r arrow<nat, nat>)
	# TODO: should not need a type argument here
	n = r.from cell<nat>
	iterator: \
		if n[] >= r.to
			none
		else
			res = n[]
			n[] := res + 1
			res some

each void(s stream ?t, f act void(?t))
	s.iter each-recur f

.each-recur void(i iterator ?t, f act void(?t))
	match i next
	as none
		void
	as some s
		f[s.value]
		i each-recur f

filter stream ?t(in stream ?t, pred act bool(?t))
	stream: \
		itr = in iter
		{itr filter-recur pred} iterator

.filter-recur opt ?t(i iterator ?t, pred act bool(?t))
	match i next
	as none
		none
	as some s
		v = s.value
		if pred[v]
			v some
		else
			# This one didn't satisfy the predicate, but keep trying until we get one or each the end
			i filter-recur pred
