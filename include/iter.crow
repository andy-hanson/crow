no-std
import
	.bool: bool
	.cell: cell, set-subscript, subscript
	.compare: >=
	.fun: subscript
	.misc: arrow, from, to, void
	.number: +, nat
	.opt: none, opt, some, value

###
Function to get an iterator.
The iterator returned should be equivalent each time, so this can be used to iterate multiple times.
###
iterable<?t> record mut
	get-iter act iterator ?t()

# Get a new iterator at the beginning.
iter iterator ?t(s iterable ?t)
	s.get-iter[]

# Converts anything with an `iter` function to an `iterable`.
to-iterable<?a, ?e> iterable ?e(a ?a) iter<?a, ?e>
	iterable: {a iter}

# Spec for anything that has an iterator.
iter<?t, ?e> spec
	iter iterator ?e(t ?t)

###
An iterator is a value that could iterate over anything.
This is often a collection; but since any function may be provided,
it could iterate an abstract sequence (such as numbers in a range) with no backing collection.

An iterator mutates itself when `next` is called to advance.
Once it returns `none`, all future calls should also return `none`.
###
iterator<?t> record mut
	get-next act opt ?t()

# Returns the current element and advances to the next.
next opt ?t(i iterator ?t)
	i.get-next[]

###
Iterator for a number range.
The beginning is inclusive and the end is exclusive.
The beginning must be less than the end.
###
iter iterator nat(r arrow<nat, nat>)
	# TODO: should not need a type argument here
	n = r.from cell<nat>
	iterator: \
		if n[] >= r.to
			none
		else
			res = n[]
			n[] := res + 1
			res some

# Calls a function for each element of an iterable.
each void(a iterable ?t, f act void(?t))
	a.iter each-recur f
.each-recur void(i iterator ?t, f act void(?t))
	match i next
	as none
		void
	as some s
		f[s.value]
		i each-recur f

# Returns a new iterable containing just the elements of the input for which `pred` returns true.
filter iterable ?a(a iterable ?a, pred act bool(?a))
	iterable: \
		itr = a iter
		{itr filter-recur pred} iterator
.filter-recur opt ?a(a iterator ?a, pred act bool(?a))
	match a next
	as none
		none
	as some s
		v = s value
		if pred[v]
			v some
		else
			# This one didn't satisfy the predicate, but keep trying until we get one or each the end
			a filter-recur pred

# Returns a new iterable which yields f[x] for each x in the input.
map iterable ?b(a iterable ?a, f act ?b(?a))
	iterable: \
		itr = a iter
		{itr map-recur f} iterator
.map-recur opt ?b(a iterator ?a, f act ?b(?a))
	match a next
	as none
		none
	as some s
		f[s value] some
