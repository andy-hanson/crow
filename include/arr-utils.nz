import
	.alloc: alloc unmanaged-alloc-elements
	.bootstrap
		+ - == != < <= > >= ? and arr bool byte by-val call char data deref drop false
		hard-assert hard-fail hard-forbid incr nat noctx-decr noctx-incr none not null
		opt or ptr ptr-cast ref-of-ptr set size size-of some void wrap-mul
	.exceptions: assert forbid
	.number-utils: + - * / decr incr
	.opt-utils: force

arr-from-begin-end arr ?t(begin ptr ?t, end ptr ?t) unsafe noctx
	arr: (end - begin), begin

empty-arr arr ?t() noctx trusted
	arr: 0, null

empty? bool(a arr ?t) noctx
	a.size == 0

has? bool(a arr ?t) noctx
	a.empty? not

slice arr ?t(a arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	arr: size, a.data + begin

slice mut-arr ?t(a mut-arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	mut-arr: size, a.data + begin

slice-from-to arr ?t(a arr ?t, begin nat, end nat) trusted
	assert: begin <= end
	a slice: begin, end - begin

slice-starting-at arr ?t(a arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

slice-starting-at mut-arr ?t(a mut-arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

slice-after arr ?t(a arr ?t, before-begin nat)
	a slice-starting-at before-begin.incr

slice-after mut-arr ?t(a mut-arr ?t, before-begin nat)
	a slice-starting-at before-begin.incr

slice-up-to arr ?t(a arr ?t, size nat)
	assert: size < a.size
	a slice: 0, size

with-max-size arr ?t(a arr ?t, max-size nat)
	a.size <= max-size ?: a, a slice 0, max-size

first ?t(a arr ?t)
	forbid: a empty?
	a at 0

first-some opt ?out(a arr ?in, cb act opt ?out(?in))
	if a empty?
		none
	else
		match cb call a.first
		as none
			a.tail first-some cb
		as some s
			s

last ?t(a arr ?t)
	forbid: a empty?
	a at a.size.decr

tail arr ?t(a arr ?t)
	forbid: a empty?
	a slice-starting-at 1

rtail arr ?t(a arr ?t)
	forbid: a empty?
	a slice 0, a.size.decr

noctx-at ?t(a arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

ref-of-val-at ?t(a arr by-val<?t>, index nat) trusted
	assert: index < a.size
	a.data + index ref-of-ptr



mut-arr<?t> record mut
	by-val
	| TODO:PRIVATE
	arr arr ?t

empty-mut-arr mut-arr ?t() noctx
	mut-arr: empty-arr

mut-arr mut-arr ?t(size nat, data ptr ?t) noctx unsafe
	mut-arr: arr: size, data

new-uninitialized-mut-arr mut-arr ?t(size nat) unsafe
	mut-arr: size, uninitialized-data<?t>: size

cast-immutable arr ?t(a mut-arr ?t) noctx unsafe
	a.arr

size nat(a mut-arr ?t) noctx
	a.arr size

data ptr ?t(a mut-arr ?t) noctx unsafe
	a.arr data

at ?t(a mut-arr ?t, index nat)
	a.arr at index

set-at void(a mut-arr ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at index, value

noctx-set-at void(a mut-arr ?t, index nat, value ?t) noctx unsafe
	hard-assert: index < a.size
	a.data + index set value

prepend arr ?t(a ?t, b arr ?t)
	(new-arr a) + b

append arr ?t(a arr ?t, b ?t)
	a + (new-arr b)

| + arr ?t(a arr ?t, b arr ?t) trusted
| 	a.size + b.size make-arr \i
| 		if i < a.size
| 			a at i
| 		else
| 			b at: i - a.size

+ arr ?t(a arr ?t, b arr ?t) trusted
	res-size = a.size + b.size
	res = res-size uninitialized-data<?t>
	res copy-data-from a.data, a.size
	res + a.size copy-data-from b.data, b.size
	arr<?t>: res-size, res

sort arr ?t(a arr ?t) data<?t> trusted
	res = a copy-to-mut-arr
	res sort
	res cast-immutable

temp-as-mut-arr mut-arr ?t(a mut-list ?t) noctx unsafe
	mut-arr: arr: a.size, a.data

temp-as-arr arr ?t(a mut-arr ?t) noctx unsafe
	a arr

temp-as-arr arr ?t(a mut-list ?t) noctx unsafe
	a.temp-as-mut-arr temp-as-arr

sort void(a mut-list ?t) trusted data<?t>
	a.temp-as-mut-arr sort

sort void(a mut-arr ?t) data<?t>
	if a.size > 1
		| Perf -- in case a is sorted already, prefer the middle element as a pivot
		a swap: 0, a.size / 2
		pivot = a at 0
		index-of-first-value-gt-pivot = a partition-recur pivot, 1, a.size.decr
		new-pivot-index = index-of-first-value-gt-pivot.decr
		a swap 0, new-pivot-index

		sort: a slice 0, new-pivot-index
		sort: a slice-after new-pivot-index

swap void(a mut-arr ?t, x nat, y nat)
	old-x = a at x
	a set-at: x, a at y
	a set-at y, old-x

| Returns index of first value > pivot
partition-recur nat(a mut-arr ?t, pivot ?t, l nat, r nat) data<?t>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		em = a at l
		if em < pivot
			a partition-recur pivot, l.incr, r
		else
			a swap l, r
			a partition-recur pivot, l, r.decr
	else
		l


| NOTE: this is not a normal record, compiler treats it specially
| TODO: constructor should be private
mut-list<?t> record mut
	| TODO:PRIVATE
	| backing.size is the capacity
	| For the GC's sake, unused parts of backing are filled with 'zeroed'
	backing mut mut-arr ?t
	size mut nat

data ptr ?t(a mut-list ?t) noctx unsafe
	a.backing data

capacity nat(a mut-list ?t) noctx unsafe
	a.backing size

| TODO:MOVE?
mut-str alias
	mut-list char

uninitialized-data ptr ?t(size nat) unsafe
	bptr = size wrap-mul size-of<?t> alloc
	bptr ptr-cast<?t, byte>

new-mut-list-by-val-with-capacity-from-unmanaged-memory by-val mut-list ?t(capacity nat) noctx unsafe
	backing = mut-arr: capacity, capacity unmanaged-alloc-elements<?t>
	mut-list<?t>: backing, 0

new-mut-list mut-list ?t() trusted
	mut-list: empty-mut-arr, 0

new-mut-list-by-val by-val mut-list<?t>() noctx trusted
	mut-list<?t>: empty-mut-arr, 0

empty? bool(a mut-list ?t) noctx
	a.size == 0

has? bool(a mut-list ?t) noctx
	a.empty? not

noctx-set-at void(a mut-list ?t, index nat, value ?t) noctx trusted
	hard-assert: index < a.size
	(a.data + index) set value

set-at void(a mut-list ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at index, value

noctx-last ?t(a mut-list ?t) noctx unsafe
	hard-forbid: a empty?
	a noctx-at a.size.noctx-decr

some? bool(a arr ?t, pred act bool(?t))
	a.empty?.not and: (pred call a.first or: a.tail some? pred)

| TODO: only written this way to be `noctx`, else could defer to `some?`
contains? bool(a arr ?t, value ?t) noctx data<?t>
	a contains-recur? value, 0

contains? bool(a mut-list ?t, value ?t) noctx trusted data<?t>
	a.temp-as-arr contains-recur? value, 0

contains-recur? bool(a arr ?t, value ?t, i nat) noctx trusted data<?t>
	if i == a.size
		false
	else
		a noctx-at i == value or: a contains-recur? value, i.noctx-incr

contains-subsequence? bool(a arr ?t, subseq arr ?t) data<?t>
	| TODO: faster algorithm
	a starts-with? subseq or: a.has? and: a.tail starts-with? subseq

starts-with? bool(a arr ?t, start arr ?t) data<?t>
	a.size >= start.size and: a slice 0, start.size arr-eq? start

ends-with? bool(a arr ?t, end arr ?t) data<?t>
	a.size >= end.size and: a slice (a.size - end.size), end.size arr-eq? end

| TODO: should be unnecessary, just use '=='
arr-eq? bool(a arr ?t, b arr ?t) data<?t>
	a.size == b.size and: a.empty? or: a.first == b.first and: a.tail arr-eq? b.tail

remove-start arr ?t(a arr ?t, start arr ?t) data<?t>
	a try-remove-start start force

try-remove-start opt arr<?t>(a arr ?t, start arr ?t) data<?t>
	if a starts-with? start
		a slice-starting-at start.size some
	else
		none

push-capacity-must-be-sufficient void(a mut-list ?t, value ?t) noctx unsafe
	hard-assert: a.size < a.capacity
	old-size = a.size
	a set-size old-size.noctx-incr
	a noctx-set-at old-size, value

noctx-remove-unordered-at-index ?t(a mut-list ?t, index nat) noctx unsafe
	res = a noctx-at index
	a noctx-set-at index, a.noctx-last
	a set-size a.size.noctx-decr
	res

.noctx-must-remove-unordered-recur void(a mut-list ?t, index nat, value ?t) noctx unsafe data<?t>
	if index == a.size
		hard-fail: "Did not find the element in the mut-list"
	elif a noctx-at index == value
		a noctx-remove-unordered-at-index index drop
	else
		a noctx-must-remove-unordered-recur index.noctx-incr, value

noctx-must-remove-unordered void(a mut-list ?t, value ?t) noctx unsafe data<?t>
	a noctx-must-remove-unordered-recur 0, value

| Unsafe as this does *not* freeze it!
unsafe-as-arr arr ?t(a mut-list ?t) noctx unsafe
	arr: a.size, a.data

move-to-arr arr ?t(a mut-list ?t) noctx trusted
	res = arr: a.size, a.data
	a set-backing empty-mut-arr
	a set-size 0
	res

noctx-at ?t(a mut-list ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a mut-list ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

copy-data-from void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len < 8
		to copy-data-from-small from, len
	else
		hl = len / 2
		to copy-data-from from, hl
		(to + hl) copy-data-from (from + hl), (len - hl)

copy-data-from-small void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len != 0
		to set: from deref
		| TODO: should be able to infer type arguments
		| TODO: I wish this were linear, but that runs out of stack ...
		to.incr copy-data-from<?t> from.incr, len.decr

push void(a mut-list ?t, value ?t) trusted
	if a.size == a.capacity
		a increase-capacity-to: a.size == 0 ?: 4, a.size * 2
	a ensure-capacity a.size.incr.round-up-to-power-of-two
	a.size < a.capacity assert
	(a.data + a.size) set value
	a set-size: a.size incr

push-all void(a mut-list ?t, values arr ?t)
	values each {a push it}

increase-capacity-to void(a mut-list ?t, new-capacity nat) unsafe
	assert: new-capacity > a.capacity
	old-data = a.data
	a set-backing: mut-arr: new-capacity, uninitialized-data<?t>: new-capacity
	a.data copy-data-from old-data, a.size

| TODO:MOVE
round-up-to-power-of-two nat(n nat)
	1 round-up-to-power-of-two-recur n
round-up-to-power-of-two-recur nat(acc nat, n nat)
	if acc >= n
		acc
	else
		acc * 2 round-up-to-power-of-two-recur n

ensure-capacity void(a mut-list ?t, capacity nat) unsafe
	if a.capacity < capacity
		a increase-capacity-to: capacity.round-up-to-power-of-two

| Unsafe because increasing the size can expose uninitialized data
unsafe-set-size void(a mut-list ?t, new-size nat) unsafe
	assert: new-size <= a.capacity
	a set-size new-size

unsafe-increase-size void(a mut-list ?t, increase-by nat) unsafe
	a unsafe-set-size: a.size + increase-by

reduce-size-if-more-than void(a mut-list ?t, new-size nat)
	if new-size < a.size
		a set-size new-size

fold ?a(val ?a, a arr ?b, combine act ?a(?a, ?b))
	if a empty?
		val
	else
		combine call val, a.first fold a.tail, combine

make-arr arr ?t(size nat, f act ?t(nat)) trusted
	size make-mut-arr f cast-immutable

make-mut-arr mut-arr ?t(size nat, f act ?t(nat)) trusted
	res = new-uninitialized-mut-arr<?t>: size
	res make-mut-arr-worker 0, f
	res

fill-arr arr ?t(size nat, value ?t)
	size make-arr \ignore
		value

fill-mut-arr mut-arr ?t(size nat, value ?t)
	size make-mut-arr \ignore
		value

fill-mut-list mut-list ?t(size nat, value ?t)
	backing = size fill-mut-arr value
	mut-list: backing, size

make-mut-arr-worker void(a mut-arr ?t, i nat, f act ?t(nat))
	if i != a.size
		a set-at: i, f call i
		a make-mut-arr-worker i.incr, f

copy-to-mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> \i
		a at i

each void(a arr ?t, f act void(?t))
	if a.empty? not
		f call a.first
		a.tail each f

each void(a mut-list ?t, f act void(?t)) trusted
	a.temp-as-arr each f

each-with-index void(a arr ?t, f act void(?t, nat))
	a each-with-index-recur f, 0

each-with-index-recur void(a arr ?t, f act void(?t, nat), n nat)
	if n != a.size
		f call (a at n), n
		a each-with-index-recur f, n.incr

map arr ?out(a arr ?in, mapper act ?out(?in)) trusted
	a.size make-arr \i
		mapper call: a at i

flat-map arr ?out(a arr ?in, mapper act arr ?out(?in)) trusted
	res = new-mut-list<?out>
	a each \x
		res push-all: mapper call x
	res move-to-arr

index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-index {it == value}

r-index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-rindex {it == value}

find-index opt nat(a arr ?t, pred act bool(?t))
	a find-index-recur 0, pred

find-index-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if index == a.size
		none
	elif pred call: a at index
		index some
	else
		a find-index-recur index.incr, pred

find-rindex opt nat(a arr ?t, pred act bool(?t))
	if a empty?
		none
	else
		a find-rindex-recur a.size.decr, pred
find-rindex-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if pred call: a at index
		index some
	elif index == 0
		none
	else
		a find-rindex-recur index.decr, pred
