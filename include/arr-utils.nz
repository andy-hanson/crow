import
	.alloc: alloc set-zero-range
	.bootstrap
		+ - == != < <= > >= ? and arr bool byte by-val call data deref false hard-assert incr nat
		noctx-incr none not null opt or ptr ptr-cast ref-of-ptr set size size-of some void wrap-mul
	.exceptions: assert forbid
	.number-utils: + - / decr incr
	.opt-utils: force

arr-from-begin-end arr ?t(begin ptr ?t, end ptr ?t) unsafe noctx
	arr: (end - begin), begin

empty-arr arr ?t() noctx trusted
	arr: 0, null

empty? bool(a arr ?t) noctx
	a.size == 0

has? bool(a arr ?t) noctx
	a.empty? not

slice arr ?t(a arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	arr: size, a.data + begin

slice mut-arr ?t(a mut-arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	mut-arr: size, a.data + begin

slice-from-to arr ?t(a arr ?t, begin nat, end nat) trusted
	assert: begin <= end
	a slice: begin, end - begin

slice-starting-at arr ?t(a arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

slice-starting-at mut-arr ?t(a mut-arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

slice-after arr ?t(a arr ?t, before-begin nat)
	a slice-starting-at before-begin.incr

slice-after mut-arr ?t(a mut-arr ?t, before-begin nat)
	a slice-starting-at before-begin.incr

slice-up-to arr ?t(a arr ?t, size nat)
	assert: size < a.size
	a slice: 0, size

with-max-size arr ?t(a arr ?t, max-size nat)
	a.size <= max-size ?: a, a slice 0, max-size

first ?t(a arr ?t)
	forbid: a empty?
	a at 0

first-some opt ?out(a arr ?in, cb act opt ?out(?in))
	if a empty?
		none
	else
		match cb call a.first
		as none
			a.tail first-some cb
		as some s
			s

last ?t(a arr ?t)
	forbid: a empty?
	a at a.size.decr

tail arr ?t(a arr ?t)
	forbid: a empty?
	a slice-starting-at 1

rtail arr ?t(a arr ?t)
	forbid: a empty?
	a slice 0, a.size.decr

noctx-at ?t(a arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

ref-of-val-at ?t(a arr by-val<?t>, index nat) trusted
	assert: index < a.size
	a.data + index ref-of-ptr



mut-arr<?t> record mut
	by-val
	| TODO:PRIVATE
	arr arr ?t

empty-mut-arr mut-arr ?t() noctx
	mut-arr: empty-arr

set-zero-elements void(a mut-arr ?t) noctx unsafe
	a.data set-zero-range a.size

mut-arr mut-arr ?t(size nat, data ptr ?t) noctx unsafe
	mut-arr: arr: size, data

new-uninitialized-mut-arr mut-arr ?t(size nat) unsafe
	mut-arr: size, uninitialized-data<?t>: size

cast-immutable arr ?t(a mut-arr ?t) noctx unsafe
	a.arr

size nat(a mut-arr ?t) noctx
	a.arr size

data ptr ?t(a mut-arr ?t) noctx unsafe
	a.arr data

at ?t(a mut-arr ?t, index nat)
	a.arr at index

set-at void(a mut-arr ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at index, value

noctx-set-at void(a mut-arr ?t, index nat, value ?t) noctx unsafe
	hard-assert: index < a.size
	a.data + index set value

prepend arr ?t(a ?t, b arr ?t)
	(new-arr a) + b

append arr ?t(a arr ?t, b ?t)
	a + (new-arr b)

| + arr ?t(a arr ?t, b arr ?t) trusted
| 	a.size + b.size make-arr \i
| 		if i < a.size
| 			a at i
| 		else
| 			b at: i - a.size

+ arr ?t(a arr ?t, b arr ?t) trusted
	res-size = a.size + b.size
	res = res-size uninitialized-data<?t>
	res copy-data-from a.data, a.size
	res + a.size copy-data-from b.data, b.size
	arr<?t>: res-size, res

sort arr ?t(a arr ?t) data<?t> trusted
	res = a copy-to-mut-arr
	res sort
	res cast-immutable

temp-as-arr arr ?t(a mut-arr ?t) noctx unsafe
	a arr

sort void(a mut-arr ?t) data<?t>
	if a.size > 1
		| Perf -- in case a is sorted already, prefer the middle element as a pivot
		a swap: 0, a.size / 2
		pivot = a at 0
		index-of-first-value-gt-pivot = a partition-recur pivot, 1, a.size.decr
		new-pivot-index = index-of-first-value-gt-pivot.decr
		a swap 0, new-pivot-index

		sort: a slice 0, new-pivot-index
		sort: a slice-after new-pivot-index

swap void(a mut-arr ?t, x nat, y nat)
	old-x = a at x
	a set-at: x, a at y
	a set-at y, old-x

| Returns index of first value > pivot
partition-recur nat(a mut-arr ?t, pivot ?t, l nat, r nat) data<?t>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		em = a at l
		if em < pivot
			a partition-recur pivot, l.incr, r
		else
			a swap l, r
			a partition-recur pivot, l, r.decr
	else
		l

uninitialized-data ptr ?t(size nat) unsafe
	bptr = size wrap-mul size-of<?t> alloc
	bptr ptr-cast<?t, byte>

some? bool(a arr ?t, pred act bool(?t))
	a.empty?.not and: (pred call a.first or: a.tail some? pred)

| TODO: only written this way to be `noctx`, else could defer to `some?`
contains? bool(a arr ?t, value ?t) noctx data<?t>
	a contains-recur? value, 0

contains-recur? bool(a arr ?t, value ?t, i nat) noctx trusted data<?t>
	if i == a.size
		false
	else
		a noctx-at i == value or: a contains-recur? value, i.noctx-incr

contains-subsequence? bool(a arr ?t, subseq arr ?t) data<?t>
	| TODO: faster algorithm
	a starts-with? subseq or: a.has? and: a.tail starts-with? subseq

starts-with? bool(a arr ?t, start arr ?t) data<?t>
	a.size >= start.size and: a slice 0, start.size arr-eq? start

ends-with? bool(a arr ?t, end arr ?t) data<?t>
	a.size >= end.size and: a slice (a.size - end.size), end.size arr-eq? end

| TODO: should be unnecessary, just use '=='
arr-eq? bool(a arr ?t, b arr ?t) data<?t>
	a.size == b.size and: a.empty? or: a.first == b.first and: a.tail arr-eq? b.tail

remove-start arr ?t(a arr ?t, start arr ?t) data<?t>
	a try-remove-start start force

try-remove-start opt arr<?t>(a arr ?t, start arr ?t) data<?t>
	if a starts-with? start
		a slice-starting-at start.size some
	else
		none

copy-data-from void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len < 8
		to copy-data-from-small from, len
	else
		hl = len / 2
		to copy-data-from from, hl
		(to + hl) copy-data-from (from + hl), (len - hl)

copy-data-from-small void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len != 0
		to set: from deref
		| TODO: should be able to infer type arguments
		| TODO: I wish this were linear, but that runs out of stack ...
		to.incr copy-data-from<?t> from.incr, len.decr

fold ?a(val ?a, a arr ?b, combine act ?a(?a, ?b))
	if a empty?
		val
	else
		combine call val, a.first fold a.tail, combine

make-arr arr ?t(size nat, f act ?t(nat)) trusted
	size make-mut-arr f cast-immutable

make-mut-arr mut-arr ?t(size nat, f act ?t(nat)) trusted
	res = new-uninitialized-mut-arr<?t>: size
	res make-mut-arr-worker 0, f
	res

fill-arr arr ?t(size nat, value ?t)
	size make-arr \ignore
		value

fill-mut-arr mut-arr ?t(size nat, value ?t)
	size make-mut-arr \ignore
		value

make-mut-arr-worker void(a mut-arr ?t, i nat, f act ?t(nat))
	if i != a.size
		a set-at: i, f call i
		a make-mut-arr-worker i.incr, f

copy-to-mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> \i
		a at i

each void(a arr ?t, f act void(?t))
	if a.empty? not
		f call a.first
		a.tail each f

each-with-index void(a arr ?t, f act void(?t, nat))
	a each-with-index-recur f, 0

each-with-index-recur void(a arr ?t, f act void(?t, nat), n nat)
	if n != a.size
		f call (a at n), n
		a each-with-index-recur f, n.incr

map arr ?out(a arr ?in, mapper act ?out(?in)) trusted
	a.size make-arr \i
		mapper call: a at i

index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-index {it == value}

r-index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-rindex {it == value}

find-index opt nat(a arr ?t, pred act bool(?t))
	a find-index-recur 0, pred

find-index-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if index == a.size
		none
	elif pred call: a at index
		index some
	else
		a find-index-recur index.incr, pred

find-rindex opt nat(a arr ?t, pred act bool(?t))
	if a empty?
		none
	else
		a find-rindex-recur a.size.decr, pred
find-rindex-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if pred call: a at index
		index some
	elif index == 0
		none
	else
		a find-rindex-recur index.decr, pred
