import
	.alloc: alloc
	.bootstrap
		+ - == < <= > >= ? and arr bool byte by-val call data deref drop false fun-mut1
		fun-mut2 hard-assert hard-fail hard-forbid incr nat noctx-decr noctx-incr none not null
		opt or pass ptr ptr-cast ref-of-ptr set size size-of some true void wrap-mul
	.exceptions: assert forbid
	.number-utils: + - * / decr incr
	.opt-utils: force

arr-from-begin-end arr ?t(begin ptr ?t, end ptr ?t) unsafe noctx
	arr: (end - begin), begin

empty-arr arr ?t() noctx trusted
	arr: 0, null

empty? bool(a arr ?t) noctx
	a.size == 0

has? bool(a arr ?t) noctx
	a.empty? not

slice arr ?t(a arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	arr: size, a.data + begin

slice-from-to arr ?t(a arr ?t, begin nat, end nat) trusted
	assert: begin <= end
	a slice: begin, end - begin

slice-starting-at arr ?t(a arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

slice-after arr ?t(a arr ?t, before-begin nat)
	a slice-starting-at before-begin.incr

slice-up-to arr ?t(a arr ?t, size nat)
	assert: size < a.size
	a slice: 0, size

with-max-size arr ?t(a arr ?t, max-size nat)
	a.size <= max-size ?: a, a slice 0, max-size

first ?t(a arr ?t)
	forbid: a empty?
	a at 0

first-some opt ?out(a arr ?in, cb fun-mut1 opt<?out> ?in)
	if a empty?
		none
	else
		match cb call a.first
		as none
			a.tail first-some cb
		as some s
			s

last ?t(a arr ?t)
	forbid: a empty?
	a at a.size.decr

tail arr ?t(a arr ?t)
	forbid: a empty?
	a slice-starting-at 1

rtail arr ?t(a arr ?t)
	forbid: a empty?
	a slice 0, a.size.decr

noctx-at ?t(a arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

ref-of-val-at ?t(a arr by-val<?t>, index nat) trusted
	assert: index < a.size
	a.data + index ref-of-ptr

prepend arr ?t(a ?t, b arr ?t)
	(new-arr a) + b

append arr ?t(a arr ?t, b ?t)
	a + (new-arr b)

+ arr ?t(a arr ?t, b arr ?t) trusted
	a.size + b.size make-arr \i
		if i < a.size
			a at i
		else
			b at: i - a.size

mut-slice<?t> record mut
	backing mut-arr ?t
	size nat
	begin nat

to-mut-slice mut-slice ?t(a mut-arr ?t)
	forbid: a.frozen?
	mut-slice: a, a.size, 0

slice mut-slice ?t(a mut-slice ?t, lo nat, size nat) trusted
	assert: lo + size <= a.size
	mut-slice: a.backing, size, a.begin + lo

slice mut-slice ?t(a mut-slice ?t, lo nat)
	assert: lo <= a.size
	a slice: lo, a.size - lo

at ?t(a mut-slice ?t, index nat) trusted
	assert: index < a.size
	a.backing at: a.begin + index

set-at void(a mut-slice ?t, index nat, value ?t) trusted
	assert: index < a.size
	a.backing set-at (a.begin + index), value

sort arr ?t(a arr ?t) data<?t>
	m = a to-mut-arr
	m sort
	m freeze

swap void(a mut-slice ?t, lo nat, hi nat)
	old-lo = a at lo
	a set-at: lo, a at hi
	a set-at hi, old-lo

sort void(a mut-arr ?t) trusted data<?t>
	a.to-mut-slice sort

sort void(a mut-slice ?t) data<?t>
	if a.size <= 1
		pass
	else
		| Perf -- in case a is sorted already, prefer the middle element as a pivot
		a swap: 0, a.size / 2
		pivot = a at 0
		index-of-first-value-gt-pivot = a partition-recur pivot, 1, a.size.decr
		new-pivot-index = index-of-first-value-gt-pivot.decr
		a swap 0, new-pivot-index

		sort: a slice 0, new-pivot-index
		sort: a slice new-pivot-index.incr


| Returns index of first value > pivot
partition-recur nat(a mut-slice ?t, pivot ?t, l nat, r nat) data<?t>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		em = a at l
		if em < pivot
			a partition-recur pivot, l.incr, r
		else
			a swap l, r
			a partition-recur pivot, l, r.decr
	else
		l


| NOTE: this is not a normal record, compiler treats it specially
mut-arr<?t> record mut
	frozen? mut bool
	| Number of *initialized* elements.
	| But 'uninitialized-mut-arr' sets 'size' and doesn't initialize!
	size mut nat
	capacity mut nat
	data mut ptr ?t

temp-as-arr arr ?t(a mut-arr ?t) unsafe noctx
	arr: a.size, a.data

uninitialized-data ptr ?t(size nat) unsafe
	bptr = size wrap-mul size-of<?t> alloc
	bptr ptr-cast<?t, byte>

new-uninitialized-mut-arr mut-arr ?t(size nat) unsafe
	mut-arr: false, size, size, uninitialized-data<?t>: size

new-mut-arr mut-arr ?t() trusted
	mut-arr: false, 0, 0, null

new-mut-arr-by-val by-val mut-arr<?t>() noctx trusted
	mut-arr<?t>: false, 0, 0, null

empty? bool(a mut-arr ?t) noctx
	a.size == 0

has? bool(a mut-arr ?t) noctx
	a.empty? not

noctx-set-at void(a mut-arr ?t, index nat, value ?t) noctx trusted
	hard-assert: index < a.size
	(a.data + index) set value

set-at void(a mut-arr ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at index, value

noctx-last ?t(a mut-arr ?t) noctx unsafe
	hard-forbid: a empty?
	a noctx-at a.size.noctx-decr

noctx-remove-unordered-at-index ?t(a mut-arr ?t, index nat) noctx unsafe
	res = a noctx-at index
	a noctx-set-at index, a.noctx-last
	a set-size a.size.noctx-decr
	res


some? bool(a arr ?t, pred fun-mut1 bool ?t)
	a.empty?.not and: (pred call a.first or: a.tail some? pred)

| TODO: only written this way to be `noctx`, else could defer to `some?`
contains? bool(a arr ?t, value ?t) noctx data<?t>
	a contains-recur? value, 0

contains? bool(a mut-arr ?t, value ?t) noctx trusted data<?t>
	a.temp-as-arr contains-recur? value, 0

contains-recur? bool(a arr ?t, value ?t, i nat) noctx trusted data<?t>
	if i == a.size
		false
	else
		a noctx-at i == value or: a contains-recur? value, i.noctx-incr

contains-subsequence? bool(a arr ?t, subseq arr ?t) data<?t>
	| TODO: faster algorithm
	a starts-with? subseq or: a.has? and: a.tail starts-with? subseq

starts-with? bool(a arr ?t, start arr ?t) data<?t>
	a.size >= start.size and: a slice 0, start.size arr-eq? start

ends-with? bool(a arr ?t, end arr ?t) data<?t>
	a.size >= end.size and: a slice (a.size - end.size), end.size arr-eq? end

| TODO: should be unnecessary, just use '=='
arr-eq? bool(a arr ?t, b arr ?t) data<?t>
	a.size == b.size and: a.empty? or: a.first == b.first and: a.tail arr-eq? b.tail

remove-start arr ?t(a arr ?t, start arr ?t) data<?t>
	a try-remove-start start force

try-remove-start opt arr<?t>(a arr ?t, start arr ?t) data<?t>
	if a starts-with? start
		a slice-starting-at start.size some
	else
		none

push-capacity-must-be-sufficient void(a mut-arr ?t, value ?t) noctx unsafe
	hard-assert: a.size < a.capacity
	old-size = a.size
	a set-size old-size.noctx-incr
	a noctx-set-at old-size, value

noctx-must-remove-unordered-recur void(a mut-arr ?t, index nat, value ?t) noctx unsafe data<?t>
	if index == a.size
		hard-fail: "Did not find the element in the mut-arr"
	elif a noctx-at index == value
		a noctx-remove-unordered-at-index index drop
	else
		a noctx-must-remove-unordered-recur index.noctx-incr, value

noctx-must-remove-unordered void(a mut-arr ?t, value ?t) noctx unsafe data<?t>
	a noctx-must-remove-unordered-recur 0, value

| Unsafe as this does *not* freeze it!
unsafe-as-arr arr ?t(a mut-arr ?t) noctx unsafe
	arr: a.size, a.data

freeze arr ?t(a mut-arr ?t) noctx trusted
	a set-frozen? true
	a unsafe-as-arr

noctx-at ?t(a mut-arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a mut-arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

copy-data-from void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len < 8
		to copy-data-from-small from, len
	else
		hl = len / 2
		to copy-data-from from, hl
		(to + hl) copy-data-from (from + hl), (len - hl)

copy-data-from-small void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len == 0
		pass
	else
		to set: from deref
		| TODO: should be able to infer type arguments
		| TODO: I wish this were linear, but that runs out of stack ...
		to.incr copy-data-from<?t> from.incr, len.decr

push void(a mut-arr ?t, value ?t) trusted
	if a.size == a.capacity
		a increase-capacity-to: a.size == 0 ?: 4, a.size * 2
	else
		pass
	a ensure-capacity a.size.incr.round-up-to-power-of-two
	a.size < a.capacity assert
	(a.data + a.size) set value
	a set-size: a.size incr

push-all void(a mut-arr ?t, values arr ?t)
	values each {a push it}

increase-capacity-to void(a mut-arr ?t, new-capacity nat) unsafe
	assert: new-capacity > a.capacity
	old-data = a.data
	a set-capacity new-capacity
	a set-data uninitialized-data<?t>: new-capacity
	a.data copy-data-from old-data, a.size

| TODO:MOVE
round-up-to-power-of-two nat(n nat)
	1 round-up-to-power-of-two-recur n
round-up-to-power-of-two-recur nat(acc nat, n nat)
	if acc >= n
		acc
	else
		acc * 2 round-up-to-power-of-two-recur n

ensure-capacity void(a mut-arr ?t, capacity nat) unsafe
	if a.capacity < capacity
		a increase-capacity-to: capacity.round-up-to-power-of-two
	else
		pass

| Unsafe because increasing the size can expose uninitialized data
unsafe-set-size void(a mut-arr ?t, new-size nat) unsafe
	assert: new-size <= a.capacity
	a set-size new-size

unsafe-increase-size void(a mut-arr ?t, increase-by nat) unsafe
	a unsafe-set-size: a.size + increase-by

reduce-size-if-more-than void(a mut-arr ?t, new-size nat)
	if new-size < a.size
		a set-size new-size
	else
		pass

fold ?a(val ?a, a arr ?b, combine fun-mut2 ?a ?a ?b)
	if a empty?
		val
	else
		combine call val, a.first fold a.tail, combine


make-arr arr ?t(size nat, f fun-mut1 ?t nat)
	size make-mut-arr f freeze

make-mut-arr mut-arr ?t(size nat, f fun-mut1 ?t nat) trusted
	res = new-uninitialized-mut-arr<?t>: size
	res make-mut-arr-worker 0, f
	res

fill-arr arr ?t(size nat, value ?t)
	size make-arr \ignore
		value

fill-mut-arr mut-arr ?t(size nat, value ?t)
	size make-mut-arr \ignore
		value

make-mut-arr-worker void(m mut-arr ?t, i nat, f fun-mut1 ?t nat)
	if i == m.size
		pass
	else
		m set-at: i, f call i
		m make-mut-arr-worker i.incr, f

to-mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> \i
		a at i

each void(a arr ?t, f fun-mut1 void ?t)
	if a empty?
		pass
	else
		f call a.first
		a.tail each f

each void(a mut-arr ?t, f fun-mut1 void ?t) trusted
	was-frozen? = a.frozen?
	a set-frozen? true
	a.temp-as-arr each f
	a set-frozen? was-frozen?

each-with-index void(a arr ?t, f fun-mut2 void ?t nat)
	a each-with-index-recur f, 0

each-with-index-recur void(a arr ?t, f fun-mut2 void ?t nat, n nat)
	if n == a.size
		pass
	else
		f call (a at n), n
		a each-with-index-recur f, n.incr

map arr ?out(a arr ?in, mapper fun-mut1 ?out ?in) trusted
	a.size make-arr \i
		mapper call: a at i

flat-map arr ?out(a arr ?in, mapper fun-mut1 arr<?out> ?in) trusted
	res = new-mut-arr<?out>
	a each {res push-all: mapper call it}
	res freeze

index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-index {it == value}

r-index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-rindex {it == value}

find-index opt nat(a arr ?t, pred fun-mut1 bool ?t)
	a find-index-recur 0, pred

find-index-recur opt nat(a arr ?t, index nat, pred fun-mut1 bool ?t)
	if index == a.size
		none
	elif pred call: a at index
		index some
	else
		a find-index-recur index.incr, pred

find-rindex opt nat(a arr ?t, pred fun-mut1 bool ?t)
	if a empty?
		none
	else
		a find-rindex-recur a.size.decr, pred
find-rindex-recur opt nat(a arr ?t, index nat, pred fun-mut1 bool ?t)
	if pred call: a at index
		index some
	elif index == 0
		none
	else
		a find-rindex-recur index.decr, pred
