import
	.bootstrap
		== < <= >= ? bool and float int int32 nat nat8 nat16 nat32 or to-int to-nat unsafe-div unsafe-to-int
		unsafe-to-int32 unsafe-to-nat unsafe-to-nat32 wrap-add wrap-mul wrap-sub
	.exceptions: assert forbid

region conversion

to-float float(a nat) noctx builtin
to-float float(a int) noctx builtin
truncate-to-int int(a float) noctx builtin

region arithmetic

multiple-of? bool(a nat, b nat)
	a mod b == 0

incr nat(n nat)
	forbid: n == max-nat
	n wrap-add 1

incr int(i int)
	forbid: i == max-int
	i wrap-add 1

| TODO: use specs for this kind of function
decr nat(a nat)
	a - 1
decr int(a int)
	a - 1
decr int32(a int32)
	a - 1

+ nat(a nat, b nat)
	res = a wrap-add b
	assert: res >= a and: res >= b
	res
- nat(a nat, b nat)
	assert: a >= b
	a wrap-sub b
* nat(a nat, b nat)
	| TODO: better safety check
	if a == 0 or: b == 0
		0
	else
		res = a wrap-mul b
		assert: res / b == a
		assert: res / a == b
		res
/ nat(a nat, b nat) trusted
	forbid: b == 0
	a unsafe-div b

unsafe-mod nat(a nat, b nat) noctx unsafe builtin

mod nat(a nat, b nat) trusted
	forbid: b == 0
	a unsafe-mod b

+ int(a int, b int)
	| TODO: safety check
	a wrap-add b
+ int32(a int32, b int32)
	a.to-int wrap-add b.to-int to-int32

- int(a int, b int)
	| TODO: safety check
	a wrap-sub b
- int32(a int32, b int32)
	a.to-int wrap-sub b.to-int to-int32

* int(a int, b int)
	| TODO: safety check
	a wrap-mul b
/ int(a int, b int) trusted
	forbid: b == 0
	forbid: a == min-int and: b == -1
	a unsafe-div b

to-int int(n nat)
	assert: n < max-int.to-nat
	n unsafe-to-int

to-int32 int32(a int)
	assert: a >= min-int32.to-int
	assert: a <= max-int32.to-int
	a unsafe-to-int32
to-int32 int32(n nat)
	assert: n < max-int32.to-nat
	n.unsafe-to-int unsafe-to-int32

to-nat nat(i int)
	forbid: i negative?
	i unsafe-to-nat

to-nat nat(i int32)
	i.to-int to-nat

to-nat32 nat32(a nat16) noctx trusted
	a.to-nat unsafe-to-nat32
to-nat32 nat32(a nat)
	assert: a < max-nat32.to-nat
	a unsafe-to-nat32

negative? bool(i int)
	i < 0

neg int(i int)
	i * -1

neg int(n nat)
	n.to-int neg

abs nat(i int)
	i-abs = i.negative? ? i.neg, i
	i-abs to-nat

mod nat(a int, b nat)
	forbid: b == 0
	if a negative?
		x = a.abs mod b
		x == b ?: 0, b - x
	else
		a.to-nat mod b

+ float(a float, b float) noctx builtin
- float(a float, b float) noctx builtin
* float(a float, b float) noctx builtin
unsafe-div float(a float, b float) noctx unsafe builtin

region constants

min-int32 int32() noctx
	-2147483648
max-int32 int32() noctx
	2147483647
min-int int() noctx
	-0x8000000000000000
max-int int() noctx
	0x7fffffffffffffff
max-nat8 nat8() noctx
	0xff
max-nat16 nat16() noctx
	0xffff
max-nat32 nat32() noctx
	0xffffffff
max-nat nat() noctx
	0xffffffffffffffff
