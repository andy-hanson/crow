import
	.bootstrap
		by-val err exception exclusion fun fut fut-callback-node fut-state-callbacks
		fut-state-resolved head island island-and-exclusion lk none ok opt ref-of-val result
		send set-state some state subscript todo value void
	.exceptions: catch
	.fut-low-level: new-unresolved-fut reject resolve resolve-or-reject
	.opt-utils: force
	.runtime: add-task exception-handler get-cur-island get-island new-exclusion
	.thread-utils: acquire-lock decrement new-lock new-thread-safe-counter release-lock thread-safe-counter

| Used to make code run after the next step. Equivalent to `sleep 0`.
delay fut void()
	void resolved

resolved fut ?t(value ?t)
	fut: new-lock, fut-state-resolved: value

rejected fut ?t(err exception)
	fut: new-lock, err

.joiner<?out, ?in0, ?in1> record force-sendable
	res fut ?out
	fun ref ?out(?in0, ?in1)
	arg0 mut opt result<?in0, exception>
	arg1 mut opt result<?in1, exception>
	| NOTE: we can't just check that both arg0 and arg1 are done -- we might try calling 'fun' twice.
	| We need to atomically decrement the counter so we only call 'fun' once
	n-remaining-args by-val thread-safe-counter

.decr-joiner void(j joiner<?out, ?in0, ?in1>) unsafe send<?out> send<?in0> send<?in1>
	if j.n-remaining-args.ref-of-val decrement
		match j.arg0 force
		as ok ok0
			match j.arg1 force
			as ok ok1
				j.fun[ok0.value, ok1.value] forward-to j.res
			as err e1
				j.res reject e1.value
		as err e0
			match j.arg1 force
			as ok
				j.res reject e0.value
			as err
				| Combine the exceptions
				todo

join fut ?out(a fut ?in0, b fut ?in1, fun ref ?out(?in0, ?in1)) trusted send<?out> send<?in0> send<?in1>
	res = new-unresolved-fut<?out>
	joiner = joiner<?out, ?in0, ?in1>: res, fun, none, none, new-thread-safe-counter: 2
	a then-void \value
		joiner set-arg0: value some
		joiner decr-joiner
	b then-void \value
		joiner set-arg1: value some
		joiner decr-joiner
	res

| NOTE: The function will be called with whatever ctx the fut terminates with!!!
then-void void(f fut ?t, cb act void(result<?t, exception>)) unsafe
	f.lk.ref-of-val acquire-lock
	match f state
	as fut-state-callbacks cbs
		| create a new callback
		f set-state fut-state-callbacks<?t>: some: fut-callback-node<?t>: cb, cbs.head
	as fut-state-resolved r
		cb[r.value ok]
	as exception e
		cb[e err]
	f.lk.ref-of-val release-lock

forward-to void(from fut ?t, to fut ?t) unsafe
	from then-void {to resolve-or-reject it}

fut-catch fut result<?t, exception>(a fut ?t) trusted
	res = new-unresolved-fut<result<?t, exception>>
	a then-void {res resolve it}
	res

then fut ?out(f fut ?in, cb ref ?out(?in)) trusted send<?out> send<?in>
	res = new-unresolved-fut<?out>
	f then-void \result
		match result
		as ok o
			cb[o.value] forward-to res
		as err e
			res reject e.value
	res

| TODO: rename to just 'then'
| This requires that we be able to handle two expected types at once,
| and choose just one based on the arity of a lambda.
then2 fut ?out(f fut void, cb ref ?out()) send<?out>
	f then<?out, void> \ignore
		cb[]

| Runs 'f' in parallel.
async fut ?t(f fun fut ?t()) trusted
	res = new-unresolved-fut<?t>
	island = get-cur-island
	island add-task island.new-exclusion, \
		f[] forward-to res
	res

subscript fut ?r(f ref ?r()) trusted send<?r>
	res = new-unresolved-fut<?r>
	f.island-and-exclusion.island.get-island add-task f.island-and-exclusion.exclusion, \
		{f.fun[] forward-to res} catch {res reject it}
	res

call-ref-void void(f ref void()) trusted
	f[] handle-exceptions

subscript fut ?r(f ref ?r(?p0), p0 ?p0) trusted send<?r> send<?p0>
	island = f.island-and-exclusion.island get-island
	res = new-unresolved-fut<?r>
	island add-task f.island-and-exclusion.exclusion, \
		{f.fun[p0] forward-to res} catch {res reject it}
	res

call-ref-void void(f ref void(?p0), p0 ?p0) trusted send<?p0>
	f[p0] handle-exceptions

subscript fut ?r(f ref ?r(?p0, ?p1), p0 ?p0, p1 ?p1) trusted send<?r> send<?p0> send<?p1>
	island = f.island-and-exclusion.island get-island
	res = new-unresolved-fut<?r>
	island add-task f.island-and-exclusion.exclusion, \
		{f.fun[p0, p1] forward-to res} catch {res reject it}
	res

call-ref-void void(f ref void(?p0, ?p1), p0 ?p0, p1 ?p1) send<?p0> send<?p1>
	f[p0, p1] handle-exceptions

handle-exceptions void(a fut ?t) trusted
	a then-void \result
		match result
		as ok
			void
		as err e
			get-cur-island.exception-handler[e.value]
