import
	.bootstrap
		by-val call err exception exclusion fun fun-mut1 fun0 fun-ref0 fun-ref1 fun-ref2 fut
		fut-callback-node fut-state-callbacks fut-state-resolved hard-unreachable head lk none ok
		opt ref-of-val result send set-state some state todo value island island-and-exclusion void
	.exceptions: catch
	.fut-low-level: new-unresolved-fut reject resolve-or-reject
	.opt-utils: force
	.runtime: add-task get-cur-island get-island new-exclusion task
	.thread-utils: acquire-lock decrement new-lock new-thread-safe-counter release-lock thread-safe-counter

| Used to make code run after the next step. Equivalent to `sleep 0`.
delay fut void()
	void resolved

resolved fut ?t(value ?t)
	fut: new-lock, fut-state-resolved: value

joiner<?out, ?in0, ?in1> record force-sendable
	res fut ?out
	fun fun-ref2 ?out ?in0 ?in1
	arg0 mut opt result<?in0, exception>
	arg1 mut opt result<?in1, exception>
	| NOTE: we can't just check that both arg0 and arg1 are done -- we might try calling 'fun' twice.
	| We need to atomically decrement the counter so we only call 'fun' once
	n-remaining-args by-val thread-safe-counter

decr-joiner void(j joiner ?out ?in0 ?in1) unsafe send<?out> send<?in0> send<?in1>
	if j.n-remaining-args.ref-of-val decrement
		match j.arg0 force
		as ok ok0
			match j.arg1 force
			as ok ok1
				j.fun call-ref ok0.value, ok1.value forward-to j.res
			as err e1
				j.res reject e1.value
		as err e0
			match j.arg1 force
			as ok a1
				j.res reject e0.value
			as err e1
				| Combine the exceptions
				todo

join fut ?out(a fut ?in0, b fut ?in1, fun fun-ref2 ?out ?in0 ?in1) trusted send<?out> send<?in0> send<?in1>
	res = new-unresolved-fut<?out>
	joiner = joiner<?out, ?in0, ?in1>: res, fun, none, none, new-thread-safe-counter: 2
	a then-void \value
		joiner set-arg0: value some
		joiner decr-joiner
	b then-void \value
		joiner set-arg1: value some
		joiner decr-joiner
	res

| NOTE: The function will be called with whatever ctx the fut terminates with!!!
then-void void(f fut ?t, cb fun-mut1 void result<?t, exception>) unsafe
	f.lk.ref-of-val acquire-lock
	match f state
	as fut-state-callbacks cbs
		| create a new callback
		f set-state fut-state-callbacks<?t>: some: fut-callback-node<?t>: cb, cbs.head
	as fut-state-resolved r
		cb call r.value.ok
	as exception e
		cb call e.err
	f.lk.ref-of-val release-lock

forward-to void(from fut ?t, to fut ?t) unsafe
	from then-void {to resolve-or-reject it}

then fut ?out(f fut ?in, cb fun-ref1 ?out ?in) trusted send<?out> send<?in>
	res = new-unresolved-fut<?out>
	f then-void \result
		match result
		as ok o
			cb call-ref o.value forward-to res
		as err e
			res reject e.value
	res

| TODO: rename to just 'then'
| This requires that we be able to handle two expected types at once,
| and choose just one based on the arity of a lambda.
then2 fut ?out(f fut void, cb fun-ref0 ?out) send<?out>
	f then<?out, void> \ignore
		cb call-ref

| Runs 'f' asynchronously.
| Since 'f' is 'fun' and not 'fun-mut' it is guaranteed to not close over 'mut' data.
| So we can run it in parallel.
async fut ?t(f fun0 fut<?t>) trusted
	res = new-unresolved-fut<?t>
	island = get-cur-island
	island add-task task: island.new-exclusion, \
		f.call forward-to res
	res

call-ref fut ?r(f fun-ref0 ?r) trusted send<?r>
	island = f.island-and-exclusion.island get-island
	res = new-unresolved-fut<?r>
	island add-task task: f.island-and-exclusion.exclusion, \
		{f.fun.call forward-to res} catch {res reject it}
	res

call-ref fut ?r(f fun-ref1 ?r ?p0, p0 ?p0) trusted send<?r> send<?p0>
	island = f.island-and-exclusion.island get-island
	res = new-unresolved-fut<?r>
	island add-task task: f.island-and-exclusion.exclusion, \
		{f.fun call p0 forward-to res} catch {res reject it}
	res

call-ref fut ?r(f fun-ref2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) trusted send<?r> send<?p0> send<?p1>
	island = f.island-and-exclusion.island get-island
	res = new-unresolved-fut<?r>
	island add-task task: f.island-and-exclusion.exclusion, \
		{f.fun call p0, p1 forward-to res} catch {res reject it}
	res

private

assert-resolved void(f fut ?t) unsafe
	match f state
	as fut-state-callbacks cbs
		hard-unreachable
	as fut-state-resolved
		void
	as exception
		void
