no-std
import
	.bool: bool, false, not, true
	.col.arr: ==
	.compare: equal
	.fun: subscript
	.misc: void
	.str: str
	.tuple: pair
	.private.bootstrap: char
	.private.exception-low-level: throw
	.private.number-low-level: ==, int, nat
export
	.private.bootstrap: none, opt, some, value

== bool(a opt int, b opt int)
	a opt-equal? b
== bool(a opt nat, b opt nat)
	a opt-equal? b
== bool(a opt str, b opt str)
	a opt-equal? b
== bool(a opt char, b opt char)
	a opt-equal? b

# TODO:GENERIC
opt-equal? bool(a opt ?a, b opt ?a) equal<?a> noctx
	if va ?= a
		if vb ?= b
			va == vb
		else
			false
	else
		b.has? not

# True iff a is `none`.
empty? bool(a opt ?a) noctx
	match a
	as none
		true
	as some
		false

# True iff a is `some`.
has? bool(a opt ?a) noctx
	a.empty? not

# Calls `f` on the value in a `some`, or does nothing.
each void(a opt ?in, f act void(?in))
	if v ?= a
		f[v]
	else
		void

# Converts `none` to `none`, or `some` to another `some` with `f` applied.
map opt ?out(a opt ?in, f act ?out(?in))
	if v ?= a
		f[v] some
	else
		none

# Takes the leftmost `some` value.
opt-or opt ?a(a opt ?a, b opt ?a)
	if a has?
		a
	else
		b

# Converts an option to a value by supplying a default to handle `none`.
or-default ?a(a opt ?a, default act ?a())
	if v ?= a
		v
	else
		default[]

or-default ?a(a opt ?a, default ?a)
	if v ?= a
		v
	else
		default

# Converts an option to a value by failing on `none`.
force ?a(a opt ?a)
	a force "tried to force empty option"

force ?a(a opt ?a, message str)
	if v ?= a
		v
	else
		throw: message

# TODO: Should be called 'force' too, but that loses the expected type
or-throw ?a(a opt ?a, get-message act str())
	if v ?= a
		v
	else
		throw: get-message[]

opt-join opt pair<?in-0, ?in-1>(a opt ?in-0, b opt ?in-1)
	a opt-join b, \x, y
		pair: x, y

###
Returns `some: f[a.force, b.force]` iff both `a` and `b` are `some`, else returns `none`.
###
opt-join opt ?out(a opt ?in-0, b opt ?in-1, f act ?out(?in-0, ?in-1))
	if va ?= a
		if vb ?= b
			f[va, vb] some
		else
			none
	else
		none
