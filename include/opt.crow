no-std
import
	.bool: bool, false, not, true
	.exception: fail
	.fun: subscript
	.misc: void
export
	.private.bootstrap: none, opt, some, value

# True iff a is `none`.
empty? bool(a opt ?a) noctx
	match a
	as none
		true
	as some
		false

# True iff a is `some`.
has? bool(a opt ?a) noctx
	a.empty? not

# Calls `f` on the value in a `some`, or does nothing.
each void(a opt ?in, f act void(?in))
	match a
	as none
		void
	as some s
		f[s value]

# Converts `none` to `none`, or `some` to another `some` with `f` applied.
map opt ?out(a opt ?in, f act ?out(?in))
	match a
	as none
		none
	as some s
		f[s value] some

# Takes the leftmost `some` value.
opt-or opt ?a(a opt ?a, b opt ?a)
	match a
	as none
		b
	as some
		a

# Converts an option to a value by supplying a default to handle `none`.
or-default ?a(a opt ?a, default act ?a())
	match a
	as none
		default[]
	as some s
		s value

# Converts an option to a value by failing on `none`.
force ?a(a opt ?a)
	match a
	as none
		fail: "tried to force empty option"
	as some s
		s value

###
Returns `some: f[a.force, b.force]` iff both `a` and `b` are `some`, else returns `none`.
###
opt-join opt ?out(a opt ?in-0, b opt ?in-1, f act ?out(?in-0, ?in-1))
	match a
	as none
		none
	as some sa
		match b
		as none
			none
		as some sb
			f[sa value, sb value] some
