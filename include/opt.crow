no-std
import
	.bool: bool, false, not, true
	.fun: subscript
	.misc: void
	.str: str
	.tuple: pair
	.private.exception-low-level: throw
export
	.private.bootstrap: none, opt, some, value

# True iff a is `none`.
empty? bool(a opt ?a) noctx
	match a
	as none
		true
	as some
		false

# True iff a is `some`.
has? bool(a opt ?a) noctx
	a.empty? not

# Calls `f` on the value in a `some`, or does nothing.
each void(a opt ?in, f act void(?in))
	match a
	as none
		void
	as some s
		f[s value]

# Converts `none` to `none`, or `some` to another `some` with `f` applied.
map opt ?out(a opt ?in, f act ?out(?in))
	match a
	as none
		none
	as some s
		f[s value] some

# Takes the leftmost `some` value.
opt-or opt ?a(a opt ?a, b opt ?a)
	match a
	as none
		b
	as some
		a

# Converts an option to a value by supplying a default to handle `none`.
or-default ?a(a opt ?a, default act ?a())
	match a
	as none
		default[]
	as some s
		s value

or-default ?a(a opt ?a, default ?a)
	match a
	as none
		default
	as some s
		s value

# Converts an option to a value by failing on `none`.
force ?a(a opt ?a)
	a force "tried to force empty option"

force ?a(a opt ?a, message str)
	match a
	as none
		throw: message
	as some s
		s value

# TODO: Should be called 'force' too, but that loses the expected type
or-throw ?a(a opt ?a, get-message act str())
	match a
	as none
		throw: get-message[]
	as some s
		s value

opt-join opt pair<?in-0, ?in-1>(a opt ?in-0, b opt ?in-1)
	a opt-join b, \x, y
		pair: x, y

###
Returns `some: f[a.force, b.force]` iff both `a` and `b` are `some`, else returns `none`.
###
opt-join opt ?out(a opt ?in-0, b opt ?in-1, f act ?out(?in-0, ?in-1))
	match a
	as none
		none
	as some sa
		match b
		as none
			none
		as some sb
			f[sa value, sb value] some
