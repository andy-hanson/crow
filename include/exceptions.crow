import
	.backtrace: get-backtrace
	.bool: bool, not
	.bootstrap:
		arr, as, backtrace, err, exception-ctx-ptr, get-ctx,
		hard-forbid, int32, ok, result, str, todo, void
	.compare: ==
	.fun: subscript
	.posix.bytes-types: zero
	.posix.setjmp: jmp-buf, jmp-buf-tag, longjmp, setjmp
	.ptr: as-ref, by-val, null, null?, ptr-to
export
	.bootstrap: exception, message

exception-ctx record mut
	jmp-buf-ptr mut jmp-buf
	thrown-exception mut exception

exception-ctx by-val exception-ctx() noctx unsafe
	# Nothing on the exception-ctx initially
	exception-ctx: null, exception: "", backtrace: as<arr str>: []

get-exception-ctx exception-ctx() unsafe
	get-ctx.exception-ctx-ptr as-ref<exception-ctx>

region throwing

rethrow ?t(e exception)
	e throw

fail ?t(reason str) trusted
	throw: exception: reason, get-backtrace

assert void(condition bool)
	if condition not
		"assert failed" fail

assert void(condition bool, message str)
	if condition not
		message fail

assert void(condition bool, message fun str())
	if condition not
		message[] fail

unreachable ?t()
	"should be unreachable" fail

forbid void(condition bool)
	condition forbid "forbid failed"

forbid void(condition bool, message str)
	if condition
		message fail

throw ?t(e exception) trusted
	exn-ctx = get-exception-ctx
	hard-forbid: exn-ctx.jmp-buf-ptr null?
	exn-ctx.thrown-exception := e
	exn-ctx.jmp-buf-ptr longjmp number-to-throw
	# Unreachable
	todo

.number-to-throw int32()
	7

region handling

finally ?t(after act void(), try act ?t())
	res = try catch \err
		after[]
		err throw
	after[]
	res

catch result<?t, exception>(try act ?t())
	{try[] ok} catch {it err}

catch ?t(try act ?t(), catcher act ?t(exception)) trusted
	get-exception-ctx catch-with-exception-ctx try, catcher

catch-with-exception-ctx ?t(ec exception-ctx, try act ?t(), catcher act ?t(exception)) unsafe
	old-thrown-exception = ec thrown-exception
	old-jmp-buf = ec jmp-buf-ptr
	store = jmp-buf-tag: zero, 0, zero
	ec.jmp-buf-ptr := store ptr-to
	setjmp-result = ec.jmp-buf-ptr setjmp
	if setjmp-result == 0
		# Get here after setting the jump.
		# If it throws, we'll go to the above branch.
		res = try[]
		ec.jmp-buf-ptr := old-jmp-buf
		ec.thrown-exception := old-thrown-exception
		res
	else
		# This is what we threw in 'throw'
		assert: setjmp-result == number-to-throw
		# Get here if we throw inside of `try`
		thrown-exception = ec thrown-exception
		# NOTE: changing thrown-exception back probably isn't really necessary
		ec.jmp-buf-ptr := old-jmp-buf
		ec.thrown-exception := old-thrown-exception
		catcher[thrown-exception]
