import
	..bootstrap: == < <= > arr data nat void
	..exceptions: assert
	..number-utils: / decr incr
	.mut-arr: cast-immutable copy-to-mut-arr mut-arr size slice-after slice-up-to set-subscript subscript

sort arr ?t(a arr ?t) data<?t> trusted
	res = a copy-to-mut-arr
	res sort-in-place
	res cast-immutable

test
	assert: (sort: new-arr<nat>) == new-arr<nat>
	assert: (new-arr<nat> 3, 1, 2).sort == new-arr 1, 2, 3

sort-in-place void(a mut-arr ?t) data<?t>
	if a.size > 1
		| Perf -- in case a is sorted already, prefer the middle element as a pivot
		a swap: 0, a.size / 2
		pivot = a[0]
		index-of-first-value-gt-pivot = a partition-recur pivot, 1, a.size.decr
		new-pivot-index = index-of-first-value-gt-pivot.decr
		a swap 0, new-pivot-index

		a slice-up-to new-pivot-index sort-in-place
		a slice-after new-pivot-index sort-in-place

| Returns index of first value > pivot
.partition-recur nat(a mut-arr ?t, pivot ?t, l nat, r nat) data<?t>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		em = a[l]
		if em < pivot
			a partition-recur pivot, l.incr, r
		else
			a swap l, r
			a partition-recur pivot, l, r.decr
	else
		l

.swap void(a mut-arr ?t, x nat, y nat)
	old-x = a[x]
	a[x] := a[y]
	a[y] := old-x
