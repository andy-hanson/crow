import
	..bootstrap: ==, <, <=, >, ->, arr, as, data, nat, void
	..exceptions: assert
	..number-utils: +, -, /
	.mut-arr: cast-immutable, mut-arr, size, set-subscript, subscript

sort arr ?t(a arr ?t) data<?t> trusted
	res = a mut-arr
	res sort-in-place
	res cast-immutable

test
	assert: (sort: as<arr nat>: []) == []
	assert: [3, 1, 2].sort == [1, 2, 3]

sort-in-place void(a mut-arr ?t) data<?t>
	if a.size > 1
		| Perf -- in case a is sorted already, prefer the middle element as a pivot
		a swap: 0, a.size / 2
		pivot = a[0]
		index-of-first-value-gt-pivot = a partition-recur pivot, 1, a.size - 1
		new-pivot-index = index-of-first-value-gt-pivot - 1
		a swap 0, new-pivot-index

		a[0 -> new-pivot-index] sort-in-place
		a[new-pivot-index + 1 -> a.size] sort-in-place

| Returns index of first value > pivot
.partition-recur nat(a mut-arr ?t, pivot ?t, l nat, r nat) data<?t>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		em = a[l]
		if em < pivot
			a partition-recur pivot, (l + 1), r
		else
			a swap l, r
			a partition-recur pivot, l, r - 1
	else
		l

.swap void(a mut-arr ?t, x nat, y nat)
	old-x = a[x]
	a[x] := a[y]
	a[y] := old-x
