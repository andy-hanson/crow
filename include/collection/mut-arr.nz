import
	..alloc: alloc-uninitialized fill-ptr-range set-zero-range
	..bootstrap: + == < <= arr bool data hard-assert nat opt ptr set size void
	..exceptions: assert
	..number-utils: + - incr
	.arr: empty-arr subscript
	.arr-util: find-index

mut-arr<?t> record mut
	by-val
	| TODO:PRIVATE
	arr arr ?t

size nat(a mut-arr ?t) noctx
	a.arr size

data ptr ?t(a mut-arr ?t) noctx unsafe
	a.arr data

subscript ?t(a mut-arr ?t, index nat)
	a.arr[index]

set-at void(a mut-arr ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at index, value

noctx-set-at void(a mut-arr ?t, index nat, value ?t) noctx unsafe
	hard-assert: index < a.size
	a.data + index set value

empty-mut-arr mut-arr ?t() noctx
	mut-arr: empty-arr

mut-arr mut-arr ?t(size nat, data ptr ?t) noctx unsafe
	mut-arr: arr: size, data

new-uninitialized-mut-arr mut-arr ?t(size nat) unsafe
	mut-arr: size, alloc-uninitialized<?t>: size

make-mut-arr mut-arr ?t(size nat, f act ?t(nat)) trusted
	res = new-uninitialized-mut-arr<?t>: size
	res.data fill-ptr-range size, f
	res

fill-mut-arr mut-arr ?t(size nat, value ?t)
	size make-mut-arr \ignore
		value

copy-to-mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> {a[it]}

temp-as-arr arr ?t(a mut-arr ?t) noctx unsafe
	a arr

cast-immutable arr ?t(a mut-arr ?t) noctx unsafe
	a.arr

set-zero-elements void(a mut-arr ?t) noctx unsafe
	a.data set-zero-range a.size

slice mut-arr ?t(a mut-arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	mut-arr: size, a.data + begin

slice-starting-at mut-arr ?t(a mut-arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

slice-after mut-arr ?t(a mut-arr ?t, before-begin nat)
	a slice-starting-at before-begin.incr

slice-up-to mut-arr ?t(a mut-arr ?t, size nat)
	assert: size <= a.size
	a slice: 0, size

region misc

index-of opt nat(a mut-arr ?t, value ?t) data<?t>
	a find-index {it == value}

find-index opt nat(a mut-arr ?t, pred act bool(?t)) trusted
	a.temp-as-arr find-index pred
