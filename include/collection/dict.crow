import
	..bootstrap:
		==, arr, arrow, bool, data, from, has?, nat, none, not, opt, size, some, subscript, to, void
	..number-utils: incr
	.arr: empty?, subscript
	.arr-util: first, map, tail

dict<?k, ?v> record
	keys arr ?k
	values arr ?v

dict dict<?k, ?v>()
	dict: [], []

dict dict<?k, ?v>(pairs arr arrow<?k, ?v>)
	keys = pairs map {it from}
	values = pairs map {it to}
	| TODO: shouldn't need type args
	dict<?k, ?v>: keys, values

empty? bool(d dict<?k, ?v>)
	d.keys empty?

subscript opt ?v(d dict<?k, ?v>, key ?k) trusted data<?k>
	| TODO: should not need to provide type arguments
	subscript-recur<?k, ?v>: d.keys, d.values, 0, key

.subscript-recur<?k, ?v> opt ?v(keys arr ?k, values arr ?v, idx nat, key ?k) data<?k>
	if idx == keys.size
		none
	elif key == keys[idx]
		values[idx] some
	else
		| TODO: should not need to provide type arguments!
		subscript-recur<?k, ?v>: keys, values, idx.incr, key

has? bool(d dict<?k, ?v>, key ?k) data<?k>
	d[key] has?

map-values dict<?k, ?v-out>(d dict<?k, ?v-in>, mapper act ?v-out(?v-in))
	new-values = d.values map mapper
	| TODO: should be able to infer type arguments 
	dict<?k, ?v-out>: d.keys, new-values

each void(d dict<?k, ?v>, f act void(?k, ?v))
	if d.empty? not
		f[d.keys.first, d.values.first]
		| TODO: type arguments should be unnecessary
		d.keys.tail dict<?k, ?v> d.values.tail each f
