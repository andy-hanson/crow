import
	..bootstrap:
		==, <=>, and, arr, arrow, as, bool, comparison, data, from, greater, has?, less,
		nat, none, not, opt, size, some, subscript, to, void
	..number-utils: incr
	..opt-utils: each
	.arr: empty?, subscript
	.arr-util: first, map, tail
	.mut-list: move-to-arr, mut-list, push

dict<?k, ?v> record
	| TODO: PRIVATE
	| Keys should be in sorted order
	keys arr ?k
	values arr ?v

dict dict<?k, ?v>()
	dict: [], []

dict dict<?k, ?v>(pairs arr arrow<?k, ?v>)
	keys = pairs map {it from}
	values = pairs map {it to}
	| TODO: shouldn't need type args
	dict<?k, ?v>: keys, values

empty? bool(d dict<?k, ?v>)
	d.keys empty?

subscript opt ?v(d dict<?k, ?v>, key ?k) trusted data<?k>
	| TODO: should not need to provide type arguments
	subscript-recur<?k, ?v>: d.keys, d.values, 0, key

.subscript-recur<?k, ?v> opt ?v(keys arr ?k, values arr ?v, idx nat, key ?k) data<?k>
	if idx == keys.size
		none
	elif key == keys[idx]
		values[idx] some
	else
		| TODO: should not need to provide type arguments!
		subscript-recur<?k, ?v>: keys, values, idx.incr, key

has? bool(d dict<?k, ?v>, key ?k) data<?k>
	d[key] has?

map-values dict<?k, ?v-out>(d dict<?k, ?v-in>, mapper act ?v-out(?v-in))
	new-values = d.values map mapper
	| TODO: should be able to infer type arguments 
	dict<?k, ?v-out>: d.keys, new-values

each void(d dict<?k, ?v>, f act void(?k, ?v))
	if d.empty? not
		f[d.keys.first, d.values.first]
		| TODO: type arguments should be unnecessary
		d.keys.tail dict<?k, ?v> d.values.tail each f

combine dict<?k, ?out>(a dict<?k, ?in-0>, b dict<?k, ?in-1>, cb act opt ?out(?k, opt ?in-0, opt ?in-1)) data<?k>
	out-keys = mut-list<?k>
	out-values = mut-list<?out>
	combine-recur: out-keys, out-values, a.keys, a.values, b.keys, b.values, cb
	dict: out-keys.move-to-arr, out-values.move-to-arr

.combine-recur void
	out-keys mut-list ?k
	out-values mut-list ?out
	a-keys arr ?k
	a-values arr ?in-0
	b-keys arr ?k
	b-values arr ?in-1
	cb act opt ?out(?k, opt ?in-0, opt ?in-1)
spec
	data<?k>
body
	if a-keys.empty? and b-keys.empty? not
		cmp = as<comparison>: if a-keys empty?
			greater
		elif b-keys empty?
			less
		else
			a-keys[0] <=> b-keys[0]
		match cmp
		as less
			cb[a-keys[0], a-values[0] some, none] each \v
				out-keys push a-keys[0]
				out-values push v
			combine-recur: out-keys, out-values, a-keys.tail, a-values.tail, b-keys, b-values, cb
		as equal
			cb[a-keys[0], a-values[0] some, b-values[0] some] each \v
				out-keys push a-keys[0]
				out-values push v
			combine-recur: out-keys, out-values, a-keys.tail, a-values.tail, b-keys.tail, b-values.tail, cb
		as greater
			cb[b-keys[0], none, b-values[0] some] each \v
				out-keys push b-keys[0]
				out-values push v
			combine-recur: out-keys, out-values, a-keys, a-values, b-keys.tail, b-values.tail, cb
