import
	..bool: and, bool, not
	..bootstrap: ->, arrow, as, comparison, from, greater, less, to, void
	..compare: ==, <=>
	..exceptions: assert
	..fun: subscript
	..number: +, nat
	..opt: each, has?, none, opt, some
	.arr: arr, data, empty?, size, subscript
	.arr-util: first, map, tail, zip
	.mut-list: ~=, move-to-arr!, mut-list
	.sort: a, b, sort-by-first

dict<?k, ?v> record
	# TODO: PRIVATE
	# Keys should be in sorted order
	ignore void
	keys arr ?k
	values arr ?v

dict dict<?k, ?v>() data<?k>
	dict: [], []

dict dict<?k, ?v>(pairs arr arrow<?k, ?v>) data<?k>
	keys = pairs map {it from}
	values = pairs map {it to}
	dict: keys, values

dict dict<?k, ?v>(keys arr ?k, values arr ?v) data<?k>
	assert: keys.size == values.size
	sorted = keys sort-by-first values
	dict: void, sorted.a, sorted.b

arr arr arrow<?k, ?v>(a dict<?k, ?v>)
	a.keys zip a.values, \key, value
		key -> value

empty? bool(d dict<?k, ?v>)
	d.keys empty?

subscript opt ?v(d dict<?k, ?v>, key ?k) trusted data<?k>
	# TODO: should not need to provide type arguments
	subscript-recur<?k, ?v>: d.keys, d.values, 0, key

.subscript-recur<?k, ?v> opt ?v(keys arr ?k, values arr ?v, idx nat, key ?k) data<?k>
	if idx == keys.size
		none
	elif key == keys[idx]
		values[idx] some
	else
		# TODO: should not need to provide type arguments!
		subscript-recur<?k, ?v>: keys, values, idx + 1, key

has? bool(d dict<?k, ?v>, key ?k) data<?k>
	d[key] has?

map-values dict<?k, ?v-out>(d dict<?k, ?v-in>, mapper act ?v-out(?v-in)) data<?k>
	new-values = d.values map mapper
	# TODO: should be able to infer type arguments 
	dict<?k, ?v-out>: d.keys, new-values

each void(d dict<?k, ?v>, f act void(?k, ?v)) data<?k>
	if d.empty? not
		f[d.keys.first, d.values.first]
		# TODO: type arguments should be unnecessary
		d.keys.tail dict<?k, ?v> d.values.tail each f

combine dict<?k, ?out>(a dict<?k, ?in-0>, b dict<?k, ?in-1>, cb act opt ?out(?k, opt ?in-0, opt ?in-1)) data<?k>
	out-keys = mut-list<?k>
	out-values = mut-list<?out>
	combine-recur: out-keys, out-values, a.keys, a.values, b.keys, b.values, cb
	dict: out-keys.move-to-arr!, out-values.move-to-arr!

.combine-recur void
	out-keys mut-list ?k
	out-values mut-list ?out
	a-keys arr ?k
	a-values arr ?in-0
	b-keys arr ?k
	b-values arr ?in-1
	cb act opt ?out(?k, opt ?in-0, opt ?in-1)
spec
	data<?k>
body
	if a-keys.empty? and b-keys.empty? not
		cmp = as<comparison>: if a-keys empty?
			greater
		elif b-keys empty?
			less
		else
			a-keys[0] <=> b-keys[0]
		match cmp
		as less
			cb[a-keys[0], a-values[0] some, none] each \v
				out-keys ~= a-keys[0]
				out-values ~= v
			combine-recur: out-keys, out-values, a-keys.tail, a-values.tail, b-keys, b-values, cb
		as equal
			cb[a-keys[0], a-values[0] some, b-values[0] some] each \v
				out-keys ~= a-keys[0]
				out-values ~= v
			combine-recur: out-keys, out-values, a-keys.tail, a-values.tail, b-keys.tail, b-values.tail, cb
		as greater
			cb[b-keys[0], none, b-values[0] some] each \v
				out-keys ~= b-keys[0]
				out-values ~= v
			combine-recur: out-keys, out-values, a-keys, a-values, b-keys.tail, b-values.tail, cb
