import
	..bootstrap: arr, arrow, bool, data, drop, from, size, to, void
	..compare: ==, <=>
	..exceptions: assert
	..number: +, nat
	.arr-util: map
	.dict: dict, has?, subscript
	.mut-list:
		~=, index-of, insert-at!, move-to-arr!, mut-list, remove-unordered-at!, size,
		set-subscript, subscript, temp-as-arr
	..opt: none, opt, some, value
	.sort: sort-by-first!

mut-dict<?k, ?v> record mut
	# TODO: PRIVATE
	ignore void
	keys mut-list ?k
	values mut-list ?v

mut-dict mut-dict<?k, ?v>() data<?k>
	mut-dict: void, mut-list, mut-list

mut-dict mut-dict<?k, ?v>(pairs arr arrow<?k, ?v>) data<?k>
	keys = pairs map {it from}
	values = pairs map {it to}
	mut-dict: keys, values

mut-dict mut-dict<?k, ?v>(keys arr ?k, values arr ?v) data<?k>
	assert: keys.size == values.size
	mut-keys = keys mut-list
	mut-values = values mut-list
	mut-keys sort-by-first! mut-values
	mut-dict: void, mut-keys, mut-values

subscript opt ?v(d mut-dict<?k, ?v>, key ?k) trusted data<?k>
	d.temp-as-dict[key]

set-subscript void(a mut-dict<?k, ?v>, key ?k, value ?v) data<?k>
	a set-subscript-recur 0, key, value

.set-subscript-recur void(a mut-dict<?k, ?v>, idx nat, key ?k, value ?v) data<?k>
	if idx == a.keys.size
		a.keys ~= key
		a.values ~= value
	else
		match key <=> a.keys[idx]
		as less
			a.keys insert-at! idx, key
			a.values insert-at! idx, value
		as equal
			a.values[idx] := value
		as greater
			a set-subscript-recur idx + 1, key, value

has? bool(a mut-dict<?k, ?v>, key ?k) trusted data<?k>
	a.temp-as-dict has? key

move-to-dict! dict<?k, ?v>(m mut-dict<?k, ?v>) data<?k>
	# TODO: should be able to infer type arguments 
	dict<?k, ?v>: m.keys.move-to-arr!, m.values.move-to-arr!

.temp-as-dict dict<?k, ?v>(m mut-dict<?k, ?v>) unsafe data<?k>
	# TODO: should be able to infer type arguments 
	dict<?k, ?v>: m.keys.temp-as-arr, m.values.temp-as-arr

remove! opt ?v(a mut-dict<?k, ?v>, key ?k) data<?k>
	match a.keys index-of key
	as none
		none
	as some s
		drop: a.keys remove-unordered-at! s.value
		some: a.values remove-unordered-at! s.value
