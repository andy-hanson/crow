import
	..bootstrap: ==, <=>, arr, arrow, bool, data, drop, from, nat, none, opt, some, to, value, void
	..number-utils: +
	.arr-util: map
	.dict: dict, has?, subscript
	.mut-list:
		~=, index-of, insert!, move-to-arr!, mut-list, remove-unordered-at!, size,
		set-subscript, subscript, temp-as-arr

mut-dict<?k, ?v> record mut
	keys mut-list ?k
	values mut-list ?v

mut-dict mut-dict<?k, ?v>()
	mut-dict: mut-list, mut-list

mut-dict mut-dict<?k, ?v>(pairs arr arrow<?k, ?v>)
	keys = pairs map {it from}
	values = pairs map {it to}
	| TODO: shouldn't need type args
	mut-dict<?k, ?v>: keys.mut-list, values.mut-list

new-mut-dict mut-dict<?k, ?v>()
	| TODO: should be able to infer type arguments -- worked when there was only one field...
	mut-dict<?k, ?v>: mut-list<?k>, mut-list<?v>

subscript opt ?v(d mut-dict<?k, ?v>, key ?k) trusted data<?k>
	d.temp-as-dict[key]

set-subscript void(a mut-dict<?k, ?v>, key ?k, value ?v) data<?k>
	a set-subscript-recur 0, key, value

.set-subscript-recur void(a mut-dict<?k, ?v>, idx nat, key ?k, value ?v) data<?k>
	if idx == a.keys.size
		a.keys ~= key
		a.values ~= value
	else
		match key <=> a.keys[idx]
		as less
			a.keys insert! idx, key
			a.values insert! idx, value
		as equal
			a.values[idx] := value
		as greater
			a set-subscript-recur (idx + 1), key, value

has? bool(a mut-dict<?k, ?v>, key ?k) trusted data<?k>
	a.temp-as-dict has? key

move-to-dict! dict<?k, ?v>(m mut-dict<?k, ?v>)
	| TODO: should be able to infer type arguments 
	dict<?k, ?v>: m.keys.move-to-arr!, m.values.move-to-arr!

.temp-as-dict dict<?k, ?v>(m mut-dict<?k, ?v>) unsafe
	| TODO: should be able to infer type arguments 
	dict<?k, ?v>: m.keys.temp-as-arr, m.values.temp-as-arr

remove! opt ?v(a mut-dict<?k, ?v>, key ?k) data<?k>
	match a.keys index-of key
	as none
		none
	as some s
		drop: a.keys remove-unordered-at! s.value
		some: a.values remove-unordered-at! s.value
