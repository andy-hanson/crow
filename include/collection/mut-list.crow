no-std
import
	..alloc: alloc-uninitialized, copy-data-from, set-zero-range, unmanaged-alloc-zeroed-elements
	..bool: bool, not
	..bootstrap: hard-assert, hard-forbid, noctx-decr, noctx-incr, todo, zeroed
	..collection.arr-util: contains?, each, index-of
	..collection.mut-arr:
		data, fill-mut-arr, mut-arr, set-zero-elements, size, subscript, temp-as-arr
	..compare: ==, <, <=, >, >=
	..exceptions: assert
	..misc: ->, drop, void
	..number: +, -, *, nat
	..opt: none, opt, some
	..posix.string: memcpy, memmove
	..ptr: +, as-any-ptr, by-val, ptr, set-subscript, size-of, subscript
	.arr: arr, data

# NOTE: this is not a normal record, compiler treats it specially
# TODO: constructor should be private
mut-list<?t> record mut
	# TODO:PRIVATE
	# backing.size is the capacity
	# For the GC's sake, unused parts of backing are filled with 'zeroed'
	backing mut mut-arr ?t
	# TODO:PRIVATE (getter public)
	size mut nat

data ptr ?t(a mut-list ?t) noctx unsafe
	a.backing data

# TODO: PRIVATE
capacity nat(a mut-list ?t) noctx unsafe
	a.backing size

mut-list-by-val by-val mut-list<?t>() noctx trusted
	mut-list<?t>: mut-arr, 0

mut-list-by-val-with-capacity-from-unmanaged-memory by-val mut-list ?t(capacity nat) noctx unsafe
	backing = mut-arr<?t>: capacity, capacity unmanaged-alloc-zeroed-elements<?t>
	mut-list<?t>: backing, 0

fill-mut-list mut-list ?t(size nat, value ?t)
	backing = size fill-mut-arr value
	mut-list: backing, size

mut-list mut-list ?t()
	mut-list: mut-arr, 0

mut-list mut-list ?t(a arr ?t)
	res = mut-list<?t>
	res ~= a
	res

copy mut-list ?t(a mut-list ?t) trusted
	a.temp-as-arr mut-list

arr arr ?t(a mut-list ?t)
	a.copy move-to-arr!

move-to-arr! arr ?t(a mut-list ?t) noctx trusted
	res = arr: a.size, a.data
	a.backing := mut-arr
	a.size := 0
	res

noctx-at ?t(a mut-list ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data[index]

subscript ?t(a mut-list ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

last ?t(a mut-list ?t)
	a[a.size - 1]

temp-as-mut-arr mut-arr ?t(a mut-list ?t) noctx unsafe
	mut-arr: a.size, a.data

temp-as-arr arr ?t(a mut-list ?t) noctx unsafe
	a.temp-as-mut-arr temp-as-arr

each void(a mut-list ?t, f act void(?t)) trusted
	a.temp-as-arr each f

empty? bool(a mut-list ?t) noctx
	a.size == 0

has? bool(a mut-list ?t) noctx
	a.empty? not

noctx-set-at! void(a mut-list ?t, index nat, value ?t) noctx trusted
	hard-assert: index < a.size
	a.data[index] := value

set-subscript void(a mut-list ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at! index, value

contains? bool(a mut-list ?t, value ?t) noctx trusted data<?t>
	a.temp-as-arr contains? value

noctx-last ?t(a mut-list ?t) noctx unsafe
	hard-forbid: a empty?
	a noctx-at a.size.noctx-decr

copy-range-to-arr arr ?t(a mut-list ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	res = alloc-uninitialized<?t>: size
	src = a.data + begin
	memcpy: res.as-any-ptr, src.as-any-ptr, size * size-of<?t>
	arr: size, res

pop-n-from-start! arr ?t(a mut-list ?t, n nat) trusted
	assert: n <= a.size
	res = a copy-range-to-arr 0, n
	dest = a.data as-any-ptr
	src = a.data + n as-any-ptr
	new-size = a.size - n
	memmove: dest, src, new-size * size-of<?t>
	a.size := new-size
	res

pop! opt ?t(a mut-list ?t) trusted
	if a empty?
		none
	else
		new-size = a.size noctx-decr
		res = a[new-size]
		# Ensure GC doesn't hold on to the memory there
		a[new-size] := zeroed
		a.size := new-size
		res some

pop-n! void(a mut-list ?t, n nat) trusted
	assert: n <= a.size
	new-size = a.size - n
	a.data + new-size set-zero-range n
	a.size := new-size

~= void(a mut-list ?t, value ?t) trusted
	a incr-capacity!
	a.size < a.capacity assert
	a.data[a.size] := value
	a.size := a.size + 1

~= void(a mut-list ?t, values arr ?t)
	values each {a ~= it}

.incr-capacity! void(a mut-list ?t) unsafe
	a ensure-capacity: a.size + 1 round-up-to-power-of-two

push-capacity-must-be-sufficient! void(a mut-list ?t, value ?t) noctx unsafe
	hard-assert: a.size < a.capacity
	old-size = a size
	a.size := old-size noctx-incr
	a noctx-set-at! old-size, value

.increase-capacity-to! void(a mut-list ?t, new-capacity nat) unsafe
	assert: new-capacity > a.capacity
	old-data = a.data
	a.backing := mut-arr: new-capacity, alloc-uninitialized<?t>: new-capacity
	a.data copy-data-from old-data, a.size
	a.backing[a.size + 1 -> a.backing.size] set-zero-elements

.ensure-capacity void(a mut-list ?t, min-capacity nat) unsafe
	if a.capacity < min-capacity
		a increase-capacity-to! min-capacity

reserve void(a mut-list ?t, reserved nat) unsafe
	a ensure-capacity reserved.round-up-to-power-of-two

remove-unordered-at! ?t(a mut-list ?t, index nat) trusted
	assert: index < a.size
	a noctx-remove-unordered-at! index

noctx-remove-unordered-at! ?t(a mut-list ?t, index nat) noctx unsafe
	res = a noctx-at index
	a noctx-set-at! index, a.noctx-last
	a.size := a.size.noctx-decr
	res

noctx-must-remove-unordered! void(a mut-list ?t, value ?t) noctx unsafe data<?t>
	a noctx-must-remove-unordered-recur! 0, value

.noctx-must-remove-unordered-recur! void(a mut-list ?t, index nat, value ?t) noctx unsafe data<?t>
	if index == a.size
		todo
	elif (a noctx-at index) == value
		a noctx-remove-unordered-at! index drop
	else
		a noctx-must-remove-unordered-recur! index.noctx-incr, value

.unsafe-set-size! void(a mut-list ?t, new-size nat) unsafe
	assert: new-size <= a.capacity
	a.size := new-size

# Unsafe because increasing the size can expose uninitialized data
unsafe-increase-size! void(a mut-list ?t, increase-by nat) unsafe
	a unsafe-set-size! a.size + increase-by

reduce-size-if-more-than! void(a mut-list ?t, new-size nat)
	if new-size < a.size
		a.pop! drop
		a reduce-size-if-more-than! new-size

# TODO:MOVE
.round-up-to-power-of-two nat(n nat)
	1 round-up-to-power-of-two-recur n
.round-up-to-power-of-two-recur nat(acc nat, n nat)
	if acc >= n
		acc
	else
		acc * 2 round-up-to-power-of-two-recur n

index-of opt nat(a mut-list ?t, value ?t) data<?t> trusted
	a.temp-as-arr index-of value

insert-at! void(a mut-list ?t, index nat, value ?t) trusted
	assert: index <= a.size
	a incr-capacity!
	dest = a.data + index + 1
	src = a.data + index
	n = a.size - index
	memmove: dest.as-any-ptr, src.as-any-ptr, n * size-of<?t>
	a[index] := value
	a.size := a.size + 1
	assert: a.size <= a.capacity

remove-at! ?t(a mut-list ?t, index nat) trusted
	assert: index < a.size
	res = a[index]
	dest = a.data + index
	src = a.data + index + 1
	n = a.size - index - 1
	memmove: dest.as-any-ptr, src.as-any-ptr, n * size-of<?t>
	a.size := a.size - 1
	res
