import
	..alloc: alloc
	..bootstrap
		+ - == != < <= >= ? and arr bool byte by-val call data deref false hard-assert incr nat
		noctx-incr none not null opt or ptr ptr-cast ref-of-ptr set size size-of some void wrap-mul
	..exceptions: assert forbid
	..number-utils: + - / decr incr
	..opt-utils: force

arr-from-begin-end arr ?t(begin ptr ?t, end ptr ?t) unsafe noctx
	arr: (end - begin), begin

empty-arr arr ?t() noctx trusted
	arr: 0, null

empty? bool(a arr ?t) noctx
	a.size == 0

has? bool(a arr ?t) noctx
	a.empty? not

slice arr ?t(a arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	arr: size, a.data + begin

slice-from-to arr ?t(a arr ?t, begin nat, end nat) trusted
	assert: begin <= end
	a slice: begin, end - begin

slice-starting-at arr ?t(a arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

slice-after arr ?t(a arr ?t, before-begin nat)
	a slice-starting-at before-begin.incr


slice-up-to arr ?t(a arr ?t, size nat)
	assert: size <= a.size
	a slice: 0, size

with-max-size arr ?t(a arr ?t, max-size nat)
	a.size <= max-size ?: a, a slice 0, max-size

first ?t(a arr ?t)
	forbid: a empty?
	a at 0

first-some opt ?out(a arr ?in, cb act opt ?out(?in))
	if a empty?
		none
	else
		match cb call a.first
		as none
			a.tail first-some cb
		as some s
			s

last ?t(a arr ?t)
	forbid: a empty?
	a at a.size.decr

tail arr ?t(a arr ?t)
	forbid: a empty?
	a slice-starting-at 1

rtail arr ?t(a arr ?t)
	forbid: a empty?
	a slice 0, a.size.decr

noctx-at ?t(a arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

ref-of-val-at ?t(a arr by-val<?t>, index nat) trusted
	assert: index < a.size
	a.data + index ref-of-ptr

prepend arr ?t(a ?t, b arr ?t)
	(new-arr a) + b

append arr ?t(a arr ?t, b ?t)
	a + (new-arr b)

| + arr ?t(a arr ?t, b arr ?t) trusted
| 	a.size + b.size make-arr \i
| 		if i < a.size
| 			a at i
| 		else
| 			b at: i - a.size

+ arr ?t(a arr ?t, b arr ?t) trusted
	res-size = a.size + b.size
	res = res-size uninitialized-data<?t>
	res copy-data-from a.data, a.size
	res + a.size copy-data-from b.data, b.size
	arr<?t>: res-size, res

uninitialized-data ptr ?t(size nat) unsafe
	bptr = size wrap-mul size-of<?t> alloc
	bptr ptr-cast<?t, byte>

some? bool(a arr ?t, pred act bool(?t))
	a.empty?.not and: (pred call a.first or: a.tail some? pred)

| TODO: only written this way to be `noctx`, else could defer to `some?`
contains? bool(a arr ?t, value ?t) noctx data<?t>
	a contains-recur? value, 0

contains-recur? bool(a arr ?t, value ?t, i nat) noctx trusted data<?t>
	if i == a.size
		false
	else
		a noctx-at i == value or: a contains-recur? value, i.noctx-incr

contains-subsequence? bool(a arr ?t, subseq arr ?t) data<?t>
	| TODO: faster algorithm
	a starts-with? subseq or: a.has? and: a.tail starts-with? subseq

starts-with? bool(a arr ?t, start arr ?t) data<?t>
	a.size >= start.size and: a slice 0, start.size arr-eq? start

ends-with? bool(a arr ?t, end arr ?t) data<?t>
	a.size >= end.size and: a slice (a.size - end.size), end.size arr-eq? end

| TODO: should be unnecessary, just use '=='
arr-eq? bool(a arr ?t, b arr ?t) data<?t>
	a.size == b.size and: a.empty? or: a.first == b.first and: a.tail arr-eq? b.tail

remove-start arr ?t(a arr ?t, start arr ?t) data<?t>
	a try-remove-start start force

try-remove-start opt arr<?t>(a arr ?t, start arr ?t) data<?t>
	if a starts-with? start
		a slice-starting-at start.size some
	else
		none

copy-data-from void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len < 8
		to copy-data-from-small from, len
	else
		hl = len / 2
		to copy-data-from from, hl
		(to + hl) copy-data-from (from + hl), (len - hl)

copy-data-from-small void(to ptr ?t, from ptr ?t, len nat) unsafe
	if len != 0
		to set: from deref
		| TODO: should be able to infer type arguments
		| TODO: I wish this were linear, but that runs out of stack ...
		to.incr copy-data-from<?t> from.incr, len.decr

fold ?a(val ?a, a arr ?b, combine act ?a(?a, ?b))
	if a empty?
		val
	else
		combine call val, a.first fold a.tail, combine

make-arr arr ?t(size nat, f act ?t(nat)) trusted
	data = size uninitialized-data<?t>
	data fill-ptr-range size, f
	arr: size, data

fill-ptr-range void(begin ptr ?t, size nat, f act ?t(nat)) unsafe
	begin fill-ptr-range-recur 0, size, f

.fill-ptr-range-recur void(begin ptr ?t, i nat, size nat, f act ?t(nat)) unsafe
	if i != size
		begin + i set: f call i
		begin fill-ptr-range-recur i.incr, size, f

fill-arr arr ?t(size nat, value ?t)
	size make-arr \ignore
		value

each void(a arr ?t, f act void(?t))
	if a.empty? not
		f call a.first
		a.tail each f

each-with-index void(a arr ?t, f act void(?t, nat))
	a each-with-index-recur f, 0

each-with-index-recur void(a arr ?t, f act void(?t, nat), n nat)
	if n != a.size
		f call (a at n), n
		a each-with-index-recur f, n.incr

map arr ?out(a arr ?in, mapper act ?out(?in)) trusted
	a.size make-arr \i
		mapper call: a at i

index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-index {it == value}

r-index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-rindex {it == value}

find-index opt nat(a arr ?t, pred act bool(?t))
	a find-index-recur 0, pred

.find-index-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if index == a.size
		none
	elif pred call: a at index
		index some
	else
		a find-index-recur index.incr, pred

find-rindex opt nat(a arr ?t, pred act bool(?t))
	if a empty?
		none
	else
		a find-rindex-recur a.size.decr, pred

.find-rindex-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if pred call: a at index
		index some
	elif index == 0
		none
	else
		a find-rindex-recur index.decr, pred
