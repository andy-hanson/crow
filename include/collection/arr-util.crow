import
	..alloc: alloc-uninitialized, fill-ptr-range
	..bool: and, bool, false, not, true
	..bootstrap:
		->, arr, data, has?, noctx-incr, none, opt,
		size, some, subscript, value, void
	..compare: ==, !=, >=
	..exceptions: assert, forbid
	..number: +, -, nat
	..opt-utils: force
	..ptr: +, ptr, set-subscript
	.arr: ~, arr-eq?, empty?, noctx-at, subscript

make-arr arr ?t(size nat, f act ?t(nat)) trusted
	data = size alloc-uninitialized<?t>
	data fill-ptr-range size, f
	arr: size, data

fill-arr arr ?t(size nat, value ?t)
	size make-arr \ignore
		value

each void(a arr ?t, f act void(?t))
	if a.empty? not
		f[a first]
		a.tail each f

each-with-index void(a arr ?t, f act void(?t, nat))
	a each-with-index-recur f, 0

.each-with-index-recur void(a arr ?t, f act void(?t, nat), n nat)
	if n != a.size
		f[a[n], n]
		a each-with-index-recur f, n + 1

map arr ?out(a arr ?in, mapper act ?out(?in)) trusted
	a.size make-arr \i
		mapper[a[i]]

first ?t(a arr ?t)
	forbid: a empty?
	a[0]

last ?t(a arr ?t)
	forbid: a empty?
	a[a.size - 1]

tail arr ?t(a arr ?t)
	forbid: a empty?
	a[1 -> a.size]

rtail arr ?t(a arr ?t)
	forbid: a empty?
	a[0 -> a.size - 1]

first-some opt ?out(a arr ?in, cb act opt ?out(?in))
	if a empty?
		none
	else
		match cb[a.first]
		as none
			a.tail first-some cb
		as some s
			s

exists? bool(a arr ?t, pred act bool(?t))
	if a empty?
		false
	elif pred[a.first]
		true
	else
		a.tail exists? pred

# TODO: only written this way to be `noctx`, else could defer to `some?`
contains? bool(a arr ?t, value ?t) noctx data<?t>
	a contains-recur? value, 0

contains-recur? bool(a arr ?t, value ?t, i nat) noctx trusted data<?t>
	if i == a.size
		false
	elif (a noctx-at i) == value
		true
	else
		a contains-recur? value, i.noctx-incr

contains-subseq? bool(a arr ?t, subseq arr ?t) data<?t>
	a index-of-subseq subseq has?

starts-with? bool(a arr ?t, start arr ?t) data<?t>
	a.size >= start.size and: a[0 -> start.size] arr-eq? start

ends-with? bool(a arr ?t, end arr ?t) data<?t>
	a.size >= end.size and: a[a.size - end.size -> a.size] arr-eq? end

remove-start arr ?t(a arr ?t, start arr ?t) data<?t>
	a try-remove-start start force

try-remove-start opt arr ?t(a arr ?t, start arr ?t) data<?t>
	if a starts-with? start
		a[start.size -> a.size] some
	else
		none

remove-end arr ?t(a arr ?t, end arr ?t) data<?t>
	a try-remove-end end force

try-remove-end opt arr ?t(a arr ?t, end arr ?t) data<?t>
	if a ends-with? end
		a[0 -> a.size - end.size] some
	else
		none

fold ?a(val ?a, a arr ?b, combine act ?a(?a, ?b))
	if a empty?
		val
	else
		combine[val, a.first] fold a.tail, combine

index-of-subseq opt nat(a arr ?t, subseq arr ?t) data<?t>
	a index-of-subseq-recur subseq, 0

.index-of-subseq-recur opt nat(a arr ?t, subseq arr ?t, i nat) data<?t>
	if i == a.size
		none
	elif a[i -> a.size] starts-with? subseq
		i some
	else
		a index-of-subseq-recur subseq, i + 1

index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-index {it == value}

r-index-of opt nat(a arr ?t, value ?t) data<?t>
	a find-rindex {it == value}

find-index opt nat(a arr ?t, pred act bool(?t))
	a find-index-recur 0, pred

.find-index-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if index == a.size
		none
	elif pred[a[index]]
		index some
	else
		a find-index-recur index + 1, pred

find-rindex opt nat(a arr ?t, pred act bool(?t))
	if a empty?
		none
	else
		a find-rindex-recur a.size - 1, pred

.find-rindex-recur opt nat(a arr ?t, index nat, pred act bool(?t))
	if pred[a[index]]
		index some
	elif index == 0
		none
	else
		a find-rindex-recur index - 1, pred

join arr ?t(a arr arr ?t, joiner arr ?t)
	if a empty?
		[]
	elif a.size == 1
		a[0]
	else
		a[0] ~ joiner ~: a.tail join joiner

split-by-subseq arr arr ?t(a arr ?t, splitter arr ?t) data<?t> trusted
	size = (a count-subseqs splitter) + 1
	data = size alloc-uninitialized<arr ?t>
	data fill-subseqs-recur a, splitter
	arr: size, data

count-subseqs nat(a arr ?t, subseq arr ?t) data<?t>
	a count-subseqs-recur subseq, 0

.count-subseqs-recur nat(a arr ?t, subseq arr ?t, acc nat) data<?t>
	match a index-of-subseq subseq
	as none
		acc
	as some s
		rest = a[s.value + subseq.size -> a.size]
		rest count-subseqs-recur subseq, acc + 1

.fill-subseqs-recur void(out ptr arr ?t, a arr ?t, splitter arr ?t) data<?t> unsafe
	match a index-of-subseq splitter
	as none
		out[] := a
	as some s
		out[] := a[0 -> s.value]
		rest = a[s.value + splitter.size -> a.size]
		out + 1 fill-subseqs-recur rest, splitter

zip arr ?out(a arr ?a, b arr ?b, cb act ?out(?a, ?b))
	assert: a.size == b.size
	a.size make-arr \i
		cb[a[i], b[i]]
