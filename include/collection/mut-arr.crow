import
	..alloc: alloc-uninitialized, fill-ptr-range, set-zero-range
	..bootstrap: ==, <, arr, arrow, bool, data, hard-assert, nat, opt, ptr, set-subscript, size, void
	..exceptions: assert
	.arr: subscript
	.arr-util: find-index

mut-arr<?t> record mut
	by-val
	| Adding a dummy field so the constructor won't conflict with mut-arr from arr
	ignore void
	| TODO:PRIVATE
	inner arr ?t

mut-arr mut-arr ?t() noctx
	mut-arr: void, []

mut-arr mut-arr ?t(size nat, data ptr ?t) noctx unsafe
	mut-arr: void, arr: size, data

mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> {a[it]}

arr arr ?t(a mut-arr ?t)
	a.copy.inner

copy mut-arr ?t(a mut-arr ?t)
	a.size make-mut-arr<?t> {a[it]}

size nat(a mut-arr ?t) noctx
	a.inner size

data ptr ?t(a mut-arr ?t) noctx unsafe
	a.inner data

subscript ?t(a mut-arr ?t, index nat)
	a.inner[index]

subscript mut-arr ?t(a mut-arr ?t, range arrow<nat, nat>)
	mut-arr: void, a.inner[range]

set-subscript void(a mut-arr ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at index, value

noctx-set-at void(a mut-arr ?t, index nat, value ?t) noctx unsafe
	hard-assert: index < a.size
	a.data[index] := value

uninitialized-mut-arr mut-arr ?t(size nat) unsafe
	mut-arr: size, alloc-uninitialized<?t>: size

make-mut-arr mut-arr ?t(size nat, f act ?t(nat)) trusted
	res = uninitialized-mut-arr<?t>: size
	res.data fill-ptr-range size, f
	res

fill-mut-arr mut-arr ?t(size nat, value ?t)
	size make-mut-arr \ignore
		value

temp-as-arr arr ?t(a mut-arr ?t) noctx unsafe
	a inner

cast-immutable arr ?t(a mut-arr ?t) noctx unsafe
	a inner

set-zero-elements void(a mut-arr ?t) noctx unsafe
	a.data set-zero-range a.size

region misc

index-of opt nat(a mut-arr ?t, value ?t) data<?t>
	a find-index {it == value}

find-index opt nat(a mut-arr ?t, pred act bool(?t)) trusted
	a.temp-as-arr find-index pred
