no-std
import
	.bool: bool, or
	.compare: ==, comparison, less, equal, greater
	.private.bootstrap: nat, unsafe-div, wrap-sub, void
export
	.private.bootstrap: any-ptr, by-val, ptr, zeroed

# Null pointer.
null ptr ?a() noctx builtin

# True if the pointer is `null`.
null? bool(a ptr ?a) noctx trusted
	a.to-nat == (null<?a>).to-nat

# Advance the pointer by `offset`.
+ ptr ?a(a ptr ?a, offset nat) noctx unsafe builtin
# Back up the pointer by `offset`.
- ptr ?a(p ptr ?a, offset nat) noctx unsafe builtin
# Get the difference between two pointers, measured in strides of `?a`.
# UB if `a < b` or if `size-of<?a> == 0`.
- nat(a ptr ?a, b ptr ?a) noctx unsafe
	a.to-nat wrap-sub b.to-nat unsafe-div size-of<?a>

###
Get the value pointed to.
UB if this is not a valid pointer.
###
subscript ?a(a ptr ?a) noctx unsafe builtin
###
Get the value pointed to at the offset.
UB if that is not a valid pointer.
###
subscript ?a(a ptr ?a, n nat) noctx unsafe
	(a + n)[]
###
Set the value pointed to.
UB if this is not a valid pointer.
###
set-subscript void(a ptr ?a, value ?a) noctx unsafe builtin
###
Set the value pointed to at the offset.
UB if that is not a valid pointer.
###
set-subscript void(a ptr ?a, n nat, value ?a) noctx unsafe
	(a + n)[] := value

###
Reinterpret a pointer to a ref.
Does nothing at runtime, just changes the type.
###
ref-of-ptr ?a(p ptr by-val<?a>) noctx unsafe
	p[] ref-of-val

###
Take a reference to something stored by-val.
Unsafe because the ref will only be valid as long as `a` is.
###
ref-of-val ?a(a by-val ?a) noctx unsafe builtin

###
Gets a pointer to something stored on the stack.
WARN: If '?a' is a reference type already, this is a pointer to a pointer!
###
ptr-to ptr ?a(t ?a) noctx unsafe builtin

# TODO: this function only works for by-ref types -- currently that is not checked by the type checker
# Convert a reference to `any-ptr`.
as-any-ptr any-ptr(ref ?a) noctx unsafe builtin
# TODO: this function only works for by-ref types -- currently that is not checked by the type checker
###
Convert a pointer to a reference of the chosen type.
UB if a value of that type was not stored at the pointer.
###
as-ref ?a(a any-ptr) noctx unsafe builtin

###
True iff two pointers are identical.
(False if they point to equal values but are different pointers.)
###
ptr-eq? bool(a ptr ?a, b ptr ?a) noctx unsafe builtin
# True iff `a.to-nat < b.to-nat`.
ptr-less? bool(a ptr ?a, b ptr ?a) noctx unsafe builtin
# True iff `a.to-nat <= b.to-nat`.
ptr-less-eq? bool(a ptr ?a, b ptr ?a) noctx unsafe
	a ptr-less? b or: a ptr-eq? b
# Equal to `a.to-nat <=> b.to-nat`.
ptr-compare comparison(a ptr ?a, b ptr ?a) noctx unsafe
	if a ptr-less? b
		less
	elif a ptr-eq? b
		equal
	else
		greater

###
True if two references have the same pointer.
Contrast with `a == b` which can also e true for different pointers with equal contents.
###
ref-eq? bool(a ?a, b ?a) noctx unsafe
	a.as-any-ptr ptr-eq? b.as-any-ptr

###
Number of bytes taken up by a type.
For a reference type, this is the size of a pointer.
0 for empty types like `void`.
###
size-of<?a> nat() noctx unsafe builtin

# TODO: require that ?out be an extern-ptr type
###
Convert a pointer to an `extern-ptr` type.
Does nothing at runtime, just changes the type.
###
ptr-cast-to-extern ?out(p ptr ?in) noctx unsafe builtin

# TODO: require that ?in be an extern-ptr type
###
Convert an extern-ptr to another pointer.
Does nothing at runtime, just changes the type.
###
ptr-cast-from-extern ptr ?out(p ?in) noctx unsafe builtin

###
Change the type pointed to.
Does nothing at runtime, just changes the type.
###
ptr-cast ptr ?out(p ptr ?in) noctx unsafe builtin

# Nat value of a pointer.
to-nat nat(p ptr ?a) noctx unsafe builtin
