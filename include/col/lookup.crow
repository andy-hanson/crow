no-std
import
	..bits: bits-and, unsafe-bit-shift-right
	..bool: ?, and, bool, false, not, true
	..compare: ==, !=, <, <=, >=, max
	..exception: assert, unreachable
	..fun: subscript
	..hash: hash, hash-mix
	..log: info, log
	..misc: ->, arrow, as, data, drop, from, to, void
	..number: nat
	..opt: force, none, opt, some, value
	..ptr: size-of
	..str: char, str
	..str-conv: to-str
	..test: is
	..private.bootstrap: todo, wrap-add, wrap-sub
	.arr: ~, arr, empty?, size, subscript
	.arr-util:
		each, each-with-index, every?, find-index, fold, fold-with-index,
		remove-at, rtail, tail, update, update-with-default
	.mut-arr:
		cast-immutable, copy-from!, fill-mut-arr, set-subscript, size, subscript,
		uninitialized-mut-arr
	.mut-list: ~=, move-to-arr!, mut-list, pop!, set-last

lookup<?k, ?v> record
	# TODO:PRIVATE
	ignore void
	root node<?k, ?v>

node<?k, ?v> union
	inner-node<?k, ?v>
	leaf-node<?k, ?v>

.inner-node<?k, ?v> record
	# Nodes keyed by the next 3 bits of the hash.
	# An inner-node should always have at least 2 non-empty children.
	children arr node<?k, ?v>

.leaf-node<?k, ?v> record
	# Unordered
	pairs arr arrow<?k, ?v>

.empty-leaf-node leaf-node<?k, ?v>()
	leaf-node: []

.low-bits nat(a nat)
	a bits-and 0b111

.inner-node-n-bits nat()
	3

.leaf-max-size nat()
	8

alloc-count nat(a lookup<?k, ?v>) unsafe
	0 alloc-count-recur a.root
.alloc-count-recur nat(acc nat, a node<?k, ?v>) unsafe
	match a
	as inner-node i
		acc wrap-add 1 fold i.children, \cur, child
			cur alloc-count-recur child
	as leaf-node
		acc wrap-add 1

overhead-bytes nat(a lookup<?k, ?v>) unsafe
	0 overhead-bytes-recur a.root
.overhead-bytes-recur nat(acc nat, a node<?k, ?v>) unsafe
	mid = acc wrap-add size-of<node<?k, ?v>>
	match a
	as inner-node i
		mid fold i.children, \cur, child
			cur overhead-bytes-recur child
	as leaf-node
		mid

lookup lookup<?k, ?v>() data<?k> hash-mix<?k>
	lookup: void, empty-leaf-node

lookup lookup<?k, ?v>(a arr arrow<?k, ?v>) data<?k> hash-mix<?k>
	if a.size <= 4 and a.no-duplicate-keys?
		lookup: void, leaf-node: a
	else
		lookup fold a, \cur, x
			cur ~ x

.no-duplicate-keys? bool(a arr arrow<?k, ?v>) data<?k>
	if a.size <= 1
		true
	else
		key = a[0] from
		a.tail every? {it.from != key} and a.tail.no-duplicate-keys?

empty? bool(a lookup<?k, ?v>) data<?k> hash-mix<?k>
	a.root node-empty?
.node-empty? bool(a node<?k, ?v>)
	match a
	as inner-node
		false
	as leaf-node l
		l.pairs empty?

size nat(a lookup<?k, ?v>) data<?k> hash-mix<?k>
	0 size-recur a.root
.size-recur nat(acc nat, a node<?k, ?v>)
	match a
	as inner-node i
		acc fold i.children, \cur, child
			cur size-recur child
	as leaf-node l
		acc wrap-add l.pairs.size

subscript opt ?v(a lookup<?k, ?v>, key ?k) data<?k> hash-mix<?k>
	match a root
	as inner-node
		hash = key hash
		a.root subscript-recur key, hash
	as leaf-node l
		l.pairs subscript-leaf-recur key
.subscript-recur opt ?v(a node<?k, ?v>, key ?k, remaining-hash nat) trusted data<?k> hash-mix<?k>
	match a
	as inner-node i
		which = remaining-hash low-bits
		if which < i.children.size
			i.children[which] subscript-recur: key, remaining-hash unsafe-bit-shift-right inner-node-n-bits
		else
			none
	as leaf-node l
		l.pairs subscript-leaf-recur key
.subscript-leaf-recur opt ?v(a arr arrow<?k, ?v>, key ?k) data<?k>
	if a empty?
		none
	elif a[0].from == key
		a[0].to some
	else
		a.tail subscript-leaf-recur key

~ lookup<?k, ?v>(a lookup<?k, ?v>, pair arrow<?k, ?v>) data<?k> hash-mix<?k>
	res = a get-or-update pair.from, \old-value
		pair.to insert
	match res new-node
	as none
		a
	as some s
		lookup: void, s.value

~ lookup<?k, ?v>(a lookup<?k, ?v>, pairs arr arrow<?k, ?v>) data<?k> hash-mix<?k>
	a fold pairs, \cur, pair
		cur ~ pair

try-add-result<?k, ?v> union
	already-has-key<?v>
	lookup<?k, ?v>

already-has-key<?v> record
	value ?v

# Adds a value if the key doesn't already exist
try-add try-add-result<?k, ?v>(a lookup<?k, ?v>, key ?k, get-value act ?v()) data<?k> hash-mix<?k>
	res = a get-or-update key, \old-value
		match old-value
		as none
			get-value[] insert
		as some
			no-change
	match res old-value
	as none
		lookup: void, res.new-node.force
	as some s
		already-has-key: s.value

- lookup<?k, ?v>(a lookup<?k, ?v>, key ?k) data<?k> hash-mix<?k>
	match a try-remove key
	as none
		a
	as some s
		s.value new-lookup

try-remove-result<?k, ?v> record
	by-val
	old-value ?v
	new-lookup lookup<?k, ?v>

try-remove opt try-remove-result<?k, ?v>(a lookup<?k, ?v>, key ?k) data<?k> hash-mix<?k>
	res = a get-or-update key, \old-value
		remove
	match res old-value
	as none
		none
	as some s
		some: try-remove-result: s.value, lookup: void, res.new-node.force

.get-or-update-result<?k, ?v> record
	by-val
	# If none, don't update anything
	new-node opt node<?k, ?v>
	old-value opt ?v


.get-or-update-action<?v> union
	no-change
	remove
	insert<?v>
.no-change record
.remove record
.insert<?v> record
	value ?v

###
`f` takes the old value and returns the new value, or 'none' to choose to preserve the old value.
###
.get-or-update get-or-update-result<?k, ?v>
	a lookup<?k, ?v>
	key ?k
	f act get-or-update-action ?v(opt ?v)
spec
	data<?k>
	hash-mix<?k>
body
	hash = key hash
	match a root
	as inner-node
		a.root get-or-update-recur key, hash, 0, f
	as leaf-node l
		l get-or-update-leaf key, hash, 0, f

.get-or-update-recur get-or-update-result<?k, ?v>
	a node<?k, ?v>
	key ?k
	remaining-hash nat
	hash-shift nat
	f act get-or-update-action ?v(opt ?v)
spec
	trusted
	data<?k>
	hash-mix<?k>
body
	match a
	as inner-node i
		which = remaining-hash low-bits
		if which < i.children.size
			next-hash = remaining-hash unsafe-bit-shift-right 3
			child-res = i.children[which] get-or-update-recur: key, next-hash, (hash-shift wrap-add 3), f
			match child-res new-node
			as none
				child-res
			as some s
				new-inner = i update-child which, s.value
				get-or-update-result: new-inner.some, child-res.old-value
		else
			match f[none]
			as no-change
				get-or-update-result: none, none
			as remove
				get-or-update-result: none, none
			as insert ins
				# TODO: should be able to write this inline
				pair = key -> ins.value
				# TODO: type args should not be necessary
				new-leaf = leaf-node<?k, ?v>: [pair]
				# TODO: type args should not be necessary
				new-node = inner-node<?k, ?v>: i.children update-with-default which, new-leaf, empty-leaf-node
				get-or-update-result: new-node.some, none
	as leaf-node l
		l get-or-update-leaf key, remaining-hash, hash-shift, f

.update-child node<?k, ?v>(a inner-node<?k, ?v>, which nat, new-child node<?k, ?v>)
	match a inner-node-to-leaf which, new-child
	as none
		if new-child node-empty?
			if which ==: a.children.size wrap-sub 1
				new-children = a.children rtail
				if new-children.size == 1
					new-children[0]
				else
					inner-node: new-children
			else
				new-children = a.children update which, new-child
				match new-children find-only-non-empty-child
				as none
					inner-node: new-children
				as some s
					s value
		else
			inner-node: a.children update which, new-child
	as some some-leaf
		# TODO: should not need a local
		v = some-leaf value
		v

# Returns 'some' if we should change this to a leaf.
inner-node-to-leaf opt leaf-node<?k, ?v>(a inner-node<?k, ?v>, which nat, new-child node<?k, ?v>) trusted
	total-size = 0 fold-with-index a.children, \cur, child, child-index
		match child-index == which ? new-child, child
		as inner-node
			99
		as leaf-node l
			cur wrap-add l.pairs.size
	if total-size <= leaf-max-size
		# TODO: if only one non-empty leaf, don't copy..
		out = total-size uninitialized-mut-arr<arrow<?k, ?v>>
		end = 0 fold-with-index a.children, \out-index, child, child-index
			match child-index == which ? new-child, child
			as inner-node
				unreachable
			as leaf-node l
				new-out-index = out-index wrap-add l.pairs.size
				out[out-index -> new-out-index] copy-from! l.pairs
				new-out-index
		assert: end == out.size
		some: leaf-node: out cast-immutable
	else
		none

.find-only-non-empty-child opt node<?k, ?v>(children arr node<?k, ?v>)
	first-non-empty-index = children find-index {it.node-empty? not} force
	if children[(first-non-empty-index wrap-add 1) -> children.size] every? {it node-empty?}
		children[first-non-empty-index] some
	else
		none

.get-or-update-leaf get-or-update-result<?k, ?v>
	a leaf-node<?k, ?v>
	key ?k
	remaining-hash nat
	hash-shift nat
	f act get-or-update-action ?v(opt ?v)
spec
	data<?k>
	hash-mix<?k>
body
	match a.pairs find-index {it.from == key}
	as none
		new-node = as<opt node<?k, ?v>>: match f[none]
		as no-change
			none
		as remove
			none
		as insert ins
			some: if a.pairs.size >= leaf-max-size
				if hash-shift >= 64
					# We've exhausted the hash.
					# TODO: fall back to a sorted dict?
					todo
				# If we get here, it's guaranteed that we don't need to recursively create leaves.
				# Just group by hash.
				a new-inner-node key, ins.value, remaining-hash, hash-shift
			else
				leaf-node: a.pairs ~ [key -> ins.value]
		get-or-update-result: new-node, none
	as some some-index
		index = some-index value
		old-value = a.pairs[index] to
		new-node = match f[old-value some]
		as no-change
			none as<opt node<?k, ?v>>
		as remove
			some: leaf-node: a.pairs remove-at index
		as insert ins
			some: leaf-node: a.pairs update index, key -> ins.value
		get-or-update-result: new-node, old-value.some

# In order to get the hash, we need to know the shift amount
.new-inner-node inner-node<?k, ?v>(a leaf-node<?k, ?v>, key ?k, value ?v, hash nat, hash-shift nat) trusted hash-mix<?k>
	key-hash = hash low-bits
	max-hash = key-hash fold a.pairs, \cur, pair
		cur max: pair.from.hash unsafe-bit-shift-right hash-shift low-bits
	res = max-hash wrap-add 1 fill-mut-arr<node<?k, ?v>> empty-leaf-node
	# TODO: avoid allocating the same leaf twice...
	res[key-hash] := leaf-node: [key -> value]
	a.pairs each \pair
		x = pair.from.hash unsafe-bit-shift-right hash-shift low-bits
		res[x] := match res[x]
		as inner-node
			unreachable
		as leaf-node l
			leaf-node: l.pairs ~ [pair]
	inner-node: res cast-immutable

region iteration

each-unordered void(a lookup<?k, ?v>, f act void(?k, ?v))
	void fold-unordered a, \ignore, key, value
		f[key, value]

each-key-unordered void(a lookup<?k, ?v>, f act void(?k))
	void fold-keys-unordered a, \ignore, key
		f[key]

fold-unordered ?a(acc ?a, a lookup<?k, ?v>, f act ?a(?a, ?k, ?v))
	acc fold-unordered-recur a.root, f
.fold-unordered-recur ?a(acc ?a, a node<?k, ?v>, f act ?a(?a, ?k, ?v))
	match a
	as inner-node i
		acc fold i.children, \cur, child
			cur fold-unordered-recur child, f
	as leaf-node l
		acc fold l.pairs, \cur, pair
			f[cur, pair.from, pair.to]

fold-keys-unordered ?a(acc ?a, a lookup<?k, ?v>, f act ?a(?a, ?k))
	acc fold-unordered a, \cur, key, value
		f[cur, key]

# TODO:PRIVATE
dbg str(a lookup<nat, str>)
	res = mut-list<char>
	res dbg-recur a.root, ""
	res move-to-arr!

.dbg-recur void(out mut-list char, a node<nat, str>, path str)
	match a
	as inner-node i
		i.children each-with-index \child, index
			if child.node-empty? not
				out dbg-recur child, path ~ index.to-str
				out ~= " "
		out.pop! drop
	as leaf-node l
		out ~= path
		out ~= "["
		l.pairs each \pair
			out ~= pair.from to-str
			out ~= " -> "
			out ~= pair to
			out ~= ", "
		if l.pairs empty?
			out ~= "]"
		else
			out.pop! drop
			out.last := "]"

# TODO:PRIVATE
dbg str(a lookup<nat, void>)
	res = mut-list<char>
	res dbg-recur a.root, ""
	res move-to-arr!

.dbg-recur void(out mut-list char, a node<nat, void>, path str)
	match a
	as inner-node i
		i.children each-with-index \child, index
			if child.node-empty? not
				out dbg-recur child, path ~ index.to-str
				out ~= " "
		out.pop! drop
	as leaf-node l
		out ~= path
		out ~= "["
		l.pairs each \pair
			out ~= pair.from to-str
			out ~= ", "
		if l.pairs empty?
			out ~= "]"
		else
			out.pop! drop
			out.last := "]"

verify void(a lookup<nat, str>, expected str)
	a.dbg is expected

test
	info log "LOOKUP TEST START"
	l0 = lookup<nat, str>
	l0.empty? is true
	l0.size is 0
	l0 verify "[]"
	l0[0] is none

	l1 = l0 ~ (5 -> "5")
	l1.empty? is false
	l1.size is 1
	info log "L1 IS"
	info log l1.dbg
	l1 verify "[5 -> 5]"
	
	l2 = l1 ~ [1 -> "1", 3 -> "3", 9 -> "9"]
	info log "L2 IS"
	info log l2.dbg
	l2 verify "[5 -> 5, 1 -> 1, 3 -> 3, 9 -> 9]"

	info log "GET L3"
	l3 = l2 ~ (13 -> "13")
	info log "L3 IS"
	info log l3.dbg
	l3 verify "[5 -> 5, 1 -> 1, 3 -> 3, 9 -> 9, 13 -> 13]"
	#l3 verify "1[1 -> 1, 9 -> 9] 3[3 -> 3] 5[13 -> 13, 5 -> 5]"

	#l3[3] is "3".some
	#l3[4] is none

	#l3 - 3 verify "[1 -> 1, 9 -> 9, 13 -> 13, 5 -> 5]"

	# TODO: lots more tests. Be sure to test removal can remove inner nodes.

	info log "LOOKUP TEST DONE"
