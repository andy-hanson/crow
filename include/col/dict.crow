no-std
import
	..bool: ==, ?, and, bool, false, not, true
	..compare: <=, >=, compare, comparison, equal, max, min
	..exception: assert
	..fun: subscript
	..misc: ->, arrow, as, data, from, to, void
	..number: ==, <=>, +, -, even?, nat
	..opt: ==, has?, none, opt, opt-or, or-default, some
	..ptr: +, -, ptr, ptr-eq?, ptr-less?, set-subscript, subscript
	..str: ==, chars, empty?, size-bytes, str
	..str-conv: interp, finish, to-str, with-str, with-value
	..test: is
	..writer: ~=, backup!, move-to-str!, writer
	.arr: arr, arr-equal?, begin-ptr, empty?, end-ptr, size, subscript
	.arr-util: each, filter, fold, map, tail
	.mut-arr:
		begin-ptr, cast-immutable, copy-from!, empty?, end-ptr, fold, mut-arr,
		mut-arr-from-begin-end, set-subscript, size, subscript, tail, uninitialized-mut-arr
	.sort: sort-by
	.private.sort-utils: binary-search-value

dict<?k, ?v> record
	# TODO:PRIVATE
	ignore void
	impl dict-impl<?k, ?v>

# TODO: comparison should be generic
dict-equal? bool(a dict<?k, ?v>, b dict<?k, ?v>) data<?k> compare<?k> equal<?v>
	# TODO:PERF
	a.arr arr-equal? b.arr, \x, y
		x.from == y.from and x.to == y.to

.dict-impl<?k, ?v> union
	overlay<?k, ?v>
	end-node<?k, ?v>

.overlay<?k, ?v> record
	# TODO: consider tracking the number of keys that are new, or change a value, or remove a value.
	# We should merge more frequently if removing keys, less frequently if adding keys.
	# never empty
	pairs arr arrow<?k, opt ?v>
	prev dict-impl<?k, ?v>

# Leftmost node. Values are non-optional as there is nothing left of this to remove from.
.end-node<?k, ?v> record
	pairs arr arrow<?k, ?v>

dict dict<?k, ?v>() data<?k> compare<?k>
	dict: void, end-node: []

dict dict<?k, ?v>(a arr arrow<?k, ?v>) data<?k> compare<?k>
	dict: void, end-node: a sort-by {it from}

empty? bool(a dict<?k, ?v>) data<?k> compare<?k>
	match a impl
	as overlay
		false
	as end-node e
		e.pairs empty?

###
Number of pairs.
This is O(n).
###
size nat(a dict<?k, ?v>) data<?k> compare<?k>
	0 fold a, \acc, k, v
		acc + 1

arr arr arrow<?k, ?v>(a dict<?k, ?v>) data<?k> compare<?k> trusted
	match a impl
	as overlay
		out = a.size uninitialized-mut-arr<arrow<?k, ?v>>
		end = out.begin-ptr fold a, \cur, k, v
			cur[] := k -> v
			cur + 1
		assert: end ptr-eq? out.end-ptr
		out cast-immutable
	as end-node e
		e pairs

~ dict<?k, ?v>(a dict<?k, ?v>, pair arrow<?k, ?v>) data<?k> compare<?k>
	dict: void, a.impl add-or-remove pair.from, pair.to.some

~ dict<?k, ?v>(a dict<?k, ?v>, b dict<?k, ?v>) data<?k> compare<?k>
	a ~ b.arr

~ dict<?k, ?v>(a dict<?k, ?v>, b arr arrow<?k, ?v>) data<?k> compare<?k>
	if b empty?
		a
	elif a empty?
		dict: b
	else
		# TODO: 'as' should be unnecessary
		pairs = as<arr arrow<?k, opt ?v>>: b map {it.from -> it.to.some} sort-by {it from}
		dict: void, merge-as-needed: pairs overlay a.impl

- dict<?k, ?v>(a dict<?k, ?v>, key ?k) data<?k> compare<?k>
	if a has-key? key
		dict: void, a.impl add-or-remove key, none
	else
		a

- dict<?k, ?v>(a dict<?k, ?v>, keys arr ?k) data<?k> compare<?k>
	a fold keys, \cur, key
		cur - key

subscript opt ?v(a dict<?k, ?v>, key ?k) data<?k> compare<?k>
	a.impl subscript-recur key
.subscript-recur opt ?v(a dict-impl<?k, ?v>, key ?k) trusted data<?k> compare<?k>
	match a
	as overlay o
		if pair ?= o.pairs binary-search-value {key <=> it.from}
			pair to
		else
			o.prev subscript-recur key
	as end-node e
		if pair ?= e.pairs binary-search-value {key <=> it.from}
			pair.to some

has-key? bool(a dict<?k, ?v>, key ?k) trusted data<?k> compare<?k>
	a[key] has?

.add-or-remove dict-impl<?k, ?v>(a dict-impl<?k, ?v>, key ?k, value opt ?v) data<?k> compare<?k>
	merge-as-needed: overlay: [key -> value], a

.merge-as-needed dict-impl<?k, ?v>(a overlay<?k, ?v>) data<?k> compare<?k>
	match a prev
	as overlay o
		if o.pairs.size should-merge? a.pairs.size
			new-pairs = o.pairs merge-overlays a.pairs
			merge-as-needed: overlay: new-pairs, o.prev
		else
			a
	as end-node e
		if e.pairs.size should-merge? a.pairs.size
			new-pairs = e.pairs merge-to-end a.pairs
			end-node: new-pairs
		else
			a

.should-merge? bool(prev-size nat, overlay-size nat)
	prev-size <=: overlay-size max 3

.merge-overlays arr arrow<?k, opt ?v>(l arr arrow<?k, opt ?v>, r arr arrow<?k, opt ?v>) trusted data<?k> compare<?k>
	res = l.size + r.size uninitialized-mut-arr<arrow<?k, opt ?v>>
	end = res.begin-ptr merge-keep-right l.begin-ptr, l.end-ptr, r.begin-ptr, r.end-ptr, \x, y
		x.from <=> y.from
	res[0 -> end - res.begin-ptr] cast-immutable

.merge-keep-right ptr ?a
	out ptr ?a
	l ptr ?a
	l-end ptr ?a
	r ptr ?a
	r-end ptr ?a
	compare act comparison(?a, ?a)
spec
	unsafe
body
	assert: l ptr-less? l-end
	assert: r ptr-less? r-end
	match compare[l[], r[]]
	as less
		out[] := l[]
		if l + 1 ptr-eq? l-end
			out + 1 finish-rest r, r-end
		else
			out + 1 merge-keep-right l + 1, l-end, r, r-end, compare
	as equal
		out[] := r[]
		if l + 1 ptr-eq? l-end
			out + 1 finish-rest r + 1, r-end
		elif r + 1 ptr-eq? r-end
			out + 1 finish-rest l + 1, l-end
		else
			out + 1 merge-keep-right l + 1, l-end, r + 1, r-end, compare
	as greater
		out[] := r[]
		if r + 1 ptr-eq? r-end
			out + 1 finish-rest l, l-end
		else
			out + 1 merge-keep-right l, l-end, r + 1, r-end, compare

.merge-to-end arr arrow<?k, ?v>(l arr arrow<?k, ?v>, r arr arrow<?k, opt ?v>) trusted data<?k> compare<?k>
	res = l.size + r.size uninitialized-mut-arr<arrow<?k, ?v>>
	end = if l empty?
		res.begin-ptr finish-rest-ignore-none r.begin-ptr, r.end-ptr
	else
		res.begin-ptr merge-to-end-recur l.begin-ptr, l.end-ptr, r.begin-ptr, r.end-ptr
	res[0 -> end - res.begin-ptr] cast-immutable

.merge-to-end-recur ptr arrow<?k, ?v>
	out ptr arrow<?k, ?v>
	l ptr arrow<?k, ?v>
	l-end ptr arrow<?k, ?v>
	r ptr arrow<?k, opt ?v>
	r-end ptr arrow<?k, opt ?v>
spec
	unsafe
	data<?k>
	compare<?k>
body
	assert: l ptr-less? l-end
	assert: r ptr-less? r-end
	match l[].from <=> r[].from
	as less
		out[] := l[]
		if l + 1 ptr-eq? l-end
			out + 1 finish-rest-ignore-none r, r-end
		else
			out + 1 merge-to-end-recur l + 1, l-end, r, r-end
	as equal
		new-out = if r-value ?= r[] to
			out[] := r[].from -> r-value
			out + 1
		else
			out

		if l + 1 ptr-eq? l-end
			new-out finish-rest-ignore-none r, r-end
		elif r + 1 ptr-eq? r-end
			new-out finish-rest l, l-end
		else
			new-out merge-to-end-recur l + 1, l-end, r + 1, r-end
	as greater
		new-out = if r-value ?= r[] to
			out[] := r[].from -> r-value
			out + 1
		else
			out

		if r + 1 ptr-eq? r-end
			new-out finish-rest l, l-end
		else
			new-out merge-to-end-recur l, l-end, r + 1, r-end

.finish-rest ptr ?a(out ptr ?a, cur ptr ?a, end ptr ?a) unsafe
	rest-size = end - cur
	out-end = out + rest-size
	out mut-arr-from-begin-end out-end copy-from!: cur mut-arr-from-begin-end end
	out-end

.finish-rest-ignore-none ptr arrow<?k, ?v>
	out ptr arrow<?k, ?v>
	r ptr arrow<?k, opt ?v>
	r-end ptr arrow<?k, opt ?v>
spec
	unsafe
body
	if r ptr-eq? r-end
		out
	else
		new-out = if r-value ?= r[] to
			out[] := r[].from -> r-value
			out + 1
		else
			out
		new-out finish-rest-ignore-none r + 1, r-end

region iteration

each void(a dict<?k, ?v>, f act void(?k, ?v)) data<?k> compare<?k>
	void fold a, \ignore, k, v
		f[k, v]

fold ?a(acc ?a, a dict<?k, ?v>, f act ?a(?a, ?k, ?v)) data<?k> compare<?k>
	iters = a init-iters
	acc fold-recur iters.end-pairs, iters.overlays, f

.fold-recur ?a
	acc ?a
	end-node arr arrow<?k, ?v>
	overlays mut-arr arr arrow<?k, opt ?v>
	f act ?a(?a, ?k, ?v)
spec
	data<?k>
	compare<?k>
body
	# Invariant: Nothing in 'overlays' is empty.
	if overlays empty?
		if end-node empty?
			acc
		else
			pair = end-node[0]
			f[acc, pair.from, pair.to] fold-recur end-node.tail, overlays, f
	else
		least-key = if end-node empty?
			overlays[0][0].from find-least-key overlays.tail
		else
			end-node[0].from
		take-from-end-node? = end-node.empty?.not and least-key == end-node[0].from
		val-from-end-node = as<opt ?v>: take-from-end-node? ? end-node[0].to.some, none
		new-end-node = take-from-end-node? ? end-node.tail, end-node
		took-from-overlays = overlays take-key least-key
		new-acc = if val ?= took-from-overlays.rightmost-value opt-or val-from-end-node
			f[acc, least-key, val]
		else
			acc
		new-acc fold-recur new-end-node, took-from-overlays.overlays, f

.find-least-key ?k(current-least-key ?k, overlays mut-arr arr arrow<?k, ?v>) data<?k> compare<?k>
	current-least-key fold overlays, \cur, overlay
		cur min overlay[0].from

.took-key<?k, ?v> record mut
	rightmost-value opt ?v
	overlays mut-arr arr arrow<?k, opt ?v>

###
Takes the key from the front of every overlay that has it.
Removes rightmost overlays from the mut-arr (by returning a new, smaller mut-arr).
Returns the rightmost value associated with that key.
###
.take-key took-key<?k, ?v>(overlays mut-arr arr arrow<?k, opt ?v>, key ?k) data<?k> compare<?k>
	overlays take-key-recur key, 0, none
.take-key-recur took-key<?k, ?v>
	overlays mut-arr arr arrow<?k, opt ?v>
	key ?k
	index nat
	rightmost-value opt ?v
spec
	data<?k>
	compare<?k>
body
	# Index can overshoot due to removing overlays
	if index >= overlays.size
		took-key: rightmost-value, overlays
	elif overlays[index][0].from == key
		new-rightmost-value = overlays[index][0] to
		new-overlay = overlays[index] tail
		if new-overlay empty?
			overlays[index] := overlays[overlays.size - 1]
			overlays[0 -> overlays.size - 1] take-key-recur key, index + 1, new-rightmost-value
		else
			overlays[index] := new-overlay
			overlays take-key-recur key, index + 1, new-rightmost-value
	else
		overlays take-key-recur key, index + 1, rightmost-value

.get-end end-node<?k, ?v>(a dict-impl<?k, ?v>)
	match a
	as overlay o
		o.prev get-end
	as end-node e
		e

.iters<?k, ?v> record mut
	end-pairs arr arrow<?k, ?v>
	overlays mut-arr arr arrow<?k, opt ?v>

.init-iters iters<?k, ?v>(a dict<?k, ?v>) trusted
	overlay-iters = 0 overlay-count a.impl uninitialized-mut-arr<arr arrow<?k, opt ?v>>
	end-pairs = overlay-iters.begin-ptr init-overlay-iters-recur! a.impl
	iters: end-pairs, overlay-iters

.overlay-count nat(acc nat, a dict-impl<?k, ?v>)
	match a
	as overlay o
		acc + 1 overlay-count o.prev
	as end-node
		acc

.init-overlay-iters-recur! arr arrow<?k, ?v>(out ptr arr arrow<?k, opt ?v>, a dict-impl<?k, ?v>) unsafe
	match a
	as overlay o
		out[] := o.pairs
		out + 1 init-overlay-iters-recur! o.prev
	as end-node e
		e pairs

filter dict<?k, ?v>(a dict<?k, ?v>, f act bool(?k, ?v)) data<?k> compare<?k>
	# No need to re-sort
	dict: void, end-node: a.arr filter \pair
		f[pair.from, pair.to]

map dict<?k-out, ?v-out>
	a dict<?k-in, ?v-in>
	f act arrow<?k-out, ?v-out>(?k-in, ?v-in)
spec
	data<?k-in>
	compare<?k-in>
	data<?k-out>
	compare<?k-out>
body
	dict: a map-to-arr f

map-to-arr arr<?out>(a dict<?k, ?v>, f act ?out(?k, ?v)) data<?k> compare<?k>
	a.arr map {f[it.from, it.to]}

map-values dict<?k, ?v-out>(a dict<?k, ?v-in>, f act ?v-out(?k, ?v-in)) data<?k> compare<?k>
	# No need to re-sort
	dict: void, end-node: a.arr map \pair
		pair.from -> f[pair.from, pair.to]

.dbg str(a dict<nat, str>)
	out = writer
	out dbg-recur! a.impl
	out move-to-str!

.dbg-recur! void(out writer, a dict-impl<nat, str>)
	match a
	as overlay o
		out dbg-recur! o.prev
		out ~= ", "
		out ~= "["
		o.pairs each \pair
			out ~= pair.from
			out ~= " -> "
			out ~= pair.to or-default "_"
			out ~= ", "
		if o.pairs empty?
			out ~= "]"
		else
			out backup! 2
			out ~= "]"
	as end-node e
		out ~= "["
		e.pairs each \pair
			out ~= pair.from to-str
			out ~= " -> "
			out ~= pair to
			out ~= ", "
		if e.pairs empty?
			out ~= "]"
		else
			out backup! 2
			out ~= "]"

verify void(a dict<nat, str>, expected str)
	a.dbg is expected

test
	a = dict<nat, str>
	a.empty? is true
	a.size is 0
	a verify "[]"
	a[10] is none

	b = a ~ (10 -> "10")
	b verify "[10 -> 10]"
	b[10] is "10".some

	c = b ~ [15 -> "15", 5 -> "5", 20 -> "20"]
	c verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20]"

	d = c ~ (11 -> "11")
	d verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	f = e - 16
	f verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	g = f - 15
	g verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	h = g - 10
	h verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> _, 11 -> 11, 15 -> _]"

	i = h ~ (10 -> "10b")
	i verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> 11, 15 -> _]"

	j = i - [11, 12]
	# Unfortunately we leave an unnecessary '11 -> _',
	# because we don't keep track of what a removal removes from, and it might be removing from the leftmost node.
	j verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> _, 15 -> _]"

	k = j ~ [11 -> "11", 25 -> "25"]
	k verify "[5 -> 5, 10 -> 10b, 11 -> 11, 20 -> 20, 25 -> 25]"

	j-folded = "" fold j, \cur, key, value
		pair = "{key} -> {value}"
		cur.empty? ? pair, "{cur}, {pair}"
	j-folded is "5 -> 5, 10 -> 10b, 15 -> 15, 20 -> 20"

	j-filtered = j filter \k, v
		k even?
	j-filtered verify "[10 -> 10b, 20 -> 20]"

	j-mapped = j map-values \k, v
		v.chars[v.size-bytes - 1 -> v.size-bytes] str
	j-mapped verify "[5 -> 5, 10 -> b, 15 -> 5, 20 -> 0]"
