no-std
import
	..bool: and, bool, not
	..compare: ==, <=>, comparison, greater, less
	..exception: assert
	..fun: subscript
	..misc: ->, arrow, as, from, to, void
	..number: +, nat
	..opt: each, has?, none, opt, some
	.arr: arr, data, empty?, size, subscript
	.arr-util: map, tail, zip
	.mut-list: ~=, move-to-arr!, mut-list
	.sort: a, b, sort-by-first

###
A dictionary type that maps keys to values.
Called a "map", "table", "hash table", or "associative array" in other languages.
Keys must be `data`; values can be anything.
See `mut-dict` for a mutable version.
See `set` for a dict with no values.
###
dict<?k, ?v> record
	# TODO: PRIVATE
	# Keys should be in sorted order
	ignore void
	keys arr ?k
	values arr ?v

# Empty dict.
dict dict<?k, ?v>() data<?k>
	dict: [], []

###
`dict` from `key -> value` pairs.
Fails if some key is repeated.
###
dict dict<?k, ?v>(pairs arr arrow<?k, ?v>) data<?k>
	keys = pairs map {it from}
	values = pairs map {it to}
	dict: keys, values

###
`dict` from keys and values from corresponding elements in the arrays.
Fails if the key and value arrays have different sizes.
Fails if some key is repeated.
###
dict dict<?k, ?v>(keys arr ?k, values arr ?v) data<?k>
	assert: keys.size == values.size
	sorted = keys sort-by-first values
	dict: void, sorted.a, sorted.b

# Converts a dict to an arr of `key -> value` pairs.
arr arr arrow<?k, ?v>(a dict<?k, ?v>)
	a.keys zip a.values, \key, value
		key -> value

# True iff the dict has no keys.
empty? bool(a dict<?k, ?v>)
	a.keys empty?

# Gets the value associated with a key, or returns `none`.
subscript opt ?v(a dict<?k, ?v>, key ?k) trusted data<?k>
	# TODO: should not need to provide type arguments
	subscript-recur<?k, ?v>: a.keys, a.values, 0, key
.subscript-recur<?k, ?v> opt ?v(keys arr ?k, values arr ?v, idx nat, key ?k) data<?k>
	if idx == keys.size
		none
	elif key == keys[idx]
		values[idx] some
	else
		# TODO: should not need to provide type arguments!
		subscript-recur<?k, ?v>: keys, values, idx + 1, key

# True iff the key is in the dict.
has? bool(a dict<?k, ?v>, key ?k) data<?k>
	a[key] has?

# Creates a new dict with the same keys, but with `f` applied to each value.
map-values dict<?k, ?v-out>(a dict<?k, ?v-in>, f act ?v-out(?v-in)) data<?k>
	# TODO: should be able to infer type arguments 
	dict<?k, ?v-out>: a.keys, a.values map f

###
Calls `f` for each `key -> value` pair in the dict.
Keys are iterated in sorted order, so each key passed to `f` is `>` all previous keys.
###
each void(a dict<?k, ?v>, f act void(?k, ?v)) data<?k>
	if a.empty? not
		f[a.keys[0], a.values[0]]
		# TODO: type arguments should be unnecessary
		a.keys.tail dict<?k, ?v> a.values.tail each f

###
Combines two dicts.
For each key in *either* `a` or `b`, calls `f`,
providing the key's corresponding values from `a` and `b`.
The result will only have `key -> value` pairs where `f` returns `some`.
###
combine dict<?k, ?out>(a dict<?k, ?in-0>, b dict<?k, ?in-1>, f act opt ?out(?k, opt ?in-0, opt ?in-1)) data<?k>
	out-keys = mut-list<?k>
	out-values = mut-list<?out>
	combine-recur: out-keys, out-values, a.keys, a.values, b.keys, b.values, f
	dict: out-keys.move-to-arr!, out-values.move-to-arr!
.combine-recur void
	out-keys mut-list ?k
	out-values mut-list ?out
	a-keys arr ?k
	a-values arr ?in-0
	b-keys arr ?k
	b-values arr ?in-1
	cb act opt ?out(?k, opt ?in-0, opt ?in-1)
spec
	data<?k>
body
	if a-keys.empty? and b-keys.empty? not
		cmp = as<comparison>: if a-keys empty?
			greater
		elif b-keys empty?
			less
		else
			a-keys[0] <=> b-keys[0]
		match cmp
		as less
			cb[a-keys[0], a-values[0] some, none] each \v
				out-keys ~= a-keys[0]
				out-values ~= v
			combine-recur: out-keys, out-values, a-keys.tail, a-values.tail, b-keys, b-values, cb
		as equal
			cb[a-keys[0], a-values[0] some, b-values[0] some] each \v
				out-keys ~= a-keys[0]
				out-values ~= v
			combine-recur: out-keys, out-values, a-keys.tail, a-values.tail, b-keys.tail, b-values.tail, cb
		as greater
			cb[b-keys[0], none, b-values[0] some] each \v
				out-keys ~= b-keys[0]
				out-values ~= v
			combine-recur: out-keys, out-values, a-keys, a-values, b-keys.tail, b-values.tail, cb
