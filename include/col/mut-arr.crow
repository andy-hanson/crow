no-std
import
	..private.alloc: alloc-uninitialized, fill-ptr-range, set-zero-range
	..bool: bool, not
	..compare: ==, <, <=
	..exception: assert
	..fun: subscript
	..misc: ->, arrow, data, from, to, void
	..number: -, *, nat
	..opt: none, opt, some
	..posix.string: memcpy
	..ptr: +, -, as-any-ptr, ptr, ptr-eq?, ptr-less?, ptr-less-eq?, set-subscript, size-of, subscript
	.arr: arr, arr-from-begin-end, begin-ptr, size, subscript
	.arr-util: each, each-with-index, find-index, fold, fold-reverse

###
Like `arr` but mutable.
`mut-arr` is fixed-size, unlike `mut-list`. It can change elements but can't add or remove them.
###
mut-arr<?a> record mut
	by-val
	# Adding a dummy field so the constructor won't conflict with mut-arr from arr
	ignore void
	# TODO:PRIVATE
	inner arr ?a

# Empty `mut-arr`.
mut-arr mut-arr ?a() noctx
	mut-arr: void, []

# `mut-arr` from a pointer and size.
mut-arr mut-arr ?a(size nat, begin-ptr ptr ?a) noctx unsafe
	mut-arr: void, arr: size, begin-ptr

###
Copies an `arr` to a `mut-arr`.
Writing to the result won't affect the original.
###
mut-arr mut-arr ?a(a arr ?a)
	a.size make-mut-arr<?a> {a[it]}

###
Copies a `mut-arr` to an `arr`.
Further writes to the `mut-arr` won't affect the `arr` that was copied from it.
###
arr arr ?a(a mut-arr ?a)
	a.copy.inner

mut-arr-from-begin-end mut-arr ?a(begin ptr ?a, end ptr ?a) unsafe
	assert: begin ptr-less-eq? end
	mut-arr: void, arr-from-begin-end: begin, end

###
Copies the elements of a `mut-arr`.
Writing to the result won't affect the original.
###
copy mut-arr ?a(a mut-arr ?a)
	a.size make-mut-arr<?a> {a[it]}

copy-to-arr arr ?a(a mut-arr ?a) trusted
	a.copy cast-immutable

copy-from! void(dest mut-arr ?a, source arr ?a) trusted
	assert: dest.size == source.size
	memcpy: dest.begin-ptr.as-any-ptr, source.begin-ptr.as-any-ptr, dest.size * size-of<?a>

copy-from! void(dest mut-arr ?a, source mut-arr ?a) trusted
	dest copy-from! source.cast-immutable

empty? bool(a mut-arr ?a) noctx
	a.size == 0

size nat(a mut-arr ?a) noctx
	a.inner size

# Pointer to the beginning of the `mut-arr`.
begin-ptr ptr ?a(a mut-arr ?a) noctx unsafe
	a.inner begin-ptr

###
Pointer to the end of the `mut-arr`.
This is one past the last valid pointer.
###
end-ptr ptr ?a(a mut-arr ?a) noctx unsafe
	a.begin-ptr + a.size

###
Gets the element at the index.
Throws if `index >= a.size`.
###
subscript ?a(a mut-arr ?a, index nat) trusted
	assert: index < a.size
	a unsafe-at index

unsafe-at ?a(a mut-arr ?a, index nat) unsafe
	a.begin-ptr[index]

###
Slices the mut-arr.
This is O(1).
Writes to the slice will affect the original. (If you don't want that, use `copy`.)
Throws if `range.from > range.to`.
Throws if the slice would exceed the bounds of the `mut-arr`.
###
subscript mut-arr ?a(a mut-arr ?a, range arrow<nat, nat>)
	assert: range.from <= range.to
	assert: range.to <= a.size
	mut-arr: void, a.inner[range]

###
Write to a single element.
Throws if `index >= a.size`.
###
set-subscript void(a mut-arr ?a, index nat, value ?a) trusted
	assert: index < a.size
	a unsafe-set-at! index, value

unsafe-set-at! void(a mut-arr ?a, index nat, value ?a) unsafe
	a.begin-ptr[index] := value


first opt ?a(a mut-arr ?a)
	if a empty?
		none
	else
		a[0] some

last opt ?a(a mut-arr ?a)
	if a empty?
		none
	else
		a[0] some

tail mut-arr ?a(a mut-arr ?a)
	a[1 -> a.size]

rtail mut-arr ?a(a mut-arr ?a)
	a[0 -> a.size - 1]

# Allocates a `mut-arr` without initializing any of its elements.
uninitialized-mut-arr mut-arr ?a(size nat) unsafe
	mut-arr: size, alloc-uninitialized<?a>: size

###
`mut-arr` where each element is `f[i]`.
Equivalent to `mut-arr: [f[0], f[1], ...]`.
###
make-mut-arr mut-arr ?a(size nat, f act ?a(nat)) trusted
	res = size uninitialized-mut-arr<?a>
	res.begin-ptr fill-ptr-range size, f
	res

###
`mut-arr` where every element is `value`.
Equivalent to `mut-arr: [value, value, ...]`.
###
fill-mut-arr mut-arr ?a(size nat, value ?a)
	size make-mut-arr \ignore
		value

zeroed-mut-arr mut-arr ?a(size nat) unsafe
	res = size uninitialized-mut-arr<?a>
	res set-zero-elements
	res

fill! void(a mut-arr ?a, value ?a)
	a map! \ignore
		value

###
Unsafe cast a mut-arr to arr.
Called "temp" because it is UB if the mut-arr is written to while the `arr` is in use.
###
temp-as-arr arr ?a(a mut-arr ?a) noctx unsafe
	a inner

###
Unsafe cast a mut-arr to arr.
Equivalent to `temp-as-arr`, but the implication is that
the `mut-arr` will never be written to again, so the `arr` can be used forever.
###
cast-immutable arr ?a(a mut-arr ?a) noctx unsafe
	a inner

###
Fill the `mut-arr` with 0 bits.
This prevents the garbage collector from tracing those elements.
Data structures that use a `mut-arr` should `set-zero-elements` on any elements they don't use.
###
set-zero-elements void(a mut-arr ?a) noctx unsafe
	a.begin-ptr set-zero-range a.size

# Equivalent to `a.temp-as-arr index-of value`.
index-of opt nat(a mut-arr ?a, value ?a) data<?a>
	a find-index {it == value}

# Equivalent to `a.temp-as-arr find-index f`.
find-index opt nat(a mut-arr ?a, f act bool(?a)) trusted
	a.temp-as-arr find-index f

reverse! void(a mut-arr ?a) trusted
	a.begin-ptr reverse-recur! a.end-ptr - 1
.reverse-recur! void(left ptr ?a, right ptr ?a) unsafe
	if left ptr-less? right
		tmp = left[]
		left[] := right[]
		right[] := tmp
		left + 1 reverse-recur! right - 1

region iteration

# Calls 'f' on each element in the mut-arr.
each void(a mut-arr ?a, f act void(?a)) trusted
	a.temp-as-arr each f

each-with-index void(a mut-arr ?a, f act void(?a, nat)) trusted
	a.temp-as-arr each-with-index f

fold ?a(acc ?a, a mut-arr ?b, f act ?a(?a, ?b)) trusted
	acc fold a.temp-as-arr, f
fold-reverse ?a(acc ?a, a mut-arr ?b, f act ?a(?a, ?b)) trusted
	acc fold-reverse a.temp-as-arr, f

map! void(a mut-arr ?a, f act ?a(?a)) trusted
	a.begin-ptr map-recur! a.end-ptr, f
.map-recur! void(cur ptr ?a, end ptr ?a, f act ?a(?a)) unsafe
	if cur ptr-eq? end not
		cur[] := f[cur[]]
		cur + 1 map-recur! end, f

map mut-arr ?out(a mut-arr ?in, f act ?out(?in)) trusted
	a.size make-mut-arr \i
		f[a[i]]
