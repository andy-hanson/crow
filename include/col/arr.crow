no-std
import
	..bool: bool, not
	..compare: ==, <, <=
	..exception: assert
	..misc: arrow, from, to
	..number: +, -, nat
	..ptr: +, -, by-val, ptr, ptr-less-eq?, ref-of-ptr, subscript
	..private.alloc: alloc-uninitialized, copy-data-from
	..private.bootstrap: hard-assert
export
	..private.bootstrap: arr, data, size

###
Arr or the range from begin to end.
`begin` is inclusive and `end` is exclusive.
UB if begin > end.
###
arr-from-begin-end arr ?a(begin ptr ?a, end ptr ?a) unsafe noctx
	hard-assert: begin ptr-less-eq? end
	arr: end - begin, begin

# True iff `a.size == 0`.
empty? bool(a arr ?a) noctx
	a.size == 0

# True iff `a.size != 0`.
has? bool(a arr ?a) noctx
	a.empty? not

noctx-at ?a(a arr ?a, index nat) trusted noctx
	hard-assert: index < a.size
	a.data[index]

###
Gets the element at the index.
Fails if `index >= a.size`.
###
subscript ?a(a arr ?a, index nat) trusted
	assert: index < a.size
	a noctx-at index

###
Slices the arr.
`range.from` is inclusive and `range.to` is exclusive.
This works in O(1) without copying any elements.
Fails if `range.from > range.to`.
Fails if the slice would exceed the bounds of the arr.
###
subscript arr ?a(a arr ?a, range arrow<nat, nat>) trusted
	assert: range.from <= range.to
	assert: range.to <= a.size
	arr: range.to - range.from, a.data + range.from

ref-of-val-at ?a(a arr by-val<?a>, index nat) trusted
	assert: index < a.size
	a.data + index ref-of-ptr

###
Concatenates two arrs.
This involves copying every element from both arrs into the new arr.
If you need to concatenate often, consider using `mut-list`.
###
~ arr ?a(a arr ?a, b arr ?a) trusted
	res-size = a.size + b.size
	res = res-size alloc-uninitialized<?a>
	res copy-data-from a.data, a.size
	res + a.size copy-data-from b.data, b.size
	arr: res-size, res
