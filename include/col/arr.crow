no-std
import
	..bool: bool, false, not, true
	..compare: ==, !=, <, <=
	..exceptions: assert
	..misc: ->, arrow, from, to
	..number: +, -, nat
	..ptr: +, -, by-val, ptr, ref-of-ptr, subscript
	..private.alloc: alloc-uninitialized, copy-data-from
	..private.bootstrap: hard-assert
export
	..private.bootstrap: arr, data, size

arr-from-begin-end arr ?t(begin ptr ?t, end ptr ?t) unsafe noctx
	arr: (end - begin), begin

empty? bool(a arr ?t) noctx
	a.size == 0

has? bool(a arr ?t) noctx
	a.empty? not

noctx-at ?t(a arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data[index]

subscript ?t(a arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

subscript arr ?t(a arr ?t, range arrow<nat, nat>) trusted
	assert: range.from <= range.to
	assert: range.to <= a.size
	arr: range.to - range.from, a.data + range.from

ref-of-val-at ?t(a arr by-val<?t>, index nat) trusted
	assert: index < a.size
	a.data + index ref-of-ptr

~ arr ?t(a arr ?t, b arr ?t) trusted
	res-size = a.size + b.size
	res = res-size alloc-uninitialized<?t>
	res copy-data-from a.data, a.size
	res + a.size copy-data-from b.data, b.size
	arr: res-size, res

# TODO: should be unnecessary, just use '=='
# (But type system must recognize that `arr ?t` is data if `?t` is)
arr-eq? bool(a arr ?t, b arr ?t) data<?t>
	if a.size != b.size
		false
	elif a.empty?
		true
	elif a[0] != b[0]
		false
	else
		a[1 -> a.size] arr-eq?: b[1 -> b.size]
