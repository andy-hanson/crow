no-std
import
	..bool: and, bool, false, not, true
	..compare: <=>
	..misc: void
	..number: nat
	.arr: arr, data, empty?, size, subscript
	.arr-util: filter, tail
	.mut-list: ~=, move-to-arr!, mut-list
	.sort: sort-unique

###
Set of unique values.
Unlike `arr`, the values are always in sorted order, and there are never two of the same value.
###
set<?a> record
	ignore void
	# TODO:PRIVATE
	values arr ?a

# Empty set.
set set ?a() data<?a>
	# TODO: type args should be unnecessary
	set: void, []

# Copies an `arr` to a `set`.
set set ?a(a arr ?a) data<?a>
	set: void, a.sort-unique

###
Array of all values in the set, in sorted order.
This is O(1) as it exposes the set's internal arr.
This is safe because it's immutable.
###
arr arr ?a(a set ?a) data<?a>
	a.values

# Number of values in the set.
size nat(a set ?a) data<?a>
	a.values size

# True iff the value is in the set.
subscript bool(a set ?a, value ?a) data<?a>
	a.values has? value
.has? bool(a arr ?a, value ?a) data<?a>
	# TODO: binary search
	if a empty?
		false
	else
		match value <=> a[0]
		as less
			false
		as equal
			true
		as greater
			a.tail has? value

###
Union of two sets.
Contains all values from either `a` or `b`.
Equivalent to `set: a.arr ~ b.arr` (but more efficient).
###
~ set ?a(a set ?a, b set ?a) data<?a>
	res = mut-list<?a>
	res union! a.values, b.values
	set: void, res.move-to-arr!
.union! void(res mut-list ?a, a arr ?a, b arr ?a) data<?a>
	if a empty?
		if b.empty? not
			res ~= b[0]
			res union! a, b.tail
	else
		if b empty?
			res ~= a[0]
			res union! a.tail, b
		else
			match a[0] <=> b[0]
			as less
				res ~= a[0]
				res union! a.tail, b
			as equal
				res ~= a[0]
				res union! a.tail, b.tail
			as greater
				res ~= b[0]
				res union! a, b.tail

###
Intersection of two sets.
Contains only values that are in both `a` and `b`.
Equivalent to `a filter {b[it]}` (but more efficient). 
###
intersect set ?a(a set ?a, b set ?a) data<?a>
	res = mut-list<?a>
	res intersect! a.values, b.values
	set: void, res.move-to-arr!
.intersect! void(res mut-list ?a, a arr ?a, b arr ?a) data<?a>
	if a.empty?.not and b.empty?.not
		match a[0] <=> b[0]
		as less
			res intersect! a.tail, b
		as equal
			res ~= a[0]
			res intersect! a.tail, b.tail
		as greater
			res intersect! a, b.tail

###
Difference of two sets.
Contains values that are in `a` but not `b`.
Equivalent to `a filter {b[it] not}` (but more efficient).
###
- set ?a(a set ?a, b set ?a) data<?a>
	res = mut-list<?a>
	res subtract! a.values, b.values
	set: void, res.move-to-arr!
.subtract! void(res mut-list ?a, a arr ?a, b arr ?a) data<?a>
	if a.empty? not
		if b empty?
			res ~= a
		else
			match a[0] <=> b[0]
			as less
				res ~= a[0]
				res subtract! a.tail, b
			as equal
				res subtract! a.tail, b.tail
			as greater
				res subtract! a, b.tail

###
Set containing a only values for which `f[x]` is true.
This is O(a.size) as filtering does not change sort order.
###
filter set ?a(a set ?a, f act bool(?a))
	set: void, a.values filter f
