no-std
import
	..bool: and, bool, false, not, true
	..compare: ==, !=, <, >, >=, <=>
	..exception: assert, forbid, unreachable
	..fun: subscript
	..log: info, log
	..misc: ->, data, void
	..number: +, -, *, nat
	..opt: force, none, opt, or-default, some, value
	..ptr:
		+, -, deep-size-bytes, ptr, ptr-eq?, ptr-less?, ptr-less-eq?, set-subscript, size-of,
		subscript
	..str: char, str
	..str-conv: finish, interp, to-str, with-str, with-value
	..test: is
	.arr: arr, arr-from-begin-end, begin-ptr, empty?, end-ptr, size, subscript
	.arr-util: deep-size-bytes, each, tail
	.index-set:
		~, alloc-count, count-greater-or-equal, count-range, deep-size-bytes, each, empty?,
		filter-less, index-set, size, subscript, try-remove
	.mut-arr:
		begin-ptr, cast-immutable, empty?, end-ptr, mut-arr, set-subscript, size, subscript,
		uninitialized-mut-arr
	.mut-list: ~=, move-to-arr!, mut-list, set-last
	.sort: sort
	.private.sort-utils: binary-search-exact-index

set<?a> record
	add add-node ?a
	remove index-set

###
We store add/remove separately.
Add nodes are a linked list where links point to the left. Largest node is on the left. Nodes are added to the right.
Removes are a flat array, since removes can happen anywhere.
Removes may be smaller than adds; that means that removals on the right are implicitly missing.
###

.add-node<?a> record
	values arr ?a
	left opt add-node ?a

set set ?a() data<?a>
	[] set

set set ?a(a arr ?a) data<?a>
	a.sort add-node none set index-set

arr arr ?a(a set ?a) data<?a>
	a map-to-arr {it}

deep-size-bytes nat(a set ?a) unsafe deep-size-bytes<?a>
	a.remove.deep-size-bytes deep-size-bytes-recur a.add
.deep-size-bytes-recur nat(acc nat, a add-node ?a) unsafe deep-size-bytes<?a>
	mid = acc + a.values.deep-size-bytes + a.left.size-of
	match a left
	as none
		mid
	as some s
		mid deep-size-bytes-recur s.value

overhead-bytes nat(a set ?a) unsafe
	a.remove.deep-size-bytes overhead-bytes-recur a.add
.overhead-bytes-recur nat(acc nat, a add-node ?a) unsafe
	mid = acc + a.size-of
	match a left
	as none
		mid
	as some s
		mid overhead-bytes-recur s.value

alloc-count nat(a set ?a) unsafe
	a.remove.alloc-count alloc-count-recur a.add
.alloc-count-recur nat(acc nat, a add-node ?a)
	# + 1 to allocate the arr
	mid = acc + 1
	match a left
	as none
		mid
	as some s
		# + 1 to allocate the left node
		mid + 1 alloc-count-recur s.value

.add-node-count nat(a set ?a)
	0 add-node-count-recur a.add
.add-node-count-recur nat(acc nat, a add-node ?a)
	match a left
	as none
		acc + 1
	as some s
		acc + 1 add-node-count-recur s.value


empty? bool(a set ?a)
	# Compaction ensures that this is the only case where we store empty values.
	a.add.values empty?

size nat(a set ?a)
	a.remove.size add-size-recur a.add
.add-size nat(a add-node ?a)
	0 add-size-recur a
.add-size-recur nat(acc nat, a add-node ?a)
	acc + a.values.size add-size-left a
.add-size-left nat(a add-node ?a)
	0 add-size-left a
.add-size-left nat(acc nat, a add-node ?a)
	match a left
	as none
		acc
	as some s
		acc add-size-recur s.value

subscript bool(a set ?a, value ?a) data<?a>
	match a.add find-in-add value
	as none
		false
	as some s
		a.remove[s value] not

.find-in-add opt nat(a add-node ?a, value ?a) data<?a>
	match a.values binary-search-exact-index value
	as none
		match a left
		as none
			none
		as some s
			s.value find-in-add value
	as some s
		a.add-size-left + s.value some

.find-in-add-for-remove-result record
	value-index nat
	size-left nat
	size-here nat
	size-right nat

.find-in-add-for-remove opt find-in-add-for-remove-result(a add-node ?a, value ?a, size-right nat) data<?a>
	match a.values binary-search-exact-index value
	as none
		match a left
		as none
			none
		as some s
			s.value find-in-add-for-remove value, size-right + a.values.size
	as some s
		sl = a add-size-left
		some: find-in-add-for-remove-result: sl + s.value, sl, a.values.size, size-right

~ set ?a(a set ?a, value ?a) data<?a>
	a try-add value or-default a

try-add opt set ?a(a set ?a, value ?a) data<?a>
	match a.add find-in-add value
	as none
		a add-and-compact value some
	as some s
		# In 'add', but may need to remove from removals
		match a.remove try-remove s.value
		as none
			none
		as some s2
			some: set: a.add, s2.value

- set ?a(a set ?a, value ?a) data<?a>
	a try-remove value or-default a

try-remove opt set ?a(a set ?a, value ?a) trusted data<?a>
	match a.add find-in-add-for-remove value, 0
	as none
		none
	as some s
		r = s value
		removals-here-and-right = 1 +: a.remove count-greater-or-equal r.size-left
		some: if r.size-here should-compact? r.size-right, removals-here-and-right
			compacted-size = r.size-here + r.size-right - 1
			a do-compact-and-remove (compact-plan: r.size-left, compacted-size), r.value-index
		else
			set: a.add, a.remove ~ r.value-index

.add-and-compact set ?a(a set ?a, value ?a) trusted data<?a>
	add-size = a.add add-size
	if add-size == 0
		set: (add-node: [value], none), index-set
	else
		# size-right starts as 1 because we're adding a value
		plan = add-size add-and-compact-plan a.add, a.remove, 1
		if plan.compacted-size == 1
			set: (add-node: [value], a.add.some), a.remove
		else
			a do-compact-and-add add-size, plan, value

.compact-plan record
	# Total size of all non-compacted nodes
	size-left nat
	# Size that the compacted node will have (sum of 'depth' rightmost nodes)
	compacted-size nat

###
Given that we're adding a new value to the right, we may compact nodes on the right.
size-here-and-left + size-right is the current size + 1.

We compact a node if:
* The combined size of all nodes to the right is >= this node's size
* Half of the values of this node have been removed
Or a combination of the two.	
###
.add-and-compact-plan compact-plan(size-here-and-left nat, a add-node ?a, remove index-set, size-right nat)
	size-here = a.values size
	size-left = size-here-and-left - size-here
	removals-here-and-right = remove count-greater-or-equal size-left
	if size-here should-compact? size-right, removals-here-and-right
		size-here-and-right = size-here + size-right
		match a left
		as none
			compact-plan: size-left, size-here-and-right
		as some s
			size-here-and-left - size-here add-and-compact-plan s.value, remove, size-here-and-right
	else
		compact-plan: size-here-and-left, size-right

.should-compact? bool(size-here nat, size-right nat, removals-here-and-right nat)
	size-right + removals-here-and-right * 2 >= size-here

.do-compact-and-add set ?a(a set ?a, add-size nat, plan compact-plan, value ?a) unsafe data<?a>
	assert: plan.compacted-size > 1
	compacted = plan.compacted-size uninitialized-mut-arr<?a>
	compacted.begin-ptr[] := value
	compactor = compactor<?a>: compacted.begin-ptr, compacted.begin-ptr + 1, compacted.end-ptr
	new-add = compactor do-compact-recur! a.add, add-size, a.remove
	set: new-add, a.remove filter-less plan.size-left

.do-compact-and-remove set ?a(a set ?a, plan compact-plan, extra-removal nat) unsafe data<?a>
	new-remove = a.remove filter-less plan.size-left
	if plan.compacted-size == 0
		match a.add left
		as none
			set
		as some s
			set: s.value, new-remove
	else
		compacted = plan.compacted-size uninitialized-mut-arr<?a>
		compactor = compactor<?a>: compacted.begin-ptr, compacted.begin-ptr, compacted.end-ptr
		old-size = plan.size-left + plan.compacted-size + 1
		new-add = compactor do-compact-recur! a.add, old-size, a.remove ~ extra-removal
		set: new-add, new-remove

.compactor<?a> record mut
	begin ptr ?a
	cur mut ptr ?a
	end ptr ?a

# NOTE: size-here-and-left is the old size, used to index into remove
.do-compact-recur! add-node ?a
	compactor compactor ?a
	a add-node ?a
	size-here-and-left nat
	remove index-set
spec
	unsafe
	data<?a>
body
	compactor merge! a.values, size-here-and-left, remove
	assert: compactor.cur ptr-less-eq? compactor.end
	if compactor.cur ptr-eq? compactor.end
		add-node: compactor.finish, a left
	else
		compactor do-compact-recur! a.left.force, size-here-and-left - a.values.size, remove

.merge! void(a compactor ?a, values arr ?a, size-here-and-left nat, remove index-set) unsafe data<?a>
	n-remove = remove count-range size-here-and-left - values.size, size-here-and-left
	n-added = values.size - n-remove
	if n-added != 0
		new-cur = a.cur + n-added
		remove-index = size-here-and-left - 1
		if a.cur ptr-eq? a.begin
			new-cur - 1 copy-from-b-recur! values.begin-ptr, values.end-ptr - 1, remove-index, remove
		else
			a.begin merge-recur! a.cur - 1, new-cur - 1, values.begin-ptr, values.end-ptr - 1, remove-index, remove
		a.cur := new-cur

.merge-recur! void
	a-begin ptr ?a
	a-read ptr ?a
	a-write ptr ?a
	b-begin ptr ?a
	b-read ptr ?a
	b-remove-index nat
	b-remove index-set
spec
	unsafe
	data<?a>
body
	forbid: a-read ptr-less? a-begin
	forbid: b-read ptr-less? b-begin
	forbid: a-write ptr-less? a-begin
	# merging from right, so take the greater value
	match a-read[] <=> b-read[]
	as less
		new-a-write = if b-remove[b-remove-index]
			a-write
		else
			a-write[] := b-read[]
			a-write - 1
		if b-read ptr-eq? b-begin not
			a-begin merge-recur! a-read, new-a-write, b-begin, b-read - 1, b-remove-index - 1, b-remove
		# Else -- done, everything from 'a' is in place
	as equal
		# We shouldn't store the same value twice.
		unreachable
	as greater
		a-write[] := a-read[]
		if a-read ptr-eq? a-begin
			a-write - 1 copy-from-b-recur! b-begin, b-read, b-remove-index, b-remove
		else
			a-begin merge-recur! a-read - 1, a-write - 1, b-begin, b-read, b-remove-index, b-remove

.copy-from-b-recur! void(a-write ptr ?a, b-begin ptr ?a, b-read ptr ?a, b-remove-index nat, b-remove index-set) unsafe
	new-a-write = if b-remove[b-remove-index]
		a-write
	else
		a-write[] := b-read[]
		a-write - 1
	if b-read ptr-eq? b-begin not
		new-a-write copy-from-b-recur! b-begin, b-read - 1, b-remove-index - 1, b-remove

.finish arr ?a(a compactor ?a) unsafe
	assert: a.cur ptr-eq? a.end
	a.begin arr-from-begin-end a.end

region iteration

each void(a set ?a, f act void(?a)) data<?a>
	void fold a, \ignore, x
		f[x]

fold ?a(acc ?a, a set ?b, f act ?a(?a, ?b)) data<?b>
	acc fold-recur a.init-iters, a.remove, f
.fold-recur ?a(acc ?a, iters mut-arr iter-part ?b, remove index-set, f act ?a(?a, ?b)) data<?b>
	if iters empty?
		acc
	else
		least-iter-index = iters[0].values[0] find-least-iter 0, 1, iters
		least-value = iters[least-iter-index].values[0]
		iters[least-iter-index] := iters[least-iter-index] tail remove
		new-iters = if iters[least-iter-index] empty?
			iters[least-iter-index] := iters[iters.size - 1]
			iters[0 -> iters.size - 1]
		else
			iters
		f[acc, least-value] fold-recur new-iters, remove, f

.find-least-iter nat(current-least ?a, current-least-index nat, iter-index nat, iters mut-arr iter-part ?a) data<?a>
	if iter-index == iters.size
		current-least-index
	else
		value = iters[iter-index].values[0]
		if value < current-least
			value find-least-iter iter-index, iter-index + 1, iters
		else
			current-least find-least-iter current-least-index, iter-index + 1, iters

.iter-part<?a> record
	by-val
	values arr ?a
	remove-index nat

.empty? bool(a iter-part ?a)
	a.values empty?

.tail iter-part ?a(a iter-part ?a, remove index-set)
	a.values.tail iter-part a.remove-index + 1 remove-from-front remove

.init-iters mut-arr iter-part ?a(a set ?a) trusted
	iters = a.add-node-count uninitialized-mut-arr<iter-part<?a>>
	res = iters.begin-ptr init-iters-recur! a.add, a.remove
	iters[0 -> res.out - iters.begin-ptr]

.init-iters-result<?a> record mut
	by-val
	next-remove-index nat
	out ptr iter-part ?a

.init-iters-recur! init-iters-result ?a(out ptr iter-part ?a, a add-node ?a, remove index-set) unsafe
	prev = match a left
	as none
		init-iters-result: 0, out
	as some s
		out init-iters-recur! s.value, remove
	here = a.values iter-part prev.next-remove-index remove-from-front remove
	new-out = if here empty?
		prev.out
	else
		prev.out[] := here
		prev.out + 1
	init-iters-result: prev.next-remove-index + a.values.size, new-out

.remove-from-front iter-part ?a(a iter-part ?a, remove index-set)
	if a.values.empty?.not and remove[a.remove-index]
		a.values.tail iter-part a.remove-index + 1 remove-from-front remove
	else
		a

# TODO: filter

map set ?out(a set ?in, f act ?out(?in)) data<?out> data<?in>
	set: a map-to-arr f

map-to-arr arr ?out(a set ?in, f act ?out(?in)) trusted data<?in>
	out = a.size uninitialized-mut-arr<?out>
	end = out.begin-ptr fold a, \cur, x
		cur[] := f[x]
		cur + 1

	assert: end ptr-eq? out.end-ptr
	out cast-immutable

# TODO:PRIVATE
dbg str(a set ?a) to-str<?a>
	out = mut-list<char>
	out dbg-add-recur! a.add
	if a.remove.empty? not
		out ~= " - ["
		a.remove each \i
			out ~= i to-str
			out ~= " "
		out.last := "]"
	out move-to-arr!

.dbg-add-recur! void(out mut-list char, a add-node ?a) to-str<?a>
	match a left
	as none
		void
	as some s
		out dbg-add-recur! s.value
		out ~= ", "
	if a.values empty?
		out ~= "[]"
	else
		out ~= "["
		a.values each \x
			out ~= x to-str
			out ~= " "
		out.last := "]"

.verify void(a set str, expected str)
	a.dbg is expected

test
	info log "SET2 TEST START"
	# TODO: be sure to test removing and then adding back
	a = set<str>
	a.empty? is true
	a.size is 0
	a verify "[]"

	b = a ~ "r"
	b.empty? is false
	b.size is 1
	b verify "[r]"

	b - "r" verify "[]"

	c = b ~ "o"
	c verify "[o r]"

	d = c ~ "c"
	d verify "[o r], [c]"

	d - "o" verify "[c r]"
	d - "r" verify "[c o]"
	d - "c" verify "[o r]"

	folded = "w" fold d, \acc, x
		"{acc}-{x}"
	folded is "w-c-o-r"

	# TODO: test filter

	dm = d map<str, str> \x
		if x == "c"
			"sea"
		elif x == "r"
			"arr"
		elif x == "o"
			"oh"
		else
			"x"
	dm verify "[arr oh sea]"

	info log "SET2 TEST DONE"
