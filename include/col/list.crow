no-std
import
	..bool: ?, bool
	..compare: ==, !=, >
	..exception: assert, forbid
	..fun: subscript
	..misc: ->, as, drop, void
	..number: +, -, nat
	..opt: empty?, none, opt, some, value
	..ptr: +, -, ptr, ptr-eq?, set-subscript, subscript
	..str: char, str
	..str-conv: to-str
	..test: is
	.arr: arr, begin-ptr, end-ptr, empty?, size
	.arr-util: each, each-with-index, first, first-some, fold, last, rtail
	.mut-arr:
		begin-ptr, cast-immutable, copy-from!, end-ptr, mut-arr, mut-arr-from-begin-end,
		set-subscript, size, subscript, uninitialized-mut-arr
	.mut-list: ~=, move-to-arr!, mut-list, set-last

###
Immutable list type.
Appending a value with `~` is amortized O(1).
Popping a value with `rtail` and `last` is always O(1).
###
list<?a> record
	# TODO:PRIVATE
	ignore void
	prev opt list ?a
	values arr ?a

# Empty list.
list list ?a()
	list: []

###
Convert an arr to a list.
This is O(1).
###
list list ?a(a arr ?a)
	list: void, none, a

###
Copy a list to an arr.
This is O(n).
###
arr arr ?a(a list ?a) trusted
	res = a.size uninitialized-mut-arr<?a>
	res.end-ptr write-out! a
	res cast-immutable

###
Append a value to the list.
This is amortized O(1).
This is because about every 2 steps it allocates an array of size 2,
every 4 steps it allocates an array of size 4, etc.
###
~ list ?a(a list ?a, value ?a) trusted
	res = a push-recur 1
	res.values[res.values.size - 1] := value
	list: void, res.prev-list, res.values.cast-immutable

.list-builder<?a> record mut
	prev-list opt list ?a
	values mut-arr ?a

.push-recur list-builder ?a(a list ?a, size-right nat) unsafe
	if a.values.size > size-right
		list-builder: a.some, size-right.uninitialized-mut-arr
	else
		new-size-right = size-right + a.values.size
		res = match a prev
		as none
			list-builder<?a>: none, new-size-right.uninitialized-mut-arr
		as some s
			s.value push-recur new-size-right
		offset = res.values.size - size-right - a.values.size
		res.values[offset -> offset + a.values.size] copy-from! a.values
		res

# True iff the list is empty.
empty? bool(a list ?a)
	res = a.values empty?
	if res
		assert: a.prev empty?
	res

###
Oldest appended value.
This is O(a.size ln)
###
first opt ?a(a list ?a)
	match a.prev
	as none
		a.values first
	as some s
		s.value first

###
Most recently appended value.
This is O(1).
###
last opt ?a(a list ?a)
	a.values last

###
All but the last value.
This is O(1).
Throws if the list is empty.
###
rtail list ?a(a list ?a)
	forbid: a.values.size == 0
	if a.values.size == 1
		match a prev
		as none
			list
		as some s
			s value
	else
		list: void, a.prev, a.values.rtail
		
###
Number of elements in the list.
This is O(ln a.size).
###
size nat(a list ?a)
	a.values.size size-recur a.prev
.size-recur nat(acc nat, a opt list ?a)
	match a
	as none
		acc
	as some s
		acc + s.value.size size-recur s.value.prev

###
Concatenate an array to a list.
This is O(1).
###
~ list ?a(a list ?a, b arr ?a)
	list: void, (a.empty? ? none, a.some), b

###
Concatenate two lists.
This is O(n).
###
~ list ?a(a list ?a, b list ?a) trusted
	a-size = a size
	res = a-size + b.size uninitialized-mut-arr<?a>
	res.end-ptr write-out! b
	res.begin-ptr + a-size write-out! a
	list: res.cast-immutable

.write-out! void(end ptr ?a, a list ?a) unsafe
	new-end = end - a.values.size
	new-end mut-arr-from-begin-end end copy-from! a.values
	match a.prev
	as none
		void
	as some s
		new-end write-out! s.value

region iteration

# Call a function for each element in the list.
each void(a list ?a, f act void(?a))
	match a.prev
	as none
		void
	as some s
		s.value each f
	a.values each f

# Call a function for each element in the list and accumulate.
fold ?a(acc ?a, a list ?b, f act ?a(?a, ?b))
	v = match a.prev
	as none
		acc
	as some s
		acc fold s.value, f
	v fold a.values, f

# Produce a list with `f[x]` applied to each element `x` in the input.
map list ?out(a list ?in, f act ?out(?in)) trusted
	res = a.size uninitialized-mut-arr<?out>
	drop: res.begin-ptr map-recur a, f
	list: res.cast-immutable
.map-recur ptr ?out(out ptr ?out, a list ?in, f act ?out(?in)) unsafe
	next-out = match a prev
	as none
		out
	as some s
		out map-recur s.value, f
	a.values each-with-index \value, index
		next-out[index] := f[value]
	next-out + a.values.size

filter list ?a(a list ?a, f act bool(?a)) trusted
	res = a.size uninitialized-mut-arr<?a>
	end = res.begin-ptr filter-recur a, f
	list: res[0 -> end - res.begin-ptr] cast-immutable
.filter-recur ptr ?a(out ptr ?a, a list ?a, f act bool(?a)) unsafe
	new-out = match a prev
	as none
		out
	as some s
		out filter-recur s.value, f
	new-out filter-recur-arr a.values.begin-ptr, a.values.end-ptr, f
.filter-recur-arr ptr ?a(out ptr ?a, cur ptr ?a, end ptr ?a, f act bool(?a)) unsafe
	if cur ptr-eq? end
		out
	else
		new-out = if f[cur[]]
			out[] := cur[]
			out + 1
		else
			out
		new-out filter-recur-arr cur + 1, end, f

first-some opt ?out(a list ?in, f act opt ?out(?in))
	before = as<opt ?out>: match a prev
	as none
		none
	as some s
		s.value first-some f

	match before
	as none
		a.values first-some f
	as some s
		s

.dbg str(a list nat)
	res = mut-list<char>
	res dbg-recur! a
	res move-to-arr!
.dbg-recur! void(out mut-list char, a list nat)
	match a prev
	as none
		void
	as some s
		out dbg-recur! s.value
		out ~= " "
	out ~= "["
	if a.values empty?
		out ~= "]"
	else
		a.values each \x
			out ~= x to-str
			out ~= " "
		out.last := "]"

test
	a = list<nat>
	assert: a empty?
	a.arr is []
	a.dbg is "[]"
	a.last is none

	b = a ~ 1
	b.dbg is "[1]"
	b.last is 1.some
	b.rtail.arr is []
	forbid: b empty?

	c = b ~ 2
	c.dbg is "[1 2]"
	c.last is 2.some
	c.rtail.arr is [1]

	d = c ~ 3
	d.dbg is "[1 2] [3]"
	d.last is 3.some
	d.rtail.arr is [1, 2]

	e = d ~ 4
	e.dbg is "[1 2 3 4]"
	e.last is 4.some
	e.rtail.arr is d.arr
	e.size is 4

	e56 = e ~ [5, 6]
	e56.dbg is "[1 2 3 4] [5 6]"
	(c ~ d).dbg is "[1 2 1 2 3]"

	e2 = e map {it + 10}
	e2.dbg is "[11 12 13 14]"

	e3 = e filter {it != 2}
	e3.dbg is "[1 3 4]"

	folded = 5 fold e, \x, y
		x + y
	folded is 15

	# TODO: compiler crashes without a type argument here
	(e first-some<str, nat> {it == 3 ? "three".some, none}) is "three".some
	(e first-some<str, nat> {it == 5 ? "five".some, none}) is none
