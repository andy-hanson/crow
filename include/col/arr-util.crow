no-std
import
	..private.alloc: alloc-uninitialized, fill-ptr-range
	..private.bootstrap: noctx-incr
	..bool: and, bool, false, not, or, to-nat, true
	..compare: ==, !=, <, <=, >=, max, min
	..exception: assert, forbid
	..fun: subscript
	..misc: ->, data, void
	..number: +, -, nat
	..opt: has?, none, opt, some, value
	..ptr: +, -, deep-size-bytes, ptr, ptr-eq?, set-subscript, size-of, subscript
	..test: is
	.arr: ~, arr, arr-from-begin-end, begin-ptr, empty?, end-ptr, noctx-at, size, subscript

alloc-count nat(a arr ?a) unsafe
	if a empty?
		0
	else
		1

###
Number of bytes that does not go into storing the values.
For an 'arr' this is a constant 16 bytes.
###
overhead-bytes nat(a arr ?a) unsafe
	a size-of

deep-size-bytes nat(a arr ?a) unsafe deep-size-bytes<?a>
	a.overhead-bytes fold a, \acc, x
		acc + x.deep-size-bytes

###
Equivalent to `[f[0], f[1], ..., f[size - 1]]`.
Arr containing the result of `f` for each number 0 to size (exclusive).
###
make-arr arr ?a(size nat, f act ?a(nat)) trusted
	res = size alloc-uninitialized<?a>
	res fill-ptr-range size, f
	arr: size, res

###
Equivalent to `[value, value, ...]`.
Arr with the given `size` where every element is `value`.
###
fill-arr arr ?a(size nat, value ?a)
	size make-arr \ignore
		value

###
Equivalent to calling `f[a[0]]`, `f[a[1]]`, etc., in turn.
Calls `f` for each element in `a`.
###
each void(a arr ?a, f act void(?a)) trusted
	a.begin-ptr each-recur a.end-ptr, f
.each-recur void(cur ptr ?a, end ptr ?a, f act void(?a)) unsafe
	if cur ptr-eq? end not
		f[cur[]]
		cur + 1 each-recur end, f

###
Equivalent to calling `f[a[0], 0]`, `f[a[1], 1]`, etc., in turn.
Calls `f` for each element in `a`, also providing the index.
###
each-with-index void(a arr ?a, f act void(?a, nat))
	a each-with-index-recur f, 0
.each-with-index-recur void(a arr ?a, f act void(?a, nat), n nat)
	if n != a.size
		f[a[n], n]
		a each-with-index-recur f, n + 1

each-ptr void(a arr ?a, f act void(ptr ?a)) unsafe
	a.begin-ptr each-ptr-recur a.end-ptr, f
each-ptr-recur void(cur ptr ?a, end ptr ?a, f act void(ptr ?a)) unsafe
	if cur ptr-eq? end not
		f[cur]
		cur + 1 each-ptr-recur end, f

###
Arr of the elements of `a` for which `f[a[i]]` returns true.
###
filter arr ?a(a arr ?a, f act bool(?a))
	a filter-with-index \cur, index
		f[cur]

filter-with-index arr ?a(a arr ?a, f act bool(?a, nat)) trusted
	res = a.size alloc-uninitialized<?a>
	end = res filter-with-index-recur a.begin-ptr, a.end-ptr, 0, f
	res arr-from-begin-end end
.filter-with-index-recur ptr ?a(out ptr ?a, cur ptr ?a, end ptr ?a, index nat, f act bool(?a, nat)) unsafe
	if cur ptr-eq? end
		out
	else
		new-out = if f[cur[], index]
			out[] := cur[]
			out + 1
		else
			out
		new-out filter-with-index-recur cur + 1, end, index + 1, f

###
Like 'filter', but keeps everything after the first time `f` returns true.
###
strip-left-while arr ?a(a arr ?a, f act bool(?a))
	if a.empty? or f[a[0]].not
		a
	else
		a.tail strip-left-while f
test
	[3, 2, 1] strip-left-while {it < 3} is [3, 2, 1]
	[1, 3, 5, 3, 1] strip-left-while {it < 5} is [5, 3, 1]

# TODO: move to iter-utiil since this works with any foldable
count nat(a arr ?a, f act bool(?a))
	0 fold a, \cur, x
		cur + f[x].to-nat

###
Equivalent to `[f[a[0]], f[a[1]], ...]`.
Arr of `f[x]` for each `x` in `a`.
###
map arr ?out(a arr ?in, f act ?out(?in))
	a.size make-arr \i
		f[a[i]]

map-with-index arr ?out(a arr ?in, f act ?out(?in, nat))
	a.size make-arr \i
		f[a[i], i]

first opt ?a(a arr ?a)
	if a empty?
		none
	else
		a[0] some

last opt ?a(a arr ?a)
	if a empty?
		none
	else
		a[a.size - 1] some

###
All but the first element of an arr.
Throws if `a empty?`.
###
tail arr ?a(a arr ?a)
	forbid: a empty?
	a[1 -> a.size]

###
All but the last element of an arr.
Throws if `a empty?`.
###
rtail arr ?a(a arr ?a)
	forbid: a empty?
	a[0 -> a.size - 1]

###
Calls `f` on each element of `a` and returns the first result that is `some`.
Returns `none` if every call to `f` returned `none`.
###
first-some opt ?out(a arr ?in, f act opt ?out(?in))
	if a empty?
		none
	else
		match f[a[0]]
		as none
			a.tail first-some f
		as some s
			s

###
Equivalent to `f[a[0]] or f[a[1]] or or ...`
Calls `f` on each element of `a` and returns `true` the first time `f` does.
###
exists? bool(a arr ?a, f act bool(?a))
	if a empty?
		false
	elif f[a[0]]
		true
	else
		a.tail exists? f

every? bool(a arr ?a, f act bool(?a))
	if a empty?
		true
	elif f[a[0]]
		a.tail every? f
	else
		false

# TODO: only written this way to be `noctx`, else could defer to `exists?`
###
Equivalent to `a exists? {it == value}`.
Also equivalent to `a[0] == value or a[1] == value or ...`.
###
contains? bool(a arr ?a, value ?a) noctx data<?a>
	a contains-recur? value, 0
.contains-recur? bool(a arr ?a, value ?a, i nat) noctx trusted data<?a>
	if i == a.size
		false
	elif (a noctx-at i) == value
		true
	else
		a contains-recur? value, i.noctx-incr

try-remove opt arr ?a(a arr ?a, value ?a) data<?a>
	a try-remove-recur 0, value
.try-remove-recur opt arr ?a(a arr ?a, index nat, value ?a) data<?a>
	if index == a.size
		none
	elif a[index] == value
		a remove-index index some
	else
		a try-remove-recur index + 1, value

remove-index arr ?a(a arr ?a, index nat)
	assert: index < a.size
	a[0 -> index] ~ a[index + 1 -> a.size]

# TODO: data<arr ?a> should be unnecessary
###
True iff the sub-sequence appears in `a`.
Equivalent to `a[0 -> subseq.size] == subseq or a[1 -> 1 + subseq.size] == subseq or ...`
###
contains-subseq? bool(a arr ?a, subseq arr ?a) data<?a> data<arr ?a>
	a index-of-subseq subseq has?

# TODO: data<arr ?a> should be unnecessary
# True iff the first elements of `a` are `start`, meaning `a[0 -> start.size] == start`.
starts-with? bool(a arr ?a, start arr ?a) data<?a> data<arr ?a>
	a.size >= start.size and: a[0 -> start.size] == start

# TODO: data<arr ?a> should be unnecessary
# True iff the last elements of `a` are `end`, meaning `a[a.size - end.size -> a.size] == end`.
ends-with? bool(a arr ?a, end arr ?a) data<?a> data<arr ?a>
	a.size >= end.size and: a[a.size - end.size -> a.size] == end

# TODO: data<arr ?a> should be unnecessary
# If `a` starts with `start`, returns the remaining elements, else returns `none`.
try-remove-start opt arr ?a(a arr ?a, start arr ?a) data<?a> data<arr ?a>
	if a starts-with? start
		a[start.size -> a.size] some
	else
		none

# TODO: data<arr ?a> should be unnecessary
# If `a` ends with `end`, returns the preceding elements, else returns `none`.
try-remove-end opt arr ?a(a arr ?a, end arr ?a) data<?a> data<arr ?a>
	if a ends-with? end
		a[0 -> a.size - end.size] some
	else
		none

###
This is like `each` but with a state variable that gets transformed by each call to `f`.
For example, for a 2-element array, this is equivalent to `f[f[val, a[0]], a[1]]`.
###
fold ?a(acc ?a, a arr ?b, f act ?a(?a, ?b)) trusted
	acc fold-recur a.begin-ptr, a.end-ptr, f
.fold-recur ?a(acc ?a, cur ptr ?b, end ptr ?b, f act ?a(?a, ?b)) unsafe
	if cur ptr-eq? end
		acc
	else
		f[acc, cur[]] fold-recur cur + 1, end, f

fold-with-index ?a(acc ?a, a arr ?b, f act ?a(?a, ?b, nat)) trusted
	acc fold-with-index-recur 0, a.begin-ptr, a.end-ptr, f
.fold-with-index-recur ?a(acc ?a, index nat, cur ptr ?b, end ptr ?b, f act ?a(?a, ?b, nat)) unsafe
	if cur ptr-eq? end
		acc
	else
		f[acc, cur[], index] fold-with-index-recur index + 1, cur + 1, end, f

fold-reverse ?a(acc ?a, a arr ?b, f act ?a(?a, ?b)) trusted
	acc fold-reverse-recur a.begin-ptr, a.end-ptr, f
.fold-reverse-recur ?a(acc ?a, begin ptr ?b, cur ptr ?b, f act ?a(?a, ?b)) unsafe
	if cur ptr-eq? begin
		acc
	else
		prev = cur - 1
		f[acc, prev[]] fold-reverse-recur begin, prev, f

# TODO: data<arr ?a> should be unnecessary
# Finds the first index where `a[i -> i + subseq.size] == subseq`.
index-of-subseq opt nat(a arr ?a, subseq arr ?a) data<?a> data<arr ?a>
	a index-of-subseq-recur subseq, 0

# TODO: data<arr ?a> should be unnecessary
.index-of-subseq-recur opt nat(a arr ?a, subseq arr ?a, i nat) data<?a> data<arr ?a>
	if i == a.size
		none
	elif a[i -> a.size] starts-with? subseq
		i some
	else
		a index-of-subseq-recur subseq, i + 1

###
Equivalent to `f[a[0]] ? 0.some, f[a[1]] ? 1.some, ...`.
Returns the first index for which `f[a[i]]` is true, or returns `none`.
###
find-index opt nat(a arr ?a, f act bool(?a))
	a find-index-recur 0, f
.find-index-recur opt nat(a arr ?a, index nat, f act bool(?a))
	if index == a.size
		none
	elif f[a[index]]
		index some
	else
		a find-index-recur index + 1, f

###
Like `find-index`, but starts from the end.
Equivalent to `f[a[a.size - 1]] ? (a.size - 1 some), f[a[a.size - 2]] ? (a.size - 2 some), ...`.
###
find-rindex opt nat(a arr ?a, f act bool(?a))
	if a empty?
		none
	else
		a find-rindex-recur a.size - 1, f
.find-rindex-recur opt nat(a arr ?a, index nat, f act bool(?a))
	if f[a[index]]
		index some
	elif index == 0
		none
	else
		a find-rindex-recur index - 1, f

###
Returns the first index where `a[i] == value`.
Equivalent to `a find-index {it == value}`.
###
index-of opt nat(a arr ?a, value ?a) trusted data<?a>
	match a ptr-of value
	as none
		none
	as some s
		s.value - a.begin-ptr some

# Like `index-of` but returns a ptr.
ptr-of opt ptr ?a(a arr ?a, value ?a) unsafe data<?a>
	a.begin-ptr ptr-of-recur a.end-ptr, value

.ptr-of-recur opt ptr ?a(cur ptr ?a, end ptr ?a, value ?a) unsafe data<?a>
	if cur ptr-eq? end
		none
	elif cur[] == value
		cur some
	else
		cur + 1 ptr-of-recur end, value

###
Returns the last index where `a[i] == value`.
Equivalent to `a find-rindex {it == value}`.
###
r-index-of opt nat(a arr ?a, value ?a) data<?a>
	a find-rindex {it == value}

###
Concatenates many arrays into a single array.
Equivalent to `a[0] ~ a[1] ~ ...`.
###
flatten arr ?a(a arr arr ?a)
	a flatten []

###
Concatenates many arrays into a single array, with `joiner` in between.
Equivalent to `a[0] ~ joiner ~ a[1] ~ joiner ~ ... ~ a[a.size - 1]`.
###
flatten arr ?a(a arr arr ?a, joiner arr ?a)
	if a empty?
		[]
	elif a.size == 1
		a[0]
	else
		a[0] ~ joiner ~: a.tail flatten joiner

# TODO: data<arr ?a> should be unnecessary
###
Splits `a` each time it finds `splitter`.
For example, "a rose is a hose is a nose" split-by-subseq "is" would be
["a rose ", " a hose ", " a nose"].
###
split-by-subseq arr arr ?a(a arr ?a, splitter arr ?a) data<?a> data<arr ?a> trusted
	size = (a count-subseqs splitter) + 1
	res = size alloc-uninitialized<arr ?a>
	res split-by-subseq-recur a, splitter
	arr: size, res
# TODO: data<arr ?a> should be unnecessary
.split-by-subseq-recur void(out ptr arr ?a, a arr ?a, splitter arr ?a) data<?a> data<arr ?a> unsafe
	match a index-of-subseq splitter
	as none
		out[] := a
	as some s
		out[] := a[0 -> s.value]
		rest = a[s.value + splitter.size -> a.size]
		out + 1 split-by-subseq-recur rest, splitter

# TODO: data<arr ?a> should be unnecessary
# Returns the number of indices for which `a[i -> i + subseq.size] == subseq`.
count-subseqs nat(a arr ?a, subseq arr ?a) data<?a> data<arr ?a>
	a count-subseqs-recur subseq, 0
# TODO: data<arr ?a> should be unnecessary
.count-subseqs-recur nat(a arr ?a, subseq arr ?a, acc nat) data<?a> data<arr ?a>
	match a index-of-subseq subseq
	as none
		acc
	as some s
		rest = a[s.value + subseq.size -> a.size]
		rest count-subseqs-recur subseq, acc + 1

###
Arr containing the result of `f` for corresponding elements of `a` and `b`.
Equivalent to `[f[a[0], b[0]], f[a[1], b[1]], ...]`.
Throws if the arrs have different sizes.
###
zip arr ?out(a arr ?a, b arr ?b, f act ?out(?a, ?b))
	assert: a.size == b.size
	a.size make-arr \i
		f[a[i], b[i]]

###
Like `zip`, but instead of throwing on different sizes,
cuts the larger array down to the smaller one's size.
###
zip-smaller arr ?out(a arr ?a, b arr ?b, f act ?out(?a, ?b))
	size = a.size min b.size
	a[0 -> size] zip b[0 -> size], f


###
Returns an array as big as the bigger of 'a' and 'b'.
Calls 'f' using corresponding elements, or 'none' if the arr is too short.
###
zip-larger arr ?out(a arr ?a, b arr ?b, f act ?out(opt ?a, opt ?b))
	a.size max b.size make-arr \i
		f[(a opt-subscript i), (b opt-subscript i)]

.opt-subscript opt ?a(a arr ?a, index nat)
	if index < a.size
		a[index] some
	else
		none

# TODO: update-at
update arr ?a(a arr ?a, index nat, new-value ?a)
	assert: index < a.size
	a[0 -> index] ~ [new-value] ~ a[index + 1 -> a.size]

update-with-default arr ?a(a arr ?a, index nat, new-value ?a, default ?a)
	if index < a.size
		a update index, new-value
	else
		index + 1 make-arr \i
			if i < a.size
				a[i]
			elif i == index
				new-value
			else
				default

# TODO: insert-at
insert arr ?a(a arr ?a, index nat, value ?a)
	assert: index <= a.size
	# TODO:PERF (only concat once)
	a[0 -> index] ~ [value] ~ a[index -> a.size]

insert arr ?a(a arr ?a, ptr ptr ?a, value ?a) unsafe
	a insert ptr - a.begin-ptr, value

remove-at arr ?a(a arr ?a, index nat)
	assert: index < a.size
	a[0 -> index] ~ a[index + 1 -> a.size]

with-max-size arr ?a(a arr ?a, max-size nat)
	if a.size <= max-size
		a
	else
		a[0 -> max-size]

pad-left arr ?a(pad ?a, a arr ?a, min-size nat)
	if a.size < min-size
		diff = min-size - a.size
		min-size make-arr \index
			if index < diff
				pad
			else
				a[index - diff]
	else
		a
