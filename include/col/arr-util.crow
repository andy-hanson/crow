no-std
import
	..private.alloc: alloc-uninitialized, fill-ptr-range
	..private.bootstrap: noctx-incr
	..bool: and, bool, false, not, true
	..compare: ==, !=, <, <=, >=
	..exception: assert, forbid
	..fun: subscript
	..misc: ->, data, void
	..number: +, -, nat
	..opt: has?, none, opt, some, value
	..ptr: +, ptr, ptr-eq?, set-subscript, subscript
	.arr: ~, arr, arr-from-begin-end, begin-ptr, empty?, end-ptr, noctx-at, size, subscript

###
Equivalent to `[f[0], f[1], ..., f[size - 1]]`.
Arr containing the result of `f` for each number 0 to size (exclusive).
###
make-arr arr ?a(size nat, f act ?a(nat)) trusted
	res = size alloc-uninitialized<?a>
	res fill-ptr-range size, f
	arr: size, res

###
Equivalent to `[value, value, ...]`.
Arr with the given `size` where every element is `value`.
###
fill-arr arr ?a(size nat, value ?a)
	size make-arr \ignore
		value

###
Equivalent to calling `f[a[0]]`, `f[a[1]]`, etc., in turn.
Calls `f` for each element in `a`.
###
each void(a arr ?a, f act void(?a)) trusted
	a.begin-ptr each-recur a.end-ptr, f
.each-recur void(cur ptr ?a, end ptr ?a, f act void(?a)) unsafe
	if cur ptr-eq? end not
		f[cur[]]
		cur + 1 each-recur end, f

###
Equivalent to calling `f[a[0], 0]`, `f[a[1], 1]`, etc., in turn.
Calls `f` for each element in `a`, also providing the index.
###
each-with-index void(a arr ?a, f act void(?a, nat))
	a each-with-index-recur f, 0
.each-with-index-recur void(a arr ?a, f act void(?a, nat), n nat)
	if n != a.size
		f[a[n], n]
		a each-with-index-recur f, n + 1

###
Arr of the elements of `a` for which `f[a[i]]` returns true.
###
filter arr ?a(a arr ?a, f act bool(?a)) trusted
	res = a.size alloc-uninitialized<?a>
	end = res filter-recur a, f
	res arr-from-begin-end end
.filter-recur ptr ?a(out ptr ?a, a arr ?a, f act bool(?a)) unsafe
	if a empty?
		out
	else
		next-out = if f[a[0]]
			out[] := a[0]
			out + 1
		else
			out
		next-out filter-recur a.tail, f

###
Equivalent to `[f[a[0]], f[a[1]], ...]`.
Arr of `f[x]` for each `x` in `a`.
###
map arr ?out(a arr ?in, f act ?out(?in)) trusted
	a.size make-arr \i
		f[a[i]]

# `a[0]`
first ?a(a arr ?a)
	a[0]

# Last element of an arr.
last ?a(a arr ?a)
	forbid: a empty?
	a[a.size - 1]

###
All but the first element of an arr.
Fails if `a empty?`.
###
tail arr ?a(a arr ?a)
	forbid: a empty?
	a[1 -> a.size]

###
All but the last element of an arr.
Fails if `a empty?`.
###
rtail arr ?a(a arr ?a)
	forbid: a empty?
	a[0 -> a.size - 1]

###
Calls `f` on each element of `a` and returns the first result that is `some`.
Returns `none` if every call to `f` returned `none`.
###
first-some opt ?out(a arr ?in, f act opt ?out(?in))
	if a empty?
		none
	else
		match f[a[0]]
		as none
			a.tail first-some f
		as some s
			s

###
Equivalent to `f[a[0]] or f[a[1]] or or ...`
Calls `f` on each element of `a` and returns `true` the first time `f` does.
###
exists? bool(a arr ?a, f act bool(?a))
	if a empty?
		false
	elif f[a[0]]
		true
	else
		a.tail exists? f

# TODO: only written this way to be `noctx`, else could defer to `some?`
###
Equivalent to `a exists? {it == value}`.
Also equivalent to `a[0] == value or a[1] == value or ...`.
###
contains? bool(a arr ?a, value ?a) noctx data<?a>
	a contains-recur? value, 0
.contains-recur? bool(a arr ?a, value ?a, i nat) noctx trusted data<?a>
	if i == a.size
		false
	elif (a noctx-at i) == value
		true
	else
		a contains-recur? value, i.noctx-incr

try-remove opt arr ?a(a arr ?a, value ?a) data<?a>
	a try-remove-recur 0, value
.try-remove-recur opt arr ?a(a arr ?a, index nat, value ?a) data<?a>
	if index == a.size
		none
	elif a[index] == value
		a remove-index index some
	else
		a try-remove-recur index + 1, value

remove-index arr ?a(a arr ?a, index nat)
	assert: index < a.size
	a[0 -> index] ~ a[index + 1 -> a.size]

# TODO: data<arr ?a> should be unnecessary
###
True iff the sub-sequence appears in `a`.
Equivalent to `a[0 -> subseq.size] == subseq or a[1 -> 1 + subseq.size] == subseq or ...`
###
contains-subseq? bool(a arr ?a, subseq arr ?a) data<?a> data<arr ?a>
	a index-of-subseq subseq has?

# TODO: data<arr ?a> should be unnecessary
# True iff the first elements of `a` are `start`, meaning `a[0 -> start.size] == start`.
starts-with? bool(a arr ?a, start arr ?a) data<?a> data<arr ?a>
	a.size >= start.size and: a[0 -> start.size] == start

# TODO: data<arr ?a> should be unnecessary
# True iff the last elements of `a` are `end`, meaning `a[a.size - end.size -> a.size] == end`.
ends-with? bool(a arr ?a, end arr ?a) data<?a> data<arr ?a>
	a.size >= end.size and: a[a.size - end.size -> a.size] == end

# TODO: data<arr ?a> should be unnecessary
# If `a` starts with `start`, returns the remaining elements, else returns `none`.
try-remove-start opt arr ?a(a arr ?a, start arr ?a) data<?a> data<arr ?a>
	if a starts-with? start
		a[start.size -> a.size] some
	else
		none

# TODO: data<arr ?a> should be unnecessary
# If `a` ends with `end`, returns the preceding elements, else returns `none`.
try-remove-end opt arr ?a(a arr ?a, end arr ?a) data<?a> data<arr ?a>
	if a ends-with? end
		a[0 -> a.size - end.size] some
	else
		none

###
This is like `each` but with a state variable that gets transformed by each call to `f`.
For example, for a 2-element array, this is equivalent to `f[f[val, a[0]], a[1]]`.
###
fold ?a(acc ?a, a arr ?b, f act ?a(?a, ?b)) trusted
	acc fold-recur a.begin-ptr, a.end-ptr, f
.fold-recur ?a(acc ?a, cur ptr ?b, end ptr ?b, f act ?a(?a, ?b)) unsafe
	if cur ptr-eq? end
		acc
	else
		f[acc, cur[]] fold-recur cur + 1, end, f

# TODO: data<arr ?a> should be unnecessary
# Finds the first index where `a[i -> i + subseq.size] == subseq`.
index-of-subseq opt nat(a arr ?a, subseq arr ?a) data<?a> data<arr ?a>
	a index-of-subseq-recur subseq, 0

# TODO: data<arr ?a> should be unnecessary
.index-of-subseq-recur opt nat(a arr ?a, subseq arr ?a, i nat) data<?a> data<arr ?a>
	if i == a.size
		none
	elif a[i -> a.size] starts-with? subseq
		i some
	else
		a index-of-subseq-recur subseq, i + 1

###
Equivalent to `f[a[0]] ? 0.some, f[a[1]] ? 1.some, ...`.
Returns the first index for which `f[a[i]]` is true, or returns `none`.
###
find-index opt nat(a arr ?a, f act bool(?a))
	a find-index-recur 0, f
.find-index-recur opt nat(a arr ?a, index nat, f act bool(?a))
	if index == a.size
		none
	elif f[a[index]]
		index some
	else
		a find-index-recur index + 1, f

###
Like `find-index`, but starts from the end.
Equivalent to `f[a[a.size - 1]] ? (a.size - 1 some), f[a[a.size - 2]] ? (a.size - 2 some), ...`.
###
find-rindex opt nat(a arr ?a, f act bool(?a))
	if a empty?
		none
	else
		a find-rindex-recur a.size - 1, f
.find-rindex-recur opt nat(a arr ?a, index nat, f act bool(?a))
	if f[a[index]]
		index some
	elif index == 0
		none
	else
		a find-rindex-recur index - 1, f

###
Returns the first index where `a[i] == value`.
Equivalent to `a find-index {it == value}`.
###
index-of opt nat(a arr ?a, value ?a) data<?a>
	a find-index {it == value}

###
Returns the last index where `a[i] == value`.
Equivalent to `a find-rindex {it == value}`.
###
r-index-of opt nat(a arr ?a, value ?a) data<?a>
	a find-rindex {it == value}

###
Concatenates many arrays into a single array.
Equivalent to `a[0] ~ a[1] ~ ...`.
###
flatten arr ?a(a arr arr ?a)
	a flatten []

###
Concatenates many arrays into a single array, with `joiner` in between.
Equivalent to `a[0] ~ joiner ~ a[1] ~ joiner ~ ... ~ a[a.size - 1]`.
###
flatten arr ?a(a arr arr ?a, joiner arr ?a)
	if a empty?
		[]
	elif a.size == 1
		a[0]
	else
		a[0] ~ joiner ~: a.tail flatten joiner

# TODO: data<arr ?a> should be unnecessary
###
Splits `a` each time it finds `splitter`.
For example, "a rose is a hose is a nose" split-by-subseq "is" would be
["a rose ", " a hose ", " a nose"].
###
split-by-subseq arr arr ?a(a arr ?a, splitter arr ?a) data<?a> data<arr ?a> trusted
	size = (a count-subseqs splitter) + 1
	res = size alloc-uninitialized<arr ?a>
	res split-by-subseq-recur a, splitter
	arr: size, res
# TODO: data<arr ?a> should be unnecessary
.split-by-subseq-recur void(out ptr arr ?a, a arr ?a, splitter arr ?a) data<?a> data<arr ?a> unsafe
	match a index-of-subseq splitter
	as none
		out[] := a
	as some s
		out[] := a[0 -> s.value]
		rest = a[s.value + splitter.size -> a.size]
		out + 1 split-by-subseq-recur rest, splitter

# TODO: data<arr ?a> should be unnecessary
# Returns the number of indices for which `a[i -> i + subseq.size] == subseq`.
count-subseqs nat(a arr ?a, subseq arr ?a) data<?a> data<arr ?a>
	a count-subseqs-recur subseq, 0
# TODO: data<arr ?a> should be unnecessary
.count-subseqs-recur nat(a arr ?a, subseq arr ?a, acc nat) data<?a> data<arr ?a>
	match a index-of-subseq subseq
	as none
		acc
	as some s
		rest = a[s.value + subseq.size -> a.size]
		rest count-subseqs-recur subseq, acc + 1

###
Arr containing the result of `f` for corresponding elements of `a` and `b`.
Equivalent to `[f[a[0], b[0]], f[a[1], b[1]], ...]`.
Fails if the arrs have different sizes.
###
zip arr ?out(a arr ?a, b arr ?b, f act ?out(?a, ?b))
	assert: a.size == b.size
	a.size make-arr \i
		f[a[i], b[i]]

insert arr ?a(a arr ?a, index nat, value ?a)
	assert: index <= a.size
	# TODO:PERF (only concat once)
	a[0 -> index] ~ [value] ~ a[index -> a.size]
