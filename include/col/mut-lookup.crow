no-std
import
	..bool: and, bool, not, or
	..compare: ==, >, >=
	..exception: assert, forbid
	..fun: subscript
	..hash: hash, hash-mix
	..misc: ->, arrow, as, data, drop, from, to, void
	..number: nat
	..opt: none, opt, some, value
	..ptr: +, ptr, ptr-eq?, set-subscript, subscript
	..str: char, str
	..str-conv: finish, interp, to-str, with-str, with-value
	..test: is
	..private.number-low-level: unsafe-mod, wrap-add, wrap-mul, wrap-sub
	.arr: arr, size
	.arr-util: each
	.mut-arr:
		begin-ptr, cast-immutable, each, empty?, end-ptr, fill!, fill-mut-arr, fold, map, mut-arr,
		set-subscript, size, subscript, uninitialized-mut-arr
	.mut-list:
		~=, at-capacity?, copy, each, empty?, filter!, find-index, fold, map!, move-to-arr!, mut-list,
		pop-n!, remove-unordered-at!, set-subscript, size, subscript

mut-lookup<?k, ?v> record mut
	# TODO:PRIVATE
	ignore void
	entries mut mut-arr entry<?k, ?v>
	total-size mut nat

.entry<?k, ?v> union mut
	none
	arrow<?k, ?v>
	mut-list<arrow<?k, ?v>>

mut-lookup mut-lookup<?k, ?v>() data<?k> hash-mix<?k>
	mut-lookup: void, mut-arr, 0

mut-lookup mut-lookup<?k, ?v>(a arr arrow<?k, ?v>) data<?k> hash-mix<?k>
	res = a.size mut-lookup-with-capacity<?k, ?v>
	a each \pair
		res[pair from] := pair to
	res

###
New dict with `capacity` empty entries.
WARN: Due to hash conflicts, this doesn't guarantee that allocations won't be needed.
###
mut-lookup-with-capacity mut-lookup<?k, ?v>(capacity nat) data<?k> hash-mix<?k>
	mut-lookup: void, (capacity fill-mut-arr none), 0

arr-unordered arr arrow<?k, ?v>(a mut-lookup<?k, ?v>) data<?k> hash-mix<?k>
	a map-to-arr-unordered \key, value
		key -> value

copy mut-lookup<?k, ?v>(a mut-lookup<?k, ?v>) data<?k> hash-mix<?k>
	entries = a.entries map \entry
		match entry
		as none
			none as<entry<?k, ?v>>
		as arrow ar
			ar
		as mut-list m
			m copy
	mut-lookup: void, entries, a.total-size
test
	a = mut-lookup<nat, str>: [1 -> "1", 2 -> "2", 5 -> "5"]
	a verify "_ (1 -> 1) [2 -> 2, 5 -> 5]"

	b = a copy
	b verify "_ (1 -> 1) [2 -> 2, 5 -> 5]"

	a[6] := "6"
	a verify "(6 -> 6) (1 -> 1) [2 -> 2, 5 -> 5]"
	b verify "_ (1 -> 1) [2 -> 2, 5 -> 5]"

empty? bool(a mut-lookup<?k, ?v>) data<?k> hash-mix<?k>
	a.size == 0

size nat(a mut-lookup<?k, ?v>) data<?k> hash-mix<?k>
	a total-size

subscript opt ?v(a mut-lookup<?k, ?v>, key ?k) trusted data<?k> hash-mix<?k>
	if a empty?
		none
	else
		match a.entries[key.hash unsafe-mod a.entries.size]
		as none
			none
		as arrow ar
			if ar.from == key
				ar.to some
			else
				none
		as mut-list m
			match m find-index {it.from == key}
			as none
				none
			as some s
				m[s value].to some

set-subscript void(a mut-lookup<?k, ?v>, key ?k, value ?v) data<?k> hash-mix<?k>
	drop: a update! key, \ignore
		value some

clear! void(a mut-lookup<?k, ?v>) data<?k> hash-mix<?k>
	a.entries fill! none
	a.total-size := 0

swap! void(a mut-lookup<?k, ?v>, b mut-lookup<?k, ?v>) data<?k> hash-mix<?k>
	temp-entries = a.entries
	a.entries := b.entries
	b.entries := temp-entries
	temp-size = a.total-size
	a.total-size := b.total-size
	b.total-size := temp-size

remove-key! opt ?v(a mut-lookup<?k, ?v>, key ?k) data<?k> hash-mix<?k>
	a update! key, \ignore
		none

###
f: Takes the value (if it exists), returns the new value (or none to remove).
Returns the old value (if it exists).
###
.update! opt ?v(a mut-lookup<?k, ?v>, key ?k, f act opt ?v(opt ?v)) trusted data<?k> hash-mix<?k>
	if a.entries empty?
		match f[none]
		as none
			void
		as some s
			a.entries := mut-arr: [key -> s.value]
			a.total-size := 1
		none
	else
		entry-index = key.hash unsafe-mod a.entries.size
		match a.entries[entry-index]
		as none
			match f[none]
			as none
				void
			as some s
				a.entries[entry-index] := key -> s.value
				a.total-size := a.total-size wrap-add 1
			none
		as arrow ar
			if ar.from == key
				a.entries[entry-index] := match f[ar.to some]
				as none
					a.total-size := a.total-size wrap-sub 1
					none
				as some s
					key -> s.value
				ar.to some
			else
				match f[none]
				as none
					none
				as some s
					if a should-expand?
						a expand!
						a[key] := s.value
					else
						a.entries[entry-index] := mut-list: [ar, key -> s.value]
						a.total-size := a.total-size wrap-add 1
					none
		as mut-list m
			match m find-index {it.from == key}
			as none
				match f[none]
				as none
					void
				as some s
					if m.at-capacity? and a.should-expand?
						a expand!
						a[key] := s.value
					else
						m ~= key -> s.value
						a.total-size := a.total-size wrap-add 1
				none
			as some some-index
				index = some-index value
				old-value = m[index] to
				match f[old-value some]
				as none
					drop: m remove-unordered-at! index
					if m empty?
						a.entries[entry-index] := none
					elif m.size == 1
						# TODO: should not need a local
						z = m[0]
						a.entries[entry-index] := z
					a.total-size := a.total-size wrap-sub 1
				as some s
					m[index] := key -> s.value
				old-value some

~= void(a mut-lookup<?k, ?v>, b arr arrow<?k, ?v>) data<?k> hash-mix<?k>
	b each \pair
		a[pair from] := pair to

# Called when we're about to allocate a bigger bucket -- maybe we should expand the table instead
.should-expand? bool(a mut-lookup<?k, ?v>)
	a.total-size >= a.entries.size

.expand! void(a mut-lookup<?k, ?v>) data<?k> hash-mix<?k>
	forbid: a.entries.size == 0
	new-size = a.entries.size wrap-mul 2
	bigger = new-size mut-lookup-with-capacity<?k, ?v>
	a each-unordered \key, value
		bigger[key] := value
	a swap! bigger
	assert: a.entries.size == new-size

region iteration

each-unordered void(a mut-lookup<?k, ?v>, f act void(?k, ?v)) data<?k> hash-mix<?k>
	void fold-unordered a, \ignore, key, value
		f[key, value]

fold-unordered ?a(acc ?a, a mut-lookup<?k, ?v>, f act ?a(?a, ?k, ?v)) data<?k> hash-mix<?k>
	acc fold a.entries, \cur, entry
		match entry
		as none
			cur
		as arrow ar
			f[cur, ar.from, ar.to]
		as mut-list m
			cur fold m, \cur2, pair
				f[cur2, pair.from, pair.to]

filter! void(a mut-lookup<?k, ?v>, f act bool(?k, ?v)) trusted data<?k> hash-mix<?k>
	a.entries.begin-ptr filter-recur! a.entries.end-ptr, f
.filter-recur! void(entry-ptr ptr entry<?k, ?v>, entry-end ptr entry<?k, ?v>, f act bool(?k, ?v)) unsafe
	if entry-ptr ptr-eq? entry-end not
		match entry-ptr[]
		as none
			void
		as arrow ar
			if f[ar.from, ar.to] not
				entry-ptr[] := none
		as mut-list m
			m filter! {f[it.from, it.to]}
			if m empty?
				entry-ptr[] := none
			elif m.size == 1
				# TODO: should not need a local
				z = m[0]
				entry-ptr[] := z
		entry-ptr + 1 filter-recur! entry-end, f


map-to-arr-unordered arr ?out(a mut-lookup<?k, ?v>, f act ?out(?k, ?v)) trusted data<?k> hash-mix<?k>
	out = a.size uninitialized-mut-arr<?out>
	end = out.begin-ptr fold-unordered a, \cur, key, value
		cur[] := f[key, value]
		cur + 1
	assert: end ptr-eq? out.end-ptr
	out cast-immutable

map-values! void(a mut-lookup<?k, ?v>, f act ?v(?k, ?v)) trusted data<?k> hash-mix<?k>
	a.entries.begin-ptr map-values-recur! a.entries.end-ptr, f
.map-values-recur! void(entry-ptr ptr entry<?k, ?v>, entry-end ptr entry<?k, ?v>, f act ?v(?k, ?v)) unsafe
	if entry-ptr ptr-eq? entry-end not
		match entry-ptr[]
		as none
			void
		as arrow ar
			entry-ptr[] := ar.from -> f[ar.from, ar.to]
		as mut-list m
			m map! {it.from -> f[it.from, it.to]}
		entry-ptr + 1 map-values-recur! entry-end, f

.dbg str(a mut-lookup<nat, str>)
	out = mut-list<char>
	a.entries each \entry
		match entry
		as none
			out ~= "_"
		as arrow ar
			out ~= "("
			out ~= ar.from to-str
			out ~= " -> "
			out ~= ar to
			out ~= ")"
		as mut-list m
			out ~= "["
			m each \pair
				out ~= pair.from to-str
				out ~= " -> "
				out ~= pair to
				out ~= ", "
			out pop-n! 2
			out ~= "]"
		out ~= " "
	out pop-n! 1
	out move-to-arr!

.verify void(a mut-lookup<nat, str>, expected str)
	a.dbg is expected

test
	a = mut-lookup<nat, str>

	a[6] := "6"
	a[5] is none
	a[6] is "6".some
	a.size is 1
	a.arr-unordered is [6 -> "6"]

	a verify "(6 -> 6)"

	a[6] := "six"
	a verify "(6 -> six)"

	a[3] := "3"
	a verify "(6 -> six) (3 -> 3)"

	a[4] := "4"
	a verify "(4 -> 4) _ (6 -> six) (3 -> 3)"

	a[8] := "8"
	a verify "[4 -> 4, 8 -> 8] _ (6 -> six) (3 -> 3)"

	a[4] is "4".some
	a[8] is "8".some
	a[5] is none

	a.arr-unordered is [4 -> "4", 8 -> "8", 6 -> "six", 3 -> "3"]

	a[12] := "12"
	a verify "(8 -> 8) _ _ (3 -> 3) [4 -> 4, 12 -> 12] _ (6 -> six) _"

	a remove-key! 5 is none
	a remove-key! 4 is "4".some

	a verify "(8 -> 8) _ _ (3 -> 3) (12 -> 12) _ (6 -> six) _"

	a[11] := "11"
	a verify "(8 -> 8) _ _ [3 -> 3, 11 -> 11] (12 -> 12) _ (6 -> six) _"

	a filter! \key, value
		key > 10 or value == "six"
	a verify "_ _ _ (11 -> 11) (12 -> 12) _ (6 -> six) _"

	a map-values! \key, value
		"{key}-{value}"
	a verify "_ _ _ (11 -> 11-11) (12 -> 12-12) _ (6 -> 6-six) _"
