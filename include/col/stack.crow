no-std
import
	..bool: ?, bool
	..compare: ==, !=
	..exception: assert, forbid, throw
	..fun: subscript
	..misc: drop, void
	..number: +, nat
	..opt: empty?, none, opt, some, value
	..ptr: +, -, ptr-eq?, set-subscript
	..str: str
	..test: is
	..test.spy: calls, fn, spy-act
	.arr: arr
	.arr-util: fold
	.mut-arr: begin-ptr, cast-immutable, end-ptr, uninitialized-mut-arr

###
Immutable stack ype.
Appending a value with `~`, removing the last value with `rtail`, and `last` are always O(1).
Accessing the first element of the stack is O(n).
###
stack<?a> record
	# TODO:PRIVATE
	ignore void
	last-node opt node ?a

.node<?a> record
	prev opt node ?a
	value ?a

# Empty stack.
stack stack ?a()
	stack: void, none

# Copy an arr to a stack.
stack stack ?a(a arr ?a)
	stack<?a> fold a, \stack, x
		stack ~ x

# Copy a stack to an arr.
arr arr ?a(a stack ?a) trusted
	res = a.size uninitialized-mut-arr<?a>
	begin = res.end-ptr fold-reverse a, \out, x
		new-out = out - 1
		new-out[] := x
		new-out
	assert: begin ptr-eq? res.begin-ptr
	res cast-immutable

arr-reverse arr ?a(a stack ?a) trusted
	res = a.size uninitialized-mut-arr<?a>
	end = res.begin-ptr fold-reverse a, \out, x
		out[] := x
		out + 1
	assert: end ptr-eq? res.end-ptr
	res cast-immutable

# True iff `a.size == 0`.
empty? bool(a stack ?a)
	a.last-node empty?

###
Appends an element to the stack.
This is O(1).
###
~ stack ?a(a stack ?a, b ?a)
	stack: void, some: node: a.last-node, b

###
Number of elements in the stack.
This is O(1).
###
size nat(a stack ?a)
	0 fold a, \acc, ignore
		drop: ignore
		acc + 1

###
Oldest element.
This is O(a size).
###
first opt ?a(a stack ?a)
	none fold-reverse a, \ignore, x
		x some

###
Most recently appended element.
This is O(1).
###
last opt ?a(a stack ?a)
	match a last-node
	as none
		none
	as some s
		s.value.value some

###
All but the last element.
This is O(1).
Throws if the stack is empty.
###
rtail stack ?a(a stack ?a)
	match a last-node
	as none
		throw: "Stack is empty"
	as some s
		stack: void, s.value prev

popped<?a> record
	value ?a
	rest stack ?a

pop opt popped ?a(a stack ?a)
	match a last-node
	as none
		none
	as some s
		some: popped: s.value.value, stack: void, s.value.prev

region iteration

each void(a stack ?a, f act void(?a))
	a.last-node each-recur f
.each-recur void(a opt node ?a, f act void(?a))
	match a
	as none
		void
	as some s
		s.value.prev each-recur f
		f[s.value value]

each-reverse void(a stack ?a, f act void(?a))
	a.last-node each-reverse-recur f
.each-reverse-recur void(a opt node ?a, f act void(?a))
	match a
	as none
		void
	as some s
		f[s.value value]
		s.value.prev each-reverse-recur f

# Call a function for each element in the stack and accumulate.
fold ?a(acc ?a, a stack ?b, f act ?a(?a, ?b))
	acc fold-recur a.last-node, f
.fold-recur ?a(acc ?a, a opt node ?b, f act ?a(?a, ?b))
	match a
	as none
		acc
	as some s
		prev-val = acc fold-recur s.value.prev, f
		f[prev-val, s.value.value]

fold-reverse ?a(acc ?a, a stack ?b, f act ?a(?a, ?b))
	acc fold-reverse-recur a.last-node, f
.fold-reverse-recur ?a(acc ?a, a opt node ?b, f act ?a(?a, ?b))
	match a
	as none
		acc
	as some s
		f[acc, s.value.value] fold-reverse-recur s.value.prev, f


# Produce a stack with `f[x]` applied to each element `x` in the input.
map stack ?out(a stack ?in, f act ?out(?in))
	stack: void, a.last-node map-recur f
.map-recur opt node ?out(a opt node ?in, f act ?out(?in))
	match a
	as none
		none
	as some s
		prev = s.value.prev map-recur f
		some: node: prev, f[s.value.value]

filter stack ?a(a stack ?a, f act bool(?a))
	stack: void, a.last-node filter-recur f
.filter-recur opt node ?a(a opt node ?a, f act bool(?a))
	match a
	as none
		none
	as some s
		prev = s.value.prev filter-recur f
		if f[s.value value]
			some: node: prev, s.value.value
		else
			prev

first-some opt ?out(a stack ?in, f act opt ?out(?in))
	a.last-node first-some-recur f
.first-some-recur opt ?out(a opt node ?in, f act opt ?out(?in))
	match a
	as none
		none
	as some some-node
		match some-node.value.prev first-some-recur f
		as none
			f[some-node.value value]
		as some some-out
			some-out

test
	a = stack<nat>
	assert: a empty?
	a.arr is []
	a.last is none

	b = a ~ 1
	b.arr is [1]
	b.last is 1.some
	b.rtail is a
	forbid: b empty?

	c = b ~ 2
	c.arr is [1, 2]
	c.last is 2.some
	c.rtail is b

	d = c ~ 3
	d.arr is [1, 2, 3]

	each-spy = spy-act<void, nat>: void
	d each each-spy.fn
	each-spy.calls is [1, 2, 3]

	d each-reverse each-spy.fn
	each-spy.calls is [3, 2, 1]

	d2 = d map {it + 10}
	d2.arr is [11, 12, 13]

	d3 = d filter {it != 2}
	d3.arr is [1, 3]

	folded = 5 fold d, \x, y
		x + y
	folded is 11

	(d first-some<str, nat> {it == 2 ? "two".some, none}) is "two".some
	(d first-some<str, nat> {it == 5 ? "five".some, none}) is none
