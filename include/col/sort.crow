no-std
import
	..compare: ==, <, <=, >, <=>, comparison, less
	..exception: assert, is
	..fun: subscript
	..misc: ->, as, data, void
	..number: +, -, /, nat
	..ptr: +, -, ptr, ptr-eq?, set-subscript, subscript
	.arr: arr
	.mut-arr: begin-ptr, cast-immutable, empty?, end-ptr, mut-arr, size, set-subscript, subscript
	.mut-list: mut-list, temp-as-mut-arr

###
Returns a new array containing the same elements as `a`, but in sorted order.
That means `res[i] <= res[i + 1]` for each element in the result.
###
sort arr ?a(a arr ?a) data<?a>
	a sort \x, y
		x <=> y
sort arr ?a(a arr ?a, comparer act comparison(?a, ?a)) trusted
	res = a mut-arr
	res sort! comparer
	res cast-immutable

###
Sort and remove duplicates.
That means `res[i] < res[i + 1]` for each element in the result.
`[2, 1, 2] sort-unique` is `[1, 2]`.
###
sort-unique arr ?a(a arr ?a) data<?a> trusted
	a.mut-arr.sort-unique! cast-immutable

test
	(sort: as<arr nat>: []) is []
	[3, 1, 2].sort is [1, 2, 3]

# Sort a mut-list in place.
sort! void(a mut-list ?a) data<?a> trusted
	a.temp-as-mut-arr sort!
sort! void(a mut-list ?a, comparer act comparison(?a, ?a)) trusted
	a.temp-as-mut-arr sort! comparer

# Sort a mut-arr in place.
sort! void(a mut-arr ?a) data<?a>
	a sort! \x, y
		x <=> y
sort! void(a mut-arr ?a, comparer act comparison(?a, ?a))
	if a.size > 1
		# Perf -- in case a is sorted already, prefer the middle element as a pivot
		a swap 0, a.size / 2
		pivot = a[0]
		new-pivot-index = (a partition! pivot, 1, a.size - 1, comparer) - 1
		a swap 0, new-pivot-index
		a[0 -> new-pivot-index] sort! comparer
		a[new-pivot-index + 1 -> a.size] sort! comparer

# Sort a mut-list in place, remove unique elements, and return the (now shorter) mut-arr.
sort-unique! mut-arr ?a(a mut-arr ?a) data<?a>
	a sort-unique! \x, y
		x <=> y
sort-unique! mut-arr ?a(a mut-arr ?a, comparer act comparison(?a, ?a)) data<?a> trusted
	if a empty?
		a
	else
		a sort! comparer
		end = a.begin-ptr[] unique-recur! a.begin-ptr + 1, a.begin-ptr + 1, a.end-ptr
		a[0 -> end - a.begin-ptr]
.unique-recur! ptr ?a(prev ?a, read ptr ?a, write ptr ?a, end ptr ?a) data<?a> unsafe
	if read ptr-eq? end
		write
	else
		here = read[]
		if here == prev
			prev unique-recur! read + 1, write, end
		else
			write[] := here
			here unique-recur! read + 1, write + 1, end

# Returns index of first value > pivot
.partition! nat(a mut-arr ?a, pivot ?a, l nat, r nat, comparer act comparison(?a, ?a))
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		if comparer[a[l], pivot] == less
			a partition! pivot, l + 1, r, comparer
		else
			a swap l, r
			a partition! pivot, l, r - 1, comparer
	else
		l

.swap void(a mut-arr ?a, x nat, y nat)
	old-x = a[x]
	a[x] := a[y]
	a[y] := old-x

sorted-by-first<?a, ?b> record
	a arr ?a
	b arr ?b

# Sort `a`, and apply the same permutation to `b`.
sort-by-first sorted-by-first<?a, ?b>(a arr ?a, b arr ?b) data<?a> trusted
	mut-a = a mut-arr
	mut-b = b mut-arr
	mut-a sort-by-first! mut-b
	mut-a.cast-immutable sorted-by-first mut-b.cast-immutable

# Sort `a` in place, and apply the same permutation to `b` in place.
sort-by-first! void(a mut-list ?a, b mut-list ?b) data<?a> trusted
	a.temp-as-mut-arr sort-by-first! b.temp-as-mut-arr

# Sort `a` in place, and apply the same permutation to `b` in place.
sort-by-first! void(a mut-arr ?a, b mut-arr ?b) data<?a>
	assert: a.size == b.size
	if a.size > 1
		a swap 0, a.size / 2
		pivot = a[0]
		new-pivot-index = (a partition-by-first! b, pivot, 1, a.size - 1) - 1
		a swap 0, new-pivot-index
		b swap 0, new-pivot-index
		a[0 -> new-pivot-index] sort-by-first! b[0 -> new-pivot-index]
		a[new-pivot-index + 1 -> a.size] sort-by-first! b[new-pivot-index + 1 -> b.size]

.partition-by-first! nat(a mut-arr ?a, b mut-arr ?b, pivot ?a, l nat, r nat) data<?a>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		if a[l] < pivot
			a partition-by-first! b, pivot, (l + 1), r
		else
			a swap l, r
			b swap l, r
			a partition-by-first! b, pivot, l, r - 1
	else
		l
