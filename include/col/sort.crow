no-std
import
	..bool: or
	..compare: ==, !=, <, <=, >
	..exception: assert
	..misc: ->, as, data, void
	..number: +, -, /, nat
	.arr: arr
	.arr-util: each
	.mut-arr: cast-immutable, mut-arr, size, set-subscript, subscript
	.mut-list: ~=, empty?, last, move-to-arr!, mut-list, temp-as-mut-arr

###
Returns a new array containing the same elements as `a`, but in sorted order.
That means `res[i] <= res[i + 1]` for each element in the result.
###
sort arr ?a(a arr ?a) data<?a> trusted
	res = a mut-arr
	res sort!
	res cast-immutable

###
Sort and remove duplicates.
That means `res[i] < res[i + 1]` for each element in the result.
`[2, 1, 2] sort-unique` is `[1, 2]`.
###
sort-unique arr ?a(a arr ?a) data<?a> trusted
	a.sort unique!
.unique! arr ?a(a arr ?a) data<?a>
	res = mut-list<?a>
	a each \x
		if res.empty? or x != res.last
			res ~= x
	res move-to-arr!

test
	assert: (sort: as<arr nat>: []) == []
	assert: [3, 1, 2].sort == [1, 2, 3]

# Sort a mut-list in place.
sort! void(a mut-list ?a) data<?a> trusted
	a.temp-as-mut-arr sort!

# Sort a mut-list in place.
sort! void(a mut-arr ?a) data<?a>
	if a.size > 1
		# Perf -- in case a is sorted already, prefer the middle element as a pivot
		a swap 0, a.size / 2
		pivot = a[0]
		new-pivot-index = (a partition! pivot, 1, a.size - 1) - 1
		a swap 0, new-pivot-index
		a[0 -> new-pivot-index] sort!
		a[new-pivot-index + 1 -> a.size] sort!

# Returns index of first value > pivot
.partition! nat(a mut-arr ?a, pivot ?a, l nat, r nat) data<?a>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		if a[l] < pivot
			a partition! pivot, l + 1, r
		else
			a swap l, r
			a partition! pivot, l, r - 1
	else
		l

.swap void(a mut-arr ?a, x nat, y nat)
	old-x = a[x]
	a[x] := a[y]
	a[y] := old-x

sorted-by-first<?a, ?b> record
	a arr ?a
	b arr ?b

# Sort `a`, and apply the same permutation to `b`.
sort-by-first sorted-by-first<?a, ?b>(a arr ?a, b arr ?b) data<?a> trusted
	mut-a = a mut-arr
	mut-b = b mut-arr
	mut-a sort-by-first! mut-b
	mut-a.cast-immutable sorted-by-first mut-b.cast-immutable

# Sort `a` in place, and apply the same permutation to `b` in place.
sort-by-first! void(a mut-list ?a, b mut-list ?b) data<?a> trusted
	a.temp-as-mut-arr sort-by-first! b.temp-as-mut-arr

# Sort `a` in place, and apply the same permutation to `b` in place.
sort-by-first! void(a mut-arr ?a, b mut-arr ?b) data<?a>
	assert: a.size == b.size
	if a.size > 1
		a swap 0, a.size / 2
		pivot = a[0]
		new-pivot-index = (a partition-by-first! b, pivot, 1, a.size - 1) - 1
		a swap 0, new-pivot-index
		b swap 0, new-pivot-index
		a[0 -> new-pivot-index] sort-by-first! b[0 -> new-pivot-index]
		a[new-pivot-index + 1 -> a.size] sort-by-first! b[new-pivot-index + 1 -> b.size]

.partition-by-first! nat(a mut-arr ?a, b mut-arr ?b, pivot ?a, l nat, r nat) data<?a>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		if a[l] < pivot
			a partition-by-first! b, pivot, (l + 1), r
		else
			a swap l, r
			b swap l, r
			a partition-by-first! b, pivot, l, r - 1
	else
		l
