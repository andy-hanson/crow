no-std
import
	..bool: bool
	..compare: ==, <=>
	..exception: assert
	..misc: arrow, data, drop, from, to, void
	..number: +, nat
	.arr: arr, size
	.arr-util: map
	.dict: dict, has?, subscript
	.mut-list:
		~=, index-of, insert-at!, move-to-arr!, mut-list, remove-unordered-at!, size,
		set-subscript, subscript, temp-as-arr
	..opt: none, opt, some, value
	.sort: sort-by-first!

###
Mutable `dict`.
Keys must still be `data`.
###
mut-dict<?k, ?v> record mut
	# TODO: PRIVATE
	ignore void
	keys mut-list ?k
	values mut-list ?v

# New empty `mut-dict`.
mut-dict mut-dict<?k, ?v>() data<?k>
	mut-dict: void, mut-list, mut-list

###
`mut-dict` from `key -> value` pairs.
Throws if some key is repeated.
###
mut-dict mut-dict<?k, ?v>(pairs arr arrow<?k, ?v>) data<?k>
	keys = pairs map {it from}
	values = pairs map {it to}
	mut-dict: keys, values

###
`mut-dict` from keys and values from corresponding elements in the arrays.
Throws if the key and value arrays have different sizes.
Throws if some key is repeated.
###
mut-dict mut-dict<?k, ?v>(keys arr ?k, values arr ?v) data<?k>
	assert: keys.size == values.size
	mut-keys = keys mut-list
	mut-values = values mut-list
	mut-keys sort-by-first! mut-values
	mut-dict: void, mut-keys, mut-values

# Gets the value associated with a key, or returns `none`.
subscript opt ?v(a mut-dict<?k, ?v>, key ?k) trusted data<?k>
	a.temp-as-dict[key]

###
Sets the value associated with a key, or returns `none`.
If the key already exists, overwrites the existing value,
else this will add a new pair, increasing the size.
###
set-subscript void(a mut-dict<?k, ?v>, key ?k, value ?v) data<?k>
	a set-subscript-recur 0, key, value

.set-subscript-recur void(a mut-dict<?k, ?v>, idx nat, key ?k, value ?v) data<?k>
	if idx == a.keys.size
		a.keys ~= key
		a.values ~= value
	else
		match key <=> a.keys[idx]
		as less
			a.keys insert-at! idx, key
			a.values insert-at! idx, value
		as equal
			a.values[idx] := value
		as greater
			a set-subscript-recur idx + 1, key, value

# True iff the key is in the dict.
has? bool(a mut-dict<?k, ?v>, key ?k) trusted data<?k>
	a.temp-as-dict has? key

###
Convert to a `dict`, clearning the original `mut-dict` in the process.
(This avoids copying but still ensures that the result is immutable.)
###
move-to-dict! dict<?k, ?v>(a mut-dict<?k, ?v>) data<?k>
	# TODO: should be able to infer type arguments 
	dict<?k, ?v>: a.keys.move-to-arr!, a.values.move-to-arr!

.temp-as-dict dict<?k, ?v>(a mut-dict<?k, ?v>) unsafe data<?k>
	# TODO: should be able to infer type arguments 
	dict<?k, ?v>: a.keys.temp-as-arr, a.values.temp-as-arr

###
Removes the key (and associated value).
Returns the value that was associated with the key, or `none` if the key was not present.
###
remove! opt ?v(a mut-dict<?k, ?v>, key ?k) data<?k>
	match a.keys index-of key
	as none
		none
	as some s
		drop: a.keys remove-unordered-at! s.value
		some: a.values remove-unordered-at! s.value
