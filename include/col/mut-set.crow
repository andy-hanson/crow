no-std
import
	..bool: bool, false, true
	..compare: ==, <=>
	..misc: data, drop, void
	..number: +, nat
	.arr: arr
	.arr-util: each
	.mut-list: ~=, insert-at!, move-to-arr!, mut-list, remove-at!, size, subscript
	.set: set
	.sort: sort

###
Mutable set of unique values.
This is like a `set` but mutable, or like a `mut-dict` with no values.
Unlike `mut-list`, values are in sorted order, not insertion order,
and it never stores two of the same value.
###
mut-set<?a> record mut
	# TODO:PRIVATE
	ignore void
	inner mut-list<?a>

# New empty `mut-set`.
mut-set mut-set ?a() data<?a>
	mut-set: void, mut-list

# Copies the arr to a new mut-set.
mut-set mut-set ?a(a arr ?a) data<?a>
	mut-set: void, a.sort.mut-list

# Number of values in the set.
size nat(a mut-set ?a) data<?a>
	a.inner size

# True iff the value is in the set.
subscript bool(a mut-set ?a, value ?a) data<?a>
	a.inner has? 0, value

.has? bool(a mut-list ?a, index nat, value ?a) data<?a>
	# TODO: binary search
	if index == a.size
		false
	else
		match value <=> a[index]
		as less
			false
		as equal
			true
		as greater
			a has? index + 1, value

###
Adds a value to the set.
Does nothing if the value is already in the set.
###
~= void(a mut-set ?a, value ?a) data<?a>
	a.inner add! 0, value drop
.add! bool(a mut-list ?a, index nat, value ?a) data<?a>
	if index == a.size
		a ~= value
		true
	else
		match value <=> a[index]
		as less
			a insert-at! index, value
			true
		as equal
			false
		as greater
			a add! index + 1, value

# Adds multiple values to the set.
~= void(a mut-set ?a, values arr ?a) data<?a>
	values each \value
		a ~= value

###
Removes a value from the set.
If the value was present, removes it and returns `true`.
If the value was not present, does nothing and returns `false`.
###
remove! bool(a mut-set ?a, value ?a) data<?a>
	a.inner remove! 0, value
.remove! bool(a mut-list ?a, index nat, value ?a) data<?a>
	if index == a.size
		false
	else
		match value <=> a[index]
		as less
			false
		as equal
			a remove-at! index drop
			true
		as greater
			a remove! index + 1, value

###
Convert to a `set`, clearning the original `mut-set` in the process.
(This avoids copying but still ensures that the result is immutable.)
###
move-to-set! set ?a(a mut-set ?a) data<?a>
	set: a.inner move-to-arr!
