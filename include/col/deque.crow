no-std
import
	..bool: and, bool
	..exception: assert
	..fun: subscript
	..misc: ->, void
	..number: +, even?, nat
	..opt: force, none, opt, some, value
	..ptr: +, -, ptr-eq?, set-subscript
	..str: char, str
	..str-conv: to-str
	..test: is
	.arr: arr, empty?, size
	.arr-util: each, first, fold, last, rtail, tail
	.mut-arr: begin-ptr, cast-immutable, end-ptr, subscript, uninitialized-mut-arr
	.mut-list: ~=, move-to-arr!, mut-list, set-last
	.stack:
		~, arr, arr-reverse, each, each-reverse, empty?, fold, fold-reverse, pop, rest, size,
		stack, value

deque<?a> record
	# TODO:PRIVATE
	# NOTE: This is in reverse (top of the stack furthest left)
	left stack ?a
	mid arr ?a
	right stack ?a

# Empty deque.
deque deque ?a()
	deque: []

###
Convert an arr to a deque.
This is O(1).
###
deque deque ?a(a arr ?a)
	deque: stack, a, stack

arr arr ?a(a deque ?a) trusted
	res = a.size uninitialized-mut-arr<?a>
	end = res.begin-ptr fold a, \out, x
		out[] := x
		out + 1
	assert: end ptr-eq? res.end-ptr
	res cast-immutable

empty? bool(a deque ?a)
	a.left.empty? and a.mid.empty? and a.right.empty?

size nat(a deque ?a)
	a.left.size + a.mid.size + a.right.size

~ deque ?a(a deque ?a, value ?a)
	deque: a.left, a.mid, a.right ~ value

~ deque ?a(value ?a, a deque ?a)
	deque: a.left ~ value, a.mid, a.right

popped<?a> record
	value ?a
	rest deque ?a

pop-left opt popped ?a(a deque ?a)
	match a.left pop
	as none
		match a.mid first
		as none
			right-arr = a.right arr
			match right-arr first
			as none
				none
			as some s
				some: popped: s.value, deque: stack, right-arr.tail, stack
		as some s
			some: popped: s.value, deque: stack, a.mid.tail, a.right
	as some s
		some: popped: s.value.value, deque: s.value.rest, a.mid, a.right

pop-right opt popped ?a(a deque ?a)
	match a.right pop
	as none
		match a.mid last
		as none
			left-arr = a.left arr-reverse
			match left-arr last
			as none
				none
			as some s
				some: popped: s.value, deque: stack, left-arr.rtail, stack
		as some s
			some: popped: s.value, deque: a.left, a.mid.rtail, stack
	as some s
		some: popped: s.value.value, deque: a.left, a.mid, s.value.rest

region iteration

each void(a deque ?a, f act void(?a))
	a.left each-reverse f
	a.mid each f
	a.right each f

fold ?a(acc ?a, a deque ?b, f act ?a(?a, ?b))
	acc fold-reverse a.left, f fold a.mid, f fold a.right, f

filter deque ?a(a deque ?a, f act bool(?a)) trusted
	res = a.size uninitialized-mut-arr<?a>
	end = res.begin-ptr fold a, \out, x
		if f[x]
			out[] := x
			out + 1
		else
			out
	deque: res[0 -> end - res.begin-ptr] cast-immutable

map deque ?out(a deque ?in, f act ?out(?in)) trusted
	res = a.size uninitialized-mut-arr<?out>
	end = res.begin-ptr fold a, \out, x
		out[] := f[x]
		out + 1
	assert: end ptr-eq? res.end-ptr
	deque: res.cast-immutable

.dbg str(a deque nat)
	out = mut-list<char>
	a.left each-reverse \x
		out ~= x to-str
		out ~= " "
	out ~= "["
	if a.mid empty?
		out ~= "]"
	else
		a.mid each \x
			out ~= x to-str
			out ~= " "
		out.last := "]"
	a.right each \x
		out ~= " "
		out ~= x to-str
	out move-to-arr!

test
	a = deque<nat>
	assert: a empty?
	a.dbg is "[]"
	a.arr is []
	a.pop-left is none
	a.pop-right is none

	bl = 1 ~ a
	bl.dbg is "1 []"
	bl.arr is [1]
	bl-pop-left = bl.pop-left force
	bl-pop-left is popped: 1, deque
	bl.pop-right is bl-pop-left.some

	br = a ~ 1
	br.dbg is "[] 1"
	br.arr is bl.arr
	br.pop-left is bl-pop-left.some
	br.pop-right is bl-pop-left.some

	c = bl ~ 2 ~ 3
	c.dbg is "1 [] 2 3"
	c-pop = c.pop-left force
	c-pop.value is 1

	# Forces it to convert to an array
	d = c-pop rest
	d.dbg is "[] 2 3"
	d.pop-left is some: popped: 2, deque: [3]

	d-pop = d.pop-left force
	d-pop.value is 2
	d-pop.rest.dbg is "[3]"

	# Test converting right stack to array
	x = 1 ~ (2 ~ (3 ~ [].deque))
	x.arr is [1, 2, 3]
	x.dbg is "1 2 3 []"
	x-pop = x.pop-right force
	x-pop.value is 3
	x-pop.rest.dbg is "[1 2]"

	six = 1 ~ (2 ~ [3, 4].deque) ~ 5 ~ 6
	six.dbg is "1 2 [3 4] 5 6"
	folded = 10 fold six, \x, y
		x + y
	folded is 31
	(six filter {it even?}).arr is [2, 4, 6]
	(six map {it + 10}).arr is [11, 12, 13, 14, 15, 16]
