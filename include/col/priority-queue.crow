no-std
import
	..bool: ?, and, bool, false, not, true
	..compare: ==, <, >, <=
	..exception: assert
	..fun: subscript
	..misc: ->, arrow, as, data, from, to, void
	..number: +, -, nat
	..opt: empty?, force, none, opt, some, value
	..ptr: +, -, ptr, ptr-eq?, set-subscript
	..str: char, str
	..str-conv: finish, interp, to-str, with-str, with-value
	..test: calls, fn, is, spy-act
	..tuple: pair
	.arr: arr, empty?, size
	.arr-util: each, first, fold, map, tail
	.mut-arr:
		begin-ptr, cast-immutable, end-ptr, first, mut-arr, set-subscript, size, subscript,
		tail, uninitialized-mut-arr
	.mut-list: ~=, move-to-arr!, mut-list, pop-n!
	.sort: sort-by, sort-by!

priority-queue<?k, ?v> record
	# TODO: PRIVATE
	ignore void
	root opt node<?k, ?v>

###
Priority queue consists of a linked list of nodes with two parts.
First part is recently inserted values. These all have a single pair in 'min' and nothing in 'pairs'.
Next part is compacted arrays of pairs. These are sorted biggest to smallest.
They grow exponentially from right to left, so total # of these nodes is logarithmic in queue size.

So node sizes might look like:

	1 1 1 8 4 2 1

A push operation just adds to the left.
A pop operation will compact all the left nodes into a big node,
and also compact any nodes of the same size or less with it.
(This applies recursively, so if the 3 1s were compacted,
they would join with the `1` on the right to size 4, then with the `2` on the right to size 6,
then with the `4` to size 10, then with the `8` to size 18, leaving only one node.)
###

.node<?k, ?v> record
	min arrow<?k, ?v>
	pairs arr arrow<?k, ?v>
	next opt node<?k, ?v>

priority-queue priority-queue<?k, ?v>() data<?k>
	priority-queue: void, none

priority-queue priority-queue<?k, ?v>(a arr arrow<?k, ?v>) data<?k>
	if a empty?
		priority-queue
	else
		sorted = a sort-by {it from}
		priority-queue: void, some: node: sorted.first.force, sorted.tail, none

empty? bool(a priority-queue<?k, ?v>) data<?k>
	a.root empty?

size nat(a priority-queue<?k, ?v>) data<?k>
	0 size-recur a.root
.size-recur nat(acc nat, a opt node<?k, ?v>)
	match a
	as none
		acc
	as some s
		acc + 1 + s.value.pairs.size size-recur s.value.next

###
Add a pair to the queue.
This is O(1).
###
~ priority-queue<?k, ?v>(a priority-queue<?k, ?v>, b arrow<?k, ?v>) data<?k>
	priority-queue: void, some: node: b, [], a.root

popped<?k, ?v> record
	popped arrow<?k, ?v>
	rest priority-queue<?k, ?v>

pop opt popped<?k, ?v>(a priority-queue<?k, ?v>) data<?k>
	match a.compact-leading-nodes root
	as none
		none
	as some some-root
		root = some-root value
		match root next
		as none
			some: root pop-from-node
		as some some-next
			next = some-next value
			match next pop-no-compact-recur root.min.from
			as none
				some: root pop-from-node
			as some s
				some: root combine-with-popped s.value

.pop-from-node popped<?k, ?v>(a node<?k, ?v>)
	rest = match a.pairs first
	as none
		a next
	as some s
		some: node: s.value, a.pairs.tail, a.next
	popped: a.min, priority-queue: void, rest

# Returns none if this (or any following node) did not have a lower min.
.pop-no-compact-recur opt popped<?k, ?v>(a node<?k, ?v>, min ?k) data<?k>
	is-min? = a.min.from < min
	next-popped = match a next
	as none
		none as<opt popped<?k, ?v>>
	as some s
		s.value pop-no-compact-recur (is-min? ? a.min.from, min)

	match next-popped
	as none
		is-min? ? a.pop-from-node.some, none
	as some s
		some: a combine-with-popped s.value

combine-with-popped popped<?k, ?v>(a node<?k, ?v>, popped popped<?k, ?v>)
	node = node<?k, ?v>: a.min, a.pairs, popped.rest.root
	popped: popped.popped, priority-queue: void, node.some

.compact-leading-nodes priority-queue<?k, ?v>(a priority-queue<?k, ?v>) data<?k> trusted
	mid = a.root find-mid 0
	if mid.n-before-mid == 0
		a
	else
		root = a.root force
		priority-queue: void, some: match mid.mid plan root, mid.n-before-mid
		as plan-did-compact p
			p node
		as plan-will-compact w
			root do-compact w.n-elements-to-compact, mid.mid

.found-mid<?k, ?v> record
	mid opt node<?k, ?v>
	n-before-mid nat

# Finds the first node with 'pairs' non-empty.
# Also returns the # of nodes before that
.find-mid found-mid<?k, ?v>(a opt node<?k, ?v>, n-before nat)
	match a
	as none
		found-mid: none, n-before
	as some s
		node = s value
		if node.pairs empty?
			node.next find-mid n-before + 1
		else
			found-mid: node.some, n-before

.plan-did-compact<?k, ?v> record
	node node<?k, ?v>

.plan-will-compact<?k, ?v> record
	n-elements-to-compact nat

.plan<?k, ?v> union
	plan-did-compact<?k, ?v>
	plan-will-compact<?k, ?v>

# We only call this if we will definitely compact something,
# TODO: 'plan' is misnamed, this now does the compaction during the recursion
.plan plan<?k, ?v>(a opt node<?k, ?v>, root node<?k, ?v>, n-singles nat) data<?k>
	match a
	as none
		plan-will-compact<?k, ?v>: n-singles
	as some s
		node = s value
		match node.next plan root, n-singles
		as plan-did-compact d
			new-node = node<?k, ?v>: node.min, node.pairs, d.node.some
			plan-did-compact: new-node
		as plan-will-compact c
			node-size-here = 1 + node.pairs.size
			if node-size-here <= c.n-elements-to-compact
				plan-will-compact: c.n-elements-to-compact + node-size-here
			else
				compacted = root do-compact c.n-elements-to-compact, node.next
				plan-did-compact: node: node.min, node.pairs, some: compacted

.do-compact node<?k, ?v>(root node<?k, ?v>, n-to-compact nat, nodes-to-compact opt node<?k, ?v>) trusted data<?k>
	compacted = n-to-compact uninitialized-mut-arr<arrow<?k, ?v>>
	mid = compacted.begin-ptr compact-non-singles! nodes-to-compact
	end = mid compact-singles! root
	assert: end ptr-eq? compacted.end-ptr
	compacted sort-by! {it from}
	arr = compacted cast-immutable
	node: arr.first.force, arr.tail, none

.compact-singles! ptr arrow<?k, ?v>(out ptr arrow<?k, ?v>, a node<?k, ?v>) unsafe
	if a.pairs empty?
		# Output later nodes first to preserve insertion order (since they're inserted to the front)
		pos = match a next
		as none
			out
		as some s
			out compact-singles! s.value
		pos[] := a.min
		pos + 1
	else
		out

.compact-non-singles! ptr arrow<?k, ?v>(out ptr arrow<?k, ?v>, a opt node<?k, ?v>) unsafe
	match a
	as none
		out
	as some s
		node = s value
		out[] := node min
		out2 = out + 1 fold node.pairs, \cur, x
			cur[] := x
			cur + 1
		out2 compact-non-singles! node.next

.dbg str(a priority-queue<nat, str>)
	res = mut-list<char>
	res dbg-recur! a.root, true
	res move-to-arr!
.dbg-recur! void(out mut-list char, a opt node<nat, str>, first bool)
	match a
	as none
		void
	as some s
		if first not
			out ~= "; "
		node = s value
		out ~= node.min.from to-str
		out ~= " "
		out ~= node.min.to to-str
		out ~= " ["
		if node.pairs.empty? not
			node.pairs each \pair
				out ~= pair.from to-str
				out ~= " "
				out ~= pair.to to-str
				out ~= ", "
			out pop-n! ", ".size
		out ~= "]"
		out dbg-recur! node.next, false

region iteration

each void(a priority-queue<?k, ?v>, f act void(?k, ?v)) data<?k>
	void fold a, \ignore, k, v
		f[k, v]

fold ?a(acc ?a, a priority-queue<?k, ?v>, f act ?a(?a, ?k, ?v)) data<?k>
	acc walk-fold a.each-arr, f

.each-part<?k, ?v> record mut
	min mut arrow<?k, ?v>
	pairs mut arr arrow<?k, ?v>

.each-arr mut-arr each-part<?k, ?v>(a priority-queue<?k, ?v>) trusted data<?k>
	res = a.node-count uninitialized-mut-arr<each-part<?k, ?v>>
	end = res.begin-ptr fill-each-arr! a.root
	assert: end ptr-eq? res.end-ptr
	res sort-by! {it.min from}
	res

.node-count nat(a priority-queue<?k, ?v>)
	0 node-count a.root

.node-count nat(acc nat, a opt node<?k, ?v>)
	match a
	as none
		acc
	as some s
		acc + 1 node-count s.value.next

.fill-each-arr! ptr each-part<?k, ?v>(out ptr each-part<?k, ?v>, a opt node<?k, ?v>) unsafe
	match a
	as none
		out
	as some s
		node = s value
		out[] := each-part: node.min, node.pairs
		out + 1 fill-each-arr! node.next

.walk-fold ?a(acc ?a, a mut-arr each-part<?k, ?v>, f act ?a(?a, ?k, ?v)) data<?k>
	match a first
	as none
		acc
	as some s
		head = s value
		min = head min
		next-acc = f[acc, min from, min to]
		match head.pairs first
		as none
			next-acc walk-fold a.tail, f
		as some s2
			head.min := s2 value
			head.pairs := head.pairs tail
			a swap-sorted!
			next-acc walk-fold a, f

.swap-sorted! void(a mut-arr each-part<?k, ?v>) data<?k>
	if a.size > 1 and a[0].min.from > a[1].min.from
		temp = a[0]
		a[0] := a[1]
		a[1] := temp
		a.tail swap-sorted!

filter priority-queue<?k, ?v>(a priority-queue<?k, ?v>, f act bool(?k, ?v)) trusted data<?k>
	out = a.size uninitialized-mut-arr<arrow<?k, ?v>>
	end = out.begin-ptr fold a, \cur, k, v
		if f[k, v]
			cur[] := k -> v
			cur + 1
		else
			cur
	out[0 -> end - out.begin-ptr].cast-immutable priority-queue

map priority-queue<?k-out, ?v-out>
	a priority-queue<?k-in, ?v-in>
	f act arrow<?k-out, ?v-out>(?k-in, ?v-in)
spec
	data<?k-in>
	data<?k-out>
body
	a map-to-arr f priority-queue

map-to-arr arr ?out(a priority-queue<?k, ?v>, f act ?out(?k, ?v)) data<?k> trusted
	out = a.size uninitialized-mut-arr<?out>
	end = out.begin-ptr fold a, \cur, k, v
		cur[] := f[k, v]
		cur + 1
	assert: end ptr-eq? out.end-ptr
	arr = out.cast-immutable
	arr

keys arr ?k(a priority-queue<?k, ?v>) data<?k>
	a map-to-arr \k, v
		k

values arr ?v(a priority-queue<?k, ?v>) data<?k>
	a map-to-arr \k, v
		v

test
	p = priority-queue<nat, str>

	p1 = p ~ (5 -> "5")
	p1.dbg is "5 5 []"

	p2 = p1 ~ (6 -> "6")
	p2.dbg is "6 6 []; 5 5 []"
	p2.compact-leading-nodes.dbg is "5 5 [6 6]"

	p2pop = p2.pop force
	p2pop.popped is 5 -> "5"
	p2pop.rest.dbg is "6 6 []"

	p3 = p2 ~ (4 -> "4")
	p4 = p3 ~ (7 -> "7")

	p4.dbg is "7 7 []; 4 4 []; 6 6 []; 5 5 []"

	p4pop = p4.pop force
	p4pop.popped is 4 -> "4"
	p4pop.rest.dbg is "5 5 [6 6, 7 7]"

	p5 = p4pop.rest ~ (6 -> "6b") ~ (6 -> "6c")
	p5.dbg is "6 6c []; 6 6b []; 5 5 [6 6, 7 7]"

	p5pop = p5.pop force
	p5pop.popped is 5 -> "5"
	p5pop.rest.dbg is "6 6 [7 7]; 6 6b [6 6c]"

	p6 = p5pop.rest ~ (7 -> "7b") ~ (8 -> "8")
	p6.dbg is "8 8 []; 7 7b []; 6 6 [7 7]; 6 6b [6 6c]"
	p6.size is 6

	p6pop = p6.pop force
	p6pop.rest.dbg is "6 6b [6 6c, 7 7, 7 7b, 8 8]"

	folded = "init" fold p6, \acc, k, v
		"{acc}, {k} -> {v}"
	folded is "init, 6 -> 6, 6 -> 6b, 6 -> 6c, 7 -> 7, 7 -> 7b, 8 -> 8"

	p6-pairs = [6 -> "6", 6 -> "6b", 6 -> "6c", 7 -> "7", 7 -> "7b", 8 -> "8"] map {it pair}
	filter-order = spy-act<bool, nat, str>: \k, v
		k == 6
	filtered = p6 filter filter-order.fn
	filter-order.calls is p6-pairs
	filtered.dbg is "6 6 [6 6b, 6 6c]"

	map-order = spy-act<arrow<nat, str>, nat, str>: \k, v
		10 - k -> "{v}x"
	mapped = p6 map map-order.fn
	map-order.calls is p6-pairs
	mapped.dbg is "2 8x [3 7x, 3 7bx, 4 6x, 4 6bx, 4 6cx]"

	p6.keys is [6, 6, 6, 7, 7, 8]
	p6.values is ["6", "6b", "6c", "7", "7b", "8"]
