import
	.alloc: try-alloc-uninitialized
	.bootstrap
		+ != < <= > any-ptr arr backtrace deref hard-assert incr nat noctx-decr noctx-incr none opt ptr
		ptr-less? set some str to-int unsafe-div unsafe-to-int unsafe-to-int32 unsafe-to-nat value void wrap-sub
	sys.execinfo: backtrace

funs-count nat() noctx unsafe builtin

get-fun-name str(fun-id nat) noctx unsafe builtin

get-fun-ptr any-ptr(fun-id nat) noctx unsafe builtin

get-backtrace backtrace() unsafe
	| Being careful to avoid calling functions that may throw here
	match try-alloc-backtrace-arrs
	as none
		backtrace: new-arr<str>
	as some s
		arrs = s value
		n-code-ptrs = (arrs.code-ptrs backtrace code-ptrs-size.unsafe-to-int.unsafe-to-int32).to-int.unsafe-to-nat
		hard-assert: n-code-ptrs <= code-ptrs-size
		0 fill-fun-ptrs-names-recur arrs.fun-ptrs, arrs.fun-names
		sort-together: arrs.fun-ptrs, arrs.fun-names, funs-count
		end-code-names = arrs.code-names + n-code-ptrs
		fill-code-names-recur: arrs.code-names, end-code-names, arrs.code-ptrs, arrs.fun-ptrs, arrs.fun-names
		backtrace: arr<str>: n-code-ptrs, arrs.code-names

.fill-code-names-recur void
	code-names ptr str
	end-code-names ptr str
	code-ptrs ptr any-ptr
	fun-ptrs ptr any-ptr
	fun-names ptr str
spec
	unsafe
body
	if code-names ptr-less? end-code-names
		code-names set: code-ptrs.deref get-fun-name fun-ptrs, fun-names, funs-count
		code-names.incr fill-code-names-recur end-code-names, code-ptrs.incr, fun-ptrs, fun-names

.code-ptrs-size nat()
	8

.backtrace-arrs record mut
	code-ptrs ptr any-ptr
	code-names ptr str
	fun-ptrs ptr any-ptr
	fun-names ptr str

.try-alloc-backtrace-arrs opt backtrace-arrs() unsafe
	size = 8
	match size try-alloc-uninitialized<any-ptr>
	as none
		none
	as some code-ptrs
		match size try-alloc-uninitialized<str>
		as none
			none
		as some code-names
			match funs-count try-alloc-uninitialized<any-ptr>
			as none
				none
			as some fun-ptrs
				match funs-count try-alloc-uninitialized<str>
				as none
					none
				as some fun-names
					some: backtrace-arrs: code-ptrs.value, code-names.value, fun-ptrs.value, fun-names.value

.fill-fun-ptrs-names-recur void(i nat, fun-ptrs ptr any-ptr, fun-names ptr str) unsafe
	if i != funs-count
		fun-ptrs + i set i.get-fun-ptr
		fun-names + i set i.get-fun-name
		i.noctx-incr fill-fun-ptrs-names-recur fun-ptrs, fun-names

.get-fun-name str(code-ptr any-ptr, fun-ptrs ptr any-ptr, fun-names ptr str, size nat) unsafe
	| TODO: this will fail to give a name for the last function
	if size < 2
		"<<UNKNOWN>>"
	elif code-ptr ptr-less? fun-ptrs.incr.deref
		fun-names deref
	else
		code-ptr get-fun-name fun-ptrs.incr, fun-names.incr, size.noctx-decr

.sort-together void(a ptr any-ptr, b ptr str, size nat) unsafe
	if size > 1
		swap: a, 0, size unsafe-div 2
		swap: b, 0, size unsafe-div 2
		after-pivot = a partition-recur-together b, a.deref, 1, size.noctx-decr
		new-pivot-index = after-pivot noctx-decr
		a swap 0, new-pivot-index
		b swap 0, new-pivot-index
		
		sort-together: a, b, new-pivot-index
		sort-together: (a + after-pivot), (b + after-pivot), size wrap-sub after-pivot

.partition-recur-together nat(a ptr any-ptr, b ptr str, pivot any-ptr, l nat, r nat) unsafe
	if l <= r
		if (a + l).deref ptr-less? pivot
			a partition-recur-together b, pivot, l.noctx-incr, r
		else
			a swap l, r
			b swap l, r
			a partition-recur-together b, pivot, l, r.noctx-decr
	else
		l

.swap void(a ptr ?t, lo nat, hi nat) unsafe
	temp = a + lo deref
	a + lo set: a + hi deref
	a + hi set temp
