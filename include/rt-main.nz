import
	.alloc
	.arr-utils: empty-arr map tail
	.bootstrap
		!= + any-ptr arr as as-any-ptr as-ref by-val call call-with-ctx c-str ctx deref false
		fun-ptr2 fut get-ctx int32 message nat noctx-decr noctx-incr null
		ptr ptr-to ref-of-val set str to-int unsafe-to-nat value void
	.cell: as-cell
	.exceptions: new-exception-ctx
	.fut-low-level: must-be-resolved
	.fut-utils: delay then2
	.io.print: print-err print-err-no-newline
	.io.process: exit-code
	.logging: new-log-ctx
	.posix.pthread: pthread-t
	.runtime
		any-unhandled-exceptions? global-ctx new-ctx new-island set-islands thread-function
		thread-local-stuff island
	.sys.sysinfo: get-nprocs
	.str-utils: to-str
	.thread-utils: create-one-thread join-one-thread new-condition new-lock

.main-ptr alias
	fun-ptr2<fut exit-code, ctx, arr str>

| Treated specially by the compiler
rt-main exit-code(argc int32, argv ptr c-str, main-ptr main-ptr) trusted noctx summon
	n-threads = get-nprocs
	gctx-by-val = as<by-val<global-ctx>>: global-ctx: new-lock, empty-arr, n-threads, 0, new-condition, false, false
	gctx = gctx-by-val ref-of-val
	island-by-val = new-island: gctx, 0, n-threads
	island = island-by-val ref-of-val

	gctx set-islands arr: 1, island.ptr-to

	main-fut = gctx do-main island, argc, argv, main-ptr

	n-threads run-threads gctx

	if gctx any-unhandled-exceptions?
		1
	else
		match main-fut.must-be-resolved
		as ok o
			o value
		as err e
			print-err-no-newline: "main failed: "
			print-err: e.value message
			1

.do-main fut exit-code(gctx global-ctx, island island, argc int32, argv ptr c-str, main-ptr main-ptr) trusted noctx
	| Before we start the engine, add a task.
	| Create a ctx manually so we can call functions that need it when creating the task
	ectx = new-exception-ctx
	log-ctx = new-log-ctx
	tls = as<by-val<thread-local-stuff>>: thread-local-stuff: ectx.ref-of-val, log-ctx.ref-of-val
	ctx-by-val = new-ctx: gctx, tls.ref-of-val, island, 0
	ctx = ctx-by-val ref-of-val
	add = as<fun fut exit-code(arr c-str, main-ptr)>: \all-args main-ptr
		add-first-task: all-args, main-ptr
	all-args = arr: argc.to-int.unsafe-to-nat, argv
	add call-with-ctx ctx, all-args, main-ptr

.thread-args record mut
	by-ref
	thread-id nat
	gctx global-ctx

| TODO: if mut-bag-node is in unmanaged memory, don't need ctx for this
| We want main-fut to be available immediately, not after having run some user code.
| So we create main-fut now, and forward the result of 'main' to that.
.add-first-task fut exit-code(all-args arr c-str, main-ptr fun-ptr2<fut exit-code, ctx, arr str>) unsafe
	| 'then' is useful here -- it handles any errors in 'main' and gets us main-fut immediately.
	| TODO: 'then' overload for fut<void> taking lambda with 0 params
	delay then2 \
		| First argument is the path to this executable.
		args = all-args tail
		main-ptr call: get-ctx, args map {it.to-str}

| Each thread will get the thread ID, and the common arguments.
.run-threads void(n-threads nat, gctx global-ctx) noctx unsafe summon
	threads = n-threads unmanaged-alloc-elements<pthread-t>
	thread-args = n-threads unmanaged-alloc-elements<by-val<thread-args>>

	actual-n-threads = n-threads noctx-decr

	start-threads-recur: 0, actual-n-threads, threads, thread-args, gctx
	thread-function: actual-n-threads, gctx
	join-threads-recur: 0, actual-n-threads, threads

	threads unmanaged-free
	thread-args unmanaged-free

.start-threads-recur void
	i nat
	n-threads nat
	threads ptr pthread-t
	thread-args-begin ptr by-val<thread-args>
	gctx global-ctx
spec
	noctx
	unsafe
	summon
body
	if i != n-threads
		thread-arg-ptr = thread-args-begin + i
		thread-arg-ptr set thread-args: i, gctx
		thread-ptr = threads + i
		thread-ptr.as-cell create-one-thread thread-arg-ptr.as-any-ptr, &thread-fun
		i.noctx-incr start-threads-recur n-threads, threads, thread-args-begin, gctx

.thread-fun any-ptr(args-ptr any-ptr) noctx unsafe summon
	args = args-ptr as-ref<thread-args>
	args.thread-id thread-function args.gctx
	null

.join-threads-recur void(i nat, n-threads nat, threads ptr pthread-t) noctx unsafe summon
	if i != n-threads
		(threads + i).deref join-one-thread
		i.noctx-incr join-threads-recur n-threads, threads
