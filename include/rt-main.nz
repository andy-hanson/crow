import
	.alloc
	.arr-utils: empty-arr map noctx-at tail
	.bootstrap
		== + any-ptr arr as as-any-ptr as-ref by-val call call-with-ctx c-str ctx deref drop false fun2
		fun-ptr1 fun-ptr2 fut get-ctx hard-assert int32 message nat noctx-decr noctx-incr null null?
		pass ptr ptr-to ref-of-val set str todo to-int unsafe-to-nat value void
	.cell: as-cell cell get
	.exceptions: new-exception-ctx
	.fut-low-level: must-be-resolved
	.fut-utils: resolved then2
	.io: exit-code print-err-sync print-err-sync-no-newline
	.posix: eagain einval esrch pthread-create pthread-join pthread-t
	.runtime: any-unhandled-exceptions? global-ctx new-ctx new-vat set-vats thread-function thread-local-stuff vat
	.str-utils: to-str
	.thread-utils: new-condition new-lock

main-ptr alias
	fun-ptr2 fut<exit-code> ctx arr<str>

| Treated specially by the compiler
rt-main exit-code(argc int32, argv ptr c-str, main-ptr main-ptr) trusted noctx summon
	drop: argv.deref to-str

	| TODO: detect # hardware processors to use for n-threads
	| TODO: get-nprocs
	n-threads = 1
	gctx-by-val = as<by-val<global-ctx>>: global-ctx: new-lock, empty-arr<vat>, n-threads, new-condition, false, false
	gctx = gctx-by-val ref-of-val
	vat-by-val = new-vat: gctx, 0, n-threads
	vat = vat-by-val ref-of-val

	gctx set-vats arr: 1, vat.ptr-to

	main-fut = gctx do-main vat, argc, argv, main-ptr

	n-threads run-threads gctx

	if gctx any-unhandled-exceptions?
		1
	else
		match main-fut.must-be-resolved
		as ok o
			o value
		as err e
			print-err-sync-no-newline: "main failed: "
			print-err-sync: e.value message
			1

do-main fut exit-code(gctx global-ctx, vat vat, argc int32, argv ptr c-str, main-ptr main-ptr) trusted noctx
	| Before we start the engine, add a task.
	| Create a ctx manually so we can call functions that need it when creating the task
	ectx = new-exception-ctx
	tls = as<by-val<thread-local-stuff>>: thread-local-stuff: ectx.ref-of-val
	ctx-by-val = new-ctx: gctx, tls.ref-of-val, vat, 0
	ctx = ctx-by-val ref-of-val
	add = as<fun2<fut<exit-code>, arr<c-str>, main-ptr>>: \all-args main-ptr
		add-first-task: all-args, main-ptr
	all-args = arr: argc.to-int.unsafe-to-nat, argv
	ctx call-with-ctx add, all-args, main-ptr

thread-args record mut
	by-ref
	thread-id nat
	gctx global-ctx

| TODO: if mut-bag-node is in unmanaged memory, don't need ctx for this
| We want main-fut to be available immediately, not after having run some user code.
| So we create main-fut now, and forward the result of 'main' to that.
add-first-task fut exit-code(all-args arr c-str, main-ptr fun-ptr2 fut<exit-code> ctx arr<str>) unsafe
	| 'then' is useful here -- it handles any errors in 'main' and gets us main-fut immediately.
	| TODO: 'then' overload for fut<void> taking lambda with 0 params
	pass.resolved.as<fut<void>> then2 \
		| First argument is the path to this executable.
		args = all-args tail
		main-ptr call: get-ctx, args map {it.to-str}

| Each thread will get the thread ID, and the common arguments.
| TODO: ?t must be a reference type
run-threads void(n-threads nat, gctx global-ctx) noctx unsafe summon
	threads = n-threads unmanaged-alloc-elements<pthread-t>
	thread-args = n-threads unmanaged-alloc-elements<by-val<thread-args>>

	actual-n-threads = n-threads noctx-decr

	start-threads-recur: 0, actual-n-threads, threads, thread-args, gctx
	thread-function: actual-n-threads, gctx
	join-threads-recur: 0, actual-n-threads, threads

	threads unmanaged-free
	thread-args unmanaged-free

start-threads-recur void
	i nat
	n-threads nat
	threads ptr pthread-t
	thread-args-begin ptr by-val<thread-args>
	gctx global-ctx
spec
	noctx
	unsafe
	summon
body
	if i == n-threads
		pass
	else
		thread-arg-ptr = thread-args-begin + i
		thread-arg-ptr set thread-args: i, gctx
		thread-ptr = threads + i
		fn = as<fun-ptr1<any-ptr, any-ptr>>: \args-ptr
			args-ptr thread-fun
		err = thread-ptr.as-cell pthread-create null, fn, thread-arg-ptr.as-any-ptr
		if err == 0
			i.noctx-incr start-threads-recur n-threads, threads, thread-args-begin, gctx
		elif err == eagain
			| TODO: warn and make do with the threads it does let us create (so long as there's at least one)
			todo
		else
			| Fatal error
			todo

thread-fun any-ptr(args-ptr any-ptr) noctx unsafe summon
	args = args-ptr as-ref<thread-args>
	args.thread-id thread-function args.gctx
	null

join-threads-recur void(i nat, n-threads nat, threads ptr pthread-t) noctx unsafe summon
	if i == n-threads
		pass
	else
		(threads + i).deref join-one-thread
		i.noctx-incr join-threads-recur n-threads, threads

join-one-thread void(tid pthread-t) noctx unsafe summon
	thread-return = as<by-val<cell<any-ptr>>>: cell: null
	err = tid pthread-join thread-return.ref-of-val
	if err == 0
		pass
	elif err == einval
		todo
	elif err == esrch
		todo
	else
		todo
	hard-assert: thread-return.ref-of-val.get null?
