import
	.alloc
	.arr-utils: empty-arr map noctx-at tail
	.bootstrap
		== + any-ptr arr as as-any-ptr as-ref by-val call call-with-ctx c-str ctx deref drop false fun2
		fun-ptr1 fun-ptr2 fut get-ctx hard-assert int32 nat noctx-decr noctx-incr null null? one
		pass ptr ptr-to ref-of-val set str todo to-int unsafe-to-nat void zero zero?
	.cell: as-cell cell get
	.exceptions: new-exception-ctx
	.fut-low-level: must-be-resolved
	.fut-utils: resolved then2
	.io: exit-code print-err-sync print-err-sync-no-newline
	.posix: eagain einval esrch pthread-create pthread-join pthread-t
	.runtime: global-ctx new-ctx new-vat thread-function thread-local-stuff vat
	.str-utils: to-str
	.thread-utils: new-condition new-lock

main-ptr alias
	fun-ptr2 fut<exit-code> ctx arr<str>

| Treated specially by the compiler
rt-main exit-code(argc int32, argv ptr c-str, main-ptr main-ptr) trusted noctx summon
	drop: argv.deref to-str

	| TODO: detect # hardware processors to use for n-threads
	| TODO: get-nprocs
	n-threads = one as<nat>
	gctx-by-val = new<by-val<global-ctx>>
		lk. new-lock
		vats. empty-arr<vat>
		n-live-threads. n-threads
		may-be-work-to-do. new-condition
		is-shut-down. false
		any-unhandled-exceptions?. false
	gctx = gctx-by-val ref-of-val
	vat-by-val = new-vat: gctx, zero, n-threads
	vat = vat-by-val ref-of-val

	gctx.vats := new<arr<vat>> one, vat.ptr-to

	main-fut = gctx do-main vat, argc, argv, main-ptr

	n-threads run-threads gctx

	when
		gctx any-unhandled-exceptions?
			one
		else
			match main-fut.must-be-resolved
				ok o
					o.value
				err e
					print-err-sync-no-newline: "main failed: "
					print-err-sync: e.value.message
					one

do-main fut exit-code(gctx global-ctx, vat vat, argc int32, argv ptr c-str, main-ptr main-ptr) trusted noctx
	| Before we start the engine, add a task.
	| Create a ctx manually so we can call functions that need it when creating the task
	ectx = new-exception-ctx
	tls = new<by-val<thread-local-stuff>> ectx.ref-of-val
	ctx-by-val = new-ctx: gctx, tls.ref-of-val, vat, zero
	ctx = ctx-by-val ref-of-val
	add = as<fun2<fut<exit-code>, arr<c-str>, main-ptr>>: \all-args main-ptr
		add-first-task: all-args, main-ptr
	all-args = new<arr<c-str>> argc.to-int.unsafe-to-nat, argv
	ctx call-with-ctx add, all-args, main-ptr

thread-args record mut
	by-ref
	thread-id nat
	gctx global-ctx

| TODO: if mut-bag-node is in unmanaged memory, don't need ctx for this
| We want main-fut to be available immediately, not after having run some user code.
| So we create main-fut now, and forward the result of 'main' to that.
add-first-task fut exit-code(all-args arr c-str, main-ptr fun-ptr2 fut<exit-code> ctx arr<str>) unsafe
	| 'then' is useful here -- it handles any errors in 'main' and gets us main-fut immediately.
	| TODO: 'then' overload for fut<void> taking lambda with 0 params
	pass.resolved.as<fut<void>> then2 \
		| First argument is the path to this executable.
		args = all-args tail
		main-ptr call: get-ctx, args map {it.to-str}

| Each thread will get the thread ID, and the common arguments.
| TODO: ?t must be a reference type
run-threads void(n-threads nat, gctx global-ctx) noctx unsafe summon
	threads = n-threads unmanaged-alloc-elements<pthread-t>
	thread-args = n-threads unmanaged-alloc-elements<by-val<thread-args>>

	actual-n-threads = n-threads noctx-decr

	start-threads-recur: zero, actual-n-threads, threads, thread-args, gctx
	thread-function: actual-n-threads, gctx
	join-threads-recur: zero, actual-n-threads, threads

	threads unmanaged-free
	thread-args unmanaged-free

start-threads-recur void
	i nat
	n-threads nat
	threads ptr pthread-t
	thread-args ptr by-val<thread-args>
	gctx global-ctx
spec
	noctx
	unsafe
	summon
body
	when
		i == n-threads
			pass
		else
			thread-arg-ptr = thread-args + i
			thread-arg-ptr set new i, gctx
			thread-ptr = threads + i
			fn = as<fun-ptr1<any-ptr, any-ptr>>: \args-ptr
				args-ptr thread-fun
			err = thread-ptr.as-cell pthread-create null, fn, thread-arg-ptr.as-any-ptr
			when
				err zero?
					i.noctx-incr start-threads-recur n-threads, threads, thread-args, gctx
				err == eagain
					| TODO: warn and make do with the threads it does let us create (so long as there's at least one)
					todo
				else
					| Fatal error
					todo

thread-fun any-ptr(args-ptr any-ptr) noctx unsafe summon
	args = args-ptr as-ref<thread-args>
	args.thread-id thread-function args.gctx
	null

join-threads-recur void(i nat, n-threads nat, threads ptr pthread-t) noctx unsafe summon
	when
		i == n-threads
			pass
		else
			(threads + i).deref join-one-thread
			i.noctx-incr join-threads-recur n-threads, threads

join-one-thread void(tid pthread-t) noctx unsafe summon
	thread-return = new<by-val<cell<any-ptr>>> null
	err = tid pthread-join thread-return.ref-of-val
	when
		err zero?
			pass
		err == einval
			todo
		err == esrch
			todo
		else
			todo
	hard-assert: thread-return.ref-of-val.get null?
