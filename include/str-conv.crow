import
	.bootstrap:
		==, >, ?, bool, char, false, float, int, int16, int32, nat, nat16, nat32, none, opt, some,
		str, todo, to-int, to-nat, true, value
	.collection.arr: +, empty?, subscript
	.collection.arr-util: first, tail
	.collection.dict: dict, each
	.collection.mut-list: move-to-arr, mut-list, push, push-all, size
	.number-utils:
		+, *, /, abs, mod, multiple-of?, neg, negative?, to-int, to-float, truncate-to-int
	.opt-utils: opt-map

to-str str(b bool) noctx
	b ? "true", "false"

to-str str(c char)
	[c]

parse-bool bool(a str)
	if a == "true"
		true
	elif a == "false"
		false
	else
		todo

to-str str(n nat)
	if n == 0
		"0"
	elif n == 1
		"1"
	elif n == 2
		"2"
	elif n == 3
		"3"
	elif n == 4
		"4"
	elif n == 5
		"5"
	elif n == 6
		"6"
	elif n == 7
		"7"
	elif n == 8
		"8"
	elif n == 9
		"9"
	else
		hi = to-str: n / 10
		lo = to-str: n mod 10
		hi + lo

to-str<?t> spec
	to-str str(a ?t)

to-str str(a str)
	a

to-str str(a dict<?k, ?v>) to-str<?k> to-str<?v>
	res = mut-list<char>
	res push "["
	a each \k, v
		if res.size > 1
			res push-all ", "
		res push-all k.to-str
		res push-all " -> "
		res push-all v.to-str
	res push "]"
	res move-to-arr

to-str str(a opt ?t) to-str<?t>
	match a
	as none
		"none"
	as some s
		"some(" + s.value.to-str + ")"

to-str str(n nat32)
	n.to-nat to-str

to-str str(n nat16)
	n.to-nat to-str

to-str str(i int)
	a = i.abs to-str
	| TODO: string interpolation
	i.negative? ? ("-" + a), a

to-str str(i int32)
	i.to-int to-str

to-str str(i int16)
	i.to-int to-str

to-str str(a float)
	| TODO: Use a real float to string algorithm
	times-100 = (a * 100.0).truncate-to-int
	hundredths = times-100 mod 100
	tenths = hundredths / 10
	whole-part = (times-100 / 100).to-str
	if hundredths == 0
		whole-part
	elif hundredths multiple-of? 10
		whole-part + "." + tenths.to-str
	else
		whole-part + "." + hundredths.to-str

char-to-nat opt nat(c char)
	if c == "0"
		0 some
	elif c == "1"
		1 some
	elif c == "2"
		2 some
	elif c == "3"
		3 some
	elif c == "4"
		4 some
	elif c == "5"
		5 some
	elif c == "6"
		6 some
	elif c == "7"
		7 some
	elif c == "8"
		8 some
	elif c == "9"
		9 some
	else
		none

parse-nat opt nat(a str)
	if a empty?
		none
	else
		a parse-nat-recur 0

parse-nat-recur opt nat(a str, accum nat)
	if a empty?
		accum some
	else
		match a.first.char-to-nat
		as none
			none
		as some s
			a.tail parse-nat-recur: accum * 10 + s.value

parse-int opt int(a str)
	if a[0] == "-"
		a.tail.parse-nat opt-map {it neg}
	else
		(a[0] == "+" ? a.tail, a).parse-nat opt-map {it to-int}

| TODO: handle the decimal point!
parse-float opt float(a str)
	a.parse-nat opt-map {it to-float}
