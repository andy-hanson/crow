no-std
import
	.bool: ?, bool, false, true
	.col.arr: ==, ~, empty?, subscript
	.col.arr-util: tail
	.col.mut-list: ~=, move-to-arr!, mut-list
	.compare: <
	.exception: unreachable
	.number:
		==, <=>, +, *, /, abs, float, int, int16, int32, mod, nat, nat8, nat16, nat32, multiple-of?,
		to-int, to-float, to-nat, truncate-to-int
	.opt: map, none, opt, some
	.str: char, str

# "true" or "false".
to-str str(b bool) noctx
	b ? "true", "false"

# Str containing a single character.
to-str str(c char)
	[c]

# Parses "true" or "false".
parse-bool opt bool(a str)
	if a == "true"
		true some
	elif a == "false"
		false some
	else
		none

###
Converts a nat to a str.
Result is only digits, no punctuation.
###
to-str str(a nat)
	a to-base 10

.digit-to-str str(a nat)
	if a == 0
		"0"
	elif a == 1
		"1"
	elif a == 2
		"2"
	elif a == 3
		"3"
	elif a == 4
		"4"
	elif a == 5
		"5"
	elif a == 6
		"6"
	elif a == 7
		"7"
	elif a == 8
		"8"
	elif a == 9
		"9"
	elif a == 10
		"a"
	elif a == 11
		"b"
	elif a == 12
		"c"
	elif a == 13
		"d"
	elif a == 14
		"e"
	elif a == 15
		"f"
	else
		unreachable

to-binary str(a nat)
	a to-base 2

to-hex str(a nat)
	a to-base 16
to-hex str(a nat8)
	a to-base 16

.to-base str(a nat, base nat)
	if a < base
		a digit-to-str
	else
		(a / base to-base base) ~ (a mod base).digit-to-str
.to-base str(a nat8, base nat)
	a.to-nat to-base base

# Spec of any type that could be converted to a str.
to-str<?a> spec
	to-str str(a ?a)

# Identity function to satisfy the `to-str` spec.
to-str str(a str)
	a

to-str str(a opt ?a) to-str<?a>
	if v ?= a
		"some({v})"
	else
		"none"

to-str str(n nat32)
	n.to-nat to-str

to-str str(n nat16)
	n.to-nat to-str

to-str str(i int)
	a = i.abs to-str
	i < 0 ? "-{a}", a

to-str str(i int32)
	i.to-int to-str

to-str str(i int16)
	i.to-int to-str

to-str str(a float)
	# TODO: Use a real float to str algorithm
	times-100 = (a * 100.0).truncate-to-int
	hundredths = times-100 mod 100
	tenths = hundredths / 10
	whole-part = (times-100 / 100).to-str
	if hundredths == 0
		whole-part
	elif hundredths multiple-of? 10
		"{whole-part}.{tenths}"
	else
		"{whole-part}.{hundredths}"

.char-to-nat opt nat(c char)
	if c == "0"
		0 some
	elif c == "1"
		1 some
	elif c == "2"
		2 some
	elif c == "3"
		3 some
	elif c == "4"
		4 some
	elif c == "5"
		5 some
	elif c == "6"
		6 some
	elif c == "7"
		7 some
	elif c == "8"
		8 some
	elif c == "9"
		9 some
	else
		none

###
Parse digits as a nat.
Return none if the str contains any punctuation or whitespace.
###
parse-nat opt nat(a str)
	if a empty?
		none
	else
		a parse-nat-recur 0
.parse-nat-recur opt nat(a str, accum nat)
	if a empty?
		accum some
	else
		if v ?= a[0].char-to-nat
			a.tail parse-nat-recur: accum * 10 + v
		else
			none

###
The str should be a series of digits, optionally preceded by "-" or "+".
If not, this returns `none`.
###
parse-int opt int(a str)
	if a[0] == "-"
		a.tail.parse-nat map {it.to-int * -1}
	else
		(a[0] == "+" ? a.tail, a).parse-nat map {it to-int}

# TODO: handle the decimal point!
###
The str should be a valid int, optionally followed by a "." and then a valid int.
If not, this returns `none`.
###
parse-float opt float(a str)
	a.parse-nat map {it to-float}


region Interpolation

interp record mut
	inner mut-list char

interp interp()
	interp: mut-list

with-str interp(a interp, b str)
	a.inner ~= b
	a

with-value interp(a interp, b ?a) to-str<?a>
	a with-str b.to-str

finish str(a interp)
	a.inner move-to-arr!
