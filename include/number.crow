no-std
import
	.bool: ?, and, bool, or
	.compare: !=, <, <=, >, >=
	.fun: subscript
	.misc: ->, arrow, from, to, void
	.opt: opt, some
	.private.number-low-level:
		unsafe-div, unsafe-to-int, unsafe-to-int32, unsafe-to-nat, unsafe-to-nat32, unsafe-mod,
		wrap-add, wrap-mul, wrap-sub
	.ptr: size-of
	.private.exception-low-level: assert, forbid
export
	.private.number-low-level:
		==, <=>, even?, float, float32, int, int8, int16, int32, int64, max-int8, max-int, max-int16,
		max-int32, max-nat, max-nat8, max-nat16, max-nat32, min-int8, min-int16, min-int32,
		min-int, nat, nat8, nat16, nat32, nat64, odd?, to-int, to-nat, unsafe-to-nat8

deep-size-bytes nat(a nat) unsafe
	a size-of

region conversion

###
Convert a nat to float.
Result is approximate for high values.
###
to-float float(a nat) noctx builtin
###
Convert an int to float.
Result is approximate for high values.
###
to-float float(a int) noctx builtin
to-float float(a float32) noctx builtin
###
Convert a float to int by tossing any fractional part.
###
truncate-to-int int(a float) noctx builtin

region arithmetic

# True if `b * c == a` for some `c`.
multiple-of? bool(a nat, b nat)
	(a mod b) == 0

# Add two nats. Fail if the result would overflow.
+ nat(a nat, b nat)
	res = a wrap-add b
	assert: res >= a and: res >= b
	res
+ nat8(a nat8, b nat8)
	res = a wrap-add b
	assert: res >= a and res >= b
	res

# Subtract two nats. Fail if the result would be negative.
- nat(a nat, b nat)
	assert: a >= b
	a wrap-sub b
- nat8(a nat8, b nat8)
	assert: a >= b
	a wrap-sub b
- nat16(a nat16, b nat16)
	assert: a >= b
	a wrap-sub b
- nat32(a nat32, b nat32)
	assert: a >= b
	a wrap-sub b

# Multiply two nats. Fail if the result would overflow.
* nat(a nat, b nat)
	# TODO: better safety check
	if a == 0 or: b == 0
		0
	else
		res = a wrap-mul b
		assert: res / b == a
		assert: res / a == b
		res
###
A divided by b, taking the floor.
Throws if `b == 0`.
###
/ nat(a nat, b nat) trusted
	forbid: b == 0
	a unsafe-div b

# Like 'a / b' but takes the ceil instead of the floor.
div-ceil nat(a nat, b nat)
	res = a / b
	if res * b == a
		res
	else
		res + 1

# Remainder of `a / b`.
mod nat(a nat, b nat) trusted
	forbid: b == 0
	a unsafe-mod b

# Remainder of `a / b.to-int`.
mod nat(a int, b nat)
	forbid: b == 0
	if a < 0
		abs-mod = a.abs mod b
		abs-mod == 0 ? 0, b - abs-mod
	else
		a.to-nat mod b

+ int(a int, b int)
	# TODO: safety check
	a wrap-add b
+ int32(a int32, b int32)
	a.to-int wrap-add b.to-int to-int32

- int(a int, b int)
	# TODO: safety check
	a wrap-sub b
- int32(a int32, b int32)
	a.to-int wrap-sub b.to-int to-int32

* int32(a int32, b int32)
	a.to-int wrap-mul b.to-int to-int32
* int(a int, b int)
	# TODO: safety check
	a wrap-mul b
/ int(a int, b int) trusted
	forbid: b == 0
	forbid: a == min-int and: b == -1
	a unsafe-div b

# Convert a nat to an int. Fail if the result would overflow.
to-int int(n nat)
	assert: n < max-int.to-nat
	n unsafe-to-int
# Convert an int to 32 bits. Fail if the result would overflow.
to-int32 int32(a int)
	assert: a >= min-int32.to-int
	assert: a <= max-int32.to-int
	a unsafe-to-int32
to-int32 int32(a nat)
	a.to-int to-int32
to-int32 int32(a nat32)
	a.to-nat to-int32
to-int32 int32(a nat16)
	a.to-nat to-int32

clamp-to-nat nat(a int)
	if a < 0
		0
	else
		a unsafe-to-nat

clamp-to-int32 int32(a int) noctx trusted
	if a < min-int32.to-int
		min-int32
	elif a > max-int32.to-int
		max-int32
	else
		a unsafe-to-int32

clamp-add int32(a int32, b int32) noctx
	a.to-int wrap-add b.to-int clamp-to-int32

# Convert an int to a nat. Fail if it's negative.
to-nat nat(a int)
	forbid: a < 0
	a unsafe-to-nat
to-nat nat(a int32)
	a.to-int to-nat

to-nat8 nat8(a nat64)
	assert: a <= max-nat8.to-nat
	a unsafe-to-nat8
to-nat32 nat32(a nat16) noctx trusted
	a.to-nat unsafe-to-nat32

# Convert a nat to 32 bits. Fail if the result would overflow.
to-nat32 nat32(a nat)
	assert: a < max-nat32.to-nat
	a unsafe-to-nat32

wrap-to-nat32 nat32(a nat) noctx trusted
	# TODO: safe?
	a unsafe-to-nat32

# Absolute value of an int, as a nat.
abs nat(a int)
	to-nat: a < 0 ? a * -1, a

abs float(a float) noctx
	a < 0 ? a * -1, a

^ nat(a nat, b nat)
	if b == 0
		1
	elif b even?
		(a * a) ^ (b / 2)
	else
		a * a ^ (b - 1)

region float

# Add two floats. Never fails.
+ float(a float, b float) noctx builtin
+ float32(a float32, b float32) noctx builtin
# Subtract two floats. Never fails.
- float(a float, b float) noctx builtin
- float32(a float32, b float32) noctx builtin
# Multiply two floats. Never fails.
* float(a float, b float) noctx builtin
* float32(a float32, b float32) noctx builtin
# Divide two floats. UB if `b == 0`.
unsafe-div float(a float, b float) noctx unsafe builtin
unsafe-div float32(a float32, b float32) noctx unsafe builtin
# Divide two floats. Fail if `b == 0`.
/ float(a float, b float) trusted
	forbid: b == 0.0
	a unsafe-div b
/ float32(a float32, b float32) trusted
	forbid: b == 0.0
	a unsafe-div b

# Raise a float to a power.
^ float(a float, b nat) noctx
	if b == 0
		1.0
	else
		a * a ^ (b wrap-sub 1)
# Raise a float to a power.
^ float32(a float32, b nat) noctx
	if b == 0
		1.0
	else
		a * a ^ (b wrap-sub 1)

square-root float(a float) noctx extern<"sqrt">
square-root float32(a float32) noctx extern<"sqrt">

# True if the float is "Not A Number".
nan? bool(a float) noctx builtin
nan? bool(a float32) noctx builtin

region number iteration

###
Calls a function for each number from `a.from` to `a.to`.
`a.from` is inclusive and `a.to` is exclusive.
Does nothing if `a.from` is not less than `a.to`.
###
each void(a arrow<nat, nat>, f act void(nat))
	if a.from < a.to
		f[a from]
		a.from + 1 -> a.to each f

each-reverse void(a arrow<nat, nat>, f act void(nat))
	if a.from < a.to
		a.from each-reverse-recur (a.to wrap-sub 1), f
.each-reverse-recur void(low nat, cur nat, f act void(nat))
	f[cur]
	if cur != low
		low each-reverse-recur (cur wrap-sub 1), f

exists? bool(a arrow<nat, nat>, f act bool(nat))
	a.from < a.to and: f[a from] or: (a.from wrap-add 1) -> a.to exists? f

find opt nat(a arrow<nat, nat>, f act bool(nat))
	if a.from < a.to
		if f[a from]
			a.from some
		else
			(a.from wrap-add 1) -> a.to find f
