import
	.bootstrap
		+ - < any-ptr as as-ref bits-and bits-not bool byte by-val eight false gc-ctx-ptr get-ctx
		hard-assert hard-forbid incr lock nat nat64 noctx-decr none null null? opt pass ptr
		ptr-cast ref-of-val set seven size-of some to-nat true unsafe-div value void wrap-add
		wrap-mul zero?
	.posix: free malloc
	.thread-utils: acquire-lock new-lock release-lock

mark-ctx record mut
	memory-start ptr nat64
	memory-size-words nat
	marks ptr bool

mark void(ctx mark-ctx, ptr-any any-ptr, size-bytes nat) noctx unsafe summon
	size = size-bytes words-of-bytes
	ptr = ptr-any.ptr-cast as<ptr<nat64>>
	hard-assert: ptr.to-nat bits-and seven zero?
	index = ptr - ctx.memory-start
	if index < ctx.memory-size-words
		ctx.marks + index mark-recur size
	else
		pass

words-of-bytes nat(size-bytes nat) noctx trusted
	size-bytes.round-up-to-multiple-of-8 unsafe-div eight

round-up-to-multiple-of-8 nat(n nat) noctx
	n wrap-add seven bits-and: seven bits-not

mark-recur void(p ptr bool, size nat) noctx unsafe
	p set true
	if size zero?
		pass
	else
		p.incr mark-recur size.noctx-decr

mark-visit void(mark-ctx mark-ctx, value ?t) noctx unsafe builtin

gc record mut
	lk by-val lock
	context-head mut opt gc-ctx
	needs-gc mut bool
	is-doing-gc mut bool
	begin ptr byte
	next-byte ptr byte

| GC info specific to a ctx.
| Currently they all share the common GC and must take a lock every time they allocate.
gc-ctx record mut
	gc mut gc
	next-ctx mut opt gc-ctx

get-gc-ctx gc-ctx(gc gc) noctx unsafe
	gc.lk.ref-of-val acquire-lock
	res = match gc.context-head
	as none
		| NOTE: malloc'd memory is not traced for garbage collection.
		| This is fine as 'gc' is kept alive anyway.
		| TODO: `size-of<by-val<gc-ctx>>.malloc` should be legal
		c = (size-of<by-val<gc-ctx>> malloc) as-ref<gc-ctx>
		c set-gc gc
		c set-next-ctx none
		c
	as some s
		c = s.value
		gc set-context-head: c next-ctx
		c set-next-ctx none
		c
	gc.lk.ref-of-val release-lock
	res

return-gc-ctx void(gc-ctx gc-ctx) noctx unsafe
	gc = gc-ctx.gc
	gc.lk.ref-of-val acquire-lock
	gc-ctx set-next-ctx: gc context-head
	gc set-context-head: gc-ctx some
	gc.lk.ref-of-val release-lock

get-gc-ctx gc-ctx() unsafe
	get-ctx.gc-ctx-ptr as-ref

get-gc gc() unsafe
	get-gc-ctx.gc

new-gc by-val gc() noctx
	gc: new-lock, none, false, false, null, null

try-gc-alloc opt any-ptr(gc gc, size nat) noctx trusted
	| TODO: allocate from gc memory!
	size.unmanaged-alloc-bytes some

gc-alloc any-ptr(gc gc, size nat) trusted
	size unmanaged-alloc-bytes
	| match gc try-gc-alloc size
	| as none
	|	| TODO: throw an exception on OOM
	|	todo
	| as some s
	|	s.value

alloc any-ptr(size nat) unsafe
	get-gc gc-alloc size

unmanaged-alloc-bytes any-ptr(size nat) noctx unsafe
	res = size malloc
	hard-forbid: res null?
	res

unmanaged-alloc-elements ptr ?t(size-elements nat) noctx unsafe
	| TODO: wrap-mul is unsafe!
	bytes = size-elements wrap-mul size-of<?t> unmanaged-alloc-bytes
	bytes ptr-cast

unmanaged-free void(p ptr ?t) noctx unsafe
	p.ptr-cast free

