import
	.bootstrap
		+ - == < any-ptr as as-any-ptr as-ref bits-and bits-not bool byte by-val deref false
		gc-ctx-ptr get-ctx hard-assert hard-forbid incr lock nat nat8 nat64 noctx-decr none null
		null? opt pass ptr ptr-eq? ptr-less? ptr-less-eq? ptr-cast ref-of-val set size-of
		some todo to-nat true unsafe-div value void wrap-add
		wrap-mul
	.posix: free malloc
	.thread-utils: acquire-lock new-lock release-lock

memset void(begin any-ptr, value nat8, size nat) extern<"memset"> noctx unsafe

mark-ctx record mut
	memory-start ptr nat64
	memory-size-words nat
	marks ptr bool

mark void(ctx mark-ctx, ptr-any any-ptr, size-bytes nat) noctx unsafe summon
	size = size-bytes words-of-bytes
	ptr = ptr-any.ptr-cast as<ptr<nat64>>
	hard-assert: ptr.to-nat bits-and 7 == 0
	index = ptr - ctx.memory-start
	if index < ctx.memory-size-words
		ctx.marks + index mark-recur size
	else
		pass

words-of-bytes nat(size-bytes nat) noctx trusted
	size-bytes.round-up-to-multiple-of-8 unsafe-div 8

round-up-to-multiple-of-8 nat(n nat) noctx
	n wrap-add 7 bits-and: 7 bits-not

mark-recur void(p ptr bool, size nat) noctx unsafe
	p set true
	if size == 0
		pass
	else
		p.incr mark-recur size.noctx-decr

mark-visit void(mark-ctx mark-ctx, value ?t) noctx unsafe builtin

gc record mut
	lk by-val lock
	context-head mut opt gc-ctx
	needs-gc mut bool
	is-doing-gc mut bool
	size-words nat
	| 'mark-cur' and 'data-cur' run in parallel
	| mark-end must be `mark-begin + size-words` and similar for data-end
	mark-begin ptr bool
	mark-cur mut ptr bool
	mark-end ptr bool
	| We allocate data in increments of nat64
	data-begin ptr nat64
	data-cur mut ptr nat64
	data-end ptr nat64

| GC info specific to a ctx.
| Currently they all share the common GC and must take a lock every time they allocate.
gc-ctx record mut
	gc mut gc
	next-ctx mut opt gc-ctx

get-gc-ctx gc-ctx(gc gc) noctx unsafe
	gc.lk.ref-of-val acquire-lock
	res = match gc.context-head
	as none
		| NOTE: malloc'd memory is not traced for garbage collection.
		| This is fine as 'gc' is kept alive anyway.
		| TODO: `size-of<by-val<gc-ctx>>.malloc` should be legal
		c = (size-of<by-val<gc-ctx>> malloc) as-ref<gc-ctx>
		c set-gc gc
		c set-next-ctx none
		c
	as some s
		c = s.value
		gc set-context-head: c next-ctx
		c set-next-ctx none
		c
	gc.lk.ref-of-val release-lock
	res

return-gc-ctx void(gc-ctx gc-ctx) noctx unsafe
	gc = gc-ctx.gc
	gc.lk.ref-of-val acquire-lock
	gc-ctx set-next-ctx: gc context-head
	gc set-context-head: gc-ctx some
	gc.lk.ref-of-val release-lock

get-gc-ctx gc-ctx() unsafe
	get-ctx.gc-ctx-ptr as-ref

get-gc gc() unsafe
	get-gc-ctx.gc

new-gc by-val gc() noctx trusted
	| TODO: handle malloc failure
	size-words = 0x1000000
	mark-begin = ptr-cast<bool, byte>: malloc: size-words
	mark-end = mark-begin + size-words
	data-begin = ptr-cast<nat64, byte>: malloc: size-words wrap-mul size-of<nat64>
	data-end = data-begin + size-words

	mark-begin.as-any-ptr memset 0, size-words

	gc: new-lock, none, false, false, size-words, mark-begin, mark-begin, mark-end, data-begin, data-begin, data-end

fill-ptr-range void(cur ptr ?t, end ptr ?t, value ?t) noctx unsafe
	if cur ptr-eq? end
		pass
	else
		cur set value
		cur.incr fill-ptr-range end, value

| TODO: should not be necessary

validate-gc void(gc gc) noctx unsafe
	hard-assert: gc.mark-begin ptr-less-eq? gc.mark-cur
	hard-assert: gc.mark-cur ptr-less-eq? gc.mark-end
	hard-assert: gc.data-begin ptr-less-eq? gc.data-cur
	hard-assert: gc.data-cur ptr-less-eq? gc.data-end
	mark-idx = gc.mark-cur - gc.mark-begin
	data-idx = gc.data-cur - gc.data-begin
	hard-assert: gc.mark-end - gc.mark-begin == gc.size-words
	hard-assert: gc.data-end - gc.data-begin == gc.size-words
	hard-assert: mark-idx == data-idx

try-gc-alloc opt any-ptr(gc gc, size-bytes nat) noctx trusted
	gc validate-gc
	| some: size-bytes unmanaged-alloc-bytes
	size-words = size-bytes words-of-bytes
	cur = gc data-cur
	next = cur + size-words
	if next ptr-less? gc.data-end
		if gc.mark-cur range-free? size-words
			gc set-mark-cur: gc.mark-cur + size-words
			gc set-data-cur next
			cur.ptr-cast<byte, nat64> some<ptr<byte>>
		else
			gc set-mark-cur: gc.mark-cur incr
			gc set-data-cur: gc.data-cur incr
			gc try-gc-alloc size-bytes
	else
		none

range-free? bool(mark ptr bool, size nat) noctx unsafe
	if size == 0
		true
	elif mark deref
		false
	else
		mark.incr range-free? size.noctx-decr

gc-alloc any-ptr(gc gc, size nat) trusted
	match gc try-gc-alloc size
	as none
		| TODO: throw an exception on OOM
		todo
	as some s
		s.value

alloc any-ptr(size nat) unsafe
	get-gc gc-alloc size

unmanaged-alloc-bytes any-ptr(size nat) noctx unsafe
	res = size malloc
	hard-forbid: res null?
	res

unmanaged-alloc-elements ptr ?t(size-elements nat) noctx unsafe
	| TODO: wrap-mul is unsafe!
	bytes = size-elements wrap-mul size-of<?t> unmanaged-alloc-bytes
	bytes ptr-cast

unmanaged-free void(p ptr ?t) noctx unsafe
	p.ptr-cast free

