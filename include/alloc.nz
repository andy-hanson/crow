import
	.bootstrap
		+ - == < <= > any-ptr as as-any-ptr as-ref bits-and bits-not bool byte by-val deref false
		gc-ctx-ptr get-ctx hard-assert hard-forbid incr lock nat nat8 nat64 none not
		null? opt or ptr ptr-eq? ptr-less? ptr-less-eq? ptr-cast ref-of-val set size-of
		some todo to-nat true unsafe-div value void wrap-add wrap-incr wrap-mul wrap-sub
	.posix: free malloc
	.thread-utils: acquire-lock new-lock release-lock

memset void(begin any-ptr, value nat8, size nat) extern<"memset"> noctx unsafe

mark-ctx record mut
	memory-size-words nat
	marks ptr bool
	memory-start ptr nat64

| Returns true if the range is GC-allocated memory and was not already marked
mark bool(ctx mark-ctx, ptr-any any-ptr, size-bytes nat) noctx unsafe summon
	size-words = size-bytes words-of-bytes
	ptr = ptr-any.ptr-cast as<ptr<nat64>>
	hard-assert: ptr.to-nat bits-and 7 == 0
	index = ptr - ctx.memory-start
	gc-memory? = index < ctx.memory-size-words
	if gc-memory?
		hard-assert: index wrap-add size-words <= ctx.memory-size-words
		mark-start = ctx.marks + index
		mark-end = mark-start + size-words
		mark-range-recur: false, mark-start, mark-end
	else
		hard-assert: index wrap-add size-words > ctx.memory-size-words
		false

words-of-bytes nat(size-bytes nat) noctx trusted
	size-bytes.round-up-to-multiple-of-8 unsafe-div 8

round-up-to-multiple-of-8 nat(n nat) noctx
	n wrap-add 7 bits-and: 7 bits-not

mark-range-recur bool(marked-anything? bool, cur ptr bool, end ptr bool) noctx unsafe
	if cur ptr-eq? end
		marked-anything?
	else
		new-marked-anything? = marked-anything? or cur.deref.not
		cur set true
		mark-range-recur: new-marked-anything?, cur.incr, end

mark-visit void(mark-ctx mark-ctx, value ?a) noctx unsafe builtin

gc record mut
	lk by-val lock
	gc-count mut nat
	context-head mut opt gc-ctx
	needs-gc? mut bool
	size-words mut nat
	| 'mark-cur' and 'data-cur' run in parallel
	| mark-end must be `mark-begin + size-words` and similar for data-end
	mark-begin ptr bool
	mark-cur mut ptr bool
	mark-end mut ptr bool
	| We allocate data in increments of nat64
	data-begin ptr nat64
	data-cur mut ptr nat64
	data-end mut ptr nat64

gc-stats record
	by-val
	cur-word nat
	total-words nat
	words-used nat

words-free nat(a gc-stats) noctx
	a.total-words wrap-sub a.words-used

| Super unsafe
| WARN: Unfortunately this doesn't prevent the original allocation in new-gc, just forbids us to use it
set-hard-limit void(gc gc, size-words nat) noctx unsafe
	gc validate-gc
	hard-assert: size-words <= gc.size-words
	cur-index = gc.mark-cur - gc.mark-begin
	hard-assert: cur-index < size-words
	gc set-size-words size-words
	gc set-mark-end: gc.mark-begin + size-words
	gc set-data-end: gc.data-begin + size-words
	gc validate-gc

| WARN: this locks up the GC for a long time
get-stats gc-stats(gc gc) noctx unsafe
	gc validate-gc
	gc.lk.ref-of-val acquire-lock
	cur-word = gc.mark-cur - gc.mark-begin
	used-words-remaining = words-used-in-range: 0, gc.mark-cur, gc.mark-end
	total-words = gc.mark-end - gc.mark-begin
	gc.lk.ref-of-val release-lock
	gc-stats: cur-word, total-words, cur-word wrap-add used-words-remaining

words-used-in-range nat(acc nat, cur ptr bool, end ptr bool) noctx unsafe
	if cur ptr-eq? end
		acc
	else
		acc wrap-add cur.deref.to-nat words-used-in-range cur.incr, end

new-gc by-val gc() noctx unsafe
	| TODO: handle malloc failure
	| 16 MB
	size-words = 0x1000000
	mark-begin = ptr-cast<bool, byte>: malloc: size-words
	mark-end = mark-begin + size-words
	data-begin = ptr-cast<nat64, byte>: malloc: size-words wrap-mul size-of<nat64>
	data-end = data-begin + size-words

	mark-begin.as-any-ptr memset 0, size-words

	gc: new-lock, 0, none, false, size-words, mark-begin, mark-begin, mark-end, data-begin, data-begin, data-end

run-garbage-collection void(gc gc, gc-root ?a) noctx unsafe
	hard-assert: gc needs-gc?
	gc set-needs-gc? false
	gc set-gc-count: gc.gc-count wrap-incr
	gc.mark-begin.as-any-ptr memset 0, gc.size-words
	mark-ctx = as<by-val<mark-ctx>>: mark-ctx: gc.size-words, gc.mark-begin, gc.data-begin
	mark-ctx.ref-of-val mark-visit gc-root
	gc set-mark-cur gc.mark-begin
	gc set-data-cur gc.data-begin
	gc validate-gc

| GC info specific to a ctx.
| Currently they all share the common GC and must take a lock every time they allocate.
gc-ctx record mut
	gc mut gc
	next-ctx mut opt gc-ctx

force-needs-gc void(gc gc) unsafe
	gc set-needs-gc? true

get-gc-ctx gc-ctx(gc gc) noctx unsafe
	gc.lk.ref-of-val acquire-lock
	res = match gc.context-head
	as none
		| NOTE: malloc'd memory is not traced for garbage collection.
		| This is fine as 'gc' is kept alive anyway.
		| TODO: `size-of<by-val<gc-ctx>>.malloc` should be legal
		c = (size-of<by-val<gc-ctx>> malloc) as-ref<gc-ctx>
		c set-gc gc
		c set-next-ctx none
		c
	as some s
		c = s.value
		gc set-context-head: c next-ctx
		c set-next-ctx none
		c
	gc.lk.ref-of-val release-lock
	res

return-gc-ctx void(gc-ctx gc-ctx) noctx unsafe
	gc = gc-ctx.gc
	gc.lk.ref-of-val acquire-lock
	gc-ctx set-next-ctx: gc context-head
	gc set-context-head: gc-ctx some
	gc.lk.ref-of-val release-lock

get-gc-ctx gc-ctx() unsafe
	get-ctx.gc-ctx-ptr as-ref

get-gc gc() unsafe
	get-gc-ctx.gc

fill-ptr-range void(cur ptr ?t, end ptr ?t, value ?t) noctx unsafe
	if cur ptr-eq? end not
		cur set value
		cur.incr fill-ptr-range end, value

validate-gc void(gc gc) noctx unsafe
	hard-assert: gc.mark-begin ptr-less-eq? gc.mark-cur
	hard-assert: gc.mark-cur ptr-less-eq? gc.mark-end
	hard-assert: gc.data-begin ptr-less-eq? gc.data-cur
	hard-assert: gc.data-cur ptr-less-eq? gc.data-end
	mark-idx = gc.mark-cur - gc.mark-begin
	data-idx = gc.data-cur - gc.data-begin
	hard-assert: gc.mark-end - gc.mark-begin == gc.size-words
	hard-assert: gc.data-end - gc.data-begin == gc.size-words
	hard-assert: mark-idx == data-idx

try-gc-alloc opt any-ptr(gc gc, size-bytes nat) noctx trusted
	gc validate-gc
	| some: size-bytes unmanaged-alloc-bytes
	size-words = size-bytes words-of-bytes
	cur = gc data-cur
	next = cur + size-words
	if next ptr-less? gc.data-end
		if gc.mark-cur range-free? (gc.mark-cur + size-words)
			gc set-mark-cur: gc.mark-cur + size-words
			gc set-data-cur next
			cur.ptr-cast<byte, nat64> some<ptr<byte>>
		else
			gc set-mark-cur: gc.mark-cur incr
			gc set-data-cur: gc.data-cur incr
			gc try-gc-alloc size-bytes
	else
		none

range-free? bool(mark ptr bool, end ptr bool) noctx unsafe
	if mark ptr-eq? end
		true
	elif mark deref
		false
	else
		mark.incr range-free? end

gc-alloc any-ptr(gc gc, size nat) trusted
	match gc try-gc-alloc size
	as none
		| TODO: throw an exception on OOM
		todo
	as some s
		s.value

alloc any-ptr(size nat) unsafe
	get-gc gc-alloc size

unmanaged-alloc-bytes any-ptr(size nat) noctx unsafe
	res = size malloc
	hard-forbid: res null?
	res

unmanaged-alloc-elements ptr ?t(size-elements nat) noctx unsafe
	| TODO: wrap-mul is unsafe!
	bytes = size-elements wrap-mul size-of<?t> unmanaged-alloc-bytes
	bytes ptr-cast

unmanaged-free void(p ptr ?t) noctx unsafe
	p.ptr-cast free

