no-std
import
	crow/bits: |, <<
	crow/bool: bool
	crow/bytes-types: bytes2048, new
	crow/c-types: c-char, c-int, long, u-short, u-int, size_t
	crow/extra-types: err-t
	crow/misc: new, void
	crow/number: int64, max-nat64, nat8, nat16, nat32, nat64, new, to-nat16, to-nat32
	crow/private/bootstrap: c-string
	crow/pointer:
		*, any-const-pointer, any-mut-pointer, const-pointer, mut-pointer, new, pointer-cast,
		size-of, to-mut-pointer
	stdio: FILE
	sys/types: mode_t

CRITICAL_SECTION record by-ref extern
	n0 nat64
	n1 nat64
	n2 nat64
	n3 nat64
	n4 nat64

InitializeCriticalSection void(a CRITICAL_SECTION) extern<kernel32>

EnterCriticalSection void(a CRITICAL_SECTION) extern<kernel32>

LeaveCriticalSection void(a CRITICAL_SECTION) extern<kernel32>

DeleteCriticalSection void(a CRITICAL_SECTION) extern<kernel32>

CONDITION_VARIABLE record mut by-ref extern
	n nat64

InitializeConditionVariable void(a CONDITION_VARIABLE) extern<kernel32>

SleepConditionVariableCS bool(
	a CONDITION_VARIABLE,
	crit CRITICAL_SECTION,
	millis DWORD,
) extern<kernel32> summon

WakeAllConditionVariable void(a CONDITION_VARIABLE) extern<kernel32>

INFINITE DWORD() noctx
	0xffffffff

SYNCHRONIZATION_BARRIER record mut by-val extern
	Reserved1 DWORD
	Reserved2 DWORD
	Reserved3_0 ULONG_PTR
	Reserved3_1 ULONG_PTR
	Reserved4 DWORD
	Reserved5 DWORD

InitializeSynchronizationBarrier bool(
	lpBarrier SYNCHRONIZATION_BARRIER mut*,
	lTotalThreads long,
	lSpinCount long,
) extern<kernel32>

DeleteSynchronizationBarrier bool(lpBarrier SYNCHRONIZATION_BARRIER mut*) extern<kernel32>

EnterSynchronizationBarrier bool(
	lpBarrier SYNCHRONIZATION_BARRIER mut*,
	dwFlags EnterSynchronizationBarrierFlags,
) extern<kernel32>

EnterSynchronizationBarrierFlags flags<DWORD> extern
	SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY = 1
	SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY = 2
	SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE = 4

WORD alias
	nat16
DWORD alias
	nat32
DWORD64 alias
	nat64
ULONG_PTR alias
	nat64

GetLastError DWORD() extern<kernel32> summon
SetLastError void(err-code DWORD) extern<kernel32> summon

ERROR_BROKEN_PIPE DWORD() noctx
	109
ERROR_TIMEOUT DWORD() noctx
	1460

HANDLE alias
	any-mut-pointer

INVALID_HANDLE_VALUE HANDLE() noctx unsafe
	max-nat64 to-mut-pointer

WaitForSingleObject DWORD(handle HANDLE, milliseconds DWORD) extern<kernel32> summon

CloseHandle bool(a HANDLE) extern<kernel32>

_beginthreadex HANDLE(
	security any-mut-pointer,
	stack_size u-int,
	start-address fun* any-mut-pointer(any-mut-pointer),
	arglist any-mut-pointer,
	initflag u-int,
	thrdaddr u-int mut*,
) extern<c>

WAIT_OBJECT_0 DWORD() noctx
	0

GetStdHandle HANDLE(stdHandle std-handle) extern<kernel32> summon

std-handle enum<DWORD> extern
	# In winbase.h these are -10, -11, -12 even though DWORD is unsigned
	STD_INPUT_HANDLE = 0xfffffff6
	STD_OUTPUT_HANDLE = 0xfffffff5
	STD_ERROR_HANDLE = 0xfffffff4

WriteFile bool(
	hFile HANDLE,
	lpBuffer any-const-pointer,
	nNumberOfBytesToWrite DWORD,
	lpNumberOfBytesWritten DWORD mut*,
	lpOverlapped any-mut-pointer,
) extern<kernel32> summon

WIN32_FIND_DATAA record by-val extern
	dwFileAttributes DWORD
	ftCreationTime FILETIME
	ftLastAccessTime FILETIME
	ftLastWriteTime FILETIME
	nFileSizeHigh DWORD
	nFileSizeLow DWORD
	dwReserved0 DWORD
	dwReserved1 DWORD
	cFileName_STORAGE chars-max-path
	cAlternateFileName_STORAGE chars14

new WIN32_FIND_DATAA() noctx
	(), (), (), (), () , (), (), (), (), ()

cFileName c-char mut*(a WIN32_FIND_DATAA mut*) unsafe
	(&a->cFileName_STORAGE)::chars-max-path mut* pointer-cast

FILETIME record by-val extern
	dwLowDateTime DWORD
	dwHighDateTime DWORD

new FILETIME() noctx
	(), ()

DeleteFileA bool(lpFileName c-string) extern<kernel32> summon

GetFileAttributesA FileAttributes(lpFileName c-string) extern<kernel32> summon

FileAttributes flags<nat32> extern
	FILE_ATTRIBUTE_READONLY = 0x1
	FILE_ATTRIBUTE_HIDDEN = 0x2
	FILE_ATTRIBUTE_SYSTEM = 0x4
	FILE_ATTRIBUTE_DIRECTORY = 0x10
	FILE_ATTRIBUTE_ARCHIVE = 0x20
	FILE_ATTRIBUTE_DEVICE = 0x40
	FILE_ATTRIBUTE_NORMAL = 0x80
	FILE_ATTRIBUTE_TEMPORARY = 0x100
	FILE_ATTRIBUTE_SPARSE_FILE = 0x200
	FILE_ATTRIBUTE_REPARSE_POINT = 0x400
	FILE_ATTRIBUTE_COMPRESSED = 0x800
	FILE_ATTRIBUTE_OFFLINE = 0x1000
	FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x2000
	FILE_ATTRIBUTE_ENCRYPTED = 0x4000
	FILE_ATTRIBUTE_INTEGRITY_STREAM = 0x8000
	FILE_ATTRIBUTE_VIRTUAL = 0x10000
	FILE_ATTRIBUTE_NO_SCRUB_DATA = 0x20000
	FILE_ATTRIBUTE_PINNED = 0x80000
	FILE_ATTRIBUTE_UNPINNED = 0x100000
	FILE_ATTRIBUTE_RECALL_ON_OPEN = 0x40000
	FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 0x400000
	INVALID_FILE_ATTRIBUTES = 0xffffffff

FindFirstFileA HANDLE(lpFileName c-string, lpFindFileData WIN32_FIND_DATAA mut*) extern<kernel32> summon
FindNextFileA bool(hFindFile HANDLE, lpFindFileData WIN32_FIND_DATAA mut*) extern<kernel32> summon
FindClose bool(hFindFile HANDLE) extern<kernel32> summon

_getcwd c-char mut*(buffer c-char mut*, size size_t) extern<c> summon
_mkdir err-t(path c-string, mode mode_t) extern<c> summon
_pclose err-t(stream FILE) extern<c> summon
_popen FILE(command c-string, mode c-string) extern<c> summon

ERROR_FILE_NOT_FOUND DWORD() noctx
	2
ERROR_PATH_NOT_FOUND DWORD() noctx
	3
ERROR_NO_MORE_FILES DWORD() noctx
	18

FormatMessageA DWORD(
	dwFlags DWORD,
	lpSource any-const-pointer,
	dwMessageId DWORD,
	dwLanguageId DWORD,
	lpBuffer c-char mut*,
	nSize DWORD,
	arguments any-mut-pointer,
) extern<kernel32> summon

FORMAT_MESSAGE_IGNORE_INSERTS DWORD() noctx
	0x200
FORMAT_MESSAGE_FROM_STRING DWORD() noctx
	0x400
FORMAT_MESSAGE_FROM_HMODULE DWORD() noctx
	0x800
FORMAT_MESSAGE_FROM_SYSTEM DWORD() noctx
	0x1000
FORMAT_MESSAGE_ARGUMENT_ARRAY DWORD() noctx
	0x2000

LANG_NEUTRAL WORD()
	0
SUBLANG_NEUTRAL WORD()
	0

MAKELANGID DWORD(p WORD, s WORD) trusted noctx
	(s.to-nat32 << 10) | p.to-nat32

STARTUPINFOA record mut by-val extern
	cb DWORD
	lpReserved c-char mut*
	lpDesktop c-char mut*
	lpTitle c-char mut*
	dwX DWORD
	dwY DWORD
	dwXSize DWORD
	dwYSize DWORD
	dwXCountChars DWORD
	dwYCountChars DWORD
	dwFillAttribute DWORD
	dwFlags startup-flags
	wShowWindow WORD
	cbReserved2 WORD
	lpReserved2 nat8 mut*
	hStdInput HANDLE
	hStdOutput HANDLE
	hStdError HANDLE

startup-flags enum<DWORD> extern
	STARTF_USESHOWWINDOW = 1
	STARTF_USESIZE = 2
	STARTF_USEPOSITION = 4
	STARTF_USECOUNTCHARS = 8
	STARTF_USEFILLATTRIBUTE = 0x10
	STARTF_RUNFULLSCREEN = 0x20
	STARTF_FORCEONFEEDBACK = 0x40
	STARTF_FORCEOFFFEEDBACK = 0x80
	STARTF_USESTDHANDLES = 0x100

new STARTUPINFOA(dwFlags startup-flags, hStdInput HANDLE, hStdOutput HANDLE, hStdError HANDLE) unsafe noctx
	size = size-of@<STARTUPINFOA> to-nat32
	size, (), (), (), (), (), (), (), (), (), (), dwFlags, (), (), (), hStdInput, hStdOutput, hStdError

SECURITY_ATTRIBUTES record mut by-val extern
	nLength DWORD
	lpSecurityDescriptor any-mut-pointer
	bInheritHandle c-int

new SECURITY_ATTRIBUTES(lpSecurityDescriptor any-mut-pointer, bInheritHandle bool) unsafe noctx
	# TODO: shouldn't need parens
	(size-of@<SECURITY_ATTRIBUTES>).to-nat32, lpSecurityDescriptor, bInheritHandle ? 1 : 0

PROCESS_INFORMATION record mut by-val extern
	hProcess HANDLE
	hThread HANDLE
	dwProcessId DWORD
	dwThreadId DWORD

new PROCESS_INFORMATION() unsafe noctx
	(), (), (), ()

CreatePipe bool(
	hReadPipe HANDLE mut*,
	hWritePipe HANDLE mut*,
	lpPipeAttributes SECURITY_ATTRIBUTES*,
	nSize DWORD,
) extern<kernel32> summon

CreateSymbolicLinkA bool(
	lpSymlinkFileName c-string,
	lpTargetFileName c-string,
	dwFlags link-flags,
) extern<kernel32> summon

link-flags flags<DWORD> extern
	SYMBOLIC_LINK_FLAG_DIRECTORY = 1
	SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE = 2

SetHandleInformation bool(hObject HANDLE, dwMask DWORD, dwFlags DWORD) extern<kernel32> summon

HANDLE_FLAG_INHERIT DWORD() noctx
	1
HANDLE_FLAG_PROTECT_FROM_CLOSE DWORD() noctx
	2

CreateProcessA bool(
	lpApplicationName c-string,
	lpCommandLine c-string,
	lpProcessAttributes SECURITY_ATTRIBUTES*,
	lpThreadAttributes SECURITY_ATTRIBUTES*,
	bInheritHandles bool,
	dwCreationFlags DWORD,
	lpEnvironment any-mut-pointer,
	lpCurrentDirectory c-string,
	lpStartupInfo STARTUPINFOA*,
	lpProcessInformation PROCESS_INFORMATION mut*,
) extern<kernel32> summon

GetExitCodeProcess bool(hProcess HANDLE, lpExitCode DWORD mut*) extern<kernel32> summon

ReadFile bool(
	hFile HANDLE,
	lpBuffer nat8 mut*,
	nNumberOfBytesToRead nat32,
	lpNumberOfBytesRead nat32 mut*,
	# TODO: Overlapped type
	lpOverlapped any-mut-pointer,
) extern<kernel32> summon

MAKEWORD WORD(a nat8, b nat8) trusted
	(a.to-nat16 | (b.to-nat16 << 8))

WSAStartup c-int(wVersionRequested WORD, lpWSAData WSADATA mut*) extern<kernel32> summon

WSADATA record mut by-val extern
	wVersion WORD
	wHighVersion WORD
	iMaxSockets u-short
	iMaxUdpDg u-short
	lpVendorInfo c-char mut*
	szDescription_STORAGE chars257
	szSystemStatus_STORAGE chars129

new WSADATA() noctx unsafe
	(), (), (), (), (), (), ()

GetSystemInfo void(lpSystemInfo SYSTEM_INFO mut*) summon extern<kernel32>

SYSTEM_INFO record mut by-val extern
	DUMMYUNIONNAME DWORD
	dwPageSize DWORD
	lpMinimumApplicationAddress any-mut-pointer
	lpMaximumApplicationAddress any-mut-pointer
	dwActiveProcessorMask int64
	dwNumberOfProcessors DWORD
	dwProcessorType DWORD
	dwAllocationGranularity DWORD
	wProcessorLevel WORD
	wProcessorRevision WORD

new SYSTEM_INFO() noctx unsafe
	(), (), (), (), (), (), (), (), (), ()

# TODO: should be 'summon'
GetTickCount DWORD() extern<kernel32>

Sleep void(dwMilliseconds DWORD) summon extern<kernel32>

CONTEXT record extern by-val
	P1Home DWORD64
	P2Home DWORD64
	P3Home DWORD64
	P4Home DWORD64
	P5Home DWORD64
	P6Home DWORD64
	ContextFlags DWORD

	SegCs WORD
	SegDs WORD
	SegEs WORD
	SegFs WORD
	SegGs WORD
	SegSs WORD
	EFlags DWORD

	Dr0 DWORD64
	Dr1 DWORD64
	Dr2 DWORD64
	Dr3 DWORD64
	Dr6 DWORD64
	Dr7 DWORD64

	Rax DWORD64
	Rcx DWORD64
	Rdx DWORD64
	Rbx DWORD64
	Rsp DWORD64
	Rbp DWORD64
	Rsi DWORD64
	Rdi DWORD64
	R8 DWORD64
	R9 DWORD64
	R10 DWORD64
	R11 DWORD64
	R12 DWORD64
	R13 DWORD64
	R14 DWORD64
	R15 DWORD64

	Rip DWORD64
	# There's a lot more declared here, reserve enough space for it all
	opaque bytes2048
new CONTEXT(ContextFlags DWORD) noctx
	cf = ContextFlags
	0, 0, 0, 0, 0, 0, cf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ()

RtlCaptureContext void(context CONTEXT mut*) extern<kernel32>

# TODO: use a flags enum
CONTEXT_AMD64 DWORD() noctx
	0x00100000
CONTEXT_CONTROL DWORD() noctx
	CONTEXT_AMD64 | 0x00000001
CONTEXT_INTEGER DWORD() noctx
	CONTEXT_AMD64 | 0x00000002
CONTEXT_SEGMENTS DWORD() noctx
	CONTEXT_AMD64 | 0x00000004
CONTEXT_FLOATING_POINT DWORD() noctx
	CONTEXT_AMD64 | 0x00000008
CONTEXT_DEBUG_REGISTERS DWORD() noctx
	CONTEXT_AMD64 | 0x00000010
CONTEXT_FULL DWORD() noctx
	CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT
CONTEXT_ALL DWORD() noctx
	CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS
CONTEXT_XSTATE DWORD() noctx
	CONTEXT_AMD64 | 0x00000040

GetCurrentProcess HANDLE() extern<kernel32>
GetCurrentThread HANDLE() extern<kernel32>

IMAGE_FILE_MACHINE_AMD64 DWORD() noctx
	0x8664

# Not using bytes-types due to alignment

.chars2 record by-val extern
	.n0 c-char
	.n1 c-char
.new chars2() noctx
	"\0", "\0"

.chars4 record by-val extern
	.n0 chars2
	.n1 chars2
.new chars4() noctx
	(), ()

.chars8 record by-val extern
	.n0 chars4
	.n1 chars4
.new chars8() noctx
	(), ()

.chars14 record by-val extern
	.n0 chars8
	.n1 chars4
	.n2 chars2
.new chars14() noctx
	(), (), ()

.chars16 record by-val extern
	.n0 chars8
	.n1 chars8
.new chars16() noctx
	(), ()

.chars32 record by-val extern
	.n0 chars16
	.n1 chars16
.new chars32() noctx
	(), ()

.chars64 record by-val extern
	.n0 chars32
	.n1 chars32
.new chars64() noctx
	(), ()

.chars128 record by-val extern
	.n0 chars64
	.n1 chars64
.new chars128() noctx
	(), ()

.chars129 record by-val extern
	.n0 chars128
	.n1 c-char
.new chars129() noctx
	(), "\0"

.chars256 record by-val extern
	.n0 chars128
	.n1 chars128
.new chars256() noctx
	(), ()

.chars257 record by-val extern
	.n0 chars256
	.n1 c-char
.new chars257() noctx
	(), "\0"

# For char[MAX_PATH]
.chars-max-path record by-val extern
	.n0 chars256
	.n1 chars4
.new chars-max-path() noctx
	(), ()

# Just ensuring that private fields are used...
test
	_ = ()::chars2.n0
	_ = ()::chars2.n1
	_ = ()::chars4.n0
	_ = ()::chars4.n1
	_ = ()::chars8.n0
	_ = ()::chars8.n1
	_ = ()::chars14.n0
	_ = ()::chars14.n1
	_ = ()::chars14.n2
	_ = ()::chars16.n0
	_ = ()::chars16.n1
	_ = ()::chars32.n0
	_ = ()::chars32.n1
	_ = ()::chars64.n0
	_ = ()::chars64.n1
	_ = ()::chars128.n0
	_ = ()::chars128.n1
	_ = ()::chars129.n0
	_ = ()::chars129.n1
	_ = ()::chars256.n0
	_ = ()::chars256.n1
	_ = ()::chars257.n0
	_ = ()::chars257.n1
	_ = ()::chars-max-path.n0
	_ = ()::chars-max-path.n1
	()
