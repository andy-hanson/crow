no-std
import
	.bool: bool, false, true
	.cell: cell, set-subscript, subscript
	.col.arr: arr, empty?, size, subscript
	.col.arr-util: find-index, index-of, starts-with?, tail, try-remove-start
	.col.dict: dict, each
	.col.mut-dict: move-to-dict!, mut-dict, set-subscript
	.col.mut-list: fill-mut-list, move-to-arr!, set-subscript, subscript
	.compare: ==
	.exception: assert, forbid, throw
	.misc: ->, void
	.number: +
	.opt: force, has?, none, opt, some, value
	.str: str
	.str-conv: interp, finish, to-str, with-str, with-value

###
Returns none on failure to parse.
On success, returns an array of corresponding arguments.
Each argument will be 'none' if the argument was passed, else an array of argument values.
If the command line is "--a --c d" and arg-names are ["a", "b", "c"],
"a" will get `[].some`, "b" will get `none`, and "c" will get `["d"].some`.
###
parse-named-args opt arr opt arr str(args arr str, arg-names arr str)
	parsed = args parse-command-dynamic
	assert: parsed.nameless empty?, "Should be no nameless args"
	assert: parsed.after empty?

	values = arg-names.size fill-mut-list<opt arr str> none
	# TODO: should not need a type argument here
	help = false cell<bool>
	parsed.named each \key, value
		match arg-names index-of key
		as none
			if key == "help"
				help[] := true
			else
				throw: "Unexpected arg {key}"
		as some s
			idx = s value
			# TODO: duplicate argument error
			forbid: values[idx] has?
			values[idx] := value.some

	if help[]
		none
	else
		values.move-to-arr! some

single-str-or-throw str(a opt arr str, option-name str)
	match a
	as none
		throw: "Need {option-name}"
	as some s
		res = s value
		if res.size == 0
			throw: "{option-name} needs a value"
		if res.size == 1
			res[0]
		else
			throw: "{option-name} got too many values"

# Command line syntax:
# `foo bar --a 1 --b 2 3 -- x y z`
# nameless: foo bar
# named: a = 1, b = 2 3
# after: x y z
.parsed-command record
	nameless arr str
	named dict<str, arr str>
	after arr str

.parse-command-dynamic parsed-command(args arr str)
	# Find the location of the first name beginning in '--'
	match args find-index {it starts-with? "--"}
	as none
		parsed-command: args, [].dict, []
	as some s
		first-named-arg-index = s.value
		nameless = args[0 -> first-named-arg-index]
		rest = args[first-named-arg-index -> args.size]
		match rest find-index {it == "--"}
		as none
			parsed-command: nameless, rest.parse-named-args, []
		as some s2
			sep-index = s2 value
			named-args = rest[0 -> sep-index] parse-named-args
			parsed-command: nameless, named-args, rest[sep-index + 1 -> rest.size]

.parse-named-args dict<str, arr str>(args arr str)
	res = mut-dict<str, arr str>
	args parse-named-args-recur res
	res move-to-dict!

.parse-named-args-recur void(args arr str, builder mut-dict<str, arr str>)
	first-name = args[0] try-remove-start "--" force
	tl = args tail
	match tl find-index {it starts-with? "--"}
	as none
		builder[first-name] := tl
	as some s
		next-named-arg-index = s value
		builder[first-name] := tl[0 -> next-named-arg-index]
		tl[next-named-arg-index -> tl.size] parse-named-args-recur builder
