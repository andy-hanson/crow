import
	.bootstrap:
		<, ==, !=, as, atomic-bool, bool, false, fun-ptr1, hard-assert,
		hard-forbid, is-locked, lock, nat, noctx-decr, noctx-incr, not, null, null?, opt,
		subscript, todo, true, value, void
	.cell: cell, subscript
	.io.time-low-level: get-monotime-nsec, timestamp
	.posix.errno: eagain, einval, esrch
	.posix.pthread: pthread-create, pthread-join, pthread-t, pthread-yield
	.ptr: any-ptr, by-val, ptr, ptr-to, ref-of-val

region atomic

atomic-bool by-val atomic-bool() noctx
	atomic-bool: false

# TODO: works on any primitive type, not just bool
compare-exchange-strong bool(value-ptr ptr bool, expected-ptr ptr bool, desired bool) noctx builtin

try-change! bool(a atomic-bool, old-value bool) noctx trusted
	a.value.ptr-to compare-exchange-strong old-value.ptr-to, old-value.not

try-set! bool(a atomic-bool) noctx
	a try-change! false

try-unset! bool(a atomic-bool) noctx
	a try-change! true

must-unset! void(a atomic-bool) noctx unsafe
	did-unset = a try-unset!
	did-unset hard-assert

lock lock()
	lock: atomic-bool

lock-by-val by-val lock() noctx
	lock: atomic-bool

try-acquire! bool(a lock) noctx trusted
	a.is-locked.ref-of-val try-set!

acquire! void(a lock) noctx unsafe
	a acquire-recur! 0

.acquire-recur! void(a lock, n-tries nat) noctx unsafe
	if a.try-acquire! not
		if n-tries == 10000
			todo
		else
			yield-thread
			a acquire-recur! n-tries.noctx-incr

yield-thread void() noctx unsafe
	err = pthread-yield
	hard-assert: err == 0

release! void(a lock) noctx unsafe
	a.is-locked.ref-of-val must-unset!

with-lock ?t(a lock, f act ?t()) trusted
	a acquire!
	res = f[]
	a release!
	res

condition record mut
	lk by-val lock
	value mut nat

condition by-val condition() noctx
	condition: lock-by-val, 0

broadcast! void(c condition) noctx trusted
	c.lk.ref-of-val acquire!
	c.value := c.value noctx-incr
	c.lk.ref-of-val release!

last-checked alias
	nat

get-last-checked last-checked(a condition) noctx
	a.value

wait-on void(cond condition, until-time opt timestamp, last-checked last-checked) noctx unsafe summon
	# last-checked should have been called before a change, we wait until c.value is different
	if cond.value == last-checked
		yield-thread
		if until-time before-time?
			cond wait-on until-time, last-checked

before-time? bool(until-time opt timestamp) noctx summon
	match until-time
	as none
		true
	as some s
		get-monotime-nsec < s.value

# TODO: use atomic operations for this
thread-safe-counter record mut
	lk by-val lock
	value mut nat

thread-safe-counter by-val thread-safe-counter() noctx
	0 thread-safe-counter

thread-safe-counter by-val thread-safe-counter(init nat) noctx
	thread-safe-counter: lock-by-val, init

# Returns the old value
get-and-increment! nat(t thread-safe-counter) noctx unsafe
	t.lk.ref-of-val acquire!
	old = t value
	t.value := old noctx-incr
	t.lk.ref-of-val release!
	old

# Returns the old value
get-and-decrement! nat(t thread-safe-counter) noctx unsafe
	t.lk.ref-of-val acquire!
	old = t value
	hard-forbid: old == 0
	t.value := old noctx-decr
	t.lk.ref-of-val release!
	old

create-one-thread void
	tid cell pthread-t
	thread-arg any-ptr
	thread-fun fun-ptr1<any-ptr, any-ptr>
spec
	noctx
	unsafe
	summon
body
	err = tid pthread-create null, thread-fun, thread-arg
	if err != 0
		if err == eagain
			# TODO: warn and make do with the threads it does let us create (so long as there's at least one)
			todo
		else
			# Fatal error
			todo

join-one-thread void(tid pthread-t) noctx unsafe summon
	thread-return = as<by-val<cell<any-ptr>>>: cell: null
	err = tid pthread-join thread-return.ref-of-val
	if err != 0
		if err == einval
			todo
		elif err == esrch
			todo
		else
			todo
	hard-assert: thread-return.ref-of-val[] null?
