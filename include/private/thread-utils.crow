no-std
import
	..bool: ?, bool, false, not, true
	..cell: cell, subscript
	..compare: ==, !=
	..fun: fun-ptr1, subscript
	..io.time-low-level: timestamp, to-timespec
	..posix.errno: eagain, einval, esrch, etimedout
	..posix.extra-types: err-t
	..posix.pthread:
		pthread-condattr-destroy, pthread-condattr-init, pthread-condattr-setclock,
		pthread-condattr-t, pthread-cond-broadcast, pthread-cond-destroy, pthread-cond-init,
		pthread-cond-t, pthread-cond-timedwait, pthread-cond-wait, pthread-create, pthread-join,
		pthread-mutexattr-destroy, pthread-mutexattr-init, pthread-mutexattr-t,
		pthread-mutex-destroy, pthread-mutex-init, pthread-mutex-lock, pthread-mutex-t,
		pthread-mutex-unlock, pthread-t, pthread-yield
	..posix.time: clock-monotonic
	..ptr: any-ptr, by-val, null, null?, ptr, ptr-to, ref-of-val
	.bootstrap:
		as, atomic-bool, hard-assert, hard-forbid, is-locked, lock, nat, noctx-decr, noctx-incr,
		opt, todo, value, void, zeroed

region atomic

atomic-bool by-val atomic-bool() noctx
	atomic-bool: false

# TODO: works on any primitive type, not just bool
compare-exchange-strong bool(value-ptr ptr bool, expected-ptr ptr bool, desired bool) noctx builtin

try-change! bool(a atomic-bool, old-value bool) noctx trusted
	a.value.ptr-to compare-exchange-strong old-value.ptr-to, old-value.not

try-set! bool(a atomic-bool) noctx
	a try-change! false

try-unset! bool(a atomic-bool) noctx
	a try-change! true

must-unset! void(a atomic-bool) noctx unsafe
	did-unset = a try-unset!
	did-unset hard-assert

lock lock()
	lock: atomic-bool

lock-by-val by-val lock() noctx
	lock: atomic-bool

try-acquire! bool(a lock) noctx trusted
	a.is-locked.ref-of-val try-set!

acquire! void(a lock) noctx unsafe
	a acquire-recur! 0

.acquire-recur! void(a lock, n-tries nat) noctx unsafe
	if a.try-acquire! not
		if n-tries == 10000
			todo
		else
			yield-thread
			a acquire-recur! n-tries.noctx-incr

yield-thread void() noctx unsafe
	err = pthread-yield
	hard-assert: err == 0

release! void(a lock) noctx unsafe
	a.is-locked.ref-of-val must-unset!

with-lock ?a(a lock, f act ?a()) trusted
	a acquire!
	res = f[]
	a release!
	res

condition record mut
	# TODO:PRIVATE
	mutex-attr by-val pthread-mutexattr-t
	mutex by-val pthread-mutex-t
	cond-attr by-val pthread-condattr-t
	cond by-val pthread-cond-t
	# Incremented each time the condition fires.
	# Used to avoid waiting on a condition that has already changed.
	# WARN: this is mutable state, but should acquire the mutex first.
	sequence mut sequence-id

# Unsafe because you must remember to 'destroy-condition'
create-condition by-val condition() noctx unsafe
	res = as<by-val condition>: condition: zeroed, zeroed, zeroed, zeroed, 0
	hard-assert-posix-error: res.ref-of-val.mutex-attr.ref-of-val pthread-mutexattr-init
	hard-assert-posix-error: res.ref-of-val.mutex.ref-of-val pthread-mutex-init res.ref-of-val.mutex-attr.ref-of-val
	hard-assert-posix-error: res.ref-of-val.cond-attr.ref-of-val pthread-condattr-init
	hard-assert-posix-error: res.ref-of-val.cond-attr.ref-of-val pthread-condattr-setclock clock-monotonic
	hard-assert-posix-error: res.ref-of-val.cond.ref-of-val pthread-cond-init res.ref-of-val.cond-attr.ref-of-val
	res

destroy-condition void(a condition) noctx unsafe
	hard-assert-posix-error: a.mutex-attr.ref-of-val pthread-mutexattr-destroy
	hard-assert-posix-error: a.mutex.ref-of-val pthread-mutex-destroy
	hard-assert-posix-error: a.cond-attr.ref-of-val pthread-condattr-destroy
	hard-assert-posix-error: a.cond.ref-of-val pthread-cond-destroy

.hard-assert-posix-error void(err err-t) noctx unsafe
	hard-assert: err == 0

broadcast! void(a condition) noctx trusted
	hard-assert-posix-error: a.mutex.ref-of-val pthread-mutex-lock
	hard-assert-posix-error: a.cond.ref-of-val pthread-cond-broadcast
	a.sequence := a.sequence noctx-incr
	hard-assert-posix-error: a.mutex.ref-of-val pthread-mutex-unlock

sequence-id alias
	nat

get-sequence sequence-id(a condition) noctx unsafe
	hard-assert-posix-error: a.mutex.ref-of-val pthread-mutex-lock
	res = a sequence
	hard-assert-posix-error: a.mutex.ref-of-val pthread-mutex-unlock
	res

###
WARN: May wake up early. Use only to be avoid consuming CPU.
`until-time`, if set, should be from `get-monotime-nsec`.
'last-sequence' is to ensure that we don't wait at all if the condition has already triggered.
###
wait-on void(a condition, until-time opt timestamp, last-sequence sequence-id) noctx unsafe summon
	hard-assert-posix-error: a.mutex.ref-of-val pthread-mutex-lock
	if a.sequence == last-sequence
		hard-assert-posix-error: match until-time
		as none
			a.cond.ref-of-val pthread-cond-wait a.mutex.ref-of-val
		as some s
			abstime = s.value to-timespec
			err = a.cond.ref-of-val pthread-cond-timedwait a.mutex.ref-of-val, abstime.ptr-to
			err == etimedout ? 0, err
	hard-assert-posix-error: a.mutex.ref-of-val pthread-mutex-unlock

# TODO: use atomic operations for this
thread-safe-counter record mut
	lk by-val lock
	value mut nat

thread-safe-counter by-val thread-safe-counter() noctx
	0 thread-safe-counter

thread-safe-counter by-val thread-safe-counter(init nat) noctx
	thread-safe-counter: lock-by-val, init

# Returns the old value
get-and-increment! nat(t thread-safe-counter) noctx unsafe
	t.lk.ref-of-val acquire!
	old = t value
	t.value := old noctx-incr
	t.lk.ref-of-val release!
	old

# Returns the old value
get-and-decrement! nat(t thread-safe-counter) noctx unsafe
	t.lk.ref-of-val acquire!
	old = t value
	hard-forbid: old == 0
	t.value := old noctx-decr
	t.lk.ref-of-val release!
	old

create-one-thread void
	tid cell pthread-t
	thread-arg any-ptr
	thread-fun fun-ptr1<any-ptr, any-ptr>
spec
	noctx
	unsafe
	summon
body
	err = tid pthread-create null, thread-fun, thread-arg
	if err != 0
		if err == eagain
			# TODO: warn and make do with the threads it does let us create (so long as there's at least one)
			todo
		else
			# Fatal error
			todo

join-one-thread void(tid pthread-t) noctx unsafe summon
	thread-return = as<by-val<cell<any-ptr>>>: cell: null
	err = tid pthread-join thread-return.ref-of-val
	if err != 0
		if err == einval
			todo
		elif err == esrch
			todo
		else
			todo
	hard-assert: thread-return.ref-of-val[] null?
