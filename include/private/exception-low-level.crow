no-std
import
	..compare: ==
	..fun: subscript
	..posix.bytes-types: zero
	..posix.setjmp: jmp-buf, jmp-buf-tag, longjmp, setjmp
	..ptr: as-ref, by-val, null, null?, ptr-to
	.backtrace: backtrace
	.bootstrap:
		arr, as, exception, exception-ctx-ptr, get-ctx, hard-assert, hard-forbid, hard-unreachable,
		int32, str

exception-ctx record mut
	jmp-buf-ptr mut jmp-buf
	thrown-exception mut exception

exception-ctx by-val exception-ctx() noctx unsafe
	# Nothing on the exception-ctx initially
	exception-ctx: null, exception: "", backtrace: as<arr str>: []

get-exception-ctx exception-ctx() unsafe
	get-ctx.exception-ctx-ptr as-ref<exception-ctx>

catch-with-exception-ctx ?t(ec exception-ctx, try act ?t(), catcher act ?t(exception)) unsafe
	old-thrown-exception = ec thrown-exception
	old-jmp-buf = ec jmp-buf-ptr
	store = jmp-buf-tag: zero, 0, zero
	ec.jmp-buf-ptr := store ptr-to
	setjmp-result = ec.jmp-buf-ptr setjmp
	if setjmp-result == 0
		# Get here after setting the jump.
		# If it throws, we'll go to the above branch.
		res = try[]
		ec.jmp-buf-ptr := old-jmp-buf
		ec.thrown-exception := old-thrown-exception
		res
	else
		# This is what we threw in 'throw'
		hard-assert: setjmp-result == number-to-throw
		# Get here if we throw inside of `try`
		thrown-exception = ec thrown-exception
		# NOTE: changing thrown-exception back probably isn't really necessary
		ec.jmp-buf-ptr := old-jmp-buf
		ec.thrown-exception := old-thrown-exception
		catcher[thrown-exception]

###
Throw an exception (that already exists).
If you want to create and throw an exception, use `fail` instead.
`throw` is useful for rethrowing an exception that was already caught.
Throwing an exception does not modify its backtrace.
###
throw ?t(e exception) trusted
	exn-ctx = get-exception-ctx
	hard-forbid: exn-ctx.jmp-buf-ptr null?
	exn-ctx.thrown-exception := e
	exn-ctx.jmp-buf-ptr longjmp number-to-throw
	hard-unreachable

.number-to-throw int32()
	7
