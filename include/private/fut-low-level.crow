no-std
import
	..fun: subscript
	..opt: none, some, value
	..ptr: ref-of-val
	..result: err, ok, result
	.bootstrap:
		cb, exception, fut, fut-state-callbacks, fut-state-no-callbacks, fut-state-resolved,
		hard-unreachable, lk, next, set-state, state, void
	.thread-utils: lock-by-val, with-lock

unresolved fut ?a() unsafe
	fut: lock-by-val, fut-state-no-callbacks

resolve! void(f fut ?a, value ?a) unsafe
	f resolve-or-reject! value.ok

reject! void(f fut ?a, e exception) unsafe
	f resolve-or-reject! e.err

resolve-or-reject! void(f fut ?a, result result<?a, exception>) unsafe
	old-state = f.lk.ref-of-val with-lock \
		old = f.state
		f.state := match result
		as ok o
			fut-state-resolved: o.value
		as err e
			# TODO: should work without this variable
			ex = e value
			ex
		old

	match old-state
	as fut-state-no-callbacks
		void
	as fut-state-callbacks cbs
		cbs call-callbacks! result
	as fut-state-resolved
		hard-unreachable
	as exception
		hard-unreachable

.call-callbacks! void(cbs fut-state-callbacks ?a, value result<?a, exception>)
	cbs.cb[value]
	match cbs.next
	as none
		void
	as some s
		s.value call-callbacks! value

# TODO: PRIVATE
# WARN: Calls the callback immediately if possible
callback! void(f fut ?a, cb act void(result<?a, exception>)) unsafe
	f.lk.ref-of-val with-lock \
		match f state
		as fut-state-no-callbacks
			f.state := fut-state-callbacks: cb, none
		as fut-state-callbacks cbs
			f.state := fut-state-callbacks: cb, some: cbs
		as fut-state-resolved r
			cb[r.value ok]
		as exception e
			cb[e err]
