import
	.bootstrap: ==, bool, char, nat, none, opt, size, some, str, subscript, value, void
	.collection.arr: +, empty?, slice-after, slice-up-to
	.collection.arr-util: each, last, r-index-of, rtail
	.io.file: is-dir?, read-dir
	.number-utils: decr

parent-path str(a str)
	match a r-index-of "/"
	as none
		""
	as some s
		a slice-up-to s.value

child-path str(a str, child-name str)
	a + "/" + child-name

each-child-recursive void(path str, filter act bool(str), f act void(str)) summon
	if path is-dir?
		path.read-dir each \child-name
			if filter[child-name]
				path child-path child-name each-child-recursive filter, f
	else
		f[path]

last-index-of opt nat(s str, c char)
	if s empty?
		none
	elif s.last == c
		s.size.decr some
	else
		s.rtail last-index-of c

get-extension opt str(name str)
	match name last-index-of "."
	as none
		none
	as some s
		name slice-after s.value some

remove-extension str(name str)
	match name last-index-of "."
	as none
		name
	as some s
		name slice-up-to s.value

add-extension str(name str, ext str)
	name + "." + ext

change-extension str(name str, ext str)
	name.remove-extension add-extension ext

base-name str(path str)
	i = path last-index-of "/"
	match i
	as none
		path
	as some s
		path slice-after s.value
