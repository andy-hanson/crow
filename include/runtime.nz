| .str-utils for c-str.to-str
| TODO: don't import .io or .number-utils
import
	.alloc: gc get-gc-ctx needs-gc new-gc return-gc-ctx unmanaged-alloc-elements
	.arr-utils: at contains? empty? mut-arr noctx-at noctx-must-remove-unordered push-capacity-must-be-sufficient
	.bootstrap
		== != > ? arr as as-any-ptr as-ref bool by-val call-with-ctx ctx empty? err exception
		exclusion false fun-mut0 fun-mut1 gc-ctx-ptr gctx-ptr get-ctx hard-assert hard-forbid
		island-and-exclusion island-id lock message nat noctx-decr noctx-incr none not ok opt
		ref-of-val result size some todo true value void
	.exceptions: exception-ctx new-exception-ctx
	.io: print-err print-err-no-newline
	.mut-bag: add empty? head mut-bag mut-bag-node next-node new-mut-bag new-mut-bag-node set-head set-next-node value
	.thread-utils
		acquire-lock broadcast condition get-and-increment get-last-checked new-lock
		new-thread-safe-counter release-lock thread-safe-counter wait-on

get-gctx global-ctx() unsafe
	get-ctx.gctx-ptr as-ref

get-island island(island-id island-id) unsafe
	get-gctx.islands at island-id

get-cur-island island() unsafe
	get-ctx.island-id get-island

| This fun is required by the compiler.
cur-island-and-exclusion island-and-exclusion() unsafe
	c = get-ctx
	island-and-exclusion: c.island-id, c.exclusion

global-ctx record mut
	lk by-val lock
	| TODO: mut-arr
	islands mut arr island
	| if a thread finds no work to do, it decrements this and waits on 'may-be-work-to-do'.
	| if the last thread decrements this, it can't go to sleep!
	| But if there's no work to do, it can set 'is-shut-down' and wake up the other threads so they can shut down too.
	n-live-threads mut nat
	may-be-work-to-do by-val condition
	is-shut-down mut bool
	| Set to true the first time the default exception handler is invoked.
	| Can never be unset.
	any-unhandled-exceptions? mut bool

island record mut
	gctx global-ctx
	id island-id
	gc by-val gc

	| these variables are all protected by tasks-lock
	tasks-lock by-val lock
	tasks by-val mut-bag<task>
	| TODO: mut-set
	currently-running-exclusions by-val mut-arr<exclusion>
	| Number of threads currently performing tasks in this island
	n-threads-running mut nat

	| not protected by tasks-lock, thread-safe on its own
	next-exclusion by-val thread-safe-counter

	| if there's an exception, we'll enqueue this as a task.
	| Default is to print it and set `gctx.any-unhandled-exceptions`
	exception-handler mut fun-mut1 void exception


task record mut
	by-val
	| Unlike a fun-ref, this is stored in the island already, so no need to store island here too.
	| Also, the fun just returns 'void'. You can just use a fut-returning fun and drop the fut.
	| The fun runs using a ctx created from the exclusion.
	exclusion exclusion
	fun fun-mut0 void


new-exclusion exclusion(v island) noctx trusted
	v.next-exclusion.ref-of-val get-and-increment

new-mut-arr-by-val-with-capacity-from-unmanaged-memory by-val mut-arr<?t>(capacity nat) noctx unsafe
	mut-arr<?t>: false, 0, capacity, capacity unmanaged-alloc-elements<?t>

new-island by-val island(gctx global-ctx, id island-id, max-threads nat) summon noctx unsafe
	exclusions = max-threads new-mut-arr-by-val-with-capacity-from-unmanaged-memory<exclusion>
	island: gctx, id, new-gc, new-lock, new-mut-bag, exclusions, 0, new-thread-safe-counter, \exn
		exn default-exception-handler

default-exception-handler void(e exception) summon unsafe
	print-err-no-newline: "uncaught exception: "
	print-err: e.message.empty? ? "<<empty message>>", e.message
	get-gctx set-any-unhandled-exceptions? true

set-this-islands-exception-handler void(exception-handler fun-mut1 void exception) summon trusted
	get-cur-island set-exception-handler exception-handler

| Unsafe because you must ensure 'task' is safe to run in parallel.
add-task void(v island, t task) unsafe
	| Do allocation outside of the lock
	node = t new-mut-bag-node

	v.tasks-lock.ref-of-val acquire-lock
	v.tasks.ref-of-val add node
	v.tasks-lock.ref-of-val release-lock

	v.gctx.may-be-work-to-do.ref-of-val broadcast

thread-local-stuff record mut
	by-ref
	| Reusing the exception ctx to avoid needing to allocate it every time
	exception-ctx exception-ctx

thread-function void(thread-id nat, gctx global-ctx) noctx unsafe summon
	ectx = new-exception-ctx
	tls = as<by-val<thread-local-stuff>>: thread-local-stuff: ectx.ref-of-val
	thread-function-recur: thread-id, gctx, tls.ref-of-val

thread-function-recur void(thread-id nat, gctx global-ctx, tls thread-local-stuff) noctx unsafe summon
	if gctx is-shut-down
		gctx.lk.ref-of-val acquire-lock
		| Remove this thread from live threads for good.
		gctx set-n-live-threads: gctx.n-live-threads noctx-decr
		assert-islands-are-shut-down: 0, gctx.islands
		gctx.lk.ref-of-val release-lock
	else
		hard-assert: gctx.n-live-threads > 0
		| Get a task to do; or sleep.
		last-checked = gctx.may-be-work-to-do.ref-of-val get-last-checked

		match gctx choose-task
		as ok ok-chosen-task
			gctx do-task tls, ok-chosen-task.value
		as err e
			if e.value.last-thread-out
				hard-forbid: gctx.is-shut-down
				gctx set-is-shut-down true
				| Wake up sleeping threads so they can shut down
				gctx.may-be-work-to-do.ref-of-val broadcast
			else
				gctx.may-be-work-to-do.ref-of-val wait-on last-checked

			gctx.lk.ref-of-val acquire-lock
			| We decremented this while holding the lock, increment it again
			gctx set-n-live-threads: gctx.n-live-threads noctx-incr
			gctx.lk.ref-of-val release-lock

		| Do another task
		thread-function-recur: thread-id, gctx, tls

new-ctx by-val ctx(gctx global-ctx, tls thread-local-stuff, island island, exclusion exclusion) noctx unsafe
	ctx: gctx.as-any-ptr, island.id, exclusion, island.gc.ref-of-val.get-gc-ctx.as-any-ptr, tls.exception-ctx.as-any-ptr

return-ctx void(c ctx) noctx unsafe
	c.gc-ctx-ptr.as-ref return-gc-ctx

do-task void(gctx global-ctx, tls thread-local-stuff, chosen-task chosen-task) noctx unsafe summon
	island = chosen-task.island
	match chosen-task.task-or-gc
	as none
		| Means -- do GC
		| We might have avoided doing a task because GC was running.
		| Now those tasks can be done.
		todo
		gctx.may-be-work-to-do.ref-of-val broadcast
	as some some-task
		task = some-task.value
		ctx = new-ctx: gctx, tls, island, task.exclusion
		| TODO: parens should not be necessary
		| ctx.ref-of-val call-with-ctx (&do-task-with-ctx).as<fun-mut1<void, fun-mut0<void>>>, task.fun
		ctx.ref-of-val call-with-ctx task.fun
		island.tasks-lock.ref-of-val acquire-lock
		island.currently-running-exclusions.ref-of-val noctx-must-remove-unordered task.exclusion
		island.tasks-lock.ref-of-val release-lock
		ctx.ref-of-val return-ctx

	| We incremented this if choosing the task.
	island.tasks-lock.ref-of-val acquire-lock
	island set-n-threads-running island.n-threads-running.noctx-decr
	island.tasks-lock.ref-of-val release-lock

| do-task-with-ctx void(task-fun fun-mut0 void) unsafe summon
| 	{task-fun call} catch \exception
| 		{get-cur-island.exception-handler call exception} catch \exception-handler-exception
| 			| TODO: can print throw exceptions? Should have an unfailable version.
| 			print-err-sync: "exception handler threw an exception!"
| 			print-err-sync: exception-handler-exception.message

task-or-gc alias
	opt task

chosen-task record mut
	by-val
	island island
	| If none, do GC on the island.
	task-or-gc task-or-gc

no-chosen-task record
	by-val
	| If true, no threads are doing any work and we should exit the program.
	last-thread-out bool


choose-task result chosen-task no-chosen-task(gctx global-ctx) noctx unsafe
	gctx.lk.ref-of-val acquire-lock

	| TODO: more fair algorithm.
	| This looks for the first island with some work to do.
	| (That is unfair as island 0 will tend to get the most attention.)

	res = as<result<chosen-task, no-chosen-task>>: match gctx.islands choose-task-recur 0
	as none
		| Did not find a task to do.
		| (Tasks may have been added concurrently;
		| this is fine as we're about to wait on a condition and will immediately wake up if so.)
		| Need to do this here while we hold the lock
		gctx set-n-live-threads gctx.n-live-threads.noctx-decr
		| TODO:KILL
		hard-assert: gctx.n-live-threads == 0
		err: no-chosen-task: gctx.n-live-threads == 0
	as some s
		s.value ok

	gctx.lk.ref-of-val release-lock

	res


choose-task-recur opt chosen-task(islands arr island, i nat) noctx unsafe
	if i == islands.size
		none
	else
		island = islands noctx-at i
		match island choose-task-in-island
		as none
			islands choose-task-recur i.noctx-incr
		as some s
			some: chosen-task: island, s.value



| some(none) means: do a GC
choose-task-in-island opt task-or-gc(island island) noctx unsafe
	island.tasks-lock.ref-of-val acquire-lock

	| TODO: ref-of-val should be unnecessary for property access?
	res = as<opt<task-or-gc>>: if island.gc.ref-of-val.needs-gc
		if island.n-threads-running == 0
			| do GC
			none some
		else
			| do nothing -- a thread is running on this island
			| we can't do a GC now, but don't want to start a new task either
			| because that would block GC
			none
	else
		match island find-and-remove-first-doable-task
		as none
			none
		as some s
			s.value.some some

	if res.empty? not
		island set-n-threads-running island.n-threads-running.noctx-incr

	island.tasks-lock.ref-of-val release-lock

	res

task-and-nodes record mut
	by-val
	task task
	nodes opt mut-bag-node<task>

find-and-remove-first-doable-task opt task(island island) noctx unsafe
	tasks = island.tasks ref-of-val
	th = tasks head
	res = island find-and-remove-first-doable-task-recur tasks.head
	match res
	as none
		none
	as some s
		tasks set-head s.value.nodes
		s.value.task some

find-and-remove-first-doable-task-recur opt task-and-nodes(island island, opt-node opt mut-bag-node<task>) noctx unsafe
	match opt-node
	as none
		none
	as some s
		node = s value
		task = node value
		| Can't do this task if the exclusion is busy.
		| (If we don't have space to expand currently-running-exclusions,
		| shouldn't be starting a new task anyway.)
		exclusions = island.currently-running-exclusions ref-of-val
		task-ok = if exclusions contains? task.exclusion
			false
		else
			exclusions push-capacity-must-be-sufficient task.exclusion
			true

		if task-ok
			| Extract this task (return just its tail)
			some: task-and-nodes: task, node.next-node
		else
			match island find-and-remove-first-doable-task-recur node.next-node
			as none
				none
			as some ss
				tn = ss.value as<task-and-nodes>
				node set-next-node tn.nodes
				some: task-and-nodes: tn.task, node some

assert-islands-are-shut-down void(i nat, islands arr island) noctx unsafe
	if i != islands.size
		island = islands noctx-at i

		island.tasks-lock.ref-of-val acquire-lock
		hard-forbid: island.gc.ref-of-val needs-gc
		hard-assert: island.n-threads-running == 0
		hard-assert: island.tasks.ref-of-val empty?
		island.tasks-lock.ref-of-val release-lock

		assert-islands-are-shut-down: i.noctx-incr, islands
