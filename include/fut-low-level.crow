import
	.bootstrap:
		cb, exception, fut, fut-callback-node, fut-state-callbacks, fut-state-resolved,
		todo, head, lk, next-node, set-state, state, void
	.fun: subscript
	.opt: none, opt, value
	.ptr: ref-of-val
	.result: err, ok, result
	.thread-utils: lock-by-val, with-lock

unresolved fut ?t() unsafe
	fut: lock-by-val, fut-state-callbacks: none

resolve! void(f fut ?t, value ?t) unsafe
	f resolve-or-reject! value.ok

reject! void(f fut ?t, e exception) unsafe
	f resolve-or-reject! e.err

resolve-or-reject! void(f fut ?t, result result<?t, exception>) unsafe
	callbacks = f.lk.ref-of-val with-lock \
		callbacks = match f.state
		as fut-state-callbacks cbs
			cbs
		as fut-state-resolved
			todo
		as exception
			todo

		f.state := match result
		as ok o
			fut-state-resolved: o.value
		as err e
			# TODO: should work without this variable
			ex = e value
			ex
		callbacks

	callbacks.head call-callbacks! result

.call-callbacks! void(node opt fut-callback-node<?t>, value result<?t, exception>)
	match node
	as none
		void
	as some s
		# the fun-ref will return a fut<void>, just ignore it
		drop: s.value.cb[value]
		s.value.next-node call-callbacks! value

drop void(_ ?t) noctx
	void
