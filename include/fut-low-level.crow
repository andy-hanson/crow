no-std
import
	.bootstrap:
		cb, exception, fut, fut-state-callbacks, fut-state-no-callbacks, fut-state-resolved,
		hard-unreachable, lk, next, set-state, state, void
	.fun: subscript
	.opt: value
	.ptr: ref-of-val
	.result: err, ok, result
	.thread-utils: lock-by-val, with-lock

unresolved fut ?t() unsafe
	fut: lock-by-val, fut-state-no-callbacks

resolve! void(f fut ?t, value ?t) unsafe
	f resolve-or-reject! value.ok

reject! void(f fut ?t, e exception) unsafe
	f resolve-or-reject! e.err

resolve-or-reject! void(f fut ?t, result result<?t, exception>) unsafe
	old-state = f.lk.ref-of-val with-lock \
		old = f.state
		f.state := match result
		as ok o
			fut-state-resolved: o.value
		as err e
			# TODO: should work without this variable
			ex = e value
			ex
		old

	match old-state
	as fut-state-no-callbacks
		void
	as fut-state-callbacks cbs
		cbs call-callbacks! result
	as fut-state-resolved
		hard-unreachable
	as exception
		hard-unreachable

.call-callbacks! void(cbs fut-state-callbacks ?t, value result<?t, exception>)
	# the fun-ref will return a fut<void>, just ignore it
	drop: cbs.cb[value]
	match cbs.next
	as none
		void
	as some s
		s.value call-callbacks! value

drop void(_ ?t) noctx
	void
