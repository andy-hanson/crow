no-std
import
	..bool: and, bool, not
	..col.arr: ~, arr, size, subscript
	..compare: <
	..exception: assert
	..io.time: get-unix-time, seconds-since-epoch, unix-time
	..log: info, log
	..misc: ->
	..number: ==, <=>, -, nat, nat8, to-int
	..opt: none, opt, opt-join
	..serialize: from-bytes, to-8-bytes
	..str: str
	..str-conv: interp, finish, parse-int, parse-nat, to-str, with-str, with-value
	..str-util: try-split-once
	..tuple: a, b
	.random: random-nat64

login-cookie record
	timestamp unix-time
	cookie nat

cookie-matches? bool(a login-cookie, cookie nat, expire-seconds nat) summon
	now = get-unix-time seconds-since-epoch
	recent? = now - a.timestamp.seconds-since-epoch < expire-seconds.to-int
	if recent? not
		info log "Cookie expired! now: {now}, then: {a.timestamp.seconds-since-epoch}, expire after: {expire-seconds}"
	if a.cookie == cookie not
		info log "Wrong cookie! expected: {a cookie}, got: {cookie}"
	recent? and a.cookie == cookie

generate-login-cookie login-cookie() summon
	login-cookie: get-unix-time, random-nat64

to-bytes arr nat8(a login-cookie)
	a.timestamp.seconds-since-epoch.to-8-bytes ~ a.cookie.to-8-bytes

from-bytes login-cookie(a arr nat8)
	assert: a.size == 16
	login-cookie: a[0 -> 8].from-bytes.unix-time, a[8 -> 16].from-bytes

to-str str(a login-cookie)
	"{a.timestamp seconds-since-epoch}|{a cookie}"

parse-login-cookie opt login-cookie(a str)
	if split ?= a try-split-once "|"
		split.a.parse-int opt-join split.b.parse-nat, \time, cookie
			time.unix-time login-cookie cookie
	else
		none
