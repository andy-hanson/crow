no-std
import
	..bits: bits-and, bit-shift-left, bits-or
	..bool: and, bool, false, not, to-nat, true
	..cell: cell, subscript
	..col.arr: arr, begin-ptr, subscript
	..col.arr-util: each
	..col.mut-arr: cast-immutable, begin-ptr, size, uninitialized-mut-arr
	..col.mut-list: ~=, move-to-arr!, mut-list
	..col.sort: sort
	..compare: !=, <
	..exception: assert, forbid, throw
	..fun: subscript
	..misc: ->, as, drop, void
	..number: ==, <=>, +, int32, nat8, nat16, nat32, to-int, to-nat, to-nat32
	..opt: has?, opt, some
	..posix.bytes-types: zero
	..posix.dirent: dir, dirent, opendir, readdir-r
	..posix.errno: enoent, errno
	..posix.fcntl: o-creat, o-rdonly, o-trunc, o-wronly, open
	..posix.stat: empty-stat, mkdir, s-ifdir, s-ifmt, s-ifreg, stat, stat-t, st-mode
	..posix.types: ino-t, mode-t, off-t
	..posix.unistd: close, getcwd, lseek, read, readlink, rmdir, unlink, write
	..ptr: +, any-ptr, as-any-ptr, null?, ptr-cast, ptr-cast-from-extern, ptr-eq?, ref-eq?, size-of
	..str: ==, <=>, char, chars, c-str, size-bytes, str
	..str-conv: finish, interp, to-str, with-str, with-value
	..str-util: to-c-str, to-str
	..private.bootstrap: todo
	.path: child-path
	.posix-util: check-errno, check-posix-error
	.print: print

# True if this is the path of a directory.
is-dir? bool(path str) summon trusted
	path.to-c-str is-dir?

.is-dir? bool(path c-str) summon unsafe
	if stat ?= path get-stat
		(stat.st-mode bits-and s-ifmt) == s-ifdir
	else
		throw: "path does not exist: {path}"

# True if this is the path of a file.
is-file? bool(path str) summon
	path.to-c-str is-file?

.is-file? bool(path c-str) summon
	if stat ?= path get-stat
		(stat.st-mode bits-and s-ifmt) == s-ifreg
	else
		false

# True if something (like a file or directory) exists at the path.
path-exists? bool(path str) summon
	path.to-c-str path-exists?

.path-exists? bool(path c-str) summon
	path.get-stat has?

.get-dirent-name str(d dirent) unsafe
	# TODO: this is offsetof(d, d-name)
	name-offset = size-of<ino-t> + size-of<off-t> + size-of<nat16> + size-of<char>
	name-ptr = d.as-any-ptr + name-offset
	name-ptr.ptr-cast<char, nat8> to-str

.seek-set int32()
	0
#.seek-cur int32()
#	1
.seek-end int32()
	2

###
Returns the basename of all children of the directory.
Does not include ".." or ".".
###
read-dir arr str(path str) summon
	path.to-c-str read-dir

.read-dir arr str(path c-str) trusted summon
	dirp = path opendir
	# TODO: handle errors
	forbid: dirp.ptr-cast-from-extern<any-ptr, dir> null?
	res = mut-list<str>
	dirp read-dir-recur res
	res.move-to-arr! sort

.read-dir-recur void(dirp dir, res mut-list str) unsafe summon
	# Initial value of entry / result should not matter
	entry = dirent: 0, 0, 0, "\0", zero
	# TODO: should not need a type argument here
	result = entry cell<dirent>
	err = dirp readdir-r entry, result
	# TODO: handle error
	assert: err == 0
	if result[].as-any-ptr.null? not
		assert: result[] ref-eq? entry
		name = entry.get-dirent-name
		if name != "." and: name != ".."
			res ~= entry.get-dirent-name
		dirp read-dir-recur res

# Gets the path a link refers to.
read-link str(path str) summon trusted
	# TODO: smart small and retry if necessAry
	buff = 1000 uninitialized-mut-arr<char>
	size = path.to-c-str readlink buff.begin-ptr, buff.size
	if size == -1
		check-errno
	buff.cast-immutable[0 -> size.to-nat] str

###
Gets the path of the current executable.
If you did specify a built executable, this will be that.
If you didn't specify a built executable, this will be in a temp directory.
If you are using the interpreter, this will be the path to `crow`.
###
current-executable-path str() summon trusted
	"/proc/self/exe" read-link

# Gets the full contents of the file as a string.
read-file str(path str) summon
	if res ?= path try-read-file
		res
	else
		# TODO: don't print, warn
		print: "file does not exist: {path}"
		""

###
Writes the full contents of the file as a string.
If the file already exists, overwrites it.
###
write-file void(path str, content str) summon
	path.to-c-str write-file content

.write-file void(path c-str, content str) summon trusted
	permission-rdwr = 6 as<nat32>
	permission-rd = 4 as<nat32>
	permission = (permission-rdwr bit-shift-left 6) bits-or (permission-rd bit-shift-left 3) bits-or permission-rd
	flags = o-creat bits-or o-wronly bits-or o-trunc
	fd = path open flags, permission
	if fd == -1
		print: "failed to open file for write: {path}"
		print: "errno: {errno}"
		print: "flags: {flags}"
		print: "permission: {permission}"
		todo
	else
		wrote-bytes = fd write content.chars.begin-ptr.ptr-cast<nat8, char>, content.size-bytes
		if wrote-bytes != content.size-bytes.to-int
			if wrote-bytes == -1
				todo
			else
				# didn't write all the bytes?
				todo
		err = fd close
		if err != 0
			todo

###
Like `read-file`, but returns `none` if the file does not exist.
Other errors (like permission errors) still throw.
###
try-read-file opt str(path str) summon
	path.to-c-str try-read-file

.try-read-file opt str(path c-str) summon trusted
	if path is-file?
		fd = path open o-rdonly, 0
		if fd == -1
			if errno != enoent
				print: "failed to open file {path}"
				todo
		else
			file-size = fd lseek 0, seek-end
			# TODO: handle errors
			forbid: file-size == -1
			# TODO: this is just a sanity check
			assert: file-size < 1000000000
			if file-size == 0
				some: ""
			else
				# Go back to beginning
				off = fd lseek 0, seek-set
				# TODO: handle errors
				assert: off == 0

				# TODO: allocation can fail, then 'fd' is left open. Need finalizers
				file-size-nat = file-size.to-nat
				res = file-size-nat uninitialized-mut-arr<char>
				n-bytes-read = fd read res.begin-ptr.ptr-cast, file-size-nat
				# TODO: handle errors
				forbid: n-bytes-read == -1
				assert: n-bytes-read == file-size
				check-posix-error: fd close
				res.cast-immutable.str some

# Gets the current directory (of the user that ran the program).
current-directory str() summon trusted
	buff = 256 uninitialized-mut-arr<char>
	b = buff.begin-ptr getcwd buff.size
	if b null?
		todo
	else
		assert: b ptr-eq? buff.begin-ptr
		b to-str

.get-stat opt stat-t(path c-str) summon trusted
	# Initial value doesn't really matter
	s = empty-stat
	err = path stat s
	if err == 0
		s some
	else
		assert: err == -1
		if errno != enoent
			todo

###
If `path` is a directory, calls `each-child-recursive` on every child of the directory.
Else, calls `f[path]`.
###
each-child-recursive void(path str, f act void(str)) summon
	filter = as<act bool(str)>: \x
		drop: x
		true
	path each-child-recursive filter, f

# `each-child-recursive` that does not descend into a child if `f[child-name]` returns false.
each-child-recursive void(path str, filter act bool(str), f act void(str)) summon
	if path is-dir?
		path.read-dir each \child-name
			if filter[child-name]
				path child-path child-name each-child-recursive filter, f
	else
		f[path]


permissions record
	read bool
	write bool
	execute bool

.to-mode mode-t(a permissions)
	(a.read.to-nat bit-shift-left 2) bits-or (a.write.to-nat bit-shift-left 1) bits-or a.execute.to-nat to-nat32

no-permissions permissions()
	permissions: false, false, false

all-permissions permissions()
	permissions: true, true, true

file-permissions record
	user permissions
	group permissions
	public permissions

user-only file-permissions(user-permissions permissions)
	file-permissions: user-permissions, no-permissions, no-permissions

to-mode mode-t(a file-permissions)
	(a.user.to-mode bit-shift-left 6) bits-or (a.group.to-mode bit-shift-left 3) bits-or a.public.to-mode

make-directory void(path str) summon
	# TODO: all-permissions.user-only instead of a number literal
	# TODO: 'to-nat32' should not be necessary
	path make-directory 0o777.to-nat32

make-directory void(path str, permissions file-permissions) summon
	path make-directory permissions.to-mode

make-directory void(path str, permissions mode-t) trusted summon
	check-posix-error: path.to-c-str mkdir permissions

remove-file void(path str) trusted summon
	check-posix-error: path.to-c-str unlink

remove-directory void(path str) trusted summon
	check-posix-error: path.to-c-str rmdir

remove-directory-and-contents-non-recursive void(path str) summon
	path remove-directory-contents-non-recursive
	path remove-directory

remove-directory-contents-non-recursive void(path str) summon
	path.read-dir each \child
		"{path}/{child}" remove-file
