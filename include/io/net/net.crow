no-std
import
	...private.bootstrap: todo
	...cell: cell, subscript
	...collection.arr: ~
	...compare: ==, !=
	...exceptions: assert
	...number: nat16
	...opt: force, none, opt, some, value
	...posix.extra-types: fd-t
	...posix.netdb:
		addrinfo, ai-addr, ai-addrlen, ai-family, ai-next, ai-passive, ai-protocol, ai-socktype,
		freeaddrinfo, getaddrinfo
	...posix.socket: af-inet, af-unspec, bind, connect, socket
	...posix.socket-type: sock-stream
	...posix.unistd: close
	...ptr: as-ref, null, null?, ptr, ptr-to, subscript
	...str: str
	...str-conv: to-str
	...str-utils: to-c-str
	..posix-util: check-posix-error
	..print: print

uri record
	host str
	port nat16
	path-and-query str
	# Basically just ignored
	after-hash str

# Returns fd of an an opened socket to uri
connect-to-uri fd-t(u uri) trusted summon
	hints = addrinfo: 0, af-unspec, sock-stream, 0, 0, null.as-ref, null, null
	result = null cell<ptr<addrinfo>>
	check-posix-error: u.host.to-c-str getaddrinfo u.port.to-str.to-c-str, hints.ptr-to, result
	op-sock = result[] find-and-connect-working-socket
	result[] freeaddrinfo
	# TODO: handle failure
	op-sock force

.find-and-connect-working-socket opt fd-t(ap ptr addrinfo) unsafe summon
	if ap null?
		none
	else
		a = ap[]
		sock = socket: a.ai-family, a.ai-socktype, a.ai-protocol
		print: "sock is " ~ sock.to-str
		if sock == -1
			# Ignore error and try again
			a.ai-next find-and-connect-working-socket
		else
			err = sock connect a.ai-addr, a.ai-addrlen
			print: "err is " ~ err.to-str
			if err == -1
				print: "connect() failed: "
				check-posix-error: sock close
				# Ignore error and try again
				a.ai-next find-and-connect-working-socket
			else
				assert: err == 0
				sock some

bind-to-port fd-t(port str) unsafe summon
	hints = addrinfo: ai-passive, af-inet, sock-stream, 0, 0, null.as-ref, null, null
	result = null cell<ptr<addrinfo>>
	check-posix-error: getaddrinfo: null, port.to-c-str, hints.ptr-to, result
	op-sock = result[] find-and-bind-working-socket
	result[] freeaddrinfo
	match op-sock
	as none
		print: "Failed to bind to port " ~ port
		todo
	as some s
		s.value

.find-and-bind-working-socket opt fd-t(ap ptr addrinfo) unsafe summon
	if ap null?
		none
	else
		a = ap[]
		listen-fd = socket: a.ai-family, a.ai-socktype, 0
		if listen-fd != -1
			if (listen-fd bind a.ai-addr, a.ai-addrlen) == 0
				print: "Connected!"
				listen-fd some
			else
				check-posix-error: listen-fd close
				a.ai-next find-and-bind-working-socket
		else
			a.ai-next find-and-bind-working-socket
