import
	...bootstrap: == != >= arr as byte drop fut nat none opt size some str todo value void
	...collection.arr: at empty?
	...collection.dict: add dict empty-dict get move-to-dict mut-dict new-mut-dict
	...collection.mut-list: index-of move-to-arr mut-str new-mut-list pop-n-from-start push-all size
	...exceptions: assert forbid
	...fut-utils: call-ref resolved then
	...io.print: print
	...posix.extra-types: fd-t
	...str-utils: as-str
	.tcp-server: close-client start-tcp-server stop tcp-handler

http-server record sendable
	stop ref void()

http-request record
	method http-method
	url str
	headers dict<str, str>
	body str

http-response record
	status nat
	status-desc str
	headers dict<str, str>
	body str

http-handler alias
	ref http-response(http-request)

http-get record
http-post record

http-method union
	http-get
	http-post

start-http-server fut http-server(port str, handler http-handler) trusted summon
	client-states = new-mut-dict<fd-t, http-parse-state>

	print: "GONNA START THE SERVER"
	drop: port
	on-accepted-client = as<ref void(fd-t)>: \fd
		client-states add fd, new-http-parse-state
		void resolved
	on-received-chunk = as<ref void(fd-t, arr byte)>: \fd bytes
		state-opt = client-states get fd
		match state-opt
		as none
			print: "Ignoring unrecognized client"
			void resolved
		as some s
			state = s value
			fd handle-chunk state, bytes.as-str, handler
	tcp-server = port start-tcp-server tcp-handler: on-accepted-client, on-received-chunk

	| TODO: KILL
	ignore <- handler call-ref: http-request: http-get, "", empty-dict, ""
	drop: ignore

	resolved: http-server: tcp-server.stop

.handle-chunk fut void(fd fd-t, state http-parse-state, chunk str, handler http-handler) summon trusted
	state.unparsed push-all chunk
	if state.content-length != 0
		if state.unparsed.size >= state.content-length
			assert: state.unparsed.size == state.content-length
			req = http-request: state.method, state.url, state.headers.move-to-dict, state.unparsed.move-to-arr
			res <- handler call-ref req
			print: "TODO: SEND THE RESPONSE"
			todo
			| TODO: close fd..
			fd close-client
			void resolved
		else
			void resolved
	else
		state handle-http-initial

		print: "TODO: PARSE HEADERS"
		todo

| TODO: not summon
.handle-http-initial void(state http-parse-state) summon
	match state.unparsed try-take-first-line
	as none
		void
	as some s
		drop: s.value
		line = s value
		if state.url empty?
			| Expect something like "GET / HTTP/1.1"
			parts = line split " "
			assert: parts.size == 3
			state set-method: parts at 0 parse-method
			state set-url: parts at 1
			forbid: state.url empty?
		else
			parts = line split ": "
			assert: parts.size == 2
			key = parts at 0
			value = parts at 1
			state.headers add key, value
			if key == "Content-Length"
				todo
		state handle-http-initial

parse-method http-method(name str)
	if name == "GET"
		http-get
	elif name == "POST"
		http-post
	else
		todo

.try-take-first-line opt str(a mut-str)
	match a index-of "\n"
	as none
		none
	as some s
		a pop-n-from-start s.value some

.http-parse-state record mut
	method mut http-method
	url mut str
	headers mut-dict<str, str>
	content-length nat
	| TODO:PERF: Use a circular buffer as we often take content off the front
	unparsed mut-str

.new-http-parse-state http-parse-state()
	http-parse-state: http-get, "", new-mut-dict, 0, new-mut-list
