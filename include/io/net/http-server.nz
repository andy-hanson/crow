import
	...bootstrap
		== != <= >= and arr as bool byte char data drop false fut nat none opt ptr-cast size some
		str todo true value void
	...collection.arr: empty? has? subscript
	...collection.arr-util: contains? last rtail split-by-subseq
	...collection.dict: add dict each empty-dict has? move-to-dict mut-dict new-mut-dict remove subscript
	...collection.mut-list
		index-of move-to-arr mut-list new-mut-list pop-n-from-start push push-all size
	...exceptions: assert forbid
	...fut-utils: resolved subscript then
	...number-utils: incr to-int
	...posix.extra-types: fd-t
	...posix.unistd: write
	...str-conv: parse-nat to-str
	...str-utils: as-str
	..print: print
	.tcp-server: close-client start-tcp-server stop tcp-handler

http-server record sendable
	stop ref void()

http-request record
	method http-method
	url str
	headers dict<str, str>
	body str

http-response record
	status nat
	status-desc str
	headers dict<str, str>
	body str

http-handler alias
	ref http-response(http-request)

http-get record
http-post record

http-method union
	http-get
	http-post

start-http-server fut http-server(port str, handler http-handler) trusted summon
	client-states = new-mut-dict<fd-t, http-parse-state>

	on-accepted-client = as<ref void(fd-t)>: \fd
		client-states add fd, new-http-parse-state
		void resolved
	on-received-chunk = as<ref void(fd-t, arr byte)>: \fd bytes
		match client-states[fd]
		as none
			print: "Ignoring unrecognized client"
			void resolved
		as some s
			state = s value
			closed <- fd handle-chunk state, bytes.as-str, handler
			if closed
				client-states remove fd
			void resolved
	tcp-server = port start-tcp-server tcp-handler: on-accepted-client, on-received-chunk

	| TODO: KILL
	ignore <- handler[http-request: http-get, "", empty-dict, ""]
	drop: ignore

	resolved: http-server: tcp-server.stop

| Returns true when closed client
.handle-chunk fut bool(fd fd-t, state http-parse-state, chunk str, handler http-handler) summon trusted
	state.unparsed push-all chunk
	finished-request? = if state.content-length != 0
		assert: state.unparsed.size <= state.content-length
		state.unparsed.size >= state.content-length
	else
		state handle-http-initial

	if finished-request?
		res <- handler[state finish-request]
		res-str = res response-to-str
		wrote = fd write res-str.data.ptr-cast<byte, char>, res-str.size
		assert: wrote == res-str.size.to-int
		fd close-client
		true resolved
	else
		false resolved

.finish-request http-request(state http-parse-state)
	http-request: state.method, state.url, state.headers.move-to-dict, state.unparsed.move-to-arr

| TODO: write out to a stream, not str
.response-to-str str(a http-response)
	res = new-mut-list<char>
	res push-all "HTTP/1.1 "
	res push-all a.status.to-str
	res push " "
	forbid: a.status-desc contains? "\n"
	res push-all a.status-desc
	| TODO: headers are case insensitive, maybe forbid any upper-case letters in headers to be consistent
	a.headers each \k v
		res push-all "\r\n"
		forbid: k contains? "\n"
		forbid: v contains? "\n"
		res push-all k
		res push-all ": "
		res push-all v
	forbid: a.headers has? "Content-Length"
	if a.body has?
		res push-all "Content-Length: "
		res push-all a.body.size.to-str
	res push-all "\r\n\r\n"
	res push-all a.body
	res move-to-arr

|ok-response str() noctx
|	"HTTP/1.1 200 OK Feelin' Fine\nShoop: Da Woop\n\nHello, internet world!\n"

| returns true if ready to clal handler
.handle-http-initial bool(state http-parse-state)
	match state.unparsed try-take-first-line
	as none
		false
	as some s
		line = s value
		if line empty?
			match state.headers["content-length"]
			as none
				true
			as some some-content-length-str
				| set state.content-length
				match some-content-length-str.value parse-nat
				as none
					| invalid content-length
					todo
				as some some-content-length
					state set-content-length some-content-length.value
					false
		elif state.url empty?
			| Expect something like "GET / HTTP/1.1"
			parts = line split-by-subseq " "
			assert: parts.size == 3
			state set-method: parts[0] parse-method
			state set-url: parts[1]
			assert: parts[2] == "HTTP/1.1"
			forbid: state.url empty?
			false
		else
			parts = line split-by-subseq ": "
			assert: parts.size == 2
			key = parts[0]
			value = parts[1]
			state.headers add key, value
			state handle-http-initial

.parse-method http-method(name str)
	if name == "GET"
		http-get
	elif name == "POST"
		http-post
	else
		todo

.try-take-first-line opt str(a mut-list char)
	match a index-of "\n"
	as none
		none
	as some s
		line = a pop-n-from-start s.value.incr rtail
		some: line strip-carriage-return

.strip-carriage-return str(a str)
	if a.has? and: a.last == "\r"
		a rtail
	else
		a

.http-parse-state record mut
	method mut http-method
	url mut str
	headers mut-dict<str, str>
	| This is not set until after the end of headers
	content-length mut nat
	| TODO:PERF: Use a circular buffer as we often take content off the front
	unparsed mut-list char

.new-http-parse-state http-parse-state()
	http-parse-state: http-get, "", new-mut-dict, 0, new-mut-list
