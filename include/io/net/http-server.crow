import
	...bool: and, bool, false, true
	...bootstrap: as, drop, todo, void
	...collection.arr: arr, data, empty?, has?, size, subscript
	...collection.arr-util: contains?, last, rtail, split-by-subseq
	...collection.dict: dict, each, has?
	...collection.mut-dict: move-to-dict!, mut-dict, remove!, set-subscript, subscript
	...collection.mut-list: ~=, index-of, move-to-arr!, mut-list, pop-n-from-start!, size
	...compare: ==, !=, <=, >=
	...exceptions: assert, forbid
	...fut: fut, resolved, subscript, then
	...number: +, nat, nat8, to-int
	...opt: none, opt, some, value
	...posix.extra-types: fd-t
	...posix.unistd: write
	...ptr: ptr-cast
	...str: char, str
	...str-conv: parse-nat, to-str
	...str-utils: as-str
	..print: print
	.tcp-server: close-client, start-tcp-server, stop, tcp-handler

http-server record sendable
	stop ref void()

http-request record
	method http-method
	url str
	headers dict<str, str>
	body str

http-response record
	status nat
	status-desc str
	headers dict<str, str>
	body str

http-handler alias
	ref http-response(http-request)

http-get record
http-post record

http-method union
	http-get
	http-post

start-http-server fut http-server(port str, handler http-handler) trusted summon
	client-states = mut-dict<fd-t, http-parse-state>

	on-accepted-client = as<ref void(fd-t)>: \fd
		client-states[fd] := http-parse-state
		void resolved
	on-received-chunk = as<ref void(fd-t, arr nat8)>: \fd, bytes
		match client-states[fd]
		as none
			print: "Ignoring unrecognized client"
			void resolved
		as some s
			state = s value
			closed <- fd handle-chunk state, bytes.as-str, handler
			if closed
				client-states remove! fd drop
			void resolved
	tcp-server = port start-tcp-server tcp-handler: on-accepted-client, on-received-chunk

	# TODO: KILL
	ignore <- handler[http-request: http-get, "", [].dict, ""]
	drop: ignore

	resolved: http-server: tcp-server.stop

# Returns true when closed client
.handle-chunk fut bool(fd fd-t, state http-parse-state, chunk str, handler http-handler) summon trusted
	state.unparsed ~= chunk
	finished-request? = if state.content-length != 0
		assert: state.unparsed.size <= state.content-length
		state.unparsed.size >= state.content-length
	else
		state handle-http-initial

	if finished-request?
		res <- handler[state finish-request]
		res-str = res response-to-str
		wrote = fd write res-str.data.ptr-cast<nat8, char>, res-str.size
		assert: wrote == res-str.size.to-int
		fd close-client
		true resolved
	else
		false resolved

.finish-request http-request(state http-parse-state)
	http-request: state.method, state.url, state.headers.move-to-dict!, state.unparsed.move-to-arr!

# TODO: write out to a stream, not str
.response-to-str str(a http-response)
	res = mut-list<char>
	res ~= "HTTP/1.1 "
	res ~= a.status.to-str
	res ~= " "
	forbid: a.status-desc contains? "\n"
	res ~= a.status-desc
	# TODO: headers are case insensitive, maybe forbid any upper-case letters in headers to be consistent
	a.headers each \k, v
		res ~= "\r\n"
		forbid: k contains? "\n"
		forbid: v contains? "\n"
		res ~= k
		res ~= ": "
		res ~= v
	forbid: a.headers has? "Content-Length"
	if a.body has?
		res ~= "Content-Length: "
		res ~= a.body.size.to-str
	res ~= "\r\n\r\n"
	res ~= a.body
	res move-to-arr!

#ok-response str() noctx
#	"HTTP/1.1 200 OK Feelin' Fine\nShoop: Da Woop\n\nHello, internet world!\n"

# returns true if ready to clal handler
.handle-http-initial bool(state http-parse-state)
	match state.unparsed try-take-first-line
	as none
		false
	as some s
		line = s value
		if line empty?
			match state.headers["content-length"]
			as none
				true
			as some some-content-length-str
				# set state.content-length
				match some-content-length-str.value parse-nat
				as none
					# invalid content-length
					todo
				as some some-content-length
					state.content-length := some-content-length value
					false
		elif state.url empty?
			# Expect something like "GET / HTTP/1.1"
			parts = line split-by-subseq " "
			assert: parts.size == 3
			state.method := parts[0] parse-method
			state.url := parts[1]
			assert: parts[2] == "HTTP/1.1"
			forbid: state.url empty?
			false
		else
			parts = line split-by-subseq ": "
			assert: parts.size == 2
			key = parts[0]
			value = parts[1]
			state.headers[key] := value
			state handle-http-initial

.parse-method http-method(name str)
	if name == "GET"
		http-get
	elif name == "POST"
		http-post
	else
		todo

.try-take-first-line opt str(a mut-list char)
	match a index-of "\n"
	as none
		none
	as some s
		line = a pop-n-from-start! s.value + 1 rtail
		some: line strip-carriage-return

.strip-carriage-return str(a str)
	if a.has? and: a.last == "\r"
		a rtail
	else
		a

.http-parse-state record mut
	method mut http-method
	url mut str
	headers mut-dict<str, str>
	# This is not set until after the end of headers
	content-length mut nat
	# TODO:PERF: Use a circular buffer as we often take content off the front
	unparsed mut-list char

.http-parse-state http-parse-state()
	http-parse-state: http-get, "", mut-dict, 0, mut-list
