no-std
import
	.bits: bits-and, bit-shift-left, bit-shift-right, bits-or
	.col.arr: arr, arr-cast, size, subscript
	.col.arr-util: fold, strip-left-while
	.compare: ==, <, <=
	.exception: assert
	.misc: ->, as
	.number: int64, max-int, nat8, nat32, nat64, to-int, to-nat, to-nat32
	.str: str
	.test: is
	.private.bootstrap: todo
	.private.number-low-level: unsafe-to-nat8

serialize<?a> spec
	to-bytes arr nat8(a ?a)
	from-bytes ?a(a arr nat8)

to-bytes arr nat8(a arr nat8)
	a
from-bytes arr nat8(a arr nat8)
	a

to-bytes arr nat8(a str) trusted
	a arr-cast
from-bytes str(a arr nat8) trusted
	a arr-cast

to-bytes arr nat8(a nat64)
	a.to-8-bytes strip-left-while {it == 0}
to-8-bytes arr nat8(a nat64) trusted
	b0 = a bit-shift-right 0x00 bits-and 0xff unsafe-to-nat8
	b1 = a bit-shift-right 0x08 bits-and 0xff unsafe-to-nat8
	b2 = a bit-shift-right 0x10 bits-and 0xff unsafe-to-nat8
	b3 = a bit-shift-right 0x18 bits-and 0xff unsafe-to-nat8
	b4 = a bit-shift-right 0x20 bits-and 0xff unsafe-to-nat8
	b5 = a bit-shift-right 0x28 bits-and 0xff unsafe-to-nat8
	b6 = a bit-shift-right 0x30 bits-and 0xff unsafe-to-nat8
	b7 = a bit-shift-right 0x38 bits-and 0xff unsafe-to-nat8
	[b7, b6, b5, b4, b3, b2, b1, b0]
from-bytes nat64(a arr nat8)
	assert: a.size <= 8
	0 fold a, \cur, x
		cur bit-shift-left 8 bits-or x.to-nat
test
	n = 0x0123456789abcdef
	bytes = n to-bytes
	bytes is [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]
	bytes.from-bytes.as<nat64> is n
	0x500.to-8-bytes is [0, 0, 0, 0, 0, 0, 5, 0]
	0x500.to-bytes is [5, 0]

to-4-bytes arr nat8(a nat32)
	a.to-nat.to-8-bytes[4 -> 8]
to-bytes arr nat8(a nat32)
	a.to-nat to-bytes
from-bytes nat32(a arr nat8)
	a.from-bytes.as<nat64> to-nat32

to-8-bytes arr nat8(a int64)
	if a < 0
		todo
	else
		a.to-nat to-8-bytes
from-bytes int64(a arr nat8)
	n = a.from-bytes as<nat64>
	if n < max-int.to-nat
		n to-int
	else
		todo
