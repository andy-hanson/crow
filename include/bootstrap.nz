| Unrecoverable assertion failure
hard-fail ?t(reason str) noctx unsafe builtin

uninitialized ?t() noctx unsafe builtin

hard-unreachable ?t() noctx unsafe
	hard-fail: "unreachable"

todo ?t() trusted noctx
	| TODO: soft-fail, remove 'trusted' above
	hard-fail: "TODO"

by-val<?t> builtin

| Unsafe because the ref will only be valid temporarily!
ref-of-val ?t(b by-val ?t) noctx unsafe builtin

| This forces something to be stack-allocated.
| WARN: If '?t' is a reference type already, this is a pointer to a pointer!
ptr-to ptr ?t(t ?t) noctx unsafe builtin

| TODO: this function only works for by-ref types -- currently that is not checked by the type checker
as-any-ptr any-ptr(ref ?t) noctx unsafe builtin
| TODO: this function only works for by-ref types -- currently that is not checked by the type checker
as-ref ?t(p any-ptr) noctx unsafe builtin

ref-of-ptr ?t(p ptr by-val<?t>) noctx unsafe
	p.deref ref-of-val

ptr-eq? bool(a ptr ?t, b ptr ?t) noctx unsafe builtin
ptr-less? bool(a ptr ?t, b ptr ?t) noctx unsafe builtin
ptr-less-eq? bool(a ptr ?t, b ptr ?t) noctx unsafe
	a ptr-less? b or: a ptr-eq? b

ref-eq? bool(a ?t, b ?t) noctx unsafe
	a.as-any-ptr ptr-eq? b.as-any-ptr

| Since this fun is not marked 'noctx', it simply returns the ctx that already exists.
get-ctx ctx() unsafe builtin

void builtin
| TODO: kill, just use nat8...
byte alias
	nat8

| A raw pointer. GC will not trace these.
| WARN: If ?t is a reference type, ptr<?t> is a pointer to a pointer to ?t
ptr<?t> builtin mut
deref ?t(p ptr ?t) noctx unsafe builtin
set void(p ptr ?t, value ?t) noctx unsafe builtin

null ptr ?t() noctx builtin
| Used by the compiler
null-any ptr bool() noctx
	null

null? bool(a ptr ?t) noctx trusted
	a.to-nat == (null<?t>).to-nat

any-ptr alias
	ptr byte

is-reference-type?<?t> bool() noctx unsafe builtin
| WARN: for a reference type, this is the size of a pointer
size-of<?t> nat() noctx unsafe builtin

ptr-cast ptr ?out(p ptr ?in) noctx unsafe builtin

magic-cast ?out(p ?in) noctx unsafe
	p.as-any-ptr as-ref

to-nat nat(p ptr ?t) noctx unsafe builtin

+ ptr ?t(p ptr ?t, offset nat) noctx unsafe builtin
- ptr ?t(p ptr ?t, offset nat) noctx unsafe builtin
- nat(a ptr ?t, b ptr ?t) noctx unsafe
	a.to-nat wrap-sub b.to-nat unsafe-div size-of<?t>

region comparison

less record
equal record
greater record
comparison union
	less
	equal
	greater

to-str str(c comparison)
	match c
	as less
		"less"
	as equal
		"equal"
	as greater
		"greater"

<=> comparison(a ?t, b ?t) data<?t> noctx builtin

== bool(a ?t, b ?t) noctx data<?t>
	match a <=> b
	as less
		false
	as equal
		true
	as greater
		false

!= bool(a ?t, b ?t) noctx data<?t>
	a == b not

< bool(a ?t, b ?t) noctx data<?t>
	match a <=> b
	as less
		true
	as equal
		false
	as greater
		false

<= bool(a ?t, b ?t) noctx data<?t>
	b < a not

> bool(a ?t, b ?t) noctx data<?t>
	a <= b not

>= bool(a ?t, b ?t) noctx data<?t>
	a < b not

min ?t(a ?t, b ?t) noctx data<?t>
	a < b ? a, b

max ?t(a ?t, b ?t) noctx data<?t>
	a > b ? a, b

| NOTE: this is not a normal record, compiler treats it specially
arr<?t> record force-data
	by-val
	size nat
	data ptr ?t

ptr-as-arr arr ?t(size nat, data ptr ?t)
	arr: size, data

char builtin
str alias
	arr char
c-str alias
	ptr char


region bool

bool builtin
false bool() noctx builtin
true bool() noctx builtin
not bool(a bool) noctx builtin
| Note: this should be lazily evaluated
and bool(a bool, b bool) noctx builtin
or bool(a bool, b bool) noctx builtin
nand bool(a bool, b bool) noctx builtin
nor bool(a bool, b bool) noctx builtin
| Only one of 'if-true' and 'if-false' arguments will be evaluated
? ?t(cond bool, if-true ?t, if-false ?t) noctx builtin
? void(cond bool, if-true void) noctx builtin

| TODO:MOVE
to-nat nat(b bool) noctx
	b ? 1, 0

region Fun

| Pointer to a function with no arguments (not even ctx)
fun-ptr0<?r> builtin
fun-ptr1<?r, ?p0> builtin
fun-ptr2<?r, ?p0, ?p1> builtin
fun-ptr3<?r, ?p0, ?p1, ?p2> builtin
fun-ptr4<?r, ?p0, ?p1, ?p2, ?p3> builtin
fun-ptr5<?r, ?p0, ?p1, ?p2, ?p3, ?p4> builtin
fun-ptr6<?r, ?p0, ?p1, ?p2, ?p3, ?p4, ?p5> builtin

| The ctx only exists temporarily, so can use 'any-ptr' without worrying about GC
ctx record mut
	by-ref
	gctx-ptr any-ptr
	island-id island-id
	exclusion exclusion
	gc-ctx-ptr any-ptr
	exception-ctx-ptr any-ptr
	log-ctx any-ptr

island-id alias
	nat

exclusion alias
	nat

island-and-exclusion record
	by-val
	island island-id
	exclusion exclusion

| Don't reference directly, instead use syntax `fun ?r(?p0, ?p1)`
| Contrasted with `act`, a fun can't close over mutable data, so is thread-safe.
| It can still close over `send` data and perform I/O, so it's not a completely pure function.
fun0<?r> builtin sendable
fun1<?r, ?p0> builtin sendable
fun2<?r, ?p0, ?p1> builtin sendable
fun3<?r, ?p0, ?p1, ?p2> builtin sendable

| Don't reference directly, instead use syntax `act ?r(?p0, ?p1)`
| Can close over anything. Can only be run by the exclusion context that created it.
fun-act0<?r> builtin mut
fun-act1<?r, ?p0> builtin mut
fun-act2<?r, ?p0, ?p1> builtin mut
fun-act3<?r, ?p0, ?p1, ?p2> builtin mut

| Don't reference directly, instead use syntax `act ?r(?p0, ?p1)`
| This wraps an `act` combined with the island/exclusion it came from, and becomes sendable
| since the `act` can't be called directly. Instead, it adds a task to the island.
fun-ref0<?r> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut<?r>()
fun-ref1<?r, ?p0> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut ?r(?p0)
fun-ref2<?r, ?p0, ?p1> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut ?r(?p0, ?p1)
fun-ref3<?r, ?p0, ?p1, ?p2> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut ?r(?p0, ?p1, ?p2)

| calling a fun-ptr is a primitive operation
call ?r(a fun-ptr0 ?r) noctx builtin
call ?r(a fun-ptr1<?r, ?p0>, p0 ?p0) noctx builtin
call ?r(a fun-ptr2<?r, ?p0, ?p1>, p0 ?p0, p1 ?p1) noctx builtin
call ?r(a fun-ptr3<?r, ?p0, ?p1, ?p2>, p0 ?p0, p1 ?p1, p2 ?p2) noctx builtin
call ?r(a fun-ptr4<?r, ?p0, ?p1, ?p2, ?p3>, p0 ?p0, p1 ?p1, p2 ?p2, p3 ?p3) noctx builtin
call ?r(a fun-ptr5<?r, ?p0, ?p1, ?p2, ?p3, ?p4>, p0 ?p0, p1 ?p1, p2 ?p2, p3 ?p3, p4 ?p4) noctx builtin
call ?r(a fun-ptr6<?r, ?p0, ?p1, ?p2, ?p3, ?p4, ?p5>, p0 ?p0, p1 ?p1, p2 ?p2, p3 ?p3, p4 ?p4, p5 ?p5) noctx builtin

call ?r(a fun ?r()) trusted
	a call-with-ctx get-ctx
call ?r(a fun ?r(?p0), p0 ?p0) trusted
	a call-with-ctx get-ctx, p0
call ?r(a fun ?r(?p0, ?p1), p0 ?p0, p1 ?p1) trusted
	a call-with-ctx get-ctx, p0, p1
call ?r(a fun ?r(?p0, ?p1, ?p2), p0 ?p0, p1 ?p1, p2 ?p2) trusted
	a call-with-ctx get-ctx, p0, p1, p2

call ?r(a act ?r()) trusted
	a call-with-ctx get-ctx
call ?r(a act ?r(?p0), p0 ?p0) trusted
	a call-with-ctx get-ctx, p0
call ?r(a act ?r(?p0, ?p1), p0 ?p0, p1 ?p1) trusted
	a call-with-ctx get-ctx, p0, p1
call ?r(a act ?r(?p0, ?p1, ?p2), p0 ?p0, p1 ?p1, p2 ?p2) trusted
	a call-with-ctx get-ctx, p0, p1, p2

call-with-ctx ?r(f fun ?r(), c ctx) noctx builtin
call-with-ctx ?r(f act ?r(), c ctx) noctx builtin
call-with-ctx ?r(f fun ?r(?p0), c ctx, p0 ?p0) noctx builtin
call-with-ctx ?r(f act ?r(?p0), c ctx, p0 ?p0) noctx builtin
call-with-ctx ?r(f fun ?r(?p0, ?p1), c ctx, p0 ?p0, p1 ?p1) noctx builtin
call-with-ctx ?r(f act ?r(?p0, ?p1), c ctx, p0 ?p0, p1 ?p1) noctx builtin
call-with-ctx ?r(f fun ?r(?p0, ?p1, ?p2), c ctx, p0 ?p0, p1 ?p1, p2 ?p2) noctx builtin
call-with-ctx ?r(f act ?r(?p0, ?p1, ?p2), c ctx, p0 ?p0, p1 ?p1, p2 ?p2) noctx builtin

| A type is data if it is:
| * A primitive
| * A record or union of pure types
data<?t> builtin-spec

| A type is sendable if it does not have any thread-unsafe mutable state.
send<?t> builtin-spec


region Arithmetic

| All are 64-bits, even on 32-bit systems
nat builtin
nat64 alias
	nat
int builtin
int64 alias
	int
float builtin
| Not currently used for anything other than posix headers, so limited arithmetic is avialable
int8 builtin
int16 builtin
int32 builtin
nat8 builtin
nat16 builtin
nat32 builtin

| UB for negative numbers
unsafe-to-nat nat(a int) noctx builtin
unsafe-to-nat8 nat8(a nat) noctx builtin
unsafe-to-nat16 nat16(a nat) noctx builtin
unsafe-to-nat32 nat32(a nat) noctx builtin

to-nat16 nat16(a nat8) noctx trusted
	a.to-nat unsafe-to-nat16

| UB for positive numbers >= 2 ** 63
unsafe-to-int int(a nat) noctx builtin
unsafe-to-int8 int8(a int) noctx builtin
unsafe-to-int16 int16(a int) noctx builtin
unsafe-to-int32 int32(a int) noctx builtin

min-int32 int32() noctx
	-2147483648
max-int32 int32() noctx
	2147483647
min-int int() noctx
	-0x8000000000000000
max-int int() noctx
	0x7fffffffffffffff
max-nat8 nat8() noctx
	0xff
max-nat16 nat16() noctx
	0xffff
max-nat32 nat32() noctx
	0xffffffff
max-nat nat() noctx
	0xffffffffffffffff

to-nat32 nat32(a nat16) noctx trusted
	a.to-nat unsafe-to-nat32
to-nat32 nat32(a nat) noctx trusted
	if a < max-nat32.to-nat
		a unsafe-to-nat32
	else
		todo

to-nat nat(n nat8) noctx builtin
to-nat nat(n nat16) noctx builtin
to-nat nat(n nat32) noctx builtin

to-int int(i int8) noctx builtin
to-int int(i int16) noctx builtin
to-int int(i int32) noctx builtin

to-float float(a nat64) noctx builtin
to-float float(a int64) noctx builtin
truncate-to-int int64(a float) noctx builtin

wrap-add int(a int, b int) noctx builtin
wrap-add nat(a nat, b nat) noctx builtin
wrap-add nat8(a nat8, b nat8) noctx builtin
wrap-add nat16(a nat16, b nat16) noctx builtin
wrap-add nat32(a nat32, b nat32) noctx builtin

wrap-sub int(a int, b int) noctx builtin
wrap-sub int16(a int16, b int16) noctx builtin
wrap-sub nat(a nat, b nat) noctx builtin
wrap-sub nat8(a nat8, b nat8) noctx builtin
wrap-sub nat16(a nat16, b nat16) noctx builtin
wrap-sub nat32(a nat32, b nat32) noctx builtin

wrap-mul int(a int, b int) noctx builtin
wrap-mul int16(a int16, b int16) noctx builtin
wrap-mul int32(a int32, b int32) noctx builtin
wrap-mul nat(a nat, b nat) noctx builtin
wrap-mul nat32(a nat32, b nat32) noctx builtin

unsafe-div int(a int, b int) noctx unsafe builtin
unsafe-div nat(a nat, b nat) noctx unsafe builtin

unsafe-mod nat(a nat, b nat) noctx unsafe builtin

bits-not nat(a nat) noctx builtin

bits-and nat16(a nat16, b nat16) noctx builtin
bits-and nat32(a nat32, b nat32) noctx builtin
bits-and nat(a nat, b nat) noctx builtin
bits-and int8(a int8, b int8) noctx builtin
bits-and int16(a int16, b int16) noctx builtin
bits-and int32(a int32, b int32) noctx builtin
bits-and int(a int, b int) noctx builtin

bits-or nat16(a nat16, b nat16) noctx builtin
bits-or nat32(a nat32, b nat32) noctx builtin
bits-or nat(a nat, b nat) noctx builtin
bits-or nat8(a nat8, b nat8) noctx builtin
bits-or int16(a int16, b int16) noctx builtin
bits-or int32(a int32, b int32) noctx builtin
bits-or int(a int, b int) noctx builtin

bits-intersect? bool(a int16, b int16) noctx
	not: a bits-and b == 0
bits-intersect? bool(a int32, b int32) noctx
	not: a bits-and b == 0
bits-intersect? bool(a nat32, b nat32) noctx
	not: a bits-and b == 0

unsafe-bit-shift-left nat(a nat, b nat) noctx builtin unsafe
unsafe-bit-shift-right nat(a nat, b nat) noctx builtin unsafe
bit-shift-left nat8(a nat8, b nat8) noctx trusted
	if b < 8
		a.to-nat unsafe-bit-shift-left b.to-nat unsafe-to-nat8
	else
		0
bit-shift-left nat16(a nat16, b nat16) noctx trusted
	if b < 16
		a.to-nat unsafe-bit-shift-left b.to-nat unsafe-to-nat16
	else
		0
bit-shift-left nat32(a nat32, b nat32) noctx trusted
	if b < 32
		a.to-nat unsafe-bit-shift-left b.to-nat unsafe-to-nat32
	else
		0
bit-shift-right nat32(a nat32, b nat32) noctx trusted
	if b < 32
		a.to-nat unsafe-bit-shift-right b.to-nat unsafe-to-nat32
	else
		0
bit-shift-right int32(a int32, b int32) noctx trusted
	if a < 0
		todo
	elif b < 0
		todo
	elif b < 32
		unsafe-to-int32: a.to-int.unsafe-to-nat unsafe-bit-shift-right b.to-int.unsafe-to-nat unsafe-to-int
	else
		todo

wrap-add int16(a int16, b int16) noctx builtin
wrap-add int32(a int32, b int32) noctx builtin

wrap-sub int32(a int32, b int32) noctx builtin

wrap-incr int(a int) noctx
	a wrap-add 1
wrap-incr int16(a int16) noctx
	a wrap-add 1
wrap-incr int32(a int32) noctx
	a wrap-add 1
wrap-incr nat(a nat) noctx
	a wrap-add 1
wrap-incr nat32(a nat32) noctx
	a wrap-add 1


wrap-decr int(a int) noctx
	a wrap-sub 1
wrap-decr int16(a int16) noctx
	a wrap-sub 1
wrap-decr int32(a int32) noctx
	a wrap-sub 1
wrap-decr nat8(a nat8) noctx
	a wrap-sub 1
wrap-decr nat(a nat) noctx
	a wrap-sub 1
wrap-decr nat32(a nat32) noctx
	a wrap-sub 1

noctx-incr nat(n nat) noctx unsafe
	hard-assert: n < max-nat
	n wrap-incr

incr ptr ?t(p ptr ?t) noctx unsafe
	p + 1

decr ptr ?t(p ptr ?t) noctx unsafe
	p - 1

noctx-decr int32(a int32) noctx unsafe
	a wrap-sub 1
noctx-decr nat32(a nat32) noctx unsafe
	hard-forbid: a == 0
	a wrap-sub 1
noctx-decr nat(n nat) noctx unsafe
	hard-forbid: n == 0
	n wrap-sub 1

region Util

void void() noctx builtin
drop void(_ ?t) noctx
	void

hard-assert void(condition bool) noctx unsafe
	if condition not
		"Assertion failed!" hard-fail

hard-forbid void(condition bool) noctx unsafe
	condition.not hard-assert

hard-assert-unreachable ?t() noctx unsafe
	"should be unreachable" hard-fail

some<?t> record
	by-val
	value ?t
none record
opt<?t> union
	none
	some<?t>

empty? bool(a opt ?t) noctx
	match a
	as none
		true
	as some
		false

has? bool(a opt ?t) noctx
	a.empty? not

| TODO: 'result' module
ok<?t> record
	by-val
	value ?t
err<?t> record
	by-val
	value ?t
result<?ok, ?err> union
	ok<?ok>
	err<?err>

then result<?ok-out, ?err>(a result<?ok-in, ?err>, f act result<?ok-out, ?err>(?ok-in))
	match a
	as ok o
		f call o.value
	as err e
		e

as ?t(value ?t) noctx builtin

region fut

exception record
	by-val
	| TODO: stack trace here too
	message str

fut<?t> record force-sendable
	lk by-val lock
	state mut fut-state ?t

fut-state<?t> union mut
	fut-state-callbacks<?t>
	fut-state-resolved<?t>
	exception

fut-state-callbacks<?t> record mut
	head opt fut-callback-node<?t>

fut-callback-node<?t> record mut
	| WARN: the cb will be called with whatever ctx resolves the fut, not the ctx that created it
	cb act void(result<?t, exception>)
	next-node opt fut-callback-node<?t>

fut-state-resolved<?t> record
	value ?t


region lock

atomic-bool record force-sendable
	value mut bool

lock record sendable
	by-ref
	| Storing this by-val to avoid needing allocations.
	| User should prefer to store the lock by-val too, and only pass by-ref
	is-locked by-val atomic-bool
