import
	.bootstrap:
		==, <, <=, >=, ?, ->, arrow, bool, and, float, from, int, int32, nat, nat8, nat16, nat32,
		or, subscript, to, to-int, to-nat, unsafe-div, unsafe-to-int, unsafe-to-int32,
		unsafe-to-nat, unsafe-to-nat32, void, wrap-add, wrap-mul, wrap-sub
	.exceptions: assert, forbid

region conversion

to-float float(a nat) noctx builtin
to-float float(a int) noctx builtin
truncate-to-int int(a float) noctx builtin

region arithmetic

multiple-of? bool(a nat, b nat)
	(a mod b) == 0

+ nat(a nat, b nat)
	res = a wrap-add b
	assert: res >= a and: res >= b
	res
- nat(a nat, b nat)
	assert: a >= b
	a wrap-sub b
* nat(a nat, b nat)
	# TODO: better safety check
	if a == 0 or: b == 0
		0
	else
		res = a wrap-mul b
		assert: res / b == a
		assert: res / a == b
		res
/ nat(a nat, b nat) trusted
	forbid: b == 0
	a unsafe-div b

unsafe-mod nat(a nat, b nat) noctx unsafe builtin

mod nat(a nat, b nat) trusted
	forbid: b == 0
	a unsafe-mod b

+ int(a int, b int)
	# TODO: safety check
	a wrap-add b
+ int32(a int32, b int32)
	a.to-int wrap-add b.to-int to-int32

- int(a int, b int)
	# TODO: safety check
	a wrap-sub b
- int32(a int32, b int32)
	a.to-int wrap-sub b.to-int to-int32

* int(a int, b int)
	# TODO: safety check
	a wrap-mul b
/ int(a int, b int) trusted
	forbid: b == 0
	forbid: a == min-int and: b == -1
	a unsafe-div b

to-int int(n nat)
	assert: n < max-int.to-nat
	n unsafe-to-int

to-int32 int32(a int)
	assert: a >= min-int32.to-int
	assert: a <= max-int32.to-int
	a unsafe-to-int32
to-int32 int32(n nat)
	assert: n < max-int32.to-nat
	n.unsafe-to-int unsafe-to-int32

to-nat nat(i int)
	forbid: i negative?
	i unsafe-to-nat

to-nat nat(i int32)
	i.to-int to-nat

to-nat32 nat32(a nat16) noctx trusted
	a.to-nat unsafe-to-nat32
to-nat32 nat32(a nat)
	assert: a < max-nat32.to-nat
	a unsafe-to-nat32

negative? bool(i int)
	i < 0

neg int(i int)
	i * -1

neg int(a nat)
	a.to-int neg

neg float(a float)
	a * -1.0

abs nat(i int)
	i-abs = i.negative? ? i.neg, i
	i-abs to-nat

mod nat(a int, b nat)
	forbid: b == 0
	if a negative?
		abs-mod = a.abs mod b
		abs-mod == 0 ? 0, b - abs-mod
	else
		a.to-nat mod b

+ float(a float, b float) noctx builtin
- float(a float, b float) noctx builtin
* float(a float, b float) noctx builtin
unsafe-div float(a float, b float) noctx unsafe builtin
/ float(a float, b float) trusted
	forbid: b == 0.0
	a unsafe-div b

^ float(a float, b nat)
	if b == 0
		1.0
	else
		a * a ^ (b - 1)

square-root float(a float) noctx extern<"sqrt">

nan? bool(a float) noctx builtin

region constants

min-int32 int32() noctx
	-2147483648
max-int32 int32() noctx
	2147483647
min-int int() noctx
	-0x8000000000000000
max-int int() noctx
	0x7fffffffffffffff
max-nat8 nat8() noctx
	0xff
max-nat16 nat16() noctx
	0xffff
max-nat32 nat32() noctx
	0xffffffff
max-nat nat() noctx
	0xffffffffffffffff

region number iteration

each void(r arrow<nat, nat>, f act void(nat))
	if r.from < r.to
		f[r.from]
		r.from + 1 -> r.to each f
