import
	.bootstrap
		< == != any-ptr as atomic-bool bool by-val call drop false fun-ptr1 hard-assert
		hard-forbid is-locked lock nat noctx-decr noctx-incr not null null? opt ptr ptr-to
		ref-of-val todo true value void wrap-mul
	.cell: cell get
	.io.time-low-level: get-monotime-nsec timestamp
	.posix.errno: eagain einval esrch
	.posix.pthread: pthread-create pthread-join pthread-t pthread-yield
	.posix.unistd: usleep

region atomic

new-atomic-bool by-val atomic-bool() noctx
	atomic-bool: false

| TODO: works on any primitive type, not just bool
compare-exchange-strong bool(value-ptr ptr bool, expected-ptr ptr bool, desired bool) noctx builtin

try-change bool(a atomic-bool, old-value bool) noctx trusted
	a.value.ptr-to compare-exchange-strong old-value.ptr-to, old-value.not

try-set bool(a atomic-bool) noctx
	a try-change false

try-unset bool(a atomic-bool) noctx
	a try-change true

must-unset void(a atomic-bool) noctx unsafe
	did-unset = a try-unset
	did-unset hard-assert

new-lock by-val lock() noctx
	lock: new-atomic-bool

try-acquire-lock bool(a lock) noctx trusted
	a.is-locked.ref-of-val try-set

acquire-lock void(a lock) noctx unsafe
	a acquire-lock-recur 0

acquire-lock-recur void(a lock, n-tries nat) noctx unsafe
	if a.try-acquire-lock not
		if n-tries == 1000
			todo
		else
			yield-thread
			a acquire-lock-recur n-tries.noctx-incr

yield-thread void() noctx unsafe
	err = pthread-yield
	hard-assert: err == 0

release-lock void(l lock) noctx unsafe
	l.is-locked.ref-of-val must-unset

with-lock ?t(l lock, f fun ?t()) trusted
	l acquire-lock
	res = f call
	l release-lock
	res

condition record mut
	lk by-val lock
	value mut nat

new-condition by-val condition() noctx
	condition: new-lock, 0

broadcast void(c condition) noctx trusted
	c.lk.ref-of-val acquire-lock
	c set-value: c.value noctx-incr
	c.lk.ref-of-val release-lock

last-checked alias
	nat

get-last-checked last-checked(c condition) noctx
	c.value

| TODO:MOVE
sleep-ms-sync void(ms nat) noctx
	| TODO: wrap-mul is unsafe
	ms wrap-mul 1000 usleep

wait-on void(cond condition, until-time opt timestamp, last-checked last-checked) noctx unsafe summon
	| last-checked should have been called before a change, we wait until c.value is different
	if cond.value == last-checked
		yield-thread
		if until-time before-time?
			cond wait-on until-time, last-checked

before-time? bool(until-time opt timestamp) noctx summon
	match until-time
	as none
		true
	as some s
		get-monotime-nsec < s.value

| TODO: use atomic operations for this
thread-safe-counter record mut
	lk by-val lock
	value mut nat

new-thread-safe-counter by-val thread-safe-counter() noctx
	0 new-thread-safe-counter

new-thread-safe-counter by-val thread-safe-counter(init nat) noctx
	thread-safe-counter: new-lock, init

increment void(t thread-safe-counter) noctx
	t.get-and-increment drop

get-and-increment nat(t thread-safe-counter) noctx trusted
	l = t.lk.ref-of-val
	l acquire-lock
	res = t.value
	t set-value: t.value noctx-incr
	l release-lock
	res

| Returns true if the counter is now 0.
decrement bool(t thread-safe-counter) noctx
	t.get-and-decrement == 0

get-and-decrement nat(t thread-safe-counter) noctx trusted
	l = t.lk.ref-of-val
	l acquire-lock
	res = t.value
	hard-forbid: res == 0
	t set-value: t.value noctx-decr
	l release-lock
	res

create-one-thread void
	tid cell pthread-t
	thread-arg any-ptr
	thread-fun fun-ptr1<any-ptr, any-ptr>
spec
	noctx
	unsafe
	summon
body
	err = tid pthread-create null, thread-fun, thread-arg
	if err != 0
		if err == eagain
			| TODO: warn and make do with the threads it does let us create (so long as there's at least one)
			todo
		else
			| Fatal error
			todo

join-one-thread void(tid pthread-t) noctx unsafe summon
	thread-return = as<by-val<cell<any-ptr>>>: cell: null
	err = tid pthread-join thread-return.ref-of-val
	if err != 0
		if err == einval
			todo
		elif err == esrch
			todo
		else
			todo
	hard-assert: thread-return.ref-of-val.get null?
