no-std
import
	.col.arr: arr, size
	.compare: ==
	.cell: cell, set-subscript, subscript
	.col.arr-util: each-with-index, first-some, map
	.exception: catch, exception
	.fun: subscript
	.misc: as, void
	.number: -, nat
	.opt: none, opt, some
	.result: result
	.private.bootstrap:
		exclusion, fun, fut-state-resolved, hard-unreachable, island, island-and-exclusion, send,
		state, value
	.private.fut-low-level: callback!, reject!, resolve!, resolve-or-reject!, unresolved
	.private.runtime: add-task, exception-handler, get-cur-island, get-island, new-exclusion
	.private.thread-utils: lock, lock-by-val, with-lock
export
	.private.bootstrap: fut

# A future that resolves immediately.
# Used to make code run in another task (to break up a big task).
delay fut void()
	void resolved

# Converts a value to a `fut` resolved with that value.
resolved fut ?a(value ?a)
	fut: lock-by-val, fut-state-resolved: value

# Returns a `fut` resolved with an exception.
rejected fut ?a(err exception)
	fut: lock-by-val, err

###
Calls `f` after both `a` and `b` have resolved.
Returns a fut that will be resolved by the result of `f`.
###
join fut ?out(a fut ?in0, b fut ?in1, f ref ?out(?in0, ?in1)) trusted send<?out> send<?in0> send<?in1>
	res = unresolved<?out>
	lock = lock
	remaining = cell<nat>: 2
	decr-remaining = as<act void()>: \
		lock with-lock \
			remaining[] := remaining[] - 1
			if remaining[] == 0
				res finish-join! a, b, f
	a callback! \ignore
		decr-remaining[]
	b callback! \ignore
		decr-remaining[]
	res

.finish-join! void(res fut ?out, a fut ?in0, b fut ?in1, f ref ?out(?in0, ?in1)) unsafe send<?out> send<?in0> send<?in1>
	match a state
	as fut-state-no-callbacks
		hard-unreachable<void>
	as fut-state-callbacks
		hard-unreachable<void>
	as fut-state-resolved resolved-a
		match b state
		as fut-state-no-callbacks
			hard-unreachable<void>
		as fut-state-callbacks
			hard-unreachable<void>
		as fut-state-resolved resolved-b
			f[resolved-a value, resolved-b value] forward-to! res
		as exception e
			res reject! e
	as exception e
		res reject! e

###
Returns a `fut` that is resolved when every element of the input has resolved.
###
join fut arr ?a(a arr fut ?a) trusted send<?a> send<arr ?a> summon
	# TODO: send<arr ?a> should be unnecessary
	res = unresolved<arr ?a>
	lock = lock
	remaining = cell<nat>: a.size
	a each-with-index \in, index
		in callback! \value
			lock with-lock \
				remaining[] := remaining[] - 1
				if remaining[] == 0
					res finish-join! a
	res

# TODO: send<arr ?a> should be unnecessary
.finish-join! void(res fut arr ?a, a arr fut ?a) unsafe send<?a> send<arr ?a> summon
	exception = a first-some \x
		match x state
		as fut-state-no-callbacks
			hard-unreachable<opt exception>
		as fut-state-callbacks
			hard-unreachable<opt exception>
		as fut-state-resolved
			none
		as exception e
			e some
	match exception
	as none
		res resolve!: a map {it must-be-resolved}
	as some s
		res reject! s.value

.must-be-resolved ?a(a fut ?a) unsafe
	match a state
	as fut-state-no-callbacks
		hard-unreachable
	as fut-state-callbacks
		hard-unreachable
	as fut-state-resolved r
		r value
	as exception
		hard-unreachable

.forward-to! void(from fut ?a, to fut ?a) unsafe
	from callback! {to resolve-or-reject! it}

###
Converts a `fut` that may be resolved with an exception
to a `fut result` that can only be successfully resolved.
###
fut-catch fut result<?a, exception>(a fut ?a) trusted
	res = unresolved<result<?a, exception>>
	a callback! {res resolve! it}
	res

###
Calls `cb` once `a` is resolved.
Returns a fut for the result of `cb`.
If `a` is resolved with an exception, never calls `cb`,
and the result of `then` will have the same exception as `a`.
###
then fut ?out(a fut ?in, cb ref ?out(?in)) trusted send<?out> send<?in>
	res = unresolved<?out>
	a callback! \result
		match result
		as ok o
			cb[o.value] forward-to! res
		as err e
			res reject! e.value
	res

# TODO: rename to just 'then'
# This requires that we be able to handle two expected types at once,
# and choose just one based on the arity of a lambda.

# Like `then`, but `cb` takes no parameter (since it will be `void` anyway.)
then-void fut ?out(a fut void, cb ref ?out()) send<?out>
	a then \ignore
		cb[]

###
Run `f` in a parallel task and return a `fut` for its result.
###
launch fut ?a(f fun fut ?a()) trusted
	res = unresolved<?a>
	island = get-cur-island
	island add-task island.new-exclusion, \
		f[] forward-to! res
	res

###
Enqueues a task that will call the function,
and returns a `fut` for the result of that task.
###
subscript fut ?r(f ref ?r()) trusted send<?r>
	res = unresolved<?r>
	f.island-and-exclusion.island.get-island add-task f.island-and-exclusion.exclusion, \
		{f.fun[] forward-to! res} catch {res reject! it}
	res

subscript fut ?r(f ref ?r(?p0), p0 ?p0) trusted send<?r> send<?p0>
	island = f.island-and-exclusion.island get-island
	res = unresolved<?r>
	island add-task f.island-and-exclusion.exclusion, \
		{f.fun[p0] forward-to! res} catch {res reject! it}
	res

subscript fut ?r(f ref ?r(?p0, ?p1), p0 ?p0, p1 ?p1) trusted send<?r> send<?p0> send<?p1>
	island = f.island-and-exclusion.island get-island
	res = unresolved<?r>
	island add-task f.island-and-exclusion.exclusion, \
		{f.fun[p0, p1] forward-to! res} catch {res reject! it}
	res

###
If the fut resolves successfully, does nothing.
Else, this will call the default exception handler.
###
handle-exceptions void(a fut ?a) trusted
	a callback! \result
		match result
		as ok
			void
		as err e
			get-cur-island.exception-handler[e.value]
