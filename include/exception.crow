no-std
import
	.bool: bool, not
	.fun: subscript
	.private.backtrace: get-backtrace
	.private.bootstrap: err, ok, result, str, void
	.private.exception-low-level: catch-with-exception-ctx, get-exception-ctx
export
	.private.bootstrap: exception, message
	.private.exception-low-level: throw

region throwing

# Create amd throw an exception with the given message.
fail ?a(message str) trusted
	throw: exception: message, get-backtrace

# Fail if the condition is false.
assert void(condition bool)
	if condition not
		"assert failed" fail

###
Fail if the condition is false, providing a custom message.
The message is eagerly evaluated; pass a `fun str()` instead to have it lazily evaluatied.
###
assert void(condition bool, message str)
	if condition not
		message fail

###
Fail if the condition is false, providing a custom message.
The message is evaluated only if an exception will be thrown.
###
assert void(condition bool, message fun str())
	if condition not
		message[] fail

# Fail if the condition is true.
forbid void(condition bool)
	condition forbid "forbid failed"

###
Fail if the condition is true, providing a custom message.
The message is eagerly evaluated; pass a `fun str()` instead to have it lazily evaluatied.
###
forbid void(condition bool, message str)
	if condition
		message fail

###
Fail if the condition is false, providing a custom message.
The message is evaluated only if an exception will be thrown.
###
forbid void(condition bool, message fun str())
	if condition
		message[] fail

###
Fail unconditionally.
This function is used to mark part of an `if` or `match` that should not be possible.
###
unreachable ?a()
	"should be unreachable" fail

region handling

###
Run `try`, and then run `after`, even if `try` threw an exception.
(The exception is only temporarily caught to run `after` and is then rethrown.)
###
finally ?a(after act void(), try act ?a())
	res = try catch \err
		after[]
		err throw
	after[]
	res

###
Run `try` and return `ok` containing its return value,
or `err` containing an exception if it threw one.
###
catch result<?a, exception>(try act ?a())
	{try[] ok} catch {it err}

###
Run `try` and return what it returns, or return the result of `catcher` if `try` threw an exception.
(An exception thrown by `catcher` will not be caught.)
###
catch ?a(try act ?a(), catcher act ?a(exception)) trusted
	get-exception-ctx catch-with-exception-ctx try, catcher
