no-std
import
	./col/arr: arr, size
	./cell: *, cell, new, set-deref
	./col/arr-util: each-with-index, first-some, map
	./exception: catch, exception
	./fun: subscript
	./misc: void
	./opt: none, opt, some
	./result: result
	./private/bootstrap:
		exclusion, fun, fut-state-exception, fut-state-resolved, hard-unreachable, island,
		island-and-exclusion, nat64, new, send, state
	./private/fut-low-level: callback!, reject!, resolve!, resolve-or-reject!, unresolved
	./private/number-low-level: ==, wrap-sub
	./private/runtime: add-task, exception-handler, get-cur-island, get-island, new-exclusion
	./private/thread-utils: lock, lock-by-val, new, with-lock
export
	./private/bootstrap: fut

# A future that resolves immediately.
# Used to make code run in another task (to break up a big task).
delay fut void()
	void resolved

# Converts a value to a `fut` resolved with that value.
resolved<a> fut a(value a)
	lock-by-val, value.fut-state-resolved

# Returns a `fut` resolved with an exception.
rejected<a> fut a(err exception)
	lock-by-val, err.fut-state-exception

###
Calls `f` after both `a` and `b` have resolved.
Returns a fut that will be resolved by the result of `f`.
###
join<out, in0, in1> fut out(a fut in0, b fut in1, f ref out(in0, in1)) trusted send<out> send<in0> send<in1>
	res = unresolved<out>
	lock lock = ()
	remaining cell nat64 = 2,
	decr-remaining act void() = () =>
		lock with-lock () =>
			*remaining := *remaining wrap-sub 1
			if *remaining == 0
				res finish-join! a, b, f
	a callback! ignore =>
		decr-remaining[]
	b callback! ignore =>
		decr-remaining[]
	res

.finish-join!<out, in0, in1> void
	res fut out
	a fut in0
	b fut in1
	f ref out(in0, in1)
spec
	unsafe
	send<out>
	send<in0>
	send<in1>
body
	match a state
	as fut-state-no-callbacks
		hard-unreachable<void>
	as fut-state-callbacks _
		hard-unreachable<void>
	as fut-state-resolved resolved-a
		match b state
		as fut-state-no-callbacks
			hard-unreachable<void>
		as fut-state-callbacks _
			hard-unreachable<void>
		as fut-state-resolved resolved-b
			f[resolved-a, resolved-b] forward-to! res
		as fut-state-exception e
			res reject! e
	as fut-state-exception e
		res reject! e

###
Returns a `fut` that is resolved when every element of the input has resolved.
###
join<a> fut a[](a fut<a>[]) trusted send<a> send<a[]> summon
	# TODO: send<a[]> should be unnecessary
	res = unresolved<a[]>
	lock lock = ()
	remaining cell nat64 = a.size,
	a each-with-index (in, index) =>
		in callback! value =>
			lock with-lock () =>
				*remaining := *remaining wrap-sub 1
				if *remaining == 0
					res finish-join! a
	res

# TODO: send<a[]> should be unnecessary
.finish-join!<a> void(res fut a[], a fut<a>[]) unsafe send<a> send<a[]> summon
	exception = a first-some x =>
		match x state
		as fut-state-no-callbacks
			hard-unreachable<exception?>
		as fut-state-callbacks _
			hard-unreachable<exception?>
		as fut-state-resolved _
			none
		as fut-state-exception e
			e some
	if e ?= exception
		res reject! e
	else
		res resolve! (a map (it => it must-be-resolved))

.must-be-resolved<a> a(a fut a) unsafe
	match a state
	as fut-state-no-callbacks
		hard-unreachable
	as fut-state-callbacks _
		hard-unreachable
	as fut-state-resolved r
		r
	as fut-state-exception _
		hard-unreachable

.forward-to!<a> void(from fut a, to fut a) unsafe
	from callback! it => to resolve-or-reject! it

###
Converts a `fut` that may be resolved with an exception
to a `fut result` that can only be successfully resolved.
###
fut-catch<a> fut result<a, exception>(a fut a) trusted
	res = unresolved<result<a, exception>>
	a callback! value => res resolve! value
	res

###
Calls `cb` once `a` is resolved.
Returns a fut for the result of `cb`.
If `a` is resolved with an exception, never calls `cb`,
and the result of `then` will have the same exception as `a`.
###
then<out, in> fut out(a fut in, cb ref out(in)) trusted send<out> send<in>
	res = unresolved<out>
	a callback! result =>
		match result
		as ok o
			cb[o] forward-to! res
		as err e
			res reject! e
	res

# TODO: rename to just 'then'
# This requires that we be able to handle two expected types at once,
# and choose just one based on the arity of a lambda.

# Like `then`, but `cb` takes no parameter (since it will be `void` anyway.)
then-void<out> fut out(a fut void, cb ref out()) send<out>
	a then ignore =>
		cb[]

###
Run `f` in a parallel task and return a `fut` for its result.
###
launch<a> fut a(f fun fut a()) trusted
	res = unresolved<a>
	island = get-cur-island
	island add-task island.new-exclusion, () =>
		f[] forward-to! res
	res

###
Enqueues a task that will call the function,
and returns a `fut` for the result of that task.
###
subscript<r> fut r(f ref r()) trusted send<r>
	res = unresolved<r>
	f.island-and-exclusion.island.get-island add-task f.island-and-exclusion.exclusion, () =>
		(() => f.fun[] forward-to! res) catch err => res reject! err
	res

subscript<r, p0> fut r(f ref r(p0), p0 p0) trusted send<r> send<p0>
	island = f.island-and-exclusion.island get-island
	res = unresolved<r>
	island add-task f.island-and-exclusion.exclusion, () =>
		(() => f.fun[p0] forward-to! res) catch err => res reject! err
	res

subscript<r, p0, p1> fut r(f ref r(p0, p1), p0 p0, p1 p1) trusted send<r> send<p0> send<p1>
	island = f.island-and-exclusion.island get-island
	res = unresolved<r>
	island add-task f.island-and-exclusion.exclusion, () =>
		(() => f.fun[p0, p1] forward-to! res) catch err => res reject! err
	res

###
If the fut resolves successfully, does nothing.
Else, this will call the default exception handler.
###
handle-exceptions<a> void(a fut a) trusted
	a callback! result =>
		match result
		as ok _
			void
		as err e
			get-cur-island.exception-handler[e]
