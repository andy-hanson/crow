###
Functions for measuring performance.

Even non-`summon` code is can measure perf, but only `summon` code can access the measurements.
###
no-std
import
	./col/array: +, array, begin, is-empty, iterate, new, next, size
	./col/collection: for-loop, index-of, join, set-subscript, subscript
	./col/dict: ~=, build, dict, iterate, size
	./col/list: ~=, build, iterate, list, to
	./col/mut-array: ~=, +, begin, build, mut-array, next, new, set-next
	./exception: finally, with-block
	./fun-util: subscript
	./io/duration: duration, nsec, to
	./io/private/time-low-level: get-monotime-nsec
	./misc: new, void
	./number: ==, <=>, +, -, nat64, to
	./range: .., iterate, size
	./string: ~~, literal, new, string, to
	./symbol: ==, <=>, hash-mix, symbol, to
	./tuple: new

+perf-result record
	total duration
	measures measure-total[symbol]
+to string(a perf-result)
	measures = ", " join for name, total : a measures
		"{name}: {total}"
	"total: {a total}, {measures}"

# Count and total duration of all measurements with the same name.
+measure-total record
	# Number of times a perf measure happend with this name.
	+count nat64
	# Total time spent in all measures with this name.
	+total-duration duration
+to string(a measure-total)
	"{a count} Ã— {a total-duration}"

# Use 'nsec' instead of 'duration' to avoid spending time converting to floats
-measure-accum record
	count nat64
	total-nsec nat64
-new measure-accum()
	0, 0
-+ measure-accum(a measure-accum, b measure-accum)
	a.count + b.count, a.total-nsec + b.total-nsec

+measure-performance record
	measure-names symbol array
+measure-performance measure-performance()
	(),
+measure-performance measure-performance(measure-names symbol[])
	measure-names.to,

# Enable performance, run the callback, then return its result and the measured performance.
+with-block[t] (t, perf-result)(a measure-performance, f act t()) summon
	assert (trusted measure-names.is-empty) : "Already measuring performance"
	with : (() => trusted clear-perf) finally
		trusted
			measure-names := a measure-names
			measure-accums := for _ : measure-names; ()
		start = perf-now
		f-res = f[]
		end = perf-now
		# TODO: 'zip'
		perf-res perf-result = (end - start).to.nsec, trusted for i : 0 .. measure-names.size
			value = measure-accums[i]
			measure-names[i], (value.count, value.total-nsec.to.nsec)
		f-res, perf-res

+perf-measure record
	measure-name symbol
+perf-measure perf-measure(measure-name symbol)
	measure-name,

###
Runs `f` and returns its result.
If the performance measure `measure-name` is enabled, this contribues to its performance measurement.
###
+with-block[t] t(a perf-measure, f act t())
	if index ?= (trusted measure-names) index-of a.measure-name
		start = perf-now
		res = f[]
		nsec = perf-now - start
		(trusted measure-accums)[index] +:= (1, nsec)
		res
	else
		f[]

# List of all names being measured
-measure-names thread-local(symbol array)
# Parallel to measure-names
-measure-accums thread-local(measure-accum mut-array)
-clear-perf void() unsafe
	measure-names := ()
	measure-accums := ()

-perf-now nat64() noctx
	get-monotime-nsec
