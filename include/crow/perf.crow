no-std
import
	./bool: ||
	./col/arr: arr, size, subscript
	./col/arr-util: zip
	./col/fix-arr: fill-fix-arr, set-subscript, subscript, temp-as-arr
	./fun-util: subscript
	./io/time-low-level: get-monotime-nsec
	./misc: drop, new, void
	./ptr: as-ref
	./sym: ==, sym
	./private/bootstrap: get-ctx, nat64, perf-ctx-ptr, thread-local-stuff
	./private/number-low-level: ==, wrap-add, wrap-sub
	./private/perf-low-level:
		measure-names, measure-values, new, ns, perf-ctx, perf-time, set-measure-names,
		set-measure-values, total-ns
export
	./private/perf-low-level: count, measure-value, total-duration

perf-reset void(names sym[]) summon
	perf = get-perf-ctx
	perf.measure-names := names
	perf.measure-values := names.size fill-fix-arr (0, 0)

# TODO: what if a measurement is taken while this is running?
perf-each-measure void(cb act void(sym, measure-value)) trusted
	perf = get-perf-ctx
	drop: perf.measure-names zip perf.measure-values.temp-as-arr, (name, value) =>
		cb[name, value]

perf-get-measure measure-value(name sym) summon
	perf = get-perf-ctx
	index = perf.measure-names find-index name
	if index == perf.measure-names.size
		0, 0
	else
		perf.measure-values[index]

perf-now perf-time() noctx
	get-monotime-nsec,

with-perf-measure<a> a(name sym, cb act a())
	start = perf-now
	res = cb[]
	start perf-measure name
	res

perf-measure void(start perf-time, name sym)
	perf = get-perf-ctx
	index = perf.measure-names find-index name
	unless index == perf.measure-names.size
		ns = perf-now.ns wrap-sub start.ns
		old = perf.measure-values[index]
		perf.measure-values[index] := (old.count wrap-add 1), (old.total-ns wrap-add ns)

.get-perf-ctx perf-ctx() trusted
	get-ctx.thread-local-stuff.perf-ctx-ptr as-ref

.find-index nat64(names sym[], name sym)
	names find-index name, 0
.find-index nat64(names sym[], name sym, index nat64)
	if index == names.size || names[index] == name
		index
	else
		names find-index name, (index wrap-add 1)
