###
Functions for measuring performance.

Even non-`summon` code is can measure perf, but only `summon` code can access the measurements.
###
no-std
import
	./col/array: +, array, begin, iterate, new, next, size
	./col/collection: for-loop, index-of, join, n-of, set-subscript, subscript
	./col/dict: ~=, build, dict, iterate, size
	./col/list: ~=, build, iterate, list, to
	./col/mut-array: ~=, +, begin, build, mut-array, next, set-next
	./exception: finally, with-block
	./fun-util: subscript
	./io/duration: duration, nsec, to
	./io/private/time-low-level: get-monotime-nsec
	./misc: new, void
	./number: ==, <=>, +, -, nat64, to
	./option: new, is-empty, option
	./pointer: *, mut-pointer, set-deref
	./range: .., iterate, size
	./string: ~~, literal, new, string, to
	./symbol: ==, <=>, hash-mix, symbol, to
	./tuple: new

+perf-result record
	total duration
	measures measure-total[symbol]
+to string(a perf-result)
	measures = ", " join for name, total : a measures
		"{name}: {total}"
	"total: {a total}, {measures}"

# Count and total duration of all measurements with the same name.
+measure-total record
	# Number of times a perf measure happend with this name.
	+count nat64
	# Total time spent in all measures with this name.
	+total-duration duration
+to string(a measure-total)
	"{a count} Ã— {a total-duration}"

# Use 'nsec' instead of 'duration' to avoid spending time converting to floats
-measure-accum record
	count nat64
	total-nsec nat64
-new measure-accum()
	0, 0
-+ measure-accum(a measure-accum, b measure-accum)
	a.count + b.count, a.total-nsec + b.total-nsec

+measure-performance record
	measure-names symbol array
+measure-performance measure-performance()
	(),
+measure-performance measure-performance(measure-names symbol[])
	measure-names.to,

# Enable performance, run the callback, then return its result and the measured performance.
+with-block[t] (t, perf-result)(a measure-performance, f act t()) summon
	assert (trusted local-perf->is-empty) : "Already measuring performance"
	with : (() => trusted clear-perf) finally
		measure-values measure-accum mut-array = a.measure-names.size n-of ()
		trusted
			*local-perf := (a.measure-names, measure-values),
		start = perf-now
		f-res = f[]
		end = perf-now
		# TODO: 'zip'
		perf-res perf-result = (end - start).to.nsec, for i : 0 .. a.measure-names.size
			value = measure-values[i]
			a.measure-names[i], (value.count, value.total-nsec.to.nsec)
		f-res, perf-res

+perf-measure record
	measure-name symbol
+perf-measure perf-measure(measure-name symbol)
	measure-name,

###
Runs `f` and returns its result.
If the performance measure `measure-name` is enabled, this contribues to its performance measurement.
###
+with-block[t] t(a perf-measure, f act t())
	if perf ?= trusted *local-perf
		if index ?= perf.measure-names index-of a.measure-name
			start = perf-now
			res = f[]
			nsec = perf-now - start
			perf.measure-accums[index] +:= (1, nsec)
			res
		else
			f[]
	else
		f[]

-local-perf perf? mut*() thread-local
-perf record mut
	measure-names symbol array
	measure-accums measure-accum mut-array
-clear-perf void() unsafe
	*local-perf := ()

-perf-now nat64() noctx
	get-monotime-nsec
