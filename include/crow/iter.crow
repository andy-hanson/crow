no-std
import
	./bool: bool
	./fun: subscript
	./misc: void
	./opt: opt, some

###
Function to get an iterator.
The iterator returned should be equivalent each time, so this can be used to iterate multiple times.
###
iterable<a> record mut
	get-iter act iterator a()

# Get a new iterator at the beginning.
iter<a> iterator a(s iterable a)
	s.get-iter[]

# Converts anything with an `iter` function to an `iterable`.
to-iterable<a, e> iterable e(a a) iter<a, e>
	(() => a iter),

# Spec for anything that has an iterator.
iter<a, e> spec
	iter iterator e(t a)

###
An iterator is a value that could iterate over anything.
This is often a collection; but since any function may be provided,
it could iterate an abstract sequence (such as numbers in a range) with no backing collection.

An iterator mutates itself when `next` is called to advance.
Once it returns `none`, all future calls should also return `none`.
###
iterator<a> record mut
	get-next act a?()

# Returns the current element and advances to the next.
next<a> a?(i iterator a)
	i.get-next[]

# Calls a function for each element of an iterable.
each<a> void(a iterable a, f act void(a))
	a.iter each-recur f
.each-recur<a> void(i iterator a, f act void(a))
	if v ?= i next
		f[v]
		i each-recur f

# Returns a new iterable containing just the elements of the input for which `pred` returns true.
filter<a> iterable a(a iterable a, pred act bool(a))
	new: () =>
		itr = a iter
		(() => itr filter-recur pred),
.filter-recur<a> a?(a iterator a, pred act bool(a))
	if v ?= a next
		if pred[v]
			v some
		else
			# This one didn't satisfy the predicate, but keep trying until we get one or each the end
			a filter-recur pred

# Returns a new iterable which yields f[x] for each x in the input.
map<out, in> iterable out(a iterable in, f act out(in))
	new: () =>
		itr = a iter
		(() => itr map-recur f),
.map-recur<out, in> out?(a iterator in, f act out(in))
	if v ?= a next
		f[v] some
