no-std
import
	./bool: &&, bool, false, not, true
	./col/collection:
		.., end, for-break, for-loop, index-of, n-of, set-subscript, split, subscript,
		try-remove-start
	./col/dict: ==, ~=, build, dict, iterate, new, size
	./col/list: ==, ~~, +, -, begin, end, iterate, is-empty, list, new, next, size, slice
	./col/mut-dict: iterate, mut-dict, new, set-subscript, size
	./col/mut-list: ~=, +, begin, build, move-to-list, mut-list, new, next, set-next
	./json: json, json-object, new
	./misc: loop-break, loop-continue, new
	./number: ==, +
	./option: ??, new, option
	./string: ==, ~~, begin, end, literal, next, slice, string, to-c-string, to-string
	./symbol: ==, <=>, hash-mix, string-to-symbol, symbol
	./test-util: is
	./tuple: new

###
In this syntax:
* Each name starting with `--` is an argument name, and words after that are its argumets.
* Everything before the first named argument will be left unparsed and put in `nameless`.
* Everything after `--` will be left unparsed and put in `after`.

For example, if the command is: `foo bar --a 1 --b 2 3 -- x y z`:
`nameless` will be: `"foo", "bar"`
`named` will be: `("a", (1,)), ("b", (2, 3))`
`after` will be: `"x", "y", "z"`
###
+parsed-command record
	nameless string[]
	named string[][symbol]
	after string[]

+== bool(a parsed-command, b parsed-command)
	a.nameless == b.nameless && a.named == b.named && a.after == b.after
-json json(a parsed-command)
	named = (for k, v : a named; k, v.json) json-object
	("nameless", a.nameless.json), ("named", named), ("after", a.after.json)

###
See comment on `parsed-command` for syntax.
Parse errors aren't possible with this syntax.
###
+parse-command parsed-command(args string[])
	nameless string mut[] = ()
	named string mut[] mut[symbol] = ()
	after mut string[] = ()
	cur mut string mut[] = nameless
	for i, arg : args
		if arg == "--"
			after := args[i + 1 .. end]
			break
		elif name ?= arg try-remove-start "--"
			cur := ()
			named[name string-to-symbol] := cur
			continue
		else
			cur ~= arg
			continue
	nameless.move-to-list, (for k, v : named; k, v.move-to-list), after

test
	("foo --bar baz -- bang" split " ").parse-command is (("foo",), (("bar", ("baz",)),), ("bang",))

###
This is stricter than `parse-command`.
It expects only named arguments with no `before` or `after`, and only the names in `arg-names` are allowed.

Returns an array with an entry for each name in `arg-names`.
Values in the array will be a list of the argument values,
or an empty option if the corresponding argument name did not appear.

For example, if the command line is "--a --c d" and arg-names are ("a", "b", "c"),
This will return `((),) (), (("d",),)`.

If the argument syntax is invalid, returns an empty option.
###
parse-named-args string[]?[]?(args string[], arg-names symbol[])
	parsed = args parse-command
	values string[]? mut[] = arg-names.size n-of ()
	err mut = false
	for key, value : parsed named
		if index ?= arg-names index-of key
			values[index] := ((values[index] ?? ()) ~~ value),
		else
			err := true
	if parsed.nameless.is-empty && parsed.after.is-empty && !err
		values.move-to-list,

###
If `a` as a single element, returns that; else throws an exception.

Useful for arguments that should have a single string as their value.
###
single-string-or-throw string(a string[]?, option-name string)
	if strs ?= a
		if strs.size == 1
			strs[0]
		elif strs.size == 0
			throw "{option-name} needs a value"
		else
			throw "{option-name} got too many values"
	else
		throw "Need {option-name}"
