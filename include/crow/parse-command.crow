no-std
import
	./bool: !, bool, false, true
	./cell: *, cell, new, set-deref
	./col/arr: arr, is-empty, new, size, subscript
	./col/arr-util: find-index, index-of, tail
	./col/dict: dict, each, new
	./col/mut-dict: move-to-dict!, mut-dict, new, set-subscript
	./col/mut-arr: fill-mut-arr, move-to-arr!, mut-arr, set-subscript, subscript
	./exception: assert, throw
	./hash: hash-mix
	./misc: void
	./number: ==, <=>, +
	./opt: force, is-empty, new, opt
	./range: ..
	./str: ==, <=>, str
	./str-conv: interp, finish, to-str, with-str, with-value
	./str-util: starts-with, try-remove-start

###
Returns none on failure to parse.
On success, returns an array of corresponding arguments.
Each argument will be 'none' if the argument was passed, else an array of argument values.
If the command line is "--a --c d" and arg-names are ("a", "b", "c"),
"a" will get `(),`, "b" will get `none`, and "c" will get `("d",),`.
###
parse-named-args str[]?[]?(args str[], arg-names str[])
	parsed = args parse-command-dynamic
	parsed.nameless.is-empty assert "Should be no nameless args"
	assert: parsed.after is-empty

	values str[]? mut[] = arg-names.size fill-mut-arr ()
	# TODO: should not need a type argument here
	help cell bool = false,
	parsed.named each (key, value) =>
		if index ?= arg-names index-of key
			# TODO: duplicate argument error
			assert: values[index] is-empty
			values[index] := (value,)
		elif key == "help"
			*help := true
		else
			throw: "Unexpected arg {key}"

	if !*help
		values.move-to-arr!,

single-str-or-throw str(a str[]?, option-name str)
	if strs ?= a
		if strs.size == 0
			throw: "{option-name} needs a value"
		if strs.size == 1
			strs[0]
		else
			throw: "{option-name} got too many values"
	else
		throw: "Need {option-name}"

# Command line syntax:
# `foo bar --a 1 --b 2 3 -- x y z`
# nameless: foo bar
# named: a = 1, b = 2 3
# after: x y z
.parsed-command record
	nameless str[]
	named str[][str]
	after str[]

.parse-command-dynamic parsed-command(args str[])
	# Find the location of the first name beginning in '--'
	if first-named-arg-index ?= args find-index arg => arg starts-with "--"
		nameless = args[0 .. first-named-arg-index]
		rest = args[first-named-arg-index .. args.size]
		if sep-index ?= rest find-index arg => arg == "--"
			named-args = rest[0 .. sep-index] parse-named-args
			nameless, named-args, rest[sep-index + 1 .. rest.size]
		else
			nameless, rest.parse-named-args, ()
	else
		args, (), ()

.parse-named-args str[][str](args str[])
	res str[] mut[str] = ()
	args parse-named-args-recur res
	res move-to-dict!

.parse-named-args-recur void(args str[], builder str[] mut[str])
	first-name = args[0] try-remove-start "--" force
	tl = args tail
	if next-named-arg-index ?= tl find-index arg => arg starts-with "--"
		builder[first-name] := tl[0 .. next-named-arg-index]
		tl[next-named-arg-index .. tl.size] parse-named-args-recur builder
	else
		builder[first-name] := tl
