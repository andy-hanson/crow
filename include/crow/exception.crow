no-std
import
	./bool: ||, bool, new, true
	./col/array: iterate, size, subscript
	./col/collection: find-index, for-loop, starts-with
	./col/list: ~=, build
	./compare: >
	./js: await, call, cast, eval
	./number: ==, <=>, -
	./option: new, option
	./range: ..
	./result: result
	./string: ==, begin, interpolate, is-empty, join, next, string, to
export
	./private/backtrace: backtrace, backtrace-entry, entries, file-path, function-name, line-number
	./private/exception-low-level:
		catch-all, describe, error, exception, exception-and-backtrace, rethrow, unreachable

+ignore-exceptions record nominal
+with-block[t] t?(_ ignore-exceptions, f t mut())
	if trusted extern native
		match f catch-all
		as ok x
			x,
		as error _
			()
	elif trusted extern js
		some t? data(x t) = x => x,
		none t? data() = () => ()
		res = trusted """
		async (f, some, none) => \{
			try \{
				return some(await f())
			} catch \{
				return none()
			}
		}
		""".eval call f, some, none await
		trusted res cast
	else
		throw todo

+todo record exception variant-member
+describe string(_ todo)
	"TODO"

+not-implemented record exception variant-member
+describe string(_ not-implemented)
	"The operation is not implemented on this platform."

# Outputs the exception's message and backtrace to a string.
+to string(a exception-and-backtrace) unsafe, native extern
	"{a exception}{a backtrace}"

+to string(a exception)
	a describe

+to string(a backtrace) unsafe, native extern
	# Don't include entries from runtime, only at start of function
	kept-entries = if idx ?= a.entries find-index x => x is-runtime-function-entry
		if idx > 0
			if a.entries[idx - 1].function-name.to::string == "call"
				a.entries[0 .. idx - 1]
			else
				a.entries[0 .. idx]
		else
			a entries
	else
		a entries
	"" join for x : kept-entries
		"\n\tat {x}"

-translate-name string(a string)
	if a == "main_0"
		"main"
	else
		a

-is-runtime-function-entry bool(a backtrace-entry) native extern
	(trusted a.function-name.to) is-runtime-function-name

-is-runtime-function-name bool(a string)
	if a starts-with "then@"
		true
	elif a == "wrap-main" || a == "__wrap_main"
		true
	elif a == "invoke-action" || a == "invoke__45action"
		true

-to string(a backtrace-entry) native extern
	name string = trusted a.function-name.to translate-name
	path string = trusted a.file-path to
	if name is-empty
		"<<unknown>>"
	elif path is-empty
		name
	elif a.line-number == 0
		"{name} ({path})"
	else
		"{name} ({path}:{a line-number})"

+force[t] t(a (t, exception-and-backtrace) result)
	match a
	as ok v
		v
	as error e
		e rethrow
