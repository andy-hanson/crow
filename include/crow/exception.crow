no-std
import
	./col/array: iterate, size
	./col/collection: for-loop, join
	./col/list: ~=, build, iterate
	./fun-util: subscript
	./misc: new, void
	./number: ==
	./string: ~~, is-empty, literal, new, string, to
export
	./private/backtrace: backtrace, backtrace-entry, entries, file-path, function-name, line-number
	./private/exception-low-level: catch, exception, message, rethrow, unreachable

region handling

+finally record mut
	-cleanup act void()
+finally finally(cleanup act void())
	cleanup,
###
Runs `try`, and then runs `cleanup`, even if `try` threw an exception.

If there was an exception, it will be rethrown after `after` finishes.
If `after` throws an exception, the original exception will be lost.
###
+with-block[t] t(a finally, try act t())
	res = a.cleanup do-if-error () => try[]
	a.cleanup[]
	res

###
Rus `try`, and if it throws an exception, runs `on-error`.

This is like `finally`, but does not run in the successful case.
###
+do-if-error[t] t(on-error act void(), try act t())
	try catch err =>
		on-error[]
		err rethrow

# Outputs the exception's message and backtrace to a string.
+to string(a exception) unsafe
	message string = a.message to
	"{message.is-empty ? "<<empty message>>" : message}{a.backtrace}"

-to string(a backtrace)
	"" join for x : a entries
		"\n\tat {x}"

-to string(a backtrace-entry)
	name string = trusted a.function-name to
	path string = trusted a.file-path to
	if name is-empty
		"<<unknown>>"
	elif path is-empty
		name
	elif a.line-number == 0
		"{name} ({path})"
	else
		"{name} ({path}:{a line-number})"
