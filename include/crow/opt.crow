no-std
import
	./bool: bool, false, true
	./compare: equal
	./fun-util: subscript
	./misc: drop, void
	./str: ==, str
	./tuple: new, pair
	./private/bootstrap: char
	./private/exception-low-level: throw
	./private/number-low-level: ==, int64, nat64
export
	./private/bootstrap: none, opt, some

== bool(a int64?, b int64?) noctx
	a opt-equal b
== bool(a nat64?, b nat64?) noctx
	a opt-equal b
== bool(a str?, b str?) noctx
	a opt-equal b
== bool(a char?, b char?) noctx
	a opt-equal b

# TODO:GENERIC
.opt-equal<a> bool(a a?, b a?) equal<a> noctx
	if va ?= a
		if vb ?= b
			va == vb
		else
			false
	else
		b is-empty

# True iff a is `none`.
is-empty<a> bool(a a?) noctx
	if x ?= a
		# TODO: use '_'
		drop: x
		false
	else
		true

size<a> nat64(a a?) noctx
	if a.is-empty
		0
	else
		1

# Calls `f` on the value in a `some`, or does nothing.
each<a> void(a a?, f act void(a))
	if v ?= a
		f[v]

# Converts `none` to `none`, or `some` to another `some` with `f` applied.
map<out, in> out?(a in?, f act out(in))
	if v ?= a
		f[v] some

# Takes the leftmost `some` value.
opt-or<a> a?(a a?, b a?)
	if a is-empty
		b
	else
		a

# Converts an option to a value by supplying a default to handle `none`.
or-default<a> a(a a?, default act a())
	if v ?= a
		v
	else
		default[]

or-default<a> a(a a?, default a)
	if v ?= a
		v
	else
		default

# Converts an option to a value by failing on `none`.
force<a> a(a a?)
	a force "tried to force empty option"

force<a> a(a a?, message str)
	if v ?= a
		v
	else
		message throw

# TODO: Should be called 'force' too, but that loses the expected type
or-throw<a> a(a a?, get-message act str())
	if v ?= a
		v
	else
		get-message[] throw

###
If both `a` and `b` are non-empty, combines them using `f`.
Else, returns the non-empty one.
###
opt-combine<a> a?(a a?, b a?, f act a(a, a))
	if va ?= a
		if vb ?= b
			f[va, vb] some
		else
			a
	else
		b

opt-join<in0, in1> pair<in0, in1>?(a in0?, b in1?)
	a opt-join b, (x, y) =>
		x, y

###
Returns `some: f[a.force, b.force]` iff both `a` and `b` are `some`, else returns `none`.
###
opt-join<out, in0, in1> out?(a in0?, b in1?, f act out(in0, in1))
	if va ?= a
		if vb ?= b
			f[va, vb] some
