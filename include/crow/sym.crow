no-std
import
	string: memcpy
	./bool: bool
	./col/arr: begin-ptr, size
	./col/arr-util: find
	./compare: comparison
	./misc: drop
	./opt: opt, some
	./ptr: ==, as-const, by-val, ptr-cast, ref-of-ptr, ref-of-val, set-deref, set-subscript
	./str: ==, <=>, char, chars, c-str, str
	./str-util: to-str
	./private/alloc: unmanaged-alloc-elements, unmanaged-alloc-uninitialized
	./private/bootstrap: new, static-syms
	./private/number-low-level: nat8, wrap-add
	./private/runtime:
		dynamic-sym-node, dynamic-syms, get-global-ctx, global-ctx, new, next, set-dynamic-syms,
		sym, syms-lock
	./private/thread-utils: with-lock
export
	# TODO: ensure that 'sym' constructor from c-str is not exported
	./private/bootstrap: sym, to-c-str

== bool(a sym, b sym) noctx trusted
	# (this is pointer equality)
	a.to-c-str == b.to-c-str

<=> comparison(a sym, b sym) noctx
	a.to-str <=> b.to-str

to-str str(a sym) noctx trusted
	a.to-c-str to-str

# TODO: name 'to-sym'
str-to-sym sym(a str) trusted
	if sym ?= static-syms find@<sym> (s => s.to-str == a)
		sym
	else
		gctx = get-global-ctx
		gctx.syms-lock.ref-of-val with-lock () =>
			gctx get-dynamic-sym a

.get-dynamic-sym sym(gctx global-ctx, a str) unsafe noctx
	if sym ?= gctx.dynamic-syms find-dynamic-sym a
		sym
	else
		sym sym = a.to-malloced-c-str,
		node-ptr = unmanaged-alloc-uninitialized@<by-val dynamic-sym-node>
		*node-ptr := sym, gctx.dynamic-syms
		gctx.dynamic-syms := node-ptr.ref-of-ptr some
		sym

.find-dynamic-sym sym?(a dynamic-sym-node?, s str) unsafe noctx
	if node ?= a
		if node.sym.to-c-str.to-str == s
			node.sym some
		else
			node.next find-dynamic-sym s

.to-malloced-c-str c-str(a str) noctx unsafe
	n-chars = a.chars size
	res = n-chars wrap-add 1 unmanaged-alloc-elements@<char>
	drop: res.ptr-cast@<nat8, char> memcpy a.chars.begin-ptr.ptr-cast@<nat8, char>, n-chars
	res[n-chars] := "\0"
	res as-const
