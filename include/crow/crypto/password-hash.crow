no-std
import
	sodium:
		crypto_pwhash_memlimit_moderate, crypto_pwhash_memlimit_sensitive,
		crypto_pwhash_opslimit_moderate, crypto_pwhash_opslimit_sensitive, crypto_pwhash_str,
		crypto_pwhash_strbytes, crypto_pwhash_str_verify
	../bool: bool
	../col/array: begin-pointer, size
	../col/mut-array: begin-pointer, cast-immutable, mut-array, uninitialized-mut-array
	../col/list: list, size, to-array, to-list
	../number: ==, nat8
	../pointer: mut-pointer, pointer-cast
	../string: char8, char8s, string
	./private/sodium: ensure-sodium-initialized

###
These correspond to options from libsodium.
Use `quality-moderate` for most cases.
`quality-sensitive` is for non-interactive use cases.
###
password-hash-quality enum
	quality-moderate
	quality-sensitive

# Get the hash of a password.
password-hash nat8[](password string, quality password-hash-quality) trusted
	ensure-sodium-initialized
	strbytes = crypto_pwhash_strbytes
	assert strbytes == 128
	res nat8 mut-array = strbytes uninitialized-mut-array
	ops-limit = match quality
	as quality-moderate
		crypto_pwhash_opslimit_moderate
	as quality-sensitive
		crypto_pwhash_opslimit_sensitive
	mem-limit = match quality
	as quality-moderate
		crypto_pwhash_memlimit_moderate
	as quality-sensitive
		crypto_pwhash_memlimit_sensitive
	res-bytes char8 mut* = res.begin-pointer pointer-cast
	chars = password.char8s to-array
	err = res-bytes crypto_pwhash_str chars.begin-pointer, chars.size, ops-limit, mem-limit
	assert err == 0
	res.cast-immutable to-list

# With very high probabiliy, this will only be `true` if `hash` was the result of hashing `password`.
password-matches-hash bool(password string, hash nat8[]) trusted
	assert hash.size == crypto_pwhash_strbytes
	chars = password.char8s to-array
	hash-array = hash to-array
	(hash-array.begin-pointer.pointer-cast crypto_pwhash_str_verify chars.begin-pointer, chars.size) == 0
