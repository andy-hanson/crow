no-std
import
	./bool: ||, bool
	./compare: <, comparison
	./col/array: array, as-array, begin, begin-pointer, end, new, next, slice
	./col/collection:
		build-options, drop-right-while, drop-while, for-loop, join, split, strip-right, try-split-once
	./col/list:
		==, <=>, ~=, ~, ~~, ~~=, +, -, as-list, begin, build, collection, end, is-empty, iterate,
		list, list-builder, list-cast, list-iterator, new, next, next-index, prev, size, slice,
		to-array, to-list
	./col/mut-list: copy, move-to-list, to-mut-list
	./fun-util: subscript
	./hash: hasher, hash-mix
	./misc: void
	./number:
		==, <=>, +, *, /, %, abs, float64, float32, int8, int16, int32, int64, is-nan, min-int64,
		nat8, nat16, nat32, nat64, to-float64, to-int64, to-nat64, truncate-to-int64
	./option: new, option
	./pointer: ==, <=>, const-pointer
	./private/c-string-util: find-c-string-end
	./private/number-low-level: wrap-sub
	./range: .., range
	./tuple: a, b, new, pair
export
	./private/bootstrap: char8, c-string, to-char8, to-nat8

###
Strings are optimized for fast concatenation and splitting.
They don't support efficient access by index, so use iterators instead.
###
!string record by-val
	.inner char8[]

!char8s char8[](a string) noctx
	a inner

!literal string(a c-string) noctx
	trusted (a .. a.find-c-string-end).as-list as-string

###
Concatenate two strings.
This is O(n).

If you need to concatenate many strings, consider using the `crow/writer` module.
###
!~~ string(a string, b string)
	a.inner ~~ b.inner,

# Same as `""`.
!new string() noctx
	""

# Same as `a == ""`.
!is-empty bool(a string) noctx
	a.inner is-empty

# Size in `char8`s
!size nat64(a string) noctx
	a.inner size

!== bool(a string, b string)
	a.inner == b.inner
!== bool(a char8, b char8) noctx
	a.to-nat8 == b.to-nat8

!<=> comparison(a string, b string)
	a.inner <=> b.inner
!<=> comparison(a char8, b char8) noctx
	a.to-nat8 <=> b.to-nat8

!hash-mix void(hasher hasher, a string)
	for c : a char8s
		hasher hash-mix c
!hash-mix void(hasher hasher, a char8)
	hasher hash-mix a.to-nat8.to-nat64

region conversion

###
Treat a list of UTF-8 character codes as a string.
This is O(1).
###
!as-string string(a char8[]) noctx
	a,
as-string string(a char8 array) noctx
	a.to-list as-string
as-string string(a char8* range) noctx, unsafe
	a.as-array as-string

###
Treats UTF-8 bytes as a string.
This is O(1).
###
!as-string string(bytes nat8[])
	trusted bytes.list-cast::char8[] as-string
as-string string(bytes nat8 array)
	bytes.to-list as-string

###
Treats a string as a list of UTF-8 bytes.
This is O(1).
###
!to-bytes nat8[](a string)
	trusted a.char8s list-cast

# TODO: this should probably be 'unsafe', but safe functions like "throw" need a c-string
###
Converts a string to a c-string by appending "\0".
This is O(n).

WARN: The resulting string is allocated from GC memory but isn't traced by the garbage collector,
so it may be freed after the current task.
###
!to-c-string c-string(a string)
	(a.char8s ~ "\0").to-array begin-pointer

###
Treats a c-string as a string by walking to the end.
This copies the memory, so the result is safe to use immutably.

Unsafe because `a` must end in a `"\0"` character somewhere.
###
!to-string string(a c-string) unsafe
	# TODO: 'copy' seems unnecessary since 'to-mut-list' should do that?
	a.literal.char8s.to-mut-list.copy.move-to-list as-string

# `"true"` or `"false"`.
!to-string string(b bool) noctx
	if b
		"true"
	else
		"false"

# String containing a single character.
!to-string string(c char8)
	(c,)::char8[] as-string

###
Converts a nat64 to a string.
Result is only digits, no punctuation.
###
!to-string string(a nat64)
	a to-base 10

.digit-to-string string(a nat64)
	if a == 0
		"0"
	elif a == 1
		"1"
	elif a == 2
		"2"
	elif a == 3
		"3"
	elif a == 4
		"4"
	elif a == 5
		"5"
	elif a == 6
		"6"
	elif a == 7
		"7"
	elif a == 8
		"8"
	elif a == 9
		"9"
	elif a == 10
		"a"
	elif a == 11
		"b"
	elif a == 12
		"c"
	elif a == 13
		"d"
	elif a == 14
		"e"
	elif a == 15
		"f"
	else
		"?"

!to-binary string(a nat64)
	a to-base 2

!to-hex string(a nat64)
	a to-base 16
!to-hex string(a nat8)
	a to-base 16

.to-base string(a nat64, base nat64)
	if a < base
		a digit-to-string
	else
		(a / base to-base base) ~~ (a % base).digit-to-string
.to-base string(a nat8, base nat64)
	a.to-nat64 to-base base

# Spec of any type that could be converted to a string.
!to-string[t] spec
	to-string string(a t)

# Identity function to satisfy the `to-string` spec.
!to-string string(a string)
	a

!to-string string(a nat8)
	a.to-nat64 to-string

!to-string string(a nat16)
	a.to-nat64 to-string

!to-string string(a nat32)
	a.to-nat64 to-string

!to-string string(a int8)
	a.to-int64 to-string

!to-string string(a int16)
	a.to-int64 to-string

!to-string string(a int32)
	a.to-int64 to-string

!to-string string(a int64)
	if a == min-int64
		"-9223372036854775808"
	else
		s = a.abs to-string
		a < 0 ? "-{s}" : s

!to-string string(a float32)
	a.to-float64 to-string

!to-string string(a float64)
	if a is-nan
		"NaN"
	else
		pos = a.abs to-string-positive
		if a < 0
			"-{pos}"
		else
			pos

.to-string-positive string(a float64)
	# TODO: Use a real float to string algorithm
	times-1000 = (a * 1000.0).truncate-to-int64
	thousandths = times-1000 % 1000
	whole-part = "{times-1000 / 1000}"
	hundredths = thousandths / 10
	tenths = hundredths / 10
	d0 = tenths digit-to-string
	d1 = hundredths % 10 digit-to-string
	d2 = thousandths % 10 digit-to-string
	if thousandths == 0
		whole-part
	else
		"{whole-part}.{d0}{d1}{d2}" strip-right "0"

region spec impls (see collection.crow)

!iterate bool(a string, f act bool(char8))
	a.char8s iterate f

!string-iterator record by-val
	.inner char8 list-iterator

!== bool(a string-iterator, b string-iterator)
	a.inner == b.inner
!<=> comparison(a string-iterator, b string-iterator)
	a.inner <=> b.inner

!begin string-iterator(a string) noctx
	a.char8s.begin,

!end string-iterator(a string) noctx
	a.char8s.end,

!collection string(a string-iterator) noctx
	a.inner.collection,

!next-index nat64(a string-iterator) noctx
	a.inner next-index

!slice string(a string-iterator, b string-iterator)
	(a.inner slice b.inner),

!next (char8, string-iterator)?(a string-iterator) noctx
	if pair ?= a.inner next
		(pair.a, (pair.b,)),

!prev (string-iterator, char8)?(a string-iterator) noctx
	if pair ?= a.inner prev
		((pair.a,), pair.b),

!+ string-iterator(a string-iterator, n nat64) noctx
	a.inner + n,
!- string-iterator(a string-iterator, n nat64) noctx
	a.inner - n,
!- nat64(a string-iterator, b string-iterator) noctx
	a.inner - b.inner

!string-builder record mut
	.inner char8 list-builder
!build string(a build-options, f act void(string-builder))
	inner char8[] = a build out => f[(out,)]
	inner as-string
!~= void(a string-builder, c char8)
	a.inner ~= c
!~~= void(a string-builder, s string)
	a.inner ~~= s.char8s

region utilities

!lines string[](a string)
	# TODO:PERF should be better (or at least just as good) with just `a split "\n"`
	arr = a.char8s to-array
	for x : arr split ("\n",)
		x as-string

# Lower cases every character in `a`.
!lower-case string(a string)
	(for x : a char8s; x lower-case-char)::char8[] as-string

.lower-case-char char8(a char8) noctx
	diff = a.to-nat8 wrap-sub "A".to-nat8
	if diff < 26
		"a".to-nat8 + diff to-char8
	else
		a

# Capitalizes every character in `a`.
!upper-case string(a string)
	(for x : a char8s; x upper-case-char)::char8[] as-string

.upper-case-char char8(a char8) noctx
	diff = a.to-nat8 wrap-sub "a".to-nat8
	if diff < 26
		"A".to-nat8 + diff to-char8
	else
		a

# Replaces every instance of the substring `find` with `replace-with`.
!replace string(a string, find string, replace-with string)
	# TODO:PERF
	if pair ?= a try-split-once find
		pair.a ~~ replace-with ~~ (pair.b replace find, replace-with)
	else
		a

# Strips whitespace from both ends.
!strip string(a string)
	a.strip-left strip-right

# Strips whitespace from the front.
!strip-left string(a string)
	(a.char8s drop-while x => x is-whitespace)::char8[] as-string

# Strips whitespace from the end.
!strip-right string(a string)
	a.char8s drop-right-while (x => x is-whitespace) as-string

!is-whitespace bool(a char8)
	a == " " || a == "\r" || a == "\n" || a == "\t"

!normalize-newlines string(a string)
	a replace "\r\n", "\n" replace "\r", "\n"

# Enclose a string in quotes and escape special characters.
!quote string(a string)
	inner string[] = for x : a char8s
		if x == "\""
			"\\\""
		elif x == "\n"
			"\\n"
		elif x == "\r"
			"\\r"
		elif x == "\t"
			"\\t"
		elif x == "\\"
			"\\\\"
		else
			# TODO: "{x}"
			(x,)::char8[] as-string
	# TODO: "\"{inner}\""
	"\"" ~~ ("" join inner) ~~ "\""

!unindent string(a string)
	a replace "\t", ""
