no-std
import
	./bool: !, &&, ||, bool, false, true
	./col/arr: arr-from-begin-end, begin-ptr, end-ptr
	./col/mut-arr: ~=, move-to-arr!, mut-arr, new
	./compare: <=, >=
	./fun: subscript
	./misc: drop, void
	./number: ==, <=>, +, *, **, float64, int64, nat64, to-float64, to-int64
	./opt: is-empty, none, opt, some
	./ptr: ==, <=>, +, -, *, const-ptr
	./str: ==, char, chars, size-bytes, str
	./test: is
	./private/exception-low-level: assert, forbid

reader record mut
	.cur .mut char*
	.end char*

new reader(a str) trusted
	a.chars.begin-ptr, a.chars.end-ptr

with-reader<a> a?(a str, f act a?(reader))
	reader reader = a,
	res = f[reader]
	if !res.is-empty && reader.is-empty
		res

is-empty bool(a reader) trusted
	assert: a.cur <= a.end
	a.cur == a.end

peek char(a reader) trusted
	forbid: a is-empty
	*a.cur

next! char(a reader) trusted
	forbid: a is-empty
	res = *a.cur
	a.cur := a.cur + 1
	res

try-take-char bool(a reader, c char)
	if !a.is-empty && a.peek == c
		a.next! drop
		true
	else
		false

skip-if-char! void(a reader, c char)
	a try-take-char c drop

try-take-str bool(a reader, s str) trusted
	size = s size-bytes
	if a.end - a.cur >= size && (a.cur arr-from-begin-end a.cur + size).str == s
		a.cur := a.cur + size
		true
	else
		false

take-nat! nat64?(a reader)
	if !a.is-empty
		if first-digit ?= a.peek.char-to-nat64
			a.next! drop
			first-digit take-nat-recur! a some
.take-nat-recur! nat64(acc nat64, a reader)
	if a is-empty
		acc
	elif v ?= a.peek.char-to-nat64
		a.next! drop
		acc * 10 + v take-nat-recur! a
	else
		acc

take-int! int64?(a reader) trusted
	start = a cur
	sign = if a.try-take-sign
		+1
	else
		-1
	if n ?= a take-nat!
		n.to-int64 * sign some
	else
		a.cur := start
		none

skip-whitespace! void(a reader)
	if a try-take-char " " || a try-take-char "\n" || a try-take-char "\t"
		a skip-whitespace!

.try-take-sign bool(a reader)
	if a try-take-char "-"
		false
	else
		a try-take-char "+" drop
		true

take-float! float64?(a reader) trusted
	sign = if a.try-take-sign
		1.0
	else
		-1.0
	if whole-nat ?= a take-nat!
		whole-part = whole-nat to-float64
		before-dot = a cur
		some: if a try-take-char "."
			if n ?= a take-nat!
				digits-taken = a.cur - (before-dot + 1)
				# TODO: more accurate methods exist
				sign * (whole-part + n.to-float64 * 0.1 ** digits-taken)
			else
				a.cur := before-dot
				sign * whole-part
		else
			sign * whole-part

take-quoted-str! str?(a reader)
	if a try-take-char "\""
		start = a.cur
		res = a take-quoted-str-recur! ()
		if res is-empty
			a.cur := start
		res

.take-quoted-str-recur! str?(a reader, res char mut[])
	if a is-empty
		none
	elif a try-take-char "\""
		res.move-to-arr!.str some
	elif a try-take-char "\\"
		if esc ?= a.next! escape
			res ~= esc
			a take-quoted-str-recur! res
	else
		res ~= a next!
		a take-quoted-str-recur! res

.escape char?(a char)
	if a == "n"
		"\n" some
	elif a == "r"
		"\r" some
	elif a == "t"
		"\t" some
	elif a == "\""
		"\"" some
	elif a == "\\"
		"\\" some
	elif a == "0"
		"\0" some

.char-to-nat64 nat64?(c char)
	if c == "0"
		0 some
	elif c == "1"
		1 some
	elif c == "2"
		2 some
	elif c == "3"
		3 some
	elif c == "4"
		4 some
	elif c == "5"
		5 some
	elif c == "6"
		6 some
	elif c == "7"
		7 some
	elif c == "8"
		8 some
	elif c == "9"
		9 some

test
	"a" is "a"
