no-std
import
	./bool: bool
	./col/collection: build, flatten, for-loop, iterate, size, subscript, with-block, with-index
	./col/list: ~~, +, ~=, begin, build, iterate, list, new, next, size
	./exception: catch-all, exception-and-backtrace, to
	./fun-util: subscript
	./log: error, log
	./misc: shared, new, void
	./pointer: any-mut-pointer, as-any-mut-pointer, mut-pointer, reference-from-pointer
	./private/bootstrap: fiber, lk, new, rejected, resolved
	./private/future-low-level: add-awaiting-fiber, must-get-result, reject, resolve, unresolved
	./private/runtime:
		add-new-fiber, add-to-queue, await-future, change-this-fibers-exclusion, cur-exclusion, get-global-ctx, yield-this-fiber
	./private/thread-utils: init, lock, uninit
	./string: interpolate
export
	./private/bootstrap: future

+await[t] t(a t future) trusted
	(a.as-any-mut-pointer, &add-awaiting-fiber-for-t@t).await-future yield-this-fiber
	a must-get-result

# Just yields the fiber temporarily. It may be restarted immediately.
+yield-fiber void() trusted
	add-to-queue yield-this-fiber

# TODO: This should be automatic before any blocking function, then delete this --------------------------------------------------------------------------------------------------------------------
~delay void()
	yield-fiber

add-awaiting-fiber-for-t[t] bool(future any-mut-pointer, fiber fiber) unsafe
	typed t future = future reference-from-pointer
	typed add-awaiting-fiber fiber

-lock[t] lock mut*(a t future) unsafe
	&a.lk

# Converts a value to a future resolved with that value.
+new[t] t future(value t)
	res t future = trusted uninit, value.resolved
	trusted res.lock init
	res

# Future resolved to `()`.
+new[t] t future() t new
	(),

# Future resolved with an exception.
+rejected[t] t future(err exception-and-backtrace)
	res t future = trusted uninit, err.rejected
	trusted res.lock init
	res

# TODO: This doesn't belong in this file any more! ----------------------------------------------------------------------------
# This is called by the compiler for 'shared () => ...' lambdas.
~shared-of-mut-lambda[r, p] r shared(param p)(a r mut(param p)) r shared, p shared
	trusted
		exclusion = cur-exclusion
		wrapper (r, p) force-lambda-shared = a,
		param =>
			# TODO:PERF -- if new-exclusion is the same as cur-exclusion, do nothing -------------------------------------------------------
			# Remember the old exclusion of this fiber. Then change it to the new exclusion and yield.
			# When it resumes, run 'f[]', then set the exclusion back and yield again.
			prev-exclusion = cur-exclusion
			exclusion change-this-fibers-exclusion
			finally prev-exclusion change-this-fibers-exclusion
			wrapper.fn[param]
-force-lambda-shared[r, p] record(fn r mut(param p)) force-shared

+parallel record nominal
###
Run `f` in a task with a new exclusion and return a future for its result.

`f` must be a `fun` and not an `act` so that it can have a new exclusion,
which allows it to run in parallel.
###
+with-block[t] t future(_ parallel, f t shared())
	res t future = trusted unresolved
	gctx = trusted get-global-ctx
	trusted gctx add-new-fiber () =>
		match (() => f[]) catch-all
		as ok x
			res resolve x
		as error e
			res reject e
	res

# Like 'parallel', but does not return a future.
+new-exclusion record nominal
+with-block[t] t(_ new-exclusion, f t shared())
	parallel with-block f await

+later record nominal
# Like 'parallel', but the block isn't 'shared', so it will run later with this same exclusion.
+with-block[t] t future(_ later, f t mut()) t shared # TODO: 't shared' shouldn't be necessary ...........................
	fs t shared() = shared () => f[]
	parallel with-block fs

+fire-and-forget record nominal
+with-block void(_ fire-and-forget, f void mut()) trusted
	_ void future = with : later
		match f catch-all
		as ok
			()
		as error e
			error log "{e}"

# TODO: This doesn't directly expose any futures ... 'parallel' module? ------------------------------------------------------------------------------
+parallel-collection[col] record(collection col)
+parallel[col] col parallel-collection(a col)
	a,
+for-loop[in-col, in-elem] void(
	a in-col parallel-collection,
	f void shared(elem in-elem),
) (in-col, in-elem) iterate, in-col size, in-elem shared
	futures void future[] = for x : a collection
		with : parallel
			f[x]
	for x : futures
		x await
+for-loop[out-elem, in-col, in-elem] out-elem[](
	a in-col parallel-collection,
	f out-elem shared(elem in-elem),
) out-elem shared, in-elem shared, (in-col, in-elem) iterate, in-col size
	futures out-elem future[] = for x : a collection
		with : parallel
			f[x]
	for x : futures
		x await

+parallel-concat[col] record(collection col) nominal
+for-loop[out-elem, in-col, in-elem] out-elem[](
	a in-col parallel-concat,
	f out-elem[] shared(elem in-elem),
) out-elem shared, in-elem shared, (in-col, in-elem) iterate, in-col size
	a.collection.parallel for-loop f flatten

+filter[out-col, in-col, elem, builder] out-col(
	a in-col parallel-collection,
	f bool shared(elem elem),
) (in-col, elem) iterate, in-col size, (out-col, elem, builder) build, elem shared, out-col shared
	bools bool[] = a for-loop f
	with out : a.collection.size build
		# TODO: 'zip'
		for i, x : a.collection with-index
			if bools[i]
				out ~= x
