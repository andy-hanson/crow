no-std
import
	./col/collection: begin, for-loop, iterate, next, size
	./col/list: ~=, build, iterate, list, size
	./col/mut-list: ~=, hint-size, move-to-list, mut-list, new
	./exception: catch, exception
	./fun-util: subscript
	./misc: break-or-continue, is-sendable, loop-break, loop-continue, new, void
	./number: ==, -, nat64
	./option: new, option
	./private/bootstrap: action, exclusion, lk, new, rejected, resolved
	./private/future-low-level: add-task, get-result, forward-to, reject, resolve, unresolved
	./private/runtime: add-task, cur-exclusion, exception-handler, get-global-ctx, new-exclusion
	./private/task-queue: task
	./private/thread-utils: init, lock, uninit
	./result: force, result
	./tuple: a, b, c, pair, tuple3
export
	./private/bootstrap: future

-lock[t] lock(a t^) unsafe
	&a.lk

###
A future already resolved to void.
Writing `<- delay` will cause the code below to run in a new task.
This can be useful for breaking up big tasks.

`delay` from `crow/io/time` is useful for delaying for linger times.
###
+delay void^()
	()

# Converts a value to a future resolved with that value.
+new[t] t^(value t)
	res t^ = trusted uninit, value.resolved
	trusted res.lock init
	res

# Future resolved to `()`.
+new[t] t^() t new
	(),

# Future resolved with an exception.
+rejected[t] t^(err exception)
	res t^ = trusted uninit, err.rejected
	trusted res.lock init
	res

###
Waits for every one of `futures` to be resolved, then returns an array all of their results.

If one of `futures` resolves with an exception, this resolves to the leftmost exception (discarding others),
regardless of which exception happened first.
###
+wait-all[t] t[]^(futures t^[]) t is-sendable
	<- futures wait-all-complete
	(for x : futures; trusted x.get-result!),

# Returns a future that is resolved once all inputs are resolved.
-wait-all-complete[t] void^(futures t^[]) t is-sendable
	res void^ = trusted unresolved
	count mut nat64 = futures.size
	task task = trusted cur-exclusion, () =>
		count := count - 1
		if count == 0
			res resolve ()
	for x : futures
		trusted x add-task task
	res

###
Future resolved to `ok` if `a` succeeds and `err` if `a` fails with an exception.
###
+future-catch[t] (t, exception) result^(a t^) t is-sendable
	res (t, exception) result^ = trusted unresolved
	trusted a add-task get-global-ctx.new-exclusion, () =>
		res resolve a.get-result
	res

+future-finally record mut
	-cleanup ref void()
+future-finally future-finally(cleanup ref void())
	cleanup,
+with-block[t] t^(a future-finally, f ref t()) t is-sendable
	fut = f[]
	res t^ = trusted unresolved
	trusted fut add-task get-global-ctx.new-exclusion, () =>
		result = fut get-result
		cleanup-fut = a.cleanup[]
		cleanup-fut add-task get-global-ctx.new-exclusion, () =>
			match result
			as ok value
				match cleanup-fut get-result
				as ok _
					res resolve value
				as err e
					res reject e
			as err e
				res reject e
	res

###
Calls `f` once `a` is resolved.
Returns a future for the result of `f`.

If `a` is resolved with an exception, this never calls `f`,
and the result of `then` will have the same exception as `a`.
###
+then[out, in] out^(a in^, f ref out(in)) out is-sendable, in is-sendable
	res out^ = trusted unresolved
	action = f action
	trusted a add-task f.exclusion, () =>
		match a get-result
		as ok value
			match (() => action[value]) catch
			as ok fut
				res forward-to fut
			as err e
				res reject e
		as err e
			res reject e
	res

# Like `then`, but `f` takes no parameter (since it will be `void` anyway.)
+then[out] out^(a void^, f ref out()) out is-sendable
	a then _ =>
		f[]

###
Use like:
	x, y <- f, g
Where 'f' and 'g' are futures.
###
+then[out, in0, in1] out^(
	a (in0^, in1^),
	f ref out(in0, in1),
) out is-sendable, in0 is-sendable, in1 is-sendable
	x <- a.a
	y <- a.b
	f[x, y]
+then[out, in0, in1, in2] out^(
	a (in0^, in1^, in2^),
	f ref out(in0, in1, in2),
) out is-sendable, in0 is-sendable, in1 is-sendable, in2 is-sendable
	x <- a.a
	y <- a.b
	z <- a.c
	f[x, y, z]

###
Calls a `ref`.

This enqueues a task with the ref's exclusion for invoking its function,
and returns a future for the result of that task.
###
+subscript[r] r^(f ref r()) r is-sendable
	res r^ = trusted unresolved
	action = f action
	trusted get-global-ctx add-task f.exclusion, () =>
		match action catch
		as ok fut
			res forward-to fut
		as err e
			res reject e
	res

# Calls a `ref` with one argument.
+subscript[r, p0] r^(f ref r(p0), p0 p0) r is-sendable, p0 is-sendable
	res r^ = trusted unresolved
	trusted get-global-ctx add-task f.exclusion, () =>
		(() => res forward-to f.action[p0]) catch err => res reject err
	res

# Calls a `ref` with two arguments.
+subscript[r, p0, p1] r^(
	f ref r(p0, p1),
	p0 p0,
	p1 p1,
) r is-sendable, p0 is-sendable, p1 is-sendable
	res r^ = trusted unresolved
	trusted get-global-ctx add-task f.exclusion, () =>
		(() => res forward-to f.action[p0, p1]) catch err => res reject err
	res

+subscript[r, p0, p1, p2] r^(
	f ref r(p0, p1, p2),
	p0 p0,
	p1 p1,
	p2 p2,
) r is-sendable, p0 is-sendable, p1 is-sendable, p2 is-sendable
	res r^ = trusted unresolved
	trusted get-global-ctx add-task f.exclusion, () =>
		(() => res forward-to f.action[p0, p1, p2]) catch err => res reject err
	res

###
If the future resolves successfully, does nothing.
Else, this will call the default exception handler.
###
handle-exceptions[t] void(a t^)
	trusted a add-task get-global-ctx.new-exclusion, () =>
		match a get-result
		as ok _
			()
		as err e
			get-global-ctx.exception-handler[e]

+loop-break[t] t break-or-continue^(a t)
	a.loop-break,
+loop-continue[t] t break-or-continue^()
	loop-continue,

+parallel record
+parallel parallel()
	()
###
Run `f` in a task with a new exclusion and return a future for its result.

`f` must be a `fun` and not an `act` so that it can have a new exclusion,
which allows it to run in parallel.
###
+with-block[t] t^(_ parallel, f fun t^())
	res t^ = trusted unresolved
	gctx = trusted get-global-ctx
	trusted gctx add-task gctx.new-exclusion, () =>
		match (() => f[]) catch
		as ok fut
			res forward-to fut
		as err e
			res reject e
	res

sequential-collection[col] record
	-inner col
sequential[col] col sequential-collection(a col)
	a,

for-loop[in-col, in-iter, in-elem] void^(
	a in-col sequential-collection,
	f ref void(in-elem),
) (in-iter, in-col) begin, (in-elem, in-iter) next, in-elem is-sendable
	a for-break x =>
		<- f[x]
		continue

for-break[in-col, in-iter, in-elem] void^(
	a in-col sequential-collection,
	f ref void break-or-continue(in-elem),
) (in-iter, in-col) begin, (in-elem, in-iter) next, in-elem is-sendable
	# TODO: we need type annotations on LHS of '<-'
	_ <- (a for-break f)::void?^
	()

for-break[out, in-col, in-iter, in-elem] out?^(
	a in-col sequential-collection,
	f ref out break-or-continue(in-elem),
) (in-iter, in-col) begin, (in-elem, in-iter) next, out is-sendable, in-elem is-sendable
	a.inner.begin for-break-recur f
-for-break-recur[out, in-col, in-iter, in-elem] out?^(
	iter in-iter,
	f ref out break-or-continue(in-elem),
) (in-iter, in-col) begin, (in-elem, in-iter) next, out is-sendable, in-elem is-sendable
	if pair ?= iter next
		b-or-c <- f[pair.a]
		match b-or-c
		as loop-break v
			(v,),
		as loop-continue
			pair.b for-break-recur@(out, in-col, in-iter, in-elem) f

for-loop[out-elem, in-col, in-iter, in-elem] out-elem[]^(
	a in-col sequential-collection,
	f ref out-elem(in-elem),
) (in-iter, in-col) begin, (in-elem, in-iter) next, in-col size, out-elem is-sendable, in-elem is-sendable
	res out-elem mut[] = ()
	res hint-size a.inner.size
	<- for x : a
		y <- f[x]
		res ~= y
		()
	res.move-to-list,

parallel-collection[col] record
	-inner col
parallel[col] col parallel-collection(a col)
	a,
for-loop[in-col, in-elem] void^(
	a in-col parallel-collection,
	f fun void^(in-elem),
) (in-col, in-elem) iterate, in-col size, in-elem is-sendable
	tasks void^[] = for x : a inner
		with : parallel
			f[x]
	tasks wait-all-complete
for-loop[out-elem, in-col, in-elem] out-elem[]^(
	a in-col parallel-collection,
	f fun out-elem^(in-elem),
) (in-col, in-elem) iterate, in-col size, out-elem is-sendable, in-elem is-sendable
	tasks out-elem^[] = for x : a inner
		with : parallel
			f[x]
	tasks wait-all
