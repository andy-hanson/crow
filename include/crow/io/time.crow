no-std
import
	time: time, time_t
	../compare: max
	../future: future, subscript, then
	../misc: break-or-continue, is-sendable, new, void
	../number: ==, <=>, +, /, nat64, to-nat64
	../pointer: null
	../future: new
	../private/future-low-level: forward-to, resolve, unresolved
	../private/runtime: add-timed-task, get-global-ctx, new-exclusion
	./duration: duration, nsec
export
	./private/time-low-level: get-monotime-nsec

get-monotime-msec nat64() summon
	get-monotime-nsec / 1000000

unix-time record
	seconds-since-epoch time_t

# Get the current Unix timestamp.
get-unix-time unix-time() summon, trusted
	null.time,

# Returns a future that will resolve after `duration` has passed.
delay void^(duration duration) summon, trusted
	get-monotime-nsec + duration.nsec.to-nat64 delay-until-time

interval record
	.time duration
interval interval(time duration)
	time,
# TODO: shouldn't need `out break-or-continue is-sendable`
# Call `action` now and on every `interval`.
for-break[out] out^(
	interval interval,
	f-loop ref out break-or-continue(),
) summon, trusted, out is-sendable, out break-or-continue is-sendable
	get-monotime-nsec repeat-interval-recur interval.time.nsec.to-nat64, f-loop
.repeat-interval-recur[out] out^(
	start-nsec nat64,
	interval-nsec nat64,
	action ref out break-or-continue(),
) summon, trusted, out is-sendable, out break-or-continue is-sendable
	choice <- action[]
	match choice
	as loop-break v
		v,
	as loop-continue
		next-time = get-monotime-nsec max start-nsec + interval-nsec
		gctx = get-global-ctx
		res out^ = unresolved
		gctx add-timed-task next-time, gctx.new-exclusion, () =>
			res forward-to (next-time repeat-interval-recur interval-nsec, action)
		res

.delay-until-time void^(target-nsec nat64) summon, unsafe
	res void^ = unresolved
	gctx = get-global-ctx
	gctx add-timed-task target-nsec, gctx.new-exclusion, () =>
		res resolve ()
	res
