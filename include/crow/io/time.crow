no-std
import
	time: time, time_t
	../compare: max
	../fun-util: subscript
	../fut: fut
	../misc: new, void
	../number: ==, <=>, +, /, nat64, to-nat64
	../ptr: null
	../private/fut-low-level: resolve, unresolved
	../private/runtime: add-timed-task, get-global-ctx, new-exclusion
	./duration: duration, nsec
export
	./private/time-low-level: get-monotime-nsec

get-monotime-msec nat64() summon
	get-monotime-nsec / 1000000

unix-time record
	seconds-since-epoch time_t

# Get the current Unix timestamp.
get-unix-time unix-time() summon trusted
	null.time,

# Returns a `fut` that will resolve after `duration` has passed.
delay fut void(duration duration) trusted summon
	get-monotime-nsec + duration.nsec.to-nat64 delay-until-time

continue-or-quit enum
	continue
	quit

# Call `action` now and on every `interval`.
repeat-interval fut void(interval duration, action act continue-or-quit()) trusted summon
	res fut void = unresolved
	res repeat-interval-recur get-monotime-nsec, interval.nsec.to-nat64, action
	res
.repeat-interval-recur void
	res fut void
	start-nsec nat64
	interval-nsec nat64
	action act continue-or-quit()
spec
	trusted
	summon
body
	match action[]
	as continue
		next-time = get-monotime-nsec max start-nsec + interval-nsec
		gctx = get-global-ctx
		gctx add-timed-task next-time, gctx.new-exclusion, () =>
			res repeat-interval-recur next-time, interval-nsec, action
	as quit
		res resolve ()

.delay-until-time fut void(target-nsec nat64) unsafe summon
	res fut void = unresolved
	gctx = get-global-ctx
	gctx add-timed-task target-nsec, gctx.new-exclusion, () =>
		res resolve ()
	res
