no-std
import
	errno: EAGAIN, errno, EWOULDBLOCK
	fcntl: fcntl, F_GETFL, F_SETFL, O_NONBLOCK
	netinet/in: new, sockaddr_in
	stdio: perror
	sys/epoll:
		epoll_create1, epoll_ctl, EPOLL_CTL_ADD, EPOLLERR, EPOLLET, epoll_event, EPOLLHUP, EPOLLIN,
		epoll_wait, event_data, events, new
	sys/socket: accept, as-fd, as-socket, listen, shutdown, SHUT_RDWR, sockaddr, SOCKET
	sys/types: socklen_t
	unistd: close, read
	../../bits: |, bits-intersect
	../../bool: ||, bool, false, not, true
	../../col/array: +, array, begin, slice
	../../col/collection: subscript
	../../col/mut-array: cast-immutable, begin-pointer, mut-array, size, uninitialized-mut-array
	../../compare: !=, <
	../../c-types: c-int, fd-t
	../../future: future, handle-exceptions, then, new, subscript
	../../misc: new, void
	../../number: ==, <=>, int32, nat8, nat16, nat32, to
	../../private/bootstrap: todo
	../../pointer: mut-pointer, pointer-cast, size-of
	../../range: ..
	../../string: literal, string
	../../tuple: new
	../../version: is-windows
	../duration: msec
	../posix-util: check-posix-error
	../print: err, out, print
	../time: delay
	./net: bind-to-port, close-socket

# Reference to a running server.
tcp-server record shared
	stop far void()

# Interface that handles TCP requests.
tcp-handler record shared
	on-accepted-client far void(SOCKET)
	# Gives the handler a chunk of data.
	# Handler needs to parse to determine when it has all the chunks, then write a response and call 'close-client'.
	# WARN: Due to asynchrony, this may be called on a client that was already closed.
	on-received-chunk far void(SOCKET, nat8 array)

###
Starts running a TCP server on the given port.
Once the function returns, it is already serving requests.
###
start-tcp-server tcp-server(port string, handler tcp-handler) summon, unsafe
	sock = port bind-to-port
	max-connections int32 = 1000
	sock listen max-connections check-posix-error
	if is-windows
		todo
	else
		sock.as-fd start-tcp-server-linux handler

-start-tcp-server-linux tcp-server(port-fd fd-t, handler tcp-handler) summon, unsafe
	port-fd set-non-blocking

	epoll-fd = 0 epoll_create1
	if epoll-fd < 0
		"epoll-create1 failed" perror
		todo
	else
		event-flags = EPOLLIN | EPOLLET
		accept-event mut epoll_event = event-flags, port-fd.to
		ctl-err = epoll-fd epoll_ctl EPOLL_CTL_ADD, port-fd, &accept-event
		unless ctl-err == 0
			"epoll_ctl failed" perror
			todo

		state tcp-server-state = false, false, 0, port-fd, epoll-fd, 0, handler
		_ = state pad-0
		_ = state pad-1
		_ = state pad-2

		out print "starting the server loop"
		done = state tcp-server-loop-linux
		done handle-exceptions

		stop far void() = () =>
			out print "STOP CALLED"
			state.should-stop := true
			done
		stop,

# Close a TCP client.
close-client void(client SOCKET) summon, unsafe
	sd-err = client shutdown SHUT_RDWR
	assert sd-err == 0
	client close-socket

-tcp-server-state record mut by-ref
	should-stop mut bool
	# TODO: my code wrongly thinks this should be packed!
	pad-0 bool
	pad-1 nat16
	port-fd fd-t
	epoll-fd fd-t
	# TODO: my code wrongly thinks this should be padded!
	pad-2 nat32
	handler tcp-handler

-tcp-server-loop-linux void^(state tcp-server-state) summon, unsafe
	unless state should-stop
		event mut epoll_event = ()
		timeout c-int = 0
		num-events = state.epoll-fd epoll_wait &event, 1, timeout
		if num-events < 0
			err print "error in epoll_wait"
			todo
		elif num-events == 0
			<- 100.msec delay
			state tcp-server-loop-linux
		else
			assert num-events == 1
			event-flags = event events
			fd int32 = event.event_data to
			if event-flags bits-intersect EPOLLERR | EPOLLHUP || !(event-flags bits-intersect EPOLLIN)
				err print "SOME KINDA ERROR"
				err = fd close
				assert err == 0
			elif fd == state.port-fd
				state.port-fd.as-socket accept-clients state.epoll-fd, state.handler.on-accepted-client
			else
				fd handle-client-linux state.handler.on-received-chunk
			state tcp-server-loop-linux

-accept-clients void(listen-fd SOCKET, epoll-fd fd-t, on-accepted-client far void(SOCKET)) summon, unsafe
	clientaddr mut sockaddr_in = ()
	clientaddr-as-sockaddr sockaddr mut* = (&clientaddr)::sockaddr_in mut* pointer-cast
	addrlen mut socklen_t = size-of@sockaddr_in to
	client-fd = listen-fd accept clientaddr-as-sockaddr, &addrlen
	if client-fd < 0
		e = errno
		unless e == EAGAIN || e == EWOULDBLOCK
			"accept() error" perror
			todo
	else
		client-fd set-non-blocking
		client-event mut epoll_event = EPOLLIN | EPOLLET, client-fd.to
		err = epoll-fd epoll_ctl EPOLL_CTL_ADD, client-fd, &client-event
		assert err == 0
		on-accepted-client[client-fd as-socket] handle-exceptions
		listen-fd accept-clients epoll-fd, on-accepted-client

-handle-client-linux void(fd fd-t, on-received-chunk far void(SOCKET, nat8 array)) summon, unsafe
	buf nat8 mut-array = 0x1000 uninitialized-mut-array
	count = fd read buf.begin-pointer, buf.size
	if count < 0
		err = errno
		unless err == EAGAIN
			"read() failed" perror
	elif count != 0
		chunk = buf.cast-immutable[0 .. count.to]
		on-received-chunk[fd.as-socket, chunk] handle-exceptions
		fd handle-client-linux on-received-chunk

-set-non-blocking void(fd fd-t) bare, summon, unsafe
	file-flags = fd fcntl F_GETFL, 0
	if file-flags < 0
		"fcntl() error" perror
		todo
	else
		err = fd fcntl F_SETFL, file-flags | O_NONBLOCK
		if err < 0
			"fcntl() error" perror
			todo
