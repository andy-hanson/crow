###
Module for low-level networking.
###

no-std
import
	bits/socket_type: SOCK_STREAM
	crow/misc: new, void
	crow/version: is-windows
	netdb:
		addrinfo, ai_addr, ai_addrlen, ai_family, ai_next, ai-passive, ai_protocol, ai_socktype,
		freeaddrinfo, getaddrinfo, new
	sys/socket:
		AF_INET, AF_UNSPEC, as-fd, bind, closesocket, connect, INVALID_SOCKET, socket, SOCKET
	unistd: close
	win32: new, MAKEWORD, WSADATA, WSAStartup
	../../cell: *, as-mut-ptr, cell, new
	../../compare: !=
	../../number: ==, int32, nat16, to-int32
	../../opt: !, new, opt
	../../ptr: ==, *, any-const-ptr, as-const, as-ref, const-ptr, mut-ptr, null
	../../str: literal, str
	../../str-conv: finish, interp, to-str, with-str, with-value
	../../str-util: to-c-str
	../../private/bootstrap: todo
	../posix-util: check-posix-error
	../print: err, out, print

# Parsed Uniform Resource Identifier
uri record
	host str
	port nat16
	path-and-query str
	# Basically just ignored
	after-hash str

# Opens a socket, connects to the URI, and returns the fd.
connect-to-uri SOCKET(u uri) trusted summon
	if is-windows
		wsa-init

	# TODO: null.as-ref is evil
	hints addrinfo = 0, AF_UNSPEC.to-int32, SOCK_STREAM, 0, 0, null::any-const-ptr.as-ref, null, null
	result cell addrinfo mut* = null,
	check-getaddrinfo-error: u.host.to-c-str getaddrinfo u.port.to-str.to-c-str, &hints, result.as-mut-ptr
	op-sock = result->as-const find-and-connect-working-socket
	*result freeaddrinfo
	# TODO: handle failure
	op-sock!

.wsa-init void() unsafe summon
	wsa-data cell WSADATA = (), 
	err = 2 MAKEWORD 2 WSAStartup wsa-data.as-mut-ptr
	out print "initialized WSA, err is {err}"
	if err != 0
		todo

.find-and-connect-working-socket SOCKET?(ap addrinfo*) unsafe summon
	unless ap == null
		a = *ap
		sock = a.ai_family socket a.ai_socktype, a.ai_protocol
		if sock == INVALID_SOCKET
			# Ignore error and try again
			a.ai_next find-and-connect-working-socket
		else
			error = sock connect a.ai_addr, a.ai_addrlen
			if error == -1
				err print "connect() failed: "
				sock close-socket
				# Ignore error and try again
				a.ai_next find-and-connect-working-socket
			else
				assert error == 0
				sock,

# Returns a file descriptor bound to the given port.
bind-to-port SOCKET(port str) unsafe summon
	if is-windows
		wsa-init

	# TODO: null.as-ref is evil
	hints addrinfo = ai-passive, AF_INET, SOCK_STREAM, 0, 0, null::any-const-ptr.as-ref, null, null
	result cell addrinfo mut* = null,
	check-getaddrinfo-error: null getaddrinfo port.to-c-str, &hints, result.as-mut-ptr
	op-sock = result->as-const find-and-bind-working-socket
	*result freeaddrinfo
	if res ?= op-sock
		res
	else
		err print "Failed to bind to port {port}"
		todo

close-socket void(sock SOCKET) unsafe summon
	if is-windows
		err = sock closesocket
		if err != 0
			todo
	else
		check-posix-error: sock.as-fd close

.find-and-bind-working-socket SOCKET?(ap addrinfo*) unsafe summon
	unless ap == null
		a = *ap
		listen-fd = a.ai_family socket a.ai_socktype, 0
		if listen-fd == INVALID_SOCKET
			a.ai_next find-and-bind-working-socket
		else
			if (listen-fd bind a.ai_addr, a.ai_addrlen) == 0
				out print "Connected!"
				listen-fd,
			else
				listen-fd close-socket
				a.ai_next find-and-bind-working-socket

.check-getaddrinfo-error void(err int32) unsafe summon
	if err != 0
		# TODO: convert to appropriate enum
		throw "getaddrinfo error: {err}"
