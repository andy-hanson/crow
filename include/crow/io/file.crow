no-std
import
	dirent: dir, dirent, new, opendir, readdir_r
	errno: ENOENT, errno
	stat: mkdir, new, S_IFDIR, S_IFMT, S_IFREG, stat, st_mode
	stdio: fclose, ferror, FILE, fopen, fread, fseek, ftell, fwrite, SEEK_SET, SEEK_END
	sys/types: ino_t, mode_t, off_t
	unistd: getcwd, readlink, rmdir, symlink, unlink
	win32:
		&, |, ==, cFileName, CreateSymbolicLinkA, DeleteFileA, ERROR_FILE_NOT_FOUND,
		ERROR_NO_MORE_FILES, ERROR_PATH_NOT_FOUND, FILE_ATTRIBUTE_DIRECTORY, FindClose,
		FindFirstFileA, FindNextFileA, _getcwd, GetFileAttributesA, GetLastError, HANDLE,
		INVALID_FILE_ATTRIBUTES, INVALID_HANDLE_VALUE, _mkdir, new,
		SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE, SYMBOLIC_LINK_FLAG_DIRECTORY,
		WIN32_FIND_DATAA
	../bits: &, |, <<
	../bytes-types: new
	../bool: !, ||, bool, false, new, to-nat64, true
	../cell: *, as-mut-ptr, cell, new
	../col/array: array, size, subscript
	../col/mut-array: cast-immutable, begin-ptr, mut-array, size, uninitialized-mut-array
	../col/list: for-loop, list, new, to-array, to-list
	../col/mut-list: ~=, move-to-list, mut-list, new
	../col/private/array-low-level: begin-ptr
	../col/sort: sort
	../compare: !=
	../exception: finally, with-block
	../flags-util: is-in
	../fun-util: subscript
	../misc: new, void
	../number: ==, <=>, +, nat8, nat16, to-nat32, to-nat64
	../opt: is-empty, new, opt
	../private/bootstrap: todo
	../ptr:
		==, +, any-const-ptr, as-any-const-ptr, as-const, const-ptr, mut-ptr, null, ptr-cast,
		ptr-cast-from-extern, ref-eq, size-of
	../range: ..
	../str: ==, <=>, char8, c-str, literal, str
	../str-conv: finish, interp, to-str, with-str, with-value
	../str-util: as-str, to-bytes, to-c-str, to-str
	../version: is-windows
	./path: child-path
	./posix-util: check-errno, check-posix-error
	./print: err, print
	./win32-util: show-win32-error

# `true` iff anything (like a file or directory) exists at the path.
path-exists bool(path str) summon trusted
	!path.get-path-kind.is-empty

###
`true` iff `path` is the path of a directory.
`false` if the path is a file.
`true` if the path is a symlink to a directory.
`false` if nothing exists at the path.
###
is-dir bool(path str) summon
	if kind ?= path get-path-kind
		kind == directory

###
`true` iff `path` is the path of a file.
`false` if the path is a directory.
`true` if the path is a symlink to a file.
`false` if nothing exists at the path.
###
is-file bool(path str) trusted summon
	path.to-c-str is-file
.is-file bool(path c-str) unsafe summon
	if kind ?= path get-path-kind
		kind == file

.path-kind enum
	directory
	file
	other

# Returns an empty option iff nothing exists at the path.
.get-path-kind path-kind?(path str) trusted summon
	path.to-c-str get-path-kind
.get-path-kind path-kind?(path c-str) unsafe summon
	if is-windows
		attr = path GetFileAttributesA
		if attr == INVALID_FILE_ATTRIBUTES
			err = GetLastError
			unless err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND
				throw "error {err} while testing path {path}: {err show-win32-error}"
		else
			if FILE_ATTRIBUTE_DIRECTORY is-in attr
				directory,
			else
				file,
	else
		s stat = ()
		err = path stat s
		if err == 0
			if s.st_mode & S_IFMT == S_IFDIR
				directory,
			elif s.st_mode & S_IFMT == S_IFREG
				file,
			else
				other,
		else
			assert err == -1
			# TODO: show error message
			assert errno == ENOENT : "error while testing path {path}"
			()

.get-dirent-name str(d dirent) unsafe
	# TODO: this is offsetof(d, d_name)
	name-offset = size-of@<ino_t> + size-of@<off_t> + size-of@<nat16> + size-of@<char8>
	name-ptr char8* = d.as-any-const-ptr + name-offset ptr-cast
	name-ptr to-str

###
Returns all children of the directory `path`, as full paths.
Use `names-in-dir` if you just want their names.
###
paths-in-dir str[](path str) summon
	for x : path names-in-dir
		path child-path x

###
Returns the basename of all children of the directory.
Does not include ".." or ".".
Use `paths-in-dir` if you want full paths.
###
names-in-dir str[](path str) summon trusted
	path.to-c-str names-in-dir

.names-in-dir str[](path c-str) trusted summon
	if is-windows
		path-search = "{path}\\*" to-c-str
		file-data cell WIN32_FIND_DATAA = (),
		file = path-search FindFirstFileA file-data.as-mut-ptr
		if file == INVALID_HANDLE_VALUE
			throw "failed to open dir {path}"
		else
			res str mut[] = ()
			res names-in-dir-recur path, file
			ok = file FindClose
			assert ok : "failed to close dir {path}"
			res.move-to-list sort
	else
		dirp = path opendir
		forbid dirp.ptr-cast-from-extern::any-const-ptr mut* == null : "failed to open dir {path}"
		res str mut[] = ()
		res names-in-dir-recur dirp
		res.move-to-list sort

.names-in-dir-recur void(out str mut[], dir-path c-str, file HANDLE) unsafe summon
	file-data cell WIN32_FIND_DATAA = (),
	ok = file FindNextFileA file-data.as-mut-ptr
	if ok
		s = file-data.as-mut-ptr.cFileName.as-const to-str
		if s != ".."
			out ~= s
		out names-in-dir-recur dir-path, file
	else
		err = GetLastError
		assert err == ERROR_NO_MORE_FILES : "Error while reading directory {dir-path}: {err show-win32-error}"

.names-in-dir-recur void(out str mut[], dirp dir) unsafe summon
	# Initial value of entry / result should not matter
	entry dirent = 0, 0, 0, "\0", ()
	result cell dirent = entry,
	err = dirp readdir_r entry, result
	# TODO: handle error
	assert err == 0
	unless result->as-any-const-ptr == null
		assert *result ref-eq entry
		name = entry get-dirent-name
		unless name == "." || name == ".."
			out ~= name
		out names-in-dir-recur dirp

# Gets the path a symbolic link refers to.
read-link str(path str) summon trusted
	# TODO: smart small and retry if necessAry
	buff mut-array char8 = 1000 uninitialized-mut-array
	size = path.to-c-str readlink buff.begin-ptr, buff.size
	if size == -1
		check-errno
	buff.cast-immutable[0 .. size.to-nat64].to-list str

# Create a symbolic link at `link` with the target `target`.
make-symlink-to void(link str, target str) summon trusted
	if is-windows
		link-flags = SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE | (target.is-dir ? SYMBOLIC_LINK_FLAG_DIRECTORY : ())
		ok = link.to-c-str CreateSymbolicLinkA target.to-c-str, link-flags
		unless ok
			throw "Error creating link {link}: {GetLastError show-win32-error}"
	else
		err = target.to-c-str symlink link.to-c-str
		unless err == 0
			assert err == -1
			check-errno

###
Gets the path of the current executable.
If this program was built to executable, this will return its path.
Otherwise, this will be the path where `crow` is installed.
###
current-executable-path str() summon trusted
	"/proc/self/exe" read-link

# Reads the full contents of the file.
read-file str(path str) summon trusted
	path.read-file-binary as-str

# Reads the full contents of the file as bytes.
read-file-binary nat8[](path str) summon
	if res ?= path try-read-file-binary
		res
	else
		throw "file does not exist: {path}"

###
Writes the full contents of the file as a string.
If the file already exists, overwrites it.
###
write-file void(path str, content str) summon trusted
	path.to-c-str write-file content

.write-file void(path c-str, content str) summon unsafe
	fd = path fopen "wb"
	forbid fd.as-any-const-ptr == null : "failed to open file for write: {path}"
	with : (() => fd close-fd path) finally
		fd write-fd path, content.to-bytes.to-array

.write-fd void(fd FILE, path c-str, bytes array nat8) summon unsafe
	wrote-bytes = bytes.begin-ptr fwrite size-of@<nat8>, bytes.size, fd
	assert wrote-bytes == bytes.size : "error writing file {path}"

###
Like `read-file`, but returns an empty option if the file does not exist.
Will still throw on other errors, like permission errors.
###
try-read-file str?(path str) summon trusted
	if bytes ?= path try-read-file-binary
		bytes.as-str,

# Like `try-read-file` but returns binary data.
try-read-file-binary nat8[]?(path str) summon trusted
	path.to-c-str try-read-file-binary

.try-read-file-binary nat8[]?(path c-str) summon trusted
	if path is-file
		fd = path fopen "rb"
		if fd.as-any-const-ptr == null
			unless errno == ENOENT
				err print "failed to open file {path}"
				todo
		else
			with : (() => fd close-fd path) finally
				(fd read-fd path),
	else
		()

.read-fd nat8[](fd FILE, path c-str) summon unsafe
	err = fd fseek 0, SEEK_END
	assert err == 0 : "Error reading {path}"

	file-size = fd ftell
	# TODO: handle errors
	forbid file-size == -1
	if file-size != 0
		# Go back to beginning
		err2 = fd fseek 0, SEEK_SET
		# TODO: handle errors
		assert err2 == 0

		# TODO: allocation can fail, then 'fd' is left open. Need finalizers
		file-size-nat = file-size to-nat64
		res mut-array nat8 = file-size-nat uninitialized-mut-array
		n-bytes-read = res.begin-ptr.ptr-cast fread size-of@<nat8>, file-size-nat, fd
		assert n-bytes-read == file-size-nat
		forbid fd ferror : "Error reading {path}"
		res.cast-immutable to-list

.close-fd void(fd FILE, path c-str) summon unsafe
	err = fd fclose
	assert err == 0 : "Error closing {path}"

# Gets the current directory (of the user that ran the program).
current-directory str() summon trusted
	buff mut-array char8 = 256 uninitialized-mut-array
	b = is-windows ? buff.begin-ptr _getcwd buff.size : buff.begin-ptr getcwd buff.size
	if b == null
		todo
	else
		assert b == buff.begin-ptr
		b.as-const to-str

###
If `path` is a directory, calls `each-child-recursive` on every child of the directory.
Else, calls `f[path]`.
###
each-child-recursive void(path str, f act void(str)) summon
	path each-child-recursive (_ => true), f

###
Like `each-child-recursive`, but calls `filter` on names of directory children
and skips them if `filter` returns false.
###
each-child-recursive void(path str, filter act bool(str), f act void(str)) summon
	if path is-dir
		for child-name : path names-in-dir
			if filter[child-name]
				path child-path child-name each-child-recursive filter, f
	else
		f[path]

# POSIX file permissions.
file-permissions record
	user permissions
	group permissions
	public permissions

# Permissions for one of user, group, public.
permissions record
	read bool
	write bool
	execute bool

.to-mode mode_t(a permissions)
	a.read.to-nat64 << 2 | a.write.to-nat64 << 1 | a.execute.to-nat64 to-nat32

no-permissions permissions()
	false, false, false

all-permissions permissions()
	true, true, true

user-only file-permissions(user-permissions permissions)
	user-permissions, no-permissions, no-permissions

# Converts permissions to an integer.
to-mode mode_t(a file-permissions)
	a.user.to-mode << 6 | a.group.to-mode << 3 | a.public.to-mode

# TODO: this might not be the correct default permissions
# Creates a new empty directory at `path`.
make-directory void(path str) summon
	# TODO: all-permissions.user-only instead of a number literal
	# TODO: 'to-nat32' should not be necessary
	path make-directory 0o777.to-nat32

make-directory void(path str, permissions file-permissions) summon
	path make-directory permissions.to-mode

make-directory void(path str, permissions mode_t) trusted summon
	path-c-str = path to-c-str
	err = is-windows ? path-c-str _mkdir permissions : path-c-str mkdir permissions
	err check-posix-error

# Deletes the file at `path`.
remove-file void(path str) trusted summon
	if is-windows
		ok = path.to-c-str DeleteFileA
		assert ok : "error removing file at {path}: {GetLastError show-win32-error}"
	else
		path.to-c-str.unlink check-posix-error

###
Deletes the directory at `path`.
It should be empty.
###
remove-directory void(path str) trusted summon
	path.to-c-str.rmdir check-posix-error

remove-directory-and-contents-non-recursive void(path str) no-doc summon
	path remove-directory-contents-non-recursive
	path remove-directory

remove-directory-contents-non-recursive void(path str) no-doc summon
	for child : path names-in-dir
		"{path}/{child}" remove-file
