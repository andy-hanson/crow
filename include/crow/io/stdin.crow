no-std
import
	stdio: stdin
	unistd: read
	../col/mut-array: begin-ptr, cast-immutable, mut-array, size, subscript, uninitialized-mut-array
	../col/list: to-list
	../compare: >=
	../fun-util: subscript
	../future: do, future, launch, new, then
	../misc: is-sendable
	../number: ==, <=>, nat8, to-nat64
	../opt: opt
	../range: ..
	../str: as-str, str, strip
	../private/bootstrap: todo
	./print: out, print

###
Reads from stdin.
If that comes from the user typing at the terminal, this will block until they hit enter.
Result will not have leading or trailing whitespace.
###
read-stdin str^() trusted summon
	launch do () =>
		buffer mut-array nat8 = 0x2000 uninitialized-mut-array
		# TODO: use a non-blocking API
		bytes-read-or-err = stdin read buffer.begin-ptr, buffer.size
		assert bytes-read-or-err >= 0
		bytes-read = bytes-read-or-err to-nat64
		if bytes-read >= buffer.size
			todo
		else
			buffer[0 .. bytes-read].cast-immutable.to-list.as-str.strip,

###
Keep reading from stdin until `parse` returns a non-empty option.
Print `error-message` after every failure.
###
read-stdin-until-parse<a> a^(error-message str, parse act a?(str)) summon is-sendable<a>
	text <- read-stdin
	if res ?= parse[text]
		res,
	else
		out print error-message
		error-message read-stdin-until-parse parse
