no-std
import
	stdio: stdin
	unistd: read
	../col/collection: subscript
	../col/mut-array:
		+, begin, begin-pointer, cast-immutable, mut-array, size, slice, uninitialized-mut-array
	../compare: >=
	../fun-util: subscript
	../future: future, new, parallel, then, with-block
	../misc: shared
	../number: ==, <=>, nat8, nat64, to
	../option: option
	../range: ..
	../string: as-string, string, strip
	../private/bootstrap: todo
	./print: out, print

###
Reads from stdin.
If that comes from the user typing at the terminal, this will block until they hit enter.
Result will not have leading or trailing whitespace.
###
+read-stdin string^() summon
	with : parallel
		trusted
			buffer nat8 mut-array = 0x2000 uninitialized-mut-array
			# TODO: use a non-blocking API
			bytes-read-or-err = stdin read buffer.begin-pointer, buffer.size
			assert bytes-read-or-err >= 0
			bytes-read nat64 = bytes-read-or-err to
			if bytes-read >= buffer.size
				todo
			else
				buffer[0 .. bytes-read].cast-immutable.as-string.strip,

###
Keep reading from stdin until `parse` returns a non-empty option.
Print `error-message` after every failure.
###
+read-stdin-until-parse[t] t^(error-message string, parse act t?(string)) summon, t shared
	text <- read-stdin
	if res ?= parse[text]
		res,
	else
		out print error-message
		error-message read-stdin-until-parse parse
