no-std
import
	../bool: !, &&, ||, ==, bool, false, to-nat64, true
	../compare: !=, <, <=, >=, equal, max, min
	../fun: subscript
	../misc: ->, void
	../number: +, -, nat64
	../opt: is-empty, none, opt, some
	../ptr: ==, +, -, *, as-const, const-ptr, mut-ptr, set-deref
	../test: is
	../tuple: pair
	../private/alloc: alloc-uninitialized, fill-ptr-range
	../private/exception-low-level: assert, forbid
	../private/number-low-level: ==, <=>, unsafe-mod, wrap-add, wrap-mul
	./arr: ==, ~, arr, arr-from-begin-end, begin-ptr, is-empty, end-ptr, noctx-at, size, subscript

###
Equivalent to `[f[0], f[1], ..., f[size - 1]]`.
Arr containing the result of `f` for each number 0 to size (exclusive).
###
make-arr<a> a[](size nat64, f act a(nat64)) trusted
	res = size alloc-uninitialized<a>
	res fill-ptr-range size, f
	size arr res.as-const

###
Equivalent to `[value, value, ...]`.
Arr with the given `size` where every element is `value`.
###
fill-arr<a> a[](size nat64, value a)
	size make-arr ignore =>
		value

###
Equivalent to calling `f[a[0]]`, `f[a[1]]`, etc., in turn.
Calls `f` for each element in `a`.
###
each<a> void(a a[], f act void(a)) trusted
	a.begin-ptr each-recur a.end-ptr, f
.each-recur<a> void(cur a*, end a*, f act void(a)) unsafe
	if cur != end
		f[*cur]
		cur + 1 each-recur end, f

###
Equivalent to calling `f[a[0], 0]`, `f[a[1], 1]`, etc., in turn.
Calls `f` for each element in `a`, also providing the index.
###
each-with-index<a> void(a a[], f act void(a, nat64))
	a each-with-index-recur f, 0
.each-with-index-recur<a> void(a a[], f act void(a, nat64), n nat64)
	if n != a.size
		f[a[n], n]
		a each-with-index-recur f, n + 1

each-ptr<a> void(a a[], f act void(a*)) unsafe
	a.begin-ptr each-ptr-recur a.end-ptr, f
.each-ptr-recur<a> void(cur a*, end a*, f act void(a*)) unsafe
	if cur != end
		f[cur]
		cur + 1 each-ptr-recur end, f

###
Arr of the elements of `a` for which `f[a[i]]` returns true.
###
filter<a> a[](a a[], f act bool(a))
	a filter-with-index (cur, index) =>
		f[cur]

filter-with-index<a> a[](a a[], f act bool(a, nat64)) trusted
	res = a.size alloc-uninitialized<a>
	end = res filter-with-index-recur a.begin-ptr, a.end-ptr, 0, f
	res.as-const arr-from-begin-end end.as-const
.filter-with-index-recur<a> a mut*
	out a mut*
	cur a*
	end a*
	index nat64
	f act bool(a, nat64)
spec
	unsafe
body
	if cur == end
		out
	else
		new-out = if f[*cur, index]
			*out := *cur
			out + 1
		else
			out
		new-out filter-with-index-recur cur + 1, end, index + 1, f

###
Like 'filter', but keeps everything after the first time `f` returns true.
###
strip-left-while<a> a[](a a[], f act bool(a))
	if a.is-empty || !f[a[0]]
		a
	else
		a.tail strip-left-while f
test
	[3, 2, 1] strip-left-while (it => it < 3) is [3, 2, 1]
	[1, 3, 5, 3, 1] strip-left-while (it => it < 5) is [5, 3, 1]

# TODO: move to iter-utiil since this works with any foldable
count<a> nat64(a a[], f act bool(a))
	0 fold a, (cur, x) =>
		cur wrap-add f[x].to-nat64

###
Equivalent to `[f[a[0]], f[a[1]], ...]`.
Arr of `f[x]` for each `x` in `a`.
###
map<out, in> out[](a in[], f act out(in))
	a.size make-arr i =>
		f[a[i]]

map-with-index<out, in> out[](a in[], f act out(in, nat64))
	a.size make-arr i =>
		f[a[i], i]

first<a> a?(a a[])
	if !a.is-empty
		a[0] some

last<a> a?(a a[])
	if !a.is-empty
		a[a.size - 1] some

###
All but the first element of an arr.
Throws if `a is-empty`.
###
tail<a> a[](a a[])
	forbid: a is-empty
	a[1 -> a.size]

###
All but the last element of an arr.
Throws if `a is-empty`.
###
rtail<a> a[](a a[])
	forbid: a is-empty
	a[0 -> a.size - 1]

###
Calls `f` on each element of `a` and returns the first result that is `some`.
Returns `none` if every call to `f` returned `none`.
###
first-some<out, in> out?(a in[], f act out?(in))
	if !a.is-empty
		res = f[a[0]]
		if res is-empty
			a.tail first-some f
		else
			res

###
Equivalent to `f[a[0]] or f[a[1]] or or ...`
Calls `f` on each element of `a` and returns `true` the first time `f` does.
###
exists<a> bool(a a[], f act bool(a))
	if a is-empty
		false
	elif f[a[0]]
		true
	else
		a.tail exists f

every<a> bool(a a[], f act bool(a))
	if a is-empty
		true
	elif f[a[0]]
		a.tail every f
	else
		false

# TODO: only written this way to be `noctx`, else could defer to `exists`
###
Equivalent to `a exists it => it == value`.
Also equivalent to `a[0] == value or a[1] == value or ...`.
###
in<a> bool(value a, a a[]) noctx equal<a>
	value in-recur a, 0
.in-recur<a> bool(value a, a a[], i nat64) noctx trusted equal<a>
	if i == a.size
		false
	elif (a noctx-at i) == value
		true
	else
		value in-recur a, (i wrap-add 1)
test
	2 in [1, 2, 3] is true
	2 in [1, 3] is false

try-remove<a> a[]?(a a[], value a) equal<a>
	a try-remove-recur 0, value
.try-remove-recur<a> a[]?(a a[], index nat64, value a) equal<a>
	if index == a.size
		none
	elif a[index] == value
		a remove-index index some
	else
		a try-remove-recur index + 1, value

remove-index<a> a[](a a[], index nat64)
	assert: index < a.size
	a[0 -> index] ~ a[index + 1 -> a.size]

# TODO: equal<a[]> should be unnecessary
###
True iff the sub-sequence appears in `a`.
Equivalent to `a[0 -> subseq.size] == subseq or a[1 -> 1 + subseq.size] == subseq or ...`
###
contains-subseq<a> bool(a a[], subseq a[]) equal<a> equal<a[]>
	!(a index-of-subseq subseq is-empty)

# TODO: equal<a[]> should be unnecessary
# True iff the first elements of `a` are `start`, meaning `a[0 -> start.size] == start`.
starts-with<a> bool(a a[], start a[]) equal<a> equal<a[]>
	a.size >= start.size && a[0 -> start.size] == start

# TODO: equal<a[]> should be unnecessary
# True iff the last elements of `a` are `end`, meaning `a[a.size - end.size -> a.size] == end`.
ends-with<a> bool(a a[], end a[]) equal<a> equal<a[]>
	a.size >= end.size && a[a.size - end.size -> a.size] == end

# TODO: equal<a[]> should be unnecessary
# If `a` starts with `start`, returns the remaining elements, else returns `none`.
try-remove-start<a> a[]?(a a[], start a[]) equal<a> equal<a[]>
	if a starts-with start
		a[start.size -> a.size] some

# TODO: equal<a[]> should be unnecessary
# If `a` ends with `end`, returns the preceding elements, else returns `none`.
try-remove-end<a> a[]?(a a[], end a[]) equal<a> equal<a[]>
	if a ends-with end
		a[0 -> a.size - end.size] some

###
This is like `each` but with a state variable that gets transformed by each call to `f`.
For example, for a 2-element array, this is equivalent to `f[f[val, a[0]], a[1]]`.
###
fold<a, b> a(acc a, a b[], f act a(a, b)) trusted
	acc fold-recur a.begin-ptr, a.end-ptr, f
.fold-recur<a, b> a(acc a, cur b*, end b*, f act a(a, b)) unsafe
	if cur == end
		acc
	else
		f[acc, *cur] fold-recur cur + 1, end, f

fold-with-index<a, b> a(acc a, a b[], f act a(a, b, nat64)) trusted
	acc fold-with-index-recur 0, a.begin-ptr, a.end-ptr, f
.fold-with-index-recur<a, b> a(acc a, index nat64, cur b*, end b*, f act a(a, b, nat64)) unsafe
	if cur == end
		acc
	else
		f[acc, *cur, index] fold-with-index-recur index + 1, cur + 1, end, f

fold-reverse<a, b> a(acc a, a b[], f act a(a, b)) trusted
	acc fold-reverse-recur a.begin-ptr, a.end-ptr, f
.fold-reverse-recur<a, b> a(acc a, begin b*, cur b*, f act a(a, b)) unsafe
	if cur == begin
		acc
	else
		prev = cur - 1
		f[acc, *prev] fold-reverse-recur begin, prev, f

# TODO: equal<a[]> should be unnecessary
# Finds the first index where `a[i -> i + subseq.size] == subseq`.
index-of-subseq<a> nat64?(a a[], subseq a[]) equal<a> equal<a[]>
	a index-of-subseq-recur subseq, 0
# TODO: equal<a[]> should be unnecessary
.index-of-subseq-recur<a> nat64?(a a[], subseq a[], i nat64) equal<a> equal<a[]>
	if i == a.size
		none
	elif a[i -> a.size] starts-with subseq
		i some
	else
		a index-of-subseq-recur subseq, i + 1

find<a> a?(a a[], f act bool(a))
	if !a.is-empty
		if f[a[0]]
			a[0] some
		else
			a.tail find f

###
Returns the first index for which `f[a[i]]` is true, or returns `none`.
###
find-index<a> nat64?(a a[], f act bool(a))
	a find-index-recur 0, f
.find-index-recur<a> nat64?(a a[], index nat64, f act bool(a))
	if index == a.size
		none
	elif f[a[index]]
		index some
	else
		a find-index-recur index + 1, f

###
Like `find-index`, but starts from the end.
###
find-rindex<a> nat64?(a a[], f act bool(a))
	if !a.is-empty
		a find-rindex-recur a.size - 1, f
.find-rindex-recur<a> nat64?(a a[], index nat64, f act bool(a))
	if f[a[index]]
		index some
	elif index != 0
		a find-rindex-recur index - 1, f

###
Returns the first index where `a[i] == value`.
Equivalent to `a find-index it => it == value`.
###
index-of<a> nat64?(a a[], value a) trusted equal<a>
	if v ?= a ptr-of value
		v - a.begin-ptr some

# Like `index-of` but returns a ptr.
ptr-of<a> a*?(a a[], value a) unsafe equal<a>
	a.begin-ptr ptr-of-recur a.end-ptr, value
.ptr-of-recur<a> a*?(cur a*, end a*, value a) unsafe equal<a>
	if cur == end
		none
	elif *cur == value
		cur some
	else
		cur + 1 ptr-of-recur end, value

###
Returns the last index where `a[i] == value`.
Equivalent to `a find-rindex it => it == value`.
###
r-index-of<a> nat64?(a a[], value a) equal<a>
	a find-rindex it => it == value

###
Concatenates many arrays into a single array.
Equivalent to `a[0] ~ a[1] ~ ...`.
###
flatten<a> a[](a a[][])
	a flatten []

###
Concatenates many arrays into a single array, with `joiner` in between.
Equivalent to `a[0] ~ joiner ~ a[1] ~ joiner ~ ... ~ a[a.size - 1]`.
###
flatten<a> a[](a a[][], joiner a[])
	if a is-empty
		[]
	elif a.size == 1
		a[0]
	else
		a[0] ~ joiner ~ (a.tail flatten joiner)

try-split-once<a> pair<a[], a[]>?(a a[], splitter a) equal<a>
	if index ?= a index-of splitter
		some: a[0 -> index] pair a[index + 1 -> a.size]

# TODO: equal<a[]> should be unnecessary
split-by<a> a[][](a a[], splitter a) equal<a> equal<a[]> trusted
	# TODO:PERF
	a split-by-subseq [splitter]

# TODO: equal<a[]> should be unnecessary
###
Splits `a` each time it finds `splitter`.
For example, "a rose is a hose is a nose" split-by-subseq "is" would be
["a rose ", " a hose ", " a nose"].
###
split-by-subseq<a> a[][](a a[], splitter a[]) equal<a> equal<a[]> trusted
	size = (a count-subseqs splitter) + 1
	res = size alloc-uninitialized<a[]>
	res split-by-subseq-recur a, splitter
	size arr res.as-const
# TODO: equal<a[]> should be unnecessary
.split-by-subseq-recur<a> void(out a[] mut*, a a[], splitter a[]) equal<a> equal<a[]> unsafe
	if index ?= a index-of-subseq splitter
		*out := a[0 -> index]
		rest = a[index + splitter.size -> a.size]
		out + 1 split-by-subseq-recur rest, splitter
	else
		*out := a

# TODO: equal<a[]> should be unnecessary
# Returns the number of indices for which `a[i -> i + subseq.size] == subseq`.
count-subseqs<a> nat64(a a[], subseq a[]) equal<a> equal<a[]>
	a count-subseqs-recur subseq, 0
# TODO: equal<a[]> should be unnecessary
.count-subseqs-recur<a> nat64(a a[], subseq a[], acc nat64) equal<a> equal<a[]>
	if index ?= a index-of-subseq subseq
		a[index + subseq.size -> a.size] count-subseqs-recur subseq, acc + 1
	else
		acc

###
Arr containing the result of `f` for corresponding elements of `a` and `b`.
Equivalent to `[f[a[0], b[0]], f[a[1], b[1]], ...]`.
Throws if the arrs have different sizes.
###
zip<out, a, b> out[](a a[], b b[], f act out(a, b))
	assert: a.size == b.size
	a.size make-arr i =>
		f[a[i], b[i]]

###
Like `zip`, but instead of throwing on different sizes,
cuts the larger array down to the smaller one's size.
###
zip-smaller<out, a, b> out[](a a[], b b[], f act out(a, b))
	size = a.size min b.size
	a[0 -> size] zip b[0 -> size], f


###
Returns an array as big as the bigger of 'a' and 'b'.
Calls 'f' using corresponding elements, or 'none' if the arr is too short.
###
zip-larger<out, a, b> out[](a a[], b b[], f act out(a?, b?))
	a.size max b.size make-arr i =>
		f[(a opt-subscript i), (b opt-subscript i)]

.opt-subscript<a> a?(a a[], index nat64)
	if index < a.size
		a[index] some

# TODO: update-at
update<a> a[](a a[], index nat64, new-value a)
	assert: index < a.size
	a[0 -> index] ~ [new-value] ~ a[index + 1 -> a.size]

update-with-default<a> a[](a a[], index nat64, new-value a, default a)
	if index < a.size
		a update index, new-value
	else
		index + 1 make-arr i =>
			if i < a.size
				a[i]
			elif i == index
				new-value
			else
				default

# TODO: insert-at
insert<a> a[](a a[], index nat64, value a)
	assert: index <= a.size
	# TODO:PERF (only concat once)
	a[0 -> index] ~ [value] ~ a[index -> a.size]

insert<a> a[](a a[], ptr a*, value a) unsafe
	a insert ptr - a.begin-ptr, value

remove-at<a> a[](a a[], index nat64)
	assert: index < a.size
	a[0 -> index] ~ a[index + 1 -> a.size]

with-max-size<a> a[](a a[], max-size nat64)
	if a.size <= max-size
		a
	else
		a[0 -> max-size]

pad-left<a> a[](pad a, a a[], min-size nat64)
	if a.size < min-size
		diff = min-size - a.size
		min-size make-arr index =>
			if index < diff
				pad
			else
				a[index - diff]
	else
		a

repeat<a> a[](a a[], n nat64) trusted
	a.size wrap-mul n make-arr i =>
		a[i unsafe-mod a.size]

reverse<a> a[](a a[])
	a.size make-arr i =>
		a[a.size - 1 - i]
