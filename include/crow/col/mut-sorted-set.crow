no-std
import
	../bool: !, bool, false, true
	../compare: compare
	../fun: subscript
	../misc: ->, data, from, void
	../number: nat64
	../opt: is-empty
	./arr: arr
	./arr-util: each, map
	./mut-sorted-dict:
		each, empty!, filter, filter!, fold, in, is-empty, map, map!, move-to-arr!,
		mut-sorted-dict, new, remove-key!, set-subscript, size, subscript
	./sorted-set: sorted-set

###
Mutable sorted set of unique values.
This is like a `set` but mutable, or like a `mut-sorted-dict` with no values.
Unlike `mut-arr`, values are in sorted order, not insertion order,
and it never stores two of the same value.
###
mut-sorted-set<a> record mut
	# TODO:PRIVATE
	ignore void
	inner mut-sorted-dict<a, void>

# New empty `mut-sorted-set`.
new<a> mut-sorted-set a() data<a> compare<a>
	void, ()

###
Copies the arr to a new mut-sorted-set.
Result won't include any duplicated elements.
###
mut-sorted-set<a> mut-sorted-set a(a a[]) data<a> compare<a>
	void, (a map (x => x -> void) mut-sorted-dict)

# True iff the set has no elements.
is-empty<a> bool(a mut-sorted-set a) data<a> compare<a>
	a.inner is-empty

# Removes all elements.
empty!<a> void(a mut-sorted-set a) data<a> compare<a>
	a.inner empty!

# Number of values in the set.
size<a> nat64(a mut-sorted-set a) data<a> compare<a>
	a.inner size

# True iff the value is in the set.
subscript<a> bool(a mut-sorted-set a, value a) data<a> compare<a>
	value in a

in<a> bool(value a, a mut-sorted-set a) data<a> compare<a>
	!a.inner[value].is-empty

###
Adds a value to the set.
Does nothing if the value is already in the set.
###
~= <a> void(a mut-sorted-set a, value a) data<a> compare<a>
	a.inner[value] := void

# Adds multiple values to the set.
~= <a> void(a mut-sorted-set a, values a[]) data<a> compare<a>
	values each value =>
		a ~= value

try-add!<a> bool(a mut-sorted-set a, value a) data<a> compare<a>
	# TODO:PERF do it without two lookups
	if value in a.inner
		false
	else
		a.inner[value] := void
		true

###
Removes a value from the set.
If the value was present, removes it and returns `true`.
If the value was not present, does nothing and returns `false`.
###
remove!<a> bool(a mut-sorted-set a, value a) data<a> compare<a>
	!(a.inner remove-key! value is-empty)

# Convert to an `arr`, clearing the original `mut-sorted-set` in the process.
move-to-arr!<a> a[](a mut-sorted-set a) data<a> compare<a>
	a.inner.move-to-arr! map pair => pair from

# Convert to a `sorted-set`, clearning the original `mut-sorted-set` in the process.
move-to-sorted-set!<a> sorted-set a(a mut-sorted-set a) data<a> compare<a>
	# TODO:PERF avoid a copy: return a 'mut-arr' which the sorted-set can move into to itself
	a.move-to-arr! sorted-set

region iteration

each<a> void(a mut-sorted-set a, f act void(a)) data<a> compare<a>
	a.inner each (k, v) => f[k]

fold<a, b> a(acc a, a mut-sorted-set b, f act a(a, b)) data<b> compare<b>
	acc fold a.inner, (cur, k, v) => f[cur, k]

filter<a> mut-sorted-set a(a mut-sorted-set a, f act bool(a)) data<a> compare<a>
	void, (a.inner filter (k, v) => f[k])

map<out, in> mut-sorted-set out(a mut-sorted-set in, f act out(in)) data<in> compare<in> data<out> compare<out>
	void, (a.inner map (k, v) => f[k] -> void)

region mutating iteration

filter!<a> void(a mut-sorted-set a, f act bool(a)) data<a> compare<a>
	a.inner filter! (k, v) => f[k]

map!<a> void(a mut-sorted-set a, f act a(a)) data<a> compare<a>
	a.inner map! (k, v) => f[k] -> void
