no-std
import
	../bool: &&, bool
	../compare: <
	../fun-util: subscript
	../json: json
	../misc: void
	../number: +, -, *, ==, <=>, nat64
	../range: .., for-loop
	../string: ==, ~~, join, literal, string, to-string
	../test-util: is
	./mut-array:
		~=, build, copy, exists, for-loop, mut-array, new, set-map, set-subscript, size, subscript,
		to-array, with-block
	./list: ~=, build, for-loop, list, to-list, with-block

###
Mutable grid (matrix) type.
This is intended for data that happens to fall in a grid; it may not be ideal for linear algebra.

This is row-major, meaning rows are stored contiguously.
So, iteration functions typically start with the top row left-to-right,
then the second row left-to-right, etc.

Grid elements are mutable, but changing the width or height is not supported.
###
!mut-grid[t] record mut
	.elements t mut-array
	width nat64
	height nat64

###
Coordinate in a grid.

`x` is the column index. The leftmost column is 0; the rightmost column is `width - 1`.
`y` is the row index. The top row is 0; the bottom row is `height - 1`.
###
!coord record
	x nat64
	y nat64

# Same as `0, 0`.
!new coord()
	0, 0

!== bool(a coord, b coord)
	a.x == b.x && a.y == b.y

# `"<x, y>"`
!to-string string(a coord)
	"<{a.x}, {a.y}>"

# `true` if `coord` is a valid coordinate (within the width and height of the grid).
!has-coord[t] bool(a t mut-grid, coord coord)
	coord.x < a.width && coord.y < a.height

###
Returns the entire row `y`.
This is O(1).
Throws if `y` is out of range.
###
!row[t] t mut-array(a t mut-grid, y nat64)
	assert y < a.height
	begin = y * a.width
	a.elements[begin .. begin + a.width]

# New empty grid with width and height 0.
!new[t] t mut-grid()
	(), 0, 0

# Number of elements in the grid (width * height).
!size[t] nat64(a t mut-grid)
	a.elements size

# Creates a new grid with the given width and height, setting every element to `f[x, y]`.
!make[t] t mut-grid(width nat64, height nat64, f act t(nat64, nat64))
	elements t mut-array = with out : width * height build
		for y : 0 .. height
			for x : 0 .. width
				out ~= f[x, y]
	elements, width, height

# Copy elements to a new grid.
!copy[t] t mut-grid(a t mut-grid)
	a.elements.copy, a.width, a.height

###
Gets the element in the `x`th column and `y`th row.

Throws if either `x` or `y` is out of bounds.
###
!subscript[t] t(a t mut-grid, x nat64, y nat64)
	index = a index-for x, y
	a.elements[index]

# Same as the other `subscript`, but takes a `coord`.
!subscript[t] t(a t mut-grid, coord coord)
	a[coord.x, coord.y]

###
Sets the element in the `x`th column and `y`th row.

Throws if either `x` or `y` is out of bounds.
###
!set-subscript[t] void(a t mut-grid, x nat64, y nat64, value t)
	index = a index-for x, y
	a.elements[index] := value

# Same as the other `set-subscript`, but takes a `coord`.
!set-subscript[t] void(a t mut-grid, coord coord, value t)
	a[coord.x, coord.y] := value

.index-for[t] nat64(a t mut-grid, x nat64, y nat64)
	assert x < a.width
	assert y < a.height
	res = y * a.width + x
	assert res < a.elements.size
	res

###
Returns a string with one line for each row.
Each row will have a space in between columns.

This makes no attempt to add padding to ensure columns line up. (TODO?)
###
!to-string[t] string(a t mut-grid) t to-string
	"\n" join for row : a.rows
		" " join for value : row.to-array.to-list
			"{value}"

region iteration

!mut-grid-rows[t] record mut
	.inner t mut-grid
!rows[t] t mut-grid-rows(a t mut-grid)
	a,

!for-loop[t] void(a t mut-grid-rows, f act void(t mut-array))
	for y : 0 .. a.inner.height
		f[a.inner row y]

!for-loop[out, in] out[](a in mut-grid-rows, f act out(in mut-array))
	for y : 0 .. a.inner.height
		f[a.inner row y]

!for-loop[t] void(a t mut-grid, f act void(t))
	a.elements for-loop f
!for-loop[out, in] out[](a in mut-grid, f act out(in))
	with out : a.size build
		for x : a
			out ~= f[x]

!for-loop[t] void(a t mut-grid, f act void(t, coord))
	coord mut coord = ()
	for x : a
		f[x, coord]
		coord := coord next-coord a.width
!for-loop[out, in] out[](a in mut-grid, f act out(in, coord))
	with out : a.size build
		coord mut coord = ()
		for x : a
			out ~= f[x, coord]
			coord := coord next-coord a.width

!exists[t] bool(a t mut-grid, f act bool(t))
	a.elements exists f

!set-map[t] void(a t mut-grid, f act t(t))
	a.elements set-map f
!set-map[t] void(a t mut-grid, f act t(t, coord))
	coord mut coord = ()
	a set-map x =>
		res = f[x, coord]
		coord := coord next-coord a.width
		res

.next-coord coord(a coord, width nat64)
	new-x = a.x + 1
	if new-x == width
		0, a.y + 1
	else
		new-x, a.y

test
	a string mut-grid = 3 make 2, (x, y) => "{x}|{y}"
	a.to-string is "0|0 1|0 2|0\n0|1 1|1 2|1"

	values = " " join for value, coord : a
		"{value}/{coord}"
	values is "0|0/<0, 0> 1|0/<1, 0> 2|0/<2, 0> 0|1/<0, 1> 1|1/<1, 1> 2|1/<2, 1>"
