no-std
import
	../bool: !, &&, bool
	../compare: !=, <
	../exception: assert
	../fun-util: subscript
	../log: info, log
	../misc: void
	../number: *
	../ptr: ==, +, *, as-const, const-ptr, mut-ptr, set-deref
	../private/number-low-level: ==, <=>, nat64, wrap-add, wrap-mul
	../range: ..
	../str: ==, str
	../str-conv: interp, finish, to-str, with-str, with-value
	../test-util: is
	../writer: ~=, backup!, move-to-str!, new, write, writer
	./fix-arr:
		begin-ptr, copy, each, end-ptr, exists, fix-arr, fold, is-empty, map!, new, set-subscript,
		size, subscript, uninitialized-fix-arr

###
Mutable grid (matrix) type.
Not really intended for linear algebra.
Rows are stored contiguously.
###
mut-grid<a> record mut
	.elements fix-arr a
	width nat64
	height nat64

# TODO: OWN FILE?
coord record
	x nat64
	y nat64

has-coord<a> bool(a mut-grid a, coord coord)
	coord.x < a.width && coord.y < a.height

to-str str(a coord)
	"<{a.x}, {a.y}>"

zero coord()
	0, 0

row<a> fix-arr a(a mut-grid a, y nat64)
	assert: y < a.height
	begin = y wrap-mul a.width
	a.elements[begin .. (begin wrap-add a.width)]

new<a> mut-grid a()
	(), 0, 0

size<a> nat64(a mut-grid a)
	a.elements size

fill-mut-grid<a> mut-grid a(width nat64, height nat64, value a)
	width make-mut-grid height, (ignore, ignore2) => value

make-mut-grid<a> mut-grid a(width nat64, height nat64, f act a(nat64, nat64)) trusted
	res mut-grid a = (width * height).uninitialized-fix-arr, width, height
	res map-with-coords! (ignore, coord) => f[coord.x, coord.y]
	res

copy<a> mut-grid a(a mut-grid a)
	a.elements.copy, a.width, a.height

subscript<a> a(a mut-grid a, x nat64, y nat64)
	index = a index-for x, y
	a.elements[index]

subscript<a> a(a mut-grid a, coord coord)
	a[coord.x, coord.y]

set-subscript<a> void(a mut-grid a, x nat64, y nat64, value a)
	index = a index-for x, y
	a.elements[index] := value

set-subscript<a> void(a mut-grid a, coord coord, value a)
	a[coord.x, coord.y] := value

.index-for<a> nat64(a mut-grid a, x nat64, y nat64)
	assert: x < a.width
	assert: y < a.height
	res = y wrap-mul a.width wrap-add x
	assert: res < a.elements.size
	res

###
Represented with row 0 coming first.
###
to-str<a> str(a mut-grid a) write<a>
	res writer = ()
	a each-row row =>
		row each value =>
			res ~= value
			res ~= " "
		if !row.is-empty
			res backup!
		res ~= "\n"
	if a.height != 0
		res backup!
	res move-to-str!

region iteration

each<a> void(a mut-grid a, f act void(a))
	void fold a, (ignore, value) => f[value]

each-row<a> void(a mut-grid a, f act void(fix-arr a))
	void fold-rows a, (ignore, row) => f[row]

fold-rows<a, b> a(acc a, a mut-grid b, f act a(a, fix-arr b))
	acc fold-rows-recur a, 0, f
.fold-rows-recur<a, b> a(acc a, a mut-grid b, y nat64, f act a(a, fix-arr b))
	if y == a.height
		acc
	else
		f[acc, a row y] fold-rows-recur a, (y wrap-add 1), f

fold<a, b> a(acc a, a mut-grid b, f act a(a, b))
	acc fold a.elements, f

fold-with-coords<a, b> a(acc a, a mut-grid b, f act a(a, b, coord)) trusted
	acc fold-with-coords-recur a.elements.begin-ptr.as-const, a.elements.end-ptr.as-const, zero, a.width, f
.fold-with-coords-recur<a, b> a
	acc a
	cur b*
	end b*
	coord coord
	width nat64
	f act a(a, b, coord)
spec
	unsafe
body
	if cur == end
		acc
	else
		f[acc, *cur, coord] fold-with-coords-recur cur + 1, end, (coord next-coord width), width, f

exists<a> bool(a mut-grid a, f act bool(a))
	a.elements exists f

map!<a> void(a mut-grid a, f act a(a))
	a.elements map! f

map-with-coords!<a> void(a mut-grid a, f act a(a, coord)) trusted
	a.elements.begin-ptr map-with-coords-recur! a.elements.end-ptr, zero, a.width, f
.map-with-coords-recur!<a> void(cur a mut*, end a mut*, coord coord, width nat64, f act a(a, coord)) unsafe
	if cur == end
		void
	else
		*cur := f[*cur, coord]
		cur + 1 map-with-coords-recur! end, (coord next-coord width), width, f

.next-coord coord(a coord, width nat64)
	new-x = a.x wrap-add 1
	if new-x == width
		0, (a.y wrap-add 1)
	else
		new-x, a.y

test
	info log "START THE TEST"

	a = 3 make-mut-grid@<str> 2, (x, y) => "{x}|{y}"
	a.to-str is "0|0 1|0 2|0\n0|1 1|1 2|1"

	folded = "S" fold-with-coords a, (acc, value, coord) => "{acc} {value}/{coord}"
	folded is "S 0|0/<0, 0> 1|0/<1, 0> 2|0/<2, 0> 0|1/<0, 1> 1|1/<1, 1> 2|1/<2, 1>"
