no-std
import
	../bool: &&, bool
	../compare: <
	../fun-util: subscript
	../misc: new, void
	../number: +, *, ==, <=>, nat64
	../ptr: ==, +, *, as-const, const-ptr, mut-ptr, set-deref
	../range: .., for-loop
	../str: ==, ~~, literal, str
	../str-conv: to-str
	../str-util: join
	../test-util: is
	./mut-array:
		begin-ptr, copy, end-ptr, exists, mut-array, fold, new, set-map, set-subscript, size,
		subscript, to-array, uninitialized-mut-array
	./list: for-loop, list, to-list

###
Mutable grid (matrix) type.
This is intended for data that happens to fall in a grid; it may not be ideal for linear algebra.

This is row-major, meaning rows are stored contiguously.
So, iteration functions typically start with the top row left-to-right,
then the second row left-to-right, etc.

Grid elements are mutable, but changing the width or height is not supported.
###
mut-grid<a> record mut
	.elements mut-array a
	width nat64
	height nat64

###
Coordinate in a grid.

`x` is the column index. The leftmost column is 0; the rightmost column is `width - 1`.
`y` is the row index. The top row is 0; the bottom row is `height - 1`.
###
coord record
	x nat64
	y nat64

# Same as `0, 0`.
new coord()
	0, 0

== bool(a coord, b coord)
	a.x == b.x && a.y == b.y

# `"<x, y>"`
to-str str(a coord)
	"<{a.x}, {a.y}>"

# `true` if `coord` is a valid coordinate (within the width and height of the grid).
has-coord<a> bool(a mut-grid a, coord coord)
	coord.x < a.width && coord.y < a.height

###
Returns the entire row `y`.
This is O(1).
Throws if `y` is out of range.
###
row<a> mut-array a(a mut-grid a, y nat64)
	assert y < a.height
	begin = y * a.width
	a.elements[begin .. begin + a.width]

# New empty grid with width and height 0.
new<a> mut-grid a()
	(), 0, 0

# Number of elements in the grid (width * height).
size<a> nat64(a mut-grid a)
	a.elements size

# Creates a new grid with the given width and height, setting every element to `value`.
fill-mut-grid<a> mut-grid a(width nat64, height nat64, value a)
	width make-mut-grid height, (_, _) => value

# Creates a new grid with the given width and height, setting every element to `f[x, y]`.
make-mut-grid<a> mut-grid a(width nat64, height nat64, f act a(nat64, nat64)) trusted
	res mut-grid a = (width * height).uninitialized-mut-array, width, height
	res set-map-with-coords (_, coord) => f[coord.x, coord.y]
	res

# Copy elements to a new grid.
copy<a> mut-grid a(a mut-grid a)
	a.elements.copy, a.width, a.height

###
Gets the element in the `x`th column and `y`th row.

Throws if either `x` or `y` is out of bounds.
###
subscript<a> a(a mut-grid a, x nat64, y nat64)
	index = a index-for x, y
	a.elements[index]

# Same as the other `subscript`, but takes a `coord`.
subscript<a> a(a mut-grid a, coord coord)
	a[coord.x, coord.y]

###
Sets the element in the `x`th column and `y`th row.

Throws if either `x` or `y` is out of bounds.
###
set-subscript<a> void(a mut-grid a, x nat64, y nat64, value a)
	index = a index-for x, y
	a.elements[index] := value

# Same as the other `set-subscript`, but takes a `coord`.
set-subscript<a> void(a mut-grid a, coord coord, value a)
	a[coord.x, coord.y] := value

.index-for<a> nat64(a mut-grid a, x nat64, y nat64)
	assert x < a.width
	assert y < a.height
	res = y * a.width + x
	assert res < a.elements.size
	res

###
Returns a string with one line for each row.
Each row will have a space in between columns.

This makes no attempt to add padding to ensure columns line up. (TODO?)
###
to-str<a> str(a mut-grid a) to-str<a>
	"\n" join for row : a.rows
		" " join for value : row.to-array.to-list
			"{value}"

region iteration

for-loop<a> void(a mut-grid a, f act void(a))
	() fold a, (_, value) => f[value]

mut-grid-rows<a> record mut
	.inner mut-grid a

rows<a> mut-grid-rows a(a mut-grid a)
	a,

for-loop<a> void(a mut-grid-rows a, f act void(mut-array a))
	for y : 0 .. a.inner.height
		f[a.inner row y]

for-loop<out, in> out[](a mut-grid-rows in, f act out(mut-array in))
	for y : 0 .. a.inner.height
		f[a.inner row y]

fold<a, b> a(acc a, a mut-grid b, f act a(a, b))
	acc fold a.elements, f

fold-with-coords<a, b> a(acc a, a mut-grid b, f act a(a, b, coord)) trusted
	acc fold-with-coords-recur a.elements.begin-ptr.as-const, a.elements.end-ptr.as-const, (), a.width, f
.fold-with-coords-recur<a, b> a(
	acc a,
	cur b*,
	end b*,
	coord coord,
	width nat64,
	f act a(a, b, coord),
) unsafe
	if cur == end
		acc
	else
		f[acc, *cur, coord] fold-with-coords-recur cur + 1, end, (coord next-coord width), width, f

exists<a> bool(a mut-grid a, f act bool(a))
	a.elements exists f

set-map<a> void(a mut-grid a, f act a(a))
	a.elements set-map f

set-map-with-coords<a> void(a mut-grid a, f act a(a, coord)) trusted
	a.elements.begin-ptr set-map-with-coords-recur a.elements.end-ptr, (), a.width, f
.set-map-with-coords-recur<a> void(cur a mut*, end a mut*, coord coord, width nat64, f act a(a, coord)) unsafe
	unless cur == end
		*cur := f[*cur, coord]
		cur + 1 set-map-with-coords-recur end, (coord next-coord width), width, f

.next-coord coord(a coord, width nat64)
	new-x = a.x + 1
	if new-x == width
		0, a.y + 1
	else
		new-x, a.y

test
	a mut-grid str = 3 make-mut-grid 2, (x, y) => "{x}|{y}"
	a.to-str is "0|0 1|0 2|0\n0|1 1|1 2|1"

	folded = "S" fold-with-coords a, (acc, value, coord) => "{acc} {value}/{coord}"
	folded is "S 0|0/<0, 0> 1|0/<1, 0> 2|0/<2, 0> 0|1/<0, 1> 1|1/<1, 1> 2|1/<2, 1>"
