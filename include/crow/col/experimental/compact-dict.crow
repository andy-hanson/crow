no-std
import
	../../bool: !, ==, bool, false, true
	../../compare: <=, compare, equal, max
	../../fun-util: subscript
	../../hash: hash-mix
	../../json: json
	../../misc: is-data, new, void
	../../number: ==, <=>, +, nat64
	../../option: ==, is-empty, new, option
	../../string: ==, ~~, join, literal, string, to-string
	../../test-util: is
	../../tuple: ==, from, new, pair, to
	../mut-array: ~=, build, mut-array, with-block
	../list: ==, ~=, build, for-loop, list, new, with-block
	../mut-set: in, mut-set, new, try-add
	../sort: sort
	./frozen-dict:
		for-loop, frozen-dict, in, is-empty, mut-array-to-frozen-dict-promise-no-duplicates, new,
		size, subscript, to-frozen-dict

compact-dict[k, v] record by-val
	ignore void
	impl (k, v) impl

==[k, v] bool(a (k, v) compact-dict, b (k, v) compact-dict) k is-data, k compare, k hash-mix, v equal
	a.to-sorted-pairs == b.to-sorted-pairs
.to-sorted-pairs[k, v] (k, v)[](a (k, v) compact-dict) k is-data, k compare, k hash-mix
	a.to-list sort pair => pair from

json[k, v] json(a (k, v) compact-dict) k is-data, k compare, k hash-mix, k json, v json
	a.to-sorted-pairs json

# TODO:KILL
node-count[k, v] nat64(a (k, v) compact-dict)
	0 node-count a.impl
.node-count[k, v] nat64(acc nat64, a (k, v) impl)
	match a
	as overlay o
		acc + 1 node-count o.prev
	as end-node _
		acc + 1

.impl[k, v] union
	overlay (k, v) overlay
	end-node (k, v) frozen-dict

.overlay[k, v] record by-ref
	pairs (k, v?) frozen-dict
	prev (k, v) impl

new[k, v] (k, v) compact-dict() k is-data, k compare, k hash-mix
	(), ().end-node

to-compact-dict[k, v] (k, v) compact-dict(a (k, v)[]) k is-data, k compare, k hash-mix
	(), a.to-frozen-dict.end-node

keys[k, v] k[](a (k, v) compact-dict) k is-data, k compare, k hash-mix
	for k, _ : a
		k

values[k, v] v[](a (k, v) compact-dict) k is-data, k compare, k hash-mix
	for _, v : a
		v

is-empty[k, v] bool(a (k, v) compact-dict) k is-data, k compare, k hash-mix
	match a impl
	as overlay _
		false
	as end-node e
		e is-empty

to-list[k, v] (k, v)[](a (k, v) compact-dict) k is-data, k compare, k hash-mix
	for k, v : a
		k, v

###
Number of pairs.
This is O(n).
###
size[k, v] nat64(a (k, v) compact-dict) k is-data, k compare, k hash-mix
	res mut = 0
	for _, _ : a
		res := res + 1
	res

~[k, v] (k, v) compact-dict(a (k, v) compact-dict, pair (k, v)) k is-data, k compare, k hash-mix
	a add-or-remove pair.from, (pair.to,)

###
TODO
~[k, v] (k, v) compact-dict(a (k, v) compact-dict, b (k, v) compact-dict) k is-data, k compare, k hash-mix
	a ~ b.arr
###

~~[k, v] (k, v) compact-dict(a (k, v) compact-dict, b (k, v)[]) k is-data, k compare, k hash-mix
	res mut = a
	for pair : b
		res := res ~ pair
	res

-[k, v] (k, v) compact-dict(a (k, v) compact-dict, key k) k is-data, k compare, k hash-mix
	if key in a
		a add-or-remove key, ()
	else
		a

subscript[k, v] v?(a (k, v) compact-dict, key k) k is-data, k compare, k hash-mix
	cur mut = a impl
	loop
		match cur
		as overlay o
			if res ?= o.pairs[key]
				break res
			else
				cur := o prev
				continue
		as end-node e
			break e[key]

in[k, v] bool(key k, a (k, v) compact-dict) k is-data, k compare, k hash-mix
	!a[key].is-empty

.add-or-remove[k, v] (k, v) compact-dict(a (k, v) compact-dict, key k, value v?) k is-data, k compare, k hash-mix
	(), ((((key, value),).to-frozen-dict, a.impl) merge-as-needed)

.merge-as-needed[k, v] (k, v) impl(a (k, v) overlay) k is-data, k compare, k hash-mix
	match a prev
	as overlay o
		if o.pairs.size should-merge a.pairs.size
			((o.pairs merge-overlays a.pairs), o.prev) merge-as-needed
		else
			a overlay
	as end-node e
		if e.size should-merge a.pairs.size
			e merge-to-end a.pairs end-node
		else
			a overlay

.should-merge bool(prev-size nat64, overlay-size nat64)
	prev-size <= (overlay-size max 3)

.merge-overlays[k, v] (k, v?) frozen-dict(
	l (k, v?) frozen-dict,
	r (k, v?) frozen-dict,
) trusted, k is-data, k compare, k hash-mix
	pairs (k, v?) mut-array = with out : l.size + r.size build
		for k, vl : l
			unless k in r
				out ~= (k, vl)
		for k, vr : r
			out ~= (k, vr)
	pairs mut-array-to-frozen-dict-promise-no-duplicates

.merge-to-end[k, v] (k, v) frozen-dict(
	l (k, v) frozen-dict,
	r (k, v?) frozen-dict,
) trusted, k is-data, k compare, k hash-mix
	pairs (k, v) mut-array = with out : l.size + r.size build
		for k, vl : l
			unless k in r
				out ~= (k, vl)
		for k, vr : r
			if v ?= vr
				out ~= (k, v)
	pairs mut-array-to-frozen-dict-promise-no-duplicates

region iteration

for-loop[k, v] void(a (k, v) compact-dict, f act void(k, v)) k is-data, k compare, k hash-mix
	cur mut = a impl
	seen k mut-set = ()
	loop
		match cur
		as overlay o
			for k, v-opt : o pairs
				if seen try-add k
					if v ?= v-opt
						f[k, v]
			cur := o prev
			continue
		as end-node e
			for k, v : e
				unless k in seen
					# Don't need to add to 'seen' because this is the last node.
					f[k, v]
			break

for-loop[a, k, v] a[](a (k, v) compact-dict, f act a(k, v)) trusted, k is-data, k compare, k hash-mix
	with out : a.size build
		for k, v : a
			out ~= f[k, v]

.dbg[k, v] string(a (k, v) compact-dict) k to-string, v to-string
	a.impl dbg
.dbg[k, v] string(a (k, v) impl) k to-string, v to-string
	match a
	as overlay o
		parts = ", " join for k, v : o pairs
			# TODO: v?.to-string ?? "_"
			v-str = if val ?= v
				"{val}"
			else
				"_"
			"{k} -> {v-str}"
		"{o.prev dbg}, [{parts}]"
	as end-node e
		parts = ", " join for k, v : e
			"{k} -> {v}"
		"[{parts}]"

verify void(a (nat64, string) compact-dict, expected string)
	a.dbg is expected
	for k, v : a
		a[k] is (v,)

test
	a (nat64, string) compact-dict = ()
	a.is-empty is true
	a.size is 0
	a verify "[]"
	a[0] is ()

	b = a ~ (10, "10")
	b.is-empty is false
	b.size is 1
	b verify "[10 -> 10]"
	b[10] is ("10",)

	c = b ~~ ((15, "15"), (5, "5"), (20, "20"))
	c verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20]"

	d = c ~ (11, "11")
	d verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _]"
	e[10] is ("10",)
	e[11] is ("11",)
	e[15] is ()

	e - 15 is e
	e - 16 is e

	f = e - 10
	f verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _, 10 -> _]"
	f[10] is ()
	10 in f is false

	g = f ~ (10, "10b")
	g verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _, 10 -> 10b]"

	h = g - 11 - 12
	h verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [15 -> _, 10 -> 10b, 11 -> _]"

	i = h ~~ ((11, "11"), (25, "25"))
	i verify "[10 -> 10b, 20 -> 20, 5 -> 5, 11 -> 11, 25 -> 25]"
