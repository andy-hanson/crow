no-std
import
	../../bool: !, ==, bool, false, true
	../../compare: <=, compare, max
	../../fun-util: subscript
	../../hash: hash-mix
	../../log: info, log
	../../misc: is-data, new, void
	../../number: ==, <=>, +, nat64
	../../option: ??, is-empty, new, option, option-equal
	../../pointer: ref-eq
	../../range: ..
	../../string: ==, ~~, join, literal, string, to-string
	../../test-util: is
	../../tuple: from, new, pair, pair-equal, to
	../array: array, every, for-loop, size, subscript
	../mut-array: ~=, build-mut-array, mut-array, with-block
	../list: ~=, build-list, for-loop, list, new, with-block
	../mut-set: in, mut-set, new, try-add
	./frozen-dict:
		for-loop, frozen-dict, in, is-empty, mut-array-to-frozen-dict-promise-no-duplicates, new,
		size, subscript, to-array, to-frozen-dict

compact-dict<k, v> record by-val
	ignore void
	impl impl<k, v>

# TODO:KILL
node-count<k, v> nat64(a compact-dict<k, v>)
	0 node-count a.impl
.node-count<k, v> nat64(acc nat64, a impl<k, v>)
	match a
	as overlay o
		acc + 1 node-count o.prev
	as end-node _
		acc + 1

.impl<k, v> union
	overlay overlay<k, v>
	end-node frozen-dict<k, v>

.overlay<k, v> record by-ref
	pairs frozen-dict<k, v?>
	prev impl<k, v>

new<k, v> compact-dict<k, v>() is-data<k> compare<k> hash-mix<k>
	(), ().end-node

compact-dict<k, v> compact-dict<k, v>(a (k, v)[]) is-data<k> compare<k> hash-mix<k>
	(), a.to-frozen-dict.end-node

keys<k, v> k[](a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	for k, _ : a
		k

values<k, v> v[](a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	for _, v : a
		v

is-empty<k, v> bool(a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	match a impl
	as overlay _
		false
	as end-node e
		e is-empty

###
Number of pairs.
This is O(n).
###

size<k, v> nat64(a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	res mut = 0
	for _, _ : a
		res := res + 1
	res

~ <k, v> compact-dict<k, v>(a compact-dict<k, v>, pair (k, v)) is-data<k> compare<k> hash-mix<k>
	a add-or-remove pair.from, (pair.to,)

###
TODO
~ <k, v> compact-dict<k, v>(a compact-dict<k, v>, b compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	a ~ b.arr
###

~~ <k, v> compact-dict<k, v>(a compact-dict<k, v>, b (k, v)[]) is-data<k> compare<k> hash-mix<k>
	res mut = a
	for pair : b
		res := res ~ pair
	res

- <k, v> compact-dict<k, v>(a compact-dict<k, v>, key k) is-data<k> compare<k> hash-mix<k>
	if key in a
		a add-or-remove key, ()
	else
		a

subscript<k, v> v?(a compact-dict<k, v>, key k) is-data<k> compare<k> hash-mix<k>
	a.impl subscript-recur key
.subscript-recur<k, v> v?(a impl<k, v>, key k) is-data<k> compare<k> hash-mix<k>
	match a
	as overlay o
		o.pairs[key] ?? o.prev subscript-recur key
	as end-node e
		e[key]

in<k, v> bool(key k, a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	!a[key].is-empty

.add-or-remove<k, v> compact-dict<k, v>(a compact-dict<k, v>, key k, value v?) is-data<k> compare<k> hash-mix<k>
	(), ((((key, value),).to-frozen-dict, a.impl) merge-as-needed)

.merge-as-needed<k, v> impl<k, v>(a overlay<k, v>) is-data<k> compare<k> hash-mix<k>
	match a prev
	as overlay o
		if o.pairs.size should-merge a.pairs.size
			((o.pairs merge-overlays a.pairs), o.prev) merge-as-needed
		else
			a overlay
	as end-node e
		if e.size should-merge a.pairs.size
			e merge-to-end a.pairs end-node
		else
			a overlay

.should-merge bool(prev-size nat64, overlay-size nat64)
	prev-size <= (overlay-size max 3)

.merge-overlays<k, v> frozen-dict<k, v?>(
	l frozen-dict<k, v?>,
	r frozen-dict<k, v?>,
) trusted is-data<k> compare<k> hash-mix<k>
	pairs mut-array (k, v?) = with out : l.size + r.size build-mut-array
		for k, vl : l
			unless k in r
				out ~= (k, vl)
		for k, vr : r
			out ~= (k, vr)
	pairs mut-array-to-frozen-dict-promise-no-duplicates

.merge-to-end<k, v> frozen-dict<k, v>(
	l frozen-dict<k, v>,
	r frozen-dict<k, v?>,
) trusted is-data<k> compare<k> hash-mix<k>
	pairs mut-array (k, v) = with out : l.size + r.size build-mut-array
		for k, vl : l
			unless k in r
				out ~= (k, vl)
		for k, vr : r
			if v ?= vr
				out ~= (k, v)
	pairs mut-array-to-frozen-dict-promise-no-duplicates

region iteration

for-loop<k, v> void(a compact-dict<k, v>, f act void(k, v)) is-data<k> compare<k> hash-mix<k>
	a.impl for-loop-recur (), f
.for-loop-recur<k, v> void(a impl<k, v>, seen mut-set k, f act void(k, v)) is-data<k> compare<k> hash-mix<k>
	match a
	as overlay o
		for k, v-opt : o pairs
			if seen try-add k
				if v ?= v-opt
					f[k, v]
		o.prev for-loop-recur seen, f
	as end-node e
		for k, v : e
			unless k in seen
				# Don't need to add to 'seen' because this is the last node.
				f[k, v]

for-loop<a, k, v> a[](a compact-dict<k, v>, f act a(k, v)) trusted is-data<k> compare<k> hash-mix<k>
	with out : a.size build-list
		for k, v : a
			out ~= f[k, v]

.dbg<k, v> string(a compact-dict<k, v>) to-string<k> to-string<v>
	a.impl dbg
.dbg<k, v> string(a impl<k, v>) to-string<k> to-string<v>
	match a
	as overlay o
		parts = ", " join for k, v : o pairs
			# TODO: v?.to-string ?? "_"
			v-str = if val ?= v
				"{val}"
			else
				"_"
			"{k} -> {v-str}"
		"{o.prev dbg}, [{parts}]"
	as end-node e
		parts = ", " join for k, v : e
			"{k} -> {v}"
		"[{parts}]"

verify void(a compact-dict<nat64, string>, expected string)
	dbg = a dbg
	unless dbg == expected
		info log "expected:"
		info log expected
		info log "but was:"
		info log dbg
	dbg is expected
	for k, v : a
		a[k] is (v,)

.== bool(a string?, b string?)
	a option-equal b

.exact-eq bool(a compact-dict<nat64, string>, b compact-dict<nat64, string>) unsafe
	match a impl
	as overlay oa
		match b impl
		as overlay ob
			oa ref-eq ob
		as end-node _
			false
	as end-node ea
		match b impl
		as overlay _
			false
		as end-node eb
			# TODO: ea.to-array::array<(nat64, string)> arr-equal@<(nat64, string)> eb.to-array::array<(nat64, string)>
			pa = ea to-array
			pb = eb to-array
			bs array bool = for i : 0 .. pa.size
				pa[i] pair-equal pb[i]
			bs every x => x

test
	a compact-dict<nat64, string> = ()
	a.is-empty is true
	a.size is 0
	a verify "[]"
	a[0] is ()

	b = a ~ (10, "10")
	b.is-empty is false
	b.size is 1
	b verify "[10 -> 10]"
	b[10] is ("10",)

	c = b ~~ ((15, "15"), (5, "5"), (20, "20"))
	c verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20]"

	d = c ~ (11, "11")
	d verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _]"
	e[10] is ("10",)
	e[11] is ("11",)
	e[15] is ()

	e - 15 exact-eq e is true
	e - 16 exact-eq e is true

	f = e - 10
	f verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _, 10 -> _]"
	f[10] is ()
	10 in f is false

	g = f ~ (10, "10b")
	g verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _, 10 -> 10b]"

	h = g - 11 - 12
	h verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [15 -> _, 10 -> 10b, 11 -> _]"

	i = h ~~ ((11, "11"), (25, "25"))
	i verify "[10 -> 10b, 20 -> 20, 5 -> 5, 11 -> 11, 25 -> 25]"
