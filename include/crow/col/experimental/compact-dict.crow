no-std
import
	../../bool: !, ==, bool, false, true
	../../compare: <=, compare, max
	../../fun-util: subscript
	../../hash: hash-mix
	../../log: info, log
	../../misc: is-data, new, void
	../../number: ==, <=>, +, nat64
	../../option: ??, is-empty, new, option, option-equal
	../../pointer: ==, +, ref-eq, set-deref
	../../range: ..
	../../string: ==, ~~, join, literal, string, to-string
	../../test-util: is
	../../tuple: from, new, pair, pair-equal, to
	../array: array, every, for-loop, size, subscript
	../mut-array:
		begin-pointer, cast-immutable, end-pointer, mut-array, mut-array-from-begin-end,
		uninitialized-mut-array
	../list: fold, list, new, to-list
	../mut-set: in, mut-set, new, try-add
	./frozen-dict:
		for-loop, frozen-dict, fold, in, is-empty, mut-array-to-frozen-dict-promise-no-duplicates,
		new, size, subscript, to-array, to-frozen-dict

compact-dict<k, v> record by-val
	ignore void
	impl impl<k, v>

# TODO:KILL
node-count<k, v> nat64(a compact-dict<k, v>)
	0 node-count a.impl
.node-count<k, v> nat64(acc nat64, a impl<k, v>)
	match a
	as overlay o
		acc + 1 node-count o.prev
	as end-node _
		acc + 1

.impl<k, v> union
	overlay overlay<k, v>
	end-node frozen-dict<k, v>

.overlay<k, v> record by-ref
	pairs frozen-dict<k, v?>
	prev impl<k, v>

new<k, v> compact-dict<k, v>() is-data<k> compare<k> hash-mix<k>
	(), ().end-node

compact-dict<k, v> compact-dict<k, v>(a (k, v)[]) is-data<k> compare<k> hash-mix<k>
	(), a.to-frozen-dict.end-node

keys<k, v> k[](a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	for k, _ : a
		k

values<k, v> v[](a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	for _, v : a
		v

is-empty<k, v> bool(a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	match a impl
	as overlay _
		false
	as end-node e
		e is-empty

###
Number of pairs.
This is O(n).
###

size<k, v> nat64(a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	0 fold a, (acc, _, _) => acc + 1

~ <k, v> compact-dict<k, v>(a compact-dict<k, v>, pair (k, v)) is-data<k> compare<k> hash-mix<k>
	a add-or-remove pair.from, (pair.to,)

###
TODO
~ <k, v> compact-dict<k, v>(a compact-dict<k, v>, b compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	a ~ b.arr
###

~~ <k, v> compact-dict<k, v>(a compact-dict<k, v>, b (k, v)[]) is-data<k> compare<k> hash-mix<k>
	a fold b, (cur, pair) => cur ~ pair

- <k, v> compact-dict<k, v>(a compact-dict<k, v>, key k) is-data<k> compare<k> hash-mix<k>
	if key in a
		a add-or-remove key, ()
	else
		a

subscript<k, v> v?(a compact-dict<k, v>, key k) is-data<k> compare<k> hash-mix<k>
	a.impl subscript-recur key
.subscript-recur<k, v> v?(a impl<k, v>, key k) is-data<k> compare<k> hash-mix<k>
	match a
	as overlay o
		o.pairs[key] ?? o.prev subscript-recur key
	as end-node e
		e[key]

in<k, v> bool(key k, a compact-dict<k, v>) is-data<k> compare<k> hash-mix<k>
	!a[key].is-empty

.add-or-remove<k, v> compact-dict<k, v>(a compact-dict<k, v>, key k, value v?) is-data<k> compare<k> hash-mix<k>
	(), ((((key, value),).to-frozen-dict, a.impl) merge-as-needed)

.merge-as-needed<k, v> impl<k, v>(a overlay<k, v>) is-data<k> compare<k> hash-mix<k>
	match a prev
	as overlay o
		if o.pairs.size should-merge a.pairs.size
			((o.pairs merge-overlays a.pairs), o.prev) merge-as-needed
		else
			a overlay
	as end-node e
		if e.size should-merge a.pairs.size
			e merge-to-end a.pairs end-node
		else
			a overlay

.should-merge bool(prev-size nat64, overlay-size nat64)
	prev-size <= (overlay-size max 3)

.merge-overlays<k, v> frozen-dict<k, v?>(
	l frozen-dict<k, v?>,
	r frozen-dict<k, v?>,
) trusted is-data<k> compare<k> hash-mix<k>
	res mut-array (k, v?) = l.size + r.size uninitialized-mut-array
	begin = res begin-pointer
	mid = begin fold l, (cur, k, vl) =>
		if k in r
			cur
		else
			*cur := k, vl
			cur + 1
	end = mid fold r, (cur, k, vr) =>
		*cur := k, vr
		cur + 1
	begin mut-array-from-begin-end end mut-array-to-frozen-dict-promise-no-duplicates

.merge-to-end<k, v> frozen-dict<k, v>(
	l frozen-dict<k, v>,
	r frozen-dict<k, v?>,
) trusted is-data<k> compare<k> hash-mix<k>
	res mut-array (k, v) = l.size + r.size uninitialized-mut-array
	begin = res begin-pointer
	mid = begin fold l, (cur, k, vl) =>
		if k in r
			cur
		else
			*cur := k, vl
			cur + 1
	end = mid fold r, (cur, k, vr) =>
		if v ?= vr
			*cur := k, v
			cur + 1
		else
			cur
	begin mut-array-from-begin-end end mut-array-to-frozen-dict-promise-no-duplicates

region iteration

fold<a, k, v> a(acc a, a compact-dict<k, v>, f act a(a, k, v)) is-data<k> compare<k> hash-mix<k>
	acc fold-recur a.impl, (), f
.fold-recur<a, k, v> a(acc a, a impl<k, v>, seen mut-set k, f act a(a, k, v)) is-data<k> compare<k> hash-mix<k>
	match a
	as overlay o
		mid = acc fold o.pairs, (cur, k, v-opt) =>
			if seen try-add k
				if v ?= v-opt
					f[cur, k, v]
				else
					cur
			else
				cur
		mid fold-recur o.prev, seen, f
	as end-node e
		acc fold e, (cur, k, v) =>
			if k in seen
				cur
			else
				# Don't need to add to 'seen' because this is the last node.
				f[cur, k, v]

for-loop<k, v> void(a compact-dict<k, v>, f act void(k, v)) is-data<k> compare<k> hash-mix<k>
	() fold a, (_, k, v) =>
		f[k, v]

for-loop<a, k, v> a[](a compact-dict<k, v>, f act a(k, v)) trusted is-data<k> compare<k> hash-mix<k>
	res mut-array a = a.size uninitialized-mut-array
	end = res.begin-pointer fold a, (cur, k, v) =>
		*cur := f[k, v]
		cur + 1
	assert end == res.end-pointer
	res.cast-immutable to-list

.dbg<k, v> string(a compact-dict<k, v>) to-string<k> to-string<v>
	a.impl dbg
.dbg<k, v> string(a impl<k, v>) to-string<k> to-string<v>
	match a
	as overlay o
		parts = ", " join for k, v : o pairs
			# TODO: v?.to-string ?? "_"
			v-str = if val ?= v
				"{val}"
			else
				"_"
			"{k} -> {v-str}"
		"{o.prev dbg}, [{parts}]"
	as end-node e
		parts = ", " join for k, v : e
			"{k} -> {v}"
		"[{parts}]"

verify void(a compact-dict<nat64, string>, expected string)
	dbg = a dbg
	unless dbg == expected
		info log "expected:"
		info log expected
		info log "but was:"
		info log dbg
	dbg is expected
	for k, v : a
		a[k] is (v,)

.== bool(a string?, b string?)
	a option-equal b

.exact-eq bool(a compact-dict<nat64, string>, b compact-dict<nat64, string>) unsafe
	match a impl
	as overlay oa
		match b impl
		as overlay ob
			oa ref-eq ob
		as end-node _
			false
	as end-node ea
		match b impl
		as overlay _
			false
		as end-node eb
			# TODO: ea.to-array::array<(nat64, string)> arr-equal@<(nat64, string)> eb.to-array::array<(nat64, string)>
			pa = ea to-array
			pb = eb to-array
			bs array bool = for i : 0 .. pa.size
				pa[i] pair-equal pb[i]
			bs every x => x

test
	a compact-dict<nat64, string> = ()
	a.is-empty is true
	a.size is 0
	a verify "[]"
	a[0] is ()

	b = a ~ (10, "10")
	b.is-empty is false
	b.size is 1
	b verify "[10 -> 10]"
	b[10] is ("10",)

	c = b ~~ ((15, "15"), (5, "5"), (20, "20"))
	c verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20]"

	d = c ~ (11, "11")
	d verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _]"
	e[10] is ("10",)
	e[11] is ("11",)
	e[15] is ()

	e - 15 exact-eq e is true
	e - 16 exact-eq e is true

	f = e - 10
	f verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _, 10 -> _]"
	f[10] is ()
	10 in f is false

	g = f ~ (10, "10b")
	g verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [11 -> 11, 15 -> _, 10 -> 10b]"

	h = g - 11 - 12
	h verify "[10 -> 10, 15 -> 15, 5 -> 5, 20 -> 20], [15 -> _, 10 -> 10b, 11 -> _]"

	i = h ~~ ((11, "11"), (25, "25"))
	i verify "[10 -> 10b, 20 -> 20, 5 -> 5, 11 -> 11, 25 -> 25]"
