no-std
import
	../../bool: &&, bool
	../../compare: <=, compare
	../../fun-util: subscript
	../../hash: hash, hash-mix
	../../misc: is-data, new, void
	../../number: ==, <=>, +, -, /, %, nat64
	../../option: new, option
	../../pointer: ==, <=>, +, -, *, const-pointer, mut-pointer, swap
	../../range: ..
	../array:
		~=, array, array-cast, as-array, begin-pointer, build-array, end-pointer, for-loop, in, index-of, is-empty, new,
		pointer-of, size, subscript, with-block
	../mut-array:
		~=, begin-pointer, build-mut-array, cast-immutable, end-pointer, fill, fill-mut-array,
		mut-array, mut-array-builder, for-loop, size, temp-as-array, to-mut-array, set-subscript,
		subscript, with-block
	../list: for-loop, list, to-array, to-list

frozen-set<a> record
	.values array a
	# These are pointers into 'values', so it's fine that 'pointer' isn't GC traced.
	.bucket-starts array a*

dbg-bucket-starts<a> nat64[](a frozen-set a) unsafe no-doc
	for pointer : a.bucket-starts to-list
		pointer - a.values.begin-pointer

new<a> frozen-set a(...a array a) is-data<a> compare<a> hash-mix<a>
	a.to-list to-frozen-set

to-frozen-set<a> frozen-set a(a a[]) trusted is-data<a> compare<a> hash-mix<a>
	a.to-array.to-mut-array unsafe-frozen-set-from-mut-array-cast-immutable

# This is O(1).
to-list<a> a[](a frozen-set a)
	a.values to-list

is-empty<a> bool(a frozen-set a)
	a.values is-empty

size<a> nat64(a frozen-set a)
	a.values size

in<a> bool(value a, a frozen-set a) is-data<a> compare<a> hash-mix<a>
	value in (a bucket-for value)

.bucket-for<a> array a(a frozen-set a, value a) trusted is-data<a> compare<a> hash-mix<a>
	if a.bucket-starts is-empty
		a values
	else
		bucket-index = value.hash % a.bucket-starts.size
		bucket-start = a.bucket-starts[bucket-index]
		bucket-end = if bucket-index == a.bucket-starts.size - 1
			a.values end-pointer
		else
			a.bucket-starts[bucket-index + 1]
		bucket-start .. bucket-end as-array

# TODO: no-doc
# WARN: The order of values is arbitrary,
# but consistent for *identical* (not ==) sets.
try-get-unordered-index<a> nat64?(a frozen-set a, value a) trusted is-data<a> compare<a> hash-mix<a>
	if a.bucket-starts is-empty
		a.values index-of value
	else
		bucket-index = value.hash % a.bucket-starts.size
		bucket-start = a.bucket-starts[bucket-index]
		bucket-end = if bucket-index == a.bucket-starts.size - 1
			a.values end-pointer
		else
			a.bucket-starts[bucket-index + 1]
		if pointer ?= (bucket-start .. bucket-end).as-array pointer-of value
			pointer - a.values.begin-pointer,

.unsafe-frozen-set-from-mut-array-cast-immutable<a> frozen-set a(
	a mut-array a,
) unsafe is-data<a> compare<a> hash-mix<a>
	if a.size <= 4
		a.cast-immutable, ()
	else
		n-buckets = a.size / 2
		bucket-counts = a get-bucket-counts n-buckets
		bucket-starts = a.begin-pointer running-sum bucket-counts.temp-as-array
		bucket-counts fill 0
		cur mut = a begin-pointer
		until cur == a.end-pointer
			bucket-index = *cur get-bucket-index bucket-counts.size
			bucket-count = bucket-counts[bucket-index]
			bucket-start = bucket-starts[bucket-index]
			bucket-cur-end = bucket-start + bucket-count
			if bucket-start <= cur && cur <= bucket-cur-end
				if cur == bucket-cur-end
					bucket-counts[bucket-index] := bucket-count + 1
				cur := cur + 1
			else
				bucket-counts[bucket-index] := bucket-count + 1
				cur swap bucket-cur-end
		a.cast-immutable, bucket-starts.array-cast

.get-bucket-counts<a> mut-array nat64(a mut-array a, n-buckets nat64) unsafe hash-mix<a>
	res = n-buckets fill-mut-array 0
	for value : a
		bucket-index = value get-bucket-index n-buckets
		res[bucket-index] := res[bucket-index] + 1
	res

.get-bucket-index<a> nat64(value a, n-buckets nat64) unsafe hash-mix<a>
	value.hash % n-buckets

.running-sum<a> array a mut*(initial a mut*, offsets array nat64) trusted
	with out : offsets.size build-array
		acc mut = initial
		for offset : offsets
			out ~= acc
			acc := acc + offset

region builder

build-frozen-set record
	.size-hint nat64
build-frozen-set build-frozen-set()
	0,
build-frozen-set build-frozen-set(size-hint nat64)
	size-hint,

frozen-set-builder<a> record mut
	.inner mut-array-builder a

with-block<a> frozen-set a(
	a build-frozen-set,
	f act void(frozen-set-builder a),
) trusted is-data<a> compare<a> hash-mix<a>
	inner mut-array a = with out : a.size-hint build-mut-array
		f[(out,)]
	inner unsafe-frozen-set-from-mut-array-cast-immutable

~= <a> void(a frozen-set-builder a, value a)
	a.inner ~= value

size<a> nat64(a frozen-set-builder a)
	a.inner size

region iteration

for-loop<a> void(a frozen-set a, f act void(a))
	a.values for-loop f
for-loop<a> void(a frozen-set a, f act void(a, nat64))
	a.values for-loop f
for-loop<out, in> out[](a frozen-set in, f act out(in)) trusted
	a.values for-loop f to-list
