no-std
import
	../../bool: &&, ==, bool, false, true
	../../cell: *, cell, new, set-deref
	../../compare: <=, compare
	../../fun-util: subscript
	../../hash: hash, hash-mix
	../../misc: is-data, new, void
	../../number: ==, <=>, +, -, /, %, nat64
	../../opt: new, opt
	../../ptr: ==, <=>, +, -, *, const-ptr, mut-ptr, set-deref, swap
	../../test-util: is
	../array: array, is-empty, new, size, subscript
	../array-util: fold, fold-with-index, in, index-of, ptr-of
	../mut-array:
		begin-ptr, cast-immutable, end-ptr, fill, fill-mut-array, mut-array, for-loop,
		size, temp-as-array, to-mut-array, set-subscript, subscript, uninitialized-mut-array
	../list: ==, for-loop, list, new, to-array, to-list
	../private/array-low-level: array-cast, array-from-begin-end, begin-ptr, end-ptr

frozen-set<a> record
	.values array a
	# These are pointers into 'values', so it's fine that 'ptr' isn't GC traced.
	.bucket-starts array a*

new<a> frozen-set a(...a array a) is-data<a> compare<a> hash-mix<a>
	a.to-list to-frozen-set

to-frozen-set<a> frozen-set a(a a[]) trusted is-data<a> compare<a> hash-mix<a>
	a.to-array.to-mut-array unsafe-frozen-set-from-mut-array-cast-immutable

# This is O(1).
to-list<a> a[](a frozen-set a)
	a.values to-list

begin-ptr<a> a*(a frozen-set a) no-doc unsafe
	a.values begin-ptr

end-ptr<a> a*(a frozen-set a) no-doc unsafe
	a.values end-ptr

is-empty<a> bool(a frozen-set a)
	a.values is-empty

size<a> nat64(a frozen-set a)
	a.values size

in<a> bool(value a, a frozen-set a) is-data<a> compare<a> hash-mix<a>
	value in (a bucket-for value)

.bucket-for<a> array a(a frozen-set a, value a) trusted is-data<a> compare<a> hash-mix<a>
	if a.bucket-starts is-empty
		a values
	else
		bucket-index = value.hash % a.bucket-starts.size
		bucket-start = a.bucket-starts[bucket-index]
		bucket-end = if bucket-index == a.bucket-starts.size - 1
			a.values end-ptr
		else
			a.bucket-starts[bucket-index + 1]
		bucket-start array-from-begin-end bucket-end

# TODO: no-doc
# WARN: The order of values is arbitrary,
# but consistent for *identical* (not ==) sets.
try-get-unordered-index<a> nat64?(a frozen-set a, value a) trusted is-data<a> compare<a> hash-mix<a>
	if a.bucket-starts is-empty
		a.values index-of value
	else
		bucket-index = value.hash % a.bucket-starts.size
		bucket-start = a.bucket-starts[bucket-index]
		bucket-end = if bucket-index == a.bucket-starts.size - 1
			a.values end-ptr
		else
			a.bucket-starts[bucket-index + 1]
		if ptr ?= bucket-start array-from-begin-end bucket-end ptr-of value
			ptr - a.begin-ptr,

unsafe-frozen-set-from-mut-array-cast-immutable<a> frozen-set a(
	a mut-array a,
) unsafe is-data<a> compare<a> hash-mix<a>
	if a.size <= 4
		a.cast-immutable, ()
	else
		n-buckets = a.size / 2
		bucket-counts = a get-bucket-counts n-buckets
		bucket-starts = a.begin-ptr running-sum bucket-counts.temp-as-array
		bucket-counts fill 0
		a.begin-ptr move-values-to-buckets-recur a.end-ptr, bucket-counts, bucket-starts
		a.cast-immutable, bucket-starts.array-cast

.get-bucket-counts<a> mut-array nat64(a mut-array a, n-buckets nat64) unsafe hash-mix<a>
	res = n-buckets fill-mut-array 0
	for value : a
		bucket-index = value get-bucket-index n-buckets
		res[bucket-index] := res[bucket-index] + 1
	res

.move-values-to-buckets-recur<a> void(
	cur a mut*,
	end a mut*,
	bucket-counts mut-array nat64,
	bucket-starts array a mut*,
) unsafe hash-mix<a>
	unless cur == end
		bucket-index = *cur get-bucket-index bucket-counts.size
		bucket-count = bucket-counts[bucket-index]
		bucket-start = bucket-starts[bucket-index]
		bucket-cur-end = bucket-start + bucket-count
		new-cur = if bucket-start <= cur && cur <= bucket-cur-end
			if cur == bucket-cur-end
				bucket-counts[bucket-index] := bucket-count + 1
			cur + 1
		else
			bucket-counts[bucket-index] := bucket-count + 1
			cur swap bucket-cur-end
			cur
		new-cur move-values-to-buckets-recur end, bucket-counts, bucket-starts

.get-bucket-index<a> nat64(value a, n-buckets nat64) unsafe hash-mix<a>
	value.hash % n-buckets

.running-sum<a> array a mut*(acc a mut*, a array nat64) trusted
	out mut-array a mut* = a.size uninitialized-mut-array
	acc running-sum-recur out.begin-ptr, out.end-ptr, a.begin-ptr
	out cast-immutable
.running-sum-recur<a> void(
	acc a mut*,
	out a mut* mut*,
	out-end a mut* mut*,
	read nat64*,
) unsafe
	*out := acc
	unless out + 1 == out-end
		acc + *read running-sum-recur out + 1, out-end, read + 1

region iteration

for-loop<a> void(a frozen-set a, f act void(a))
	() fold a, (_, x) =>
		f[x]

for-loop<out, in> out[](a frozen-set in, f act out(in)) trusted
	res mut-array out = a.size uninitialized-mut-array
	out cell out mut* = res.begin-ptr,
	for x : a
		*(*out) := f[x]
		*out := *out + 1
	assert *out == res.end-ptr
	res.cast-immutable to-list

fold<a, b> a(acc a, a frozen-set b, f act a(a, b))
	acc fold a.values, f

fold-with-index<a, b> a(acc a, a frozen-set b, f act a(a, b, nat64))
	acc fold-with-index a.values, f

.verify void(a frozen-set nat64, values nat64[], bucket-starts nat64[]) unsafe
	a.values.to-list is values
	(for ptr : a.bucket-starts to-list; ptr - a.values.begin-ptr)::nat64[] is bucket-starts

test
	a frozen-set nat64 = ()
	a.is-empty is true
	a.size is 0
	a verify (), ()
	0 in a is false

	b frozen-set nat64 = 3, 1, 5, 2
	b verify (3, 1, 5, 2), ()
	0 in b is false
	1 in b is true
	2 in b is true
	3 in b is true
	4 in b is false
	5 in b is true
	6 in b is false

	c frozen-set nat64 = 3, 1, 5, 2, 8
	c verify (2, 8, 3, 5, 1), (0, 2)
	0 in c is false
	1 in c is true
	2 in c is true
	3 in c is true
	4 in c is false
	5 in c is true
	6 in c is false
	7 in c is false
	8 in c is true
	9 in c is false
