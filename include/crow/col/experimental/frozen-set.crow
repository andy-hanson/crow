no-std
import
	../../bool: &&, bool
	../../compare: <=
	../../fun-util: subscript
	../../hash: hash
	../../misc: key, new, void
	../../number: ==, <=>, +, -, /, %, nat64
	../../option: new, option
	../../pointer: ==, <=>, +, -, *, const-pointer, mut-pointer, swap
	../../range: ..
	../array:
		~=, array, array-cast, as-array, begin-pointer, build, end-pointer, for-loop, in, index-of,
		is-empty, new, pointer-of, size, subscript, with-block
	../mut-array:
		~=, begin-pointer, build, cast-immutable, end-pointer, fill, fill-mut-array, mut-array,
		mut-array-builder, for-loop, size, temp-as-array, to-mut-array, set-subscript, subscript,
		with-block
	../list: for-loop, list, to-array, to-list

frozen-set[t] record
	.values t array
	# These are pointers into 'values', so it's fine that 'pointer' isn't GC traced.
	.bucket-starts t* array

dbg-bucket-starts[t] nat64[](a t frozen-set) no-doc, unsafe
	for pointer : a.bucket-starts to-list
		pointer - a.values.begin-pointer

new[t] t frozen-set(...a t array) t key
	a.to-list to-frozen-set

to-frozen-set[t] t frozen-set(a t[]) t key
	trusted a.to-array.to-mut-array unsafe-frozen-set-from-mut-array-cast-immutable

# This is O(1).
to-list[t] t[](a t frozen-set)
	a.values to-list

is-empty[t] bool(a t frozen-set)
	a.values is-empty

size[t] nat64(a t frozen-set)
	a.values size

in[t] bool(value t, a t frozen-set) t key
	value in (a bucket-for value)

.bucket-for[t] t array(a t frozen-set, value t) t key
	if a.bucket-starts is-empty
		a values
	else
		bucket-index = value.hash % a.bucket-starts.size
		bucket-start = a.bucket-starts[bucket-index]
		bucket-end = if bucket-index == a.bucket-starts.size - 1
			trusted a.values end-pointer
		else
			a.bucket-starts[bucket-index + 1]
		trusted bucket-start .. bucket-end as-array

# TODO: no-doc
# WARN: The order of values is arbitrary,
# but consistent for *identical* (not ==) sets.
try-get-unordered-index[t] nat64?(a t frozen-set, value t) t key
	if a.bucket-starts is-empty
		a.values index-of value
	else
		bucket-index = value.hash % a.bucket-starts.size
		bucket-start = a.bucket-starts[bucket-index]
		bucket-end = if bucket-index == a.bucket-starts.size - 1
			trusted a.values end-pointer
		else
			a.bucket-starts[bucket-index + 1]
		trusted if pointer ?= (bucket-start .. bucket-end).as-array pointer-of value
			pointer - a.values.begin-pointer,

.unsafe-frozen-set-from-mut-array-cast-immutable[t] t frozen-set(
	a t mut-array,
) unsafe, t key
	if a.size <= 4
		a.cast-immutable, ()
	else
		n-buckets = a.size / 2
		bucket-counts = a get-bucket-counts n-buckets
		bucket-starts = a.begin-pointer running-sum bucket-counts.temp-as-array
		bucket-counts fill 0
		cur mut = a begin-pointer
		until cur == a.end-pointer
			bucket-index = *cur get-bucket-index bucket-counts.size
			bucket-count = bucket-counts[bucket-index]
			bucket-start = bucket-starts[bucket-index]
			bucket-cur-end = bucket-start + bucket-count
			if bucket-start <= cur && cur <= bucket-cur-end
				if cur == bucket-cur-end
					bucket-counts[bucket-index] := bucket-count + 1
				cur := cur + 1
			else
				bucket-counts[bucket-index] := bucket-count + 1
				cur swap bucket-cur-end
		a.cast-immutable, bucket-starts.array-cast

.get-bucket-counts[t] nat64 mut-array(a t mut-array, n-buckets nat64) unsafe, t key
	res = n-buckets fill-mut-array 0
	for value : a
		bucket-index = value get-bucket-index n-buckets
		res[bucket-index] := res[bucket-index] + 1
	res

.get-bucket-index[t] nat64(value t, n-buckets nat64) unsafe, t key
	value.hash % n-buckets

.running-sum[t] t mut* array(initial t mut*, offsets nat64 array)
	with out : offsets.size build
		acc mut = initial
		for offset : offsets
			out ~= acc
			acc := trusted acc + offset

region builder

build-frozen-set record
	.size-hint nat64
build build-frozen-set()
	0,
build build-frozen-set(size-hint nat64)
	size-hint,

frozen-set-builder[t] record mut
	.inner t mut-array-builder

with-block[t] t frozen-set(
	a build-frozen-set,
	f act void(t frozen-set-builder),
) t key
	trusted (with out : a.size-hint build; f[(out,)]) unsafe-frozen-set-from-mut-array-cast-immutable

~=[t] void(a t frozen-set-builder, value t)
	a.inner ~= value

size[t] nat64(a t frozen-set-builder)
	a.inner size

region iteration

for-loop[t] void(a t frozen-set, f act void(t))
	a.values for-loop f
for-loop[t] void(a t frozen-set, f act void(nat64, t))
	a.values for-loop f
for-loop[out, in] out[](a in frozen-set, f act out(in))
	a.values for-loop f to-list
