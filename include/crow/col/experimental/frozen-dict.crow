no-std
import
	../../bool: !, &&, ==, bool, false, true
	../../compare: <=, compare, equal
	../../fun-util: subscript
	../../hash: hash, hash-mix
	../../misc: is-data, new, void
	../../number: ==, <=>, +, -, /, %, nat64
	../../option: is-empty, new, option, option-equal
	../../pointer: ==, <=>, +, -, *, const-pointer, mut-pointer, set-deref, swap
	../../range: ..
	../../string: ==, literal, string
	../../test-util: is
	../../tuple: from, new, pair, to
	../../private/alloc: alloc-uninitialized
	../array:
		array, array-cast, as-array, begin-pointer, end-pointer, fold, for-loop, is-empty, new,
		size, subscript
	../mut-array:
		as-mut-array, begin-pointer, cast-immutable, end-pointer, fill, fill-mut-array, mut-array,
		for-loop, size, temp-as-array, to-mut-array, set-subscript, subscript, uninitialized-mut-array
	../list: ==, for-loop, list, new, to-array, to-list

###
Immutable dictionary that is not efficient to update.
However, this is more compact than `dict` and has faster lookups.
###
frozen-dict<k, v> record by-val
	.pairs array (k, v)
	.bucket-starts array (k, v)*

new<k, v> frozen-dict<k, v>(...a array (k, v)) is-data<k> compare<k> hash-mix<k>
	a.to-list to-frozen-dict

to-frozen-dict<k, v> frozen-dict<k, v>(a (k, v)[]) trusted is-data<k> compare<k> hash-mix<k>
	a.to-array.to-mut-array.mut-array-to-frozen-dict-promise-no-duplicates remove-duplicates

# This is O(1).
to-array<k, v> array<(k, v)>(a frozen-dict<k, v>) noctx
	a pairs

# This is O(1).
to-list<k, v> (k, v)[](a frozen-dict<k, v>) noctx
	a.to-array to-list

# TODO:INTERNAL
begin-pointer<k, v> (k, v)*(a frozen-dict<k, v>) unsafe
	a.pairs begin-pointer

end-pointer<k, v> (k, v)*(a frozen-dict<k, v>) unsafe
	a.pairs end-pointer

is-empty<k, v> bool(a frozen-dict<k, v>)
	a.pairs is-empty

size<k, v> nat64(a frozen-dict<k, v>)
	a.pairs size

subscript<k, v> v?(a frozen-dict<k, v>, key k) trusted is-data<k> compare<k> hash-mix<k>
	if pointer ?= a find-pointer key
		pointer->to,

in<k, v> bool(key k, a frozen-dict<k, v>) trusted is-data<k> compare<k> hash-mix<k>
	!(a find-pointer key is-empty)

# TODO:INTERNAL
try-get-unordered-index<k, v> nat64?(a frozen-dict<k, v>, key k) trusted is-data<k> compare<k> hash-mix<k>
	if pointer ?= a find-pointer key
		pointer - a.pairs.begin-pointer,

.find-pointer<k, v> (k, v)*?(a frozen-dict<k, v>, key k) unsafe is-data<k> compare<k> hash-mix<k>
	bucket = if a.bucket-starts is-empty
		a pairs
	else
		bucket-index = key.hash % a.bucket-starts.size
		bucket-start = a.bucket-starts[bucket-index]
		bucket-end = if bucket-index == a.bucket-starts.size - 1
			a.pairs end-pointer
		else
			a.bucket-starts[bucket-index + 1]
		bucket-start .. bucket-end as-array

	bucket.begin-pointer find-pointer bucket.end-pointer, key

find-index<k, v> nat64?(pairs array (k, v), key k) unsafe is-data<k> compare<k> hash-mix<k>
	if pointer ?= pairs.begin-pointer find-pointer pairs.end-pointer, key
		pointer - pairs.begin-pointer,

find-pointer<k, v> (k, v)*?(cur (k, v)*, end (k, v)*, key k) unsafe is-data<k> compare<k> hash-mix<k>
	if cur == end
		()
	elif cur->from == key
		cur,
	else
		cur + 1 find-pointer end, key

mut-array-to-frozen-dict-promise-no-duplicates<k, v> frozen-dict<k, v>(
	a mut-array (k, v),
) no-doc unsafe is-data<k> compare<k> hash-mix<k>
	if a.size <= 4
		a.cast-immutable, ()
	else
		n-buckets = a.size / 2
		bucket-counts = a get-bucket-counts n-buckets
		bucket-starts = a.begin-pointer running-sum bucket-counts.temp-as-array
		bucket-counts fill 0
		a.begin-pointer move-values-to-buckets-recur a.end-pointer, bucket-counts, bucket-starts
		a.cast-immutable, bucket-starts.array-cast

.remove-duplicates<k, v> frozen-dict<k, v>(
	a frozen-dict<k, v>,
) unsafe is-data<k> compare<k> hash-mix<k>
	if a has-duplicates
		# Write out pairs from each bucket to a mut-array, omitting a pair if its key appears later in the same bucket.
		# Then call mut-array-to-frozen-dict-promise-no-duplicates 
		out-pairs (k, v) mut* = a.size alloc-uninitialized
		end = out-pairs write-without-duplicates a
		(out-pairs .. end).as-mut-array mut-array-to-frozen-dict-promise-no-duplicates
	else
		a

.write-without-duplicates<k, v> (k, v) mut*(out (k, v) mut*, a frozen-dict<k, v>) trusted equal<k>
	if a.bucket-starts is-empty
		out write-bucket-without-duplicates a.pairs.begin-pointer, a.pairs.end-pointer
	else
		cur = *a.bucket-starts.begin-pointer
		next = a.bucket-starts.begin-pointer + 1
		out write-without-duplicates-recur cur, next, a.bucket-starts.end-pointer, a.pairs.end-pointer
.write-without-duplicates-recur<k, v> (k, v) mut*(
	out (k, v) mut*,
	cur-bucket-start (k, v)*,
	next-bucket (k, v)**,
	end-buckets (k, v)**,
	last-bucket-end (k, v)*,
) unsafe equal<k>
	if next-bucket == end-buckets
		out write-bucket-without-duplicates cur-bucket-start, last-bucket-end
	else
		mid = out write-bucket-without-duplicates cur-bucket-start, *next-bucket
		mid write-without-duplicates-recur *next-bucket, next-bucket + 1, end-buckets, last-bucket-end

.write-bucket-without-duplicates<k, v> (k, v) mut*(
	out (k, v) mut*,
	begin (k, v)*,
	end (k, v)*,
) unsafe equal<k>
	if begin == end
		out
	else
		mid = if begin->from key-in-range begin + 1, end
			out
		else
			*out := *begin
			out + 1
		mid write-bucket-without-duplicates begin + 1, end

.has-duplicates<k, v> bool(a frozen-dict<k, v>) trusted equal<k>
	if a.bucket-starts is-empty
		a.pairs.begin-pointer bucket-has-duplicates a.pairs.end-pointer
	else
		cur = *a.bucket-starts.begin-pointer
		next = a.bucket-starts.begin-pointer + 1
		cur has-duplicates-recur next, a.bucket-starts.end-pointer, a.pairs.end-pointer
.has-duplicates-recur<k, v> bool(
	cur-bucket-start (k, v)*,
	next-bucket (k, v)**,
	end-buckets (k, v)**,
	last-bucket-end (k, v)*,
) unsafe equal<k>
	if next-bucket == end-buckets
		cur-bucket-start bucket-has-duplicates last-bucket-end
	elif cur-bucket-start bucket-has-duplicates *next-bucket
		true
	else
		*next-bucket has-duplicates-recur next-bucket + 1, end-buckets, last-bucket-end

.bucket-has-duplicates<k, v> bool(begin (k, v)*, end (k, v)*) unsafe equal<k>
	if begin == end
		false
	elif begin->from key-in-range begin + 1, end
		true
	else
		begin + 1 bucket-has-duplicates end

.key-in-range<k, v> bool(key k, begin (k, v)*, end (k, v)*) unsafe equal<k>
	if begin == end
		false
	elif key == begin->from
		true
	else
		key key-in-range begin + 1, end

.get-bucket-counts<k, v> mut-array nat64(a mut-array (k, v), n-buckets nat64) unsafe hash-mix<k>
	res = n-buckets fill-mut-array 0
	for pair : a
		bucket-index = pair.from get-bucket-index n-buckets
		res[bucket-index] := res[bucket-index] + 1
	res

.move-values-to-buckets-recur<k, v> void(
	cur (k, v) mut*,
	end (k, v) mut*,
	bucket-counts mut-array nat64,
	bucket-starts array (k, v) mut*,
) unsafe hash-mix<k>
	unless cur == end
		bucket-index = cur->from get-bucket-index bucket-counts.size
		bucket-count = bucket-counts[bucket-index]
		bucket-start = bucket-starts[bucket-index]
		bucket-cur-end = bucket-start + bucket-count
		new-cur = if bucket-start <= cur && cur <= bucket-cur-end
			if cur == bucket-cur-end
				bucket-counts[bucket-index] := bucket-count + 1
			cur + 1
		else
			bucket-counts[bucket-index] := bucket-count + 1
			cur swap bucket-cur-end
			cur
		new-cur move-values-to-buckets-recur end, bucket-counts, bucket-starts

.get-bucket-index<k> nat64(key k, n-buckets nat64) hash-mix<k>
	key.hash % n-buckets

.running-sum<k, v> array<(k, v) mut*>(acc (k, v) mut*, a array nat64) trusted
	out mut-array (k, v) mut* = a.size uninitialized-mut-array
	acc running-sum-recur out.begin-pointer, out.end-pointer, a.begin-pointer
	out cast-immutable
.running-sum-recur<k, v> void(
	acc (k, v) mut*,
	out (k, v) mut* mut*,
	out-end (k, v) mut* mut*,
	read nat64*,
) unsafe
	*out := acc
	unless out + 1 == out-end
		acc + *read running-sum-recur out + 1, out-end, read + 1

region iteration

for-loop<k, v> void(a frozen-dict<k, v>, f act void(k, v))
	for pair : a pairs
		f[pair from, pair to]

for-loop<out, k, v> out[](a frozen-dict<k, v>, f act out(k, v))
	for pair : a.pairs to-list
		f[pair from, pair to]

fold<a, k, v> a(acc a, a frozen-dict<k, v>, f act a(a, k, v))
	acc fold a.pairs, (inner-acc, pair) =>
		f[inner-acc, pair from, pair to]

fold<a, k, v> a(acc a, a frozen-dict<k, v>, f act a(a, k, v, nat64))
	acc fold a.pairs, (inner-acc, pair, index) =>
		f[inner-acc, pair from, pair to, index]

.verify void(a frozen-dict<nat64, string>, keys-order nat64[], bucket-starts nat64[]) unsafe
	(for pair : a.pairs to-list; pair from)::nat64[] is keys-order
	(for pointer : a.bucket-starts to-list; pointer - a.pairs.begin-pointer)::nat64[] is bucket-starts

.== bool(a string?, b string?)
	a option-equal b

test
	a frozen-dict<nat64, string> = ()
	a.is-empty is true
	a.size is 0
	a verify (), ()
	a[0] is ()
	
	b frozen-dict<nat64, string> = (3, "3"), (1, "1"), (5, "5"), (2, "2")
	b verify (3, 1, 5, 2), ()
	b[0] is ()
	b[1] is ("1",)
	b[2] is ("2",)
	b[3] is ("3",)
	b[4] is ()
	b[5] is ("5",)
	b[6] is ()

	c frozen-dict<nat64, string> = (3, "3"), (1, "1"), (5, "5"), (2, "2"), (8, "8")
	c verify (2, 8, 3, 5, 1), (0, 2)
	c[0] is ()
	c[1] is ("1",)
	c[2] is ("2",)
	c[3] is ("3",)
	c[4] is ()
	c[5] is ("5",)
	c[6] is ()
	c[7] is ()
	c[8] is ("8",)
	c[9] is ()

test
	a frozen-dict<nat64, string> = (1, "1"), (1, "2")
	a.size is 1
	a verify (1,), ()
	a[1] is ("2",)
