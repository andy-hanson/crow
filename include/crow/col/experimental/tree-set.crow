no-std
import
	../../bool: !, &&, bool, false, new, true
	../../compare: !=, <, <=, >, >=, compare
	../../exception: unreachable
	../../fun-util: subscript
	../../misc: is-data, new, void
	../../number: ==, <=>, +, -, /, nat64, new
	../../option: !, new, option
	../../pointer: ==, <=>, +, -, *, const-pointer
	../../range: ..
	../../string: ==, <=>, ~~, iter, join, literal, next, slice-left, starts-with, string, to-string
	../../test-util: is
	../array:
		~=, ~~=, array, array-builder, begin-pointer, build-array, end-pointer, for-loop, insert-at,
		is-empty, last, remove-at, rtail, size, subscript, tail, with-block
	../iter: rest
	../list: ~=, build-list, for-loop, list, list-builder, size, to-array, to-list, with-block
	../mut-stack: ~=, mut-stack, new, peek, pop
	../sort: sort-unique
	../private/sort-utils: binary-search-has, binary-search-insert-pointer

###
Set of unique values.
Unlike `array`, the values are always in sorted order, and there are never two of the same value.
###
tree-set<a> record
	.root node a
	.total-size nat64

.node<a> union
	inner inner-node a
	leaf array a

.inner-node<a> record by-ref
	value a
	left node a
	right node a

# True iff the set is empty.
is-empty<a> bool(a tree-set a) is-data<a> compare<a>
	a.total-size == 0

# Number of values in the set.
size<a> nat64(a tree-set a) is-data<a> compare<a>
	a total-size

# Empty `tree-set`.
new<a> tree-set a(...a array a) is-data<a> compare<a>
	a.to-list to-tree-set

# Copy a list to a `tree-set`.
to-tree-set<a> tree-set a(a a[]) is-data<a> compare<a>
	values = a sort-unique
	values.to-array.leaf, values.size

###
List of all values in the set, in sorted order.
This is O(n).
###
to-list<a> a[](a tree-set a) is-data<a> compare<a>
	match a.root
	as inner i
		i tree-to-array a.size to-list
	as leaf l
		l to-list

# True iff the value is in the set.
in<a> bool(value a, a tree-set a) is-data<a> compare<a>
	a.root has value
.has<a> bool(a node a, value a) trusted compare<a>
	match a
	as inner i
		match value <=> i.value
		as less
			i.left has value
		as equal
			true
		as greater
			i.right has value
	as leaf l
		l binary-search-has value

###
Add a value to the set.
No effect if the value is already in the set.
This is O(a.size ln)
###
~ <a> tree-set a(a tree-set a, value a) is-data<a> compare<a>
	new-size = a.size + 1
	match a.root add-recur value, new-size.get-max-height
	as none
		a
	as inserted i
		i, a.size + 1
	as find-scapegoat _
		unreachable

###
Union of two sets.
This is O(n).
###
~~ <a> tree-set a(a tree-set a, b tree-set a) trusted is-data<a> compare<a>
	list a[] = with out : a.size + b.size build-list
		b-iter = b iter
		for x : a
			out walk-iter-union x, b-iter
		b-iter consume-rest out
	list to-tree-set

.walk-iter-union<a> void(out list-builder a, value a, a iter a) unsafe is-data<a> compare<a>
	if peek ?= a peek
		match value <=> peek
		as less
			out ~= value
		as equal
			out ~= value
			_ = a next
			()
		as greater
			out ~= peek
			_ = a next
			out walk-iter-union value, a
	else
		out ~= value

intersect<a> tree-set a(a tree-set a, b tree-set a) trusted is-data<a> compare<a>
	b-iter = b iter
	a filter x => b-iter walk-iter-has x

.walk-iter-has<a> bool(a iter a, value a) unsafe is-data<a> compare<a>
	if peek ?= a peek
		match value <=> peek
		as less
			false
		as equal
			_ = a next
			true
		as greater
			_ = a next
			a walk-iter-has value

###
Returns a set that does not contain 'b'.
If 'b' is not in the set, returns it unmodified.
This is O(a.size ln).
###
- <a> tree-set a(a tree-set a, b a) is-data<a> compare<a>
	if res ?= a try-remove b
		res
	else
		a

###
If `value` is in `a`, returns `a` with the first instance of `value` removed.
Else, returns an empty option.
###
.try-remove<a> array<a>?(a array a, value a) compare<a>
	a try-remove-recur 0, value
.try-remove-recur<a> array<a>?(a array a, index nat64, value a) compare<a>
	unless index == a.size
		if a[index] == value
			(a remove-at index),
		else
			a try-remove-recur index + 1, value

###
If 'b' is in the set, returns `none~.
Else, returns a set with 'b' removed.
This is O(a.size ln).
###
try-remove<a> tree-set<a>?(a tree-set a, b a) is-data<a> compare<a>
	if node ?= a.root try-remove-recur b
		(node, a.size - 1),

.try-remove-recur<a> node<a>?(a node a, b a) compare<a>
	match a
	as inner i
		match b <=> i.value
		as less
			if new-left ?= i.left try-remove-recur b
				(i.value, new-left, i.right).inner,
		as equal
			if i.right node-is-empty
				i.left,
			else
				# Remove the base of the tree -- making one of the sides take over.
				if popped ?= i.left pop-right
					(popped.value, popped.rest, i.right).inner,
				else
					i.right,
		as greater
			if new-right ?= i.right try-remove-recur b
				(i.value, i.left, new-right).inner,
	as leaf l
		# TODO: use a binary search (try-remove uses linear search since it's for arbitrary array)
		if l2 ?= l try-remove b
			l2.leaf,

.node-is-empty<a> bool(a node a)
	match a
	as inner _
		false
	as leaf l
		l is-empty

.popped<a> record
	value a
	rest node a

.pop-right<a> popped<a>?(a node a)
	match a
	as inner i
		if popped ?= i.right pop-right
			(popped.value, (i.value, i.left, popped.rest).inner),
		else
			# Then this is rightmost
			(i.value, i.left),
	as leaf l
		if last ?= l last
			(last, l.rtail.leaf),

- <a> tree-set a(a tree-set a, b tree-set a) trusted is-data<a> compare<a>
	b-iter = b iter
	a filter x => !(b-iter walk-iter-has x)

.iter<a> record mut
	cur mut array a
	# If a node is on the stack, we have yet to write out the middle and right.
	# TODO:PERF use a mut-array, initialized to the tree's height
	stack mut-stack inner-node a

.iter<a> iter a(a tree-set a) trusted
	stack mut-stack inner-node a = ()
	cur = stack init-iter-recur a.root
	cur, stack
.init-iter-recur<a> array a(stack mut-stack inner-node a, node node a)
	match node
	as inner i
		stack ~= i
		stack init-iter-recur i.left
	as leaf l
		l
.peek<a> a?(a iter a)
	if a.cur is-empty
		if x ?= a.stack peek
			x.value,
	else
		a.cur[0],
.next<a> a?(a iter a) trusted
	if a.cur is-empty
		if node ?= a.stack pop
			res = node value
			match node right
			as inner i
				a.stack ~= i
			as leaf l
				a.cur := l
			res,
	else
		res = a.cur[0]
		a.cur := a.cur tail
		res,

.find-scapegoat record
	# size of this subtree (including the new value)
	size nat64
	# height of this subtree
	height nat64

.add-result<a> union
	none
	inserted node a
	find-scapegoat find-scapegoat

.add-recur<a> add-result a(a node a, value a, max-height nat64) compare<a>
	match a
	as inner i
		i add-to-inner value, max-height
	as leaf l
		l add-to-array value, max-height

.add-to-inner<a> add-result a(a inner-node a, value a, max-height nat64) compare<a>
	match value <=> a.value
	as less
		match a.left add-recur value, max-height - 1
		as none
			none
		as inserted new-left
			(a.value, new-left, a.right).inner inserted
		as find-scapegoat f
			a handle-scapegoat value, a.right, f
	as equal
		none
	as greater
		match a.right add-recur value, max-height - 1
		as none
			none
		as inserted new-right
			(a.value, a.left, new-right).inner inserted
		as find-scapegoat f
			a handle-scapegoat value, a.left, f

.add-to-array<a> add-result a(a array a, value a, max-height nat64) trusted compare<a>
	insert-pointer = a binary-search-insert-pointer value
	if insert-pointer != a.end-pointer && *insert-pointer == value
		none
	elif a.size < 4
		(a insert-at insert-pointer - a.begin-pointer, value).leaf inserted
	elif max-height == 0
		# Can't add new nodes
		(a.size + 1, 1) find-scapegoat
	else
		a break-up-arr value, insert-pointer, max-height

.break-up-arr<a> add-result a(a array a, value a, insert-pointer a*, max-height nat64) unsafe compare<a>
	assert a.begin-pointer <= insert-pointer
	assert insert-pointer <= a.end-pointer
	# Break it up into nodes, adding to height
	mid-pointer = a.begin-pointer + (a.end-pointer - a.begin-pointer) / 2
	mid-index = mid-pointer - a.begin-pointer
	if insert-pointer == mid-pointer
		(value, a[0 .. mid-index].leaf, a[mid-index .. a.size].leaf).inner inserted
	else
		mid = *mid-pointer
		assert mid-index < a.size
		left-arr = a[0 .. mid-index]
		right-arr = a[mid-index + 1 .. a.size]
		forbid left-arr is-empty
		forbid right-arr is-empty
		if insert-pointer < mid-pointer
			# TODO:PERF: This redundantly finds insert-pointer again
			match left-arr add-to-array value, max-height - 1
			as none
				unreachable
			as inserted i
				(mid, i, right-arr.leaf).inner inserted
			as find-scapegoat f
				(a.size + 1, f.height + 1) find-scapegoat
		else
			match right-arr add-to-array value, max-height - 1
			as none
				unreachable
			as inserted i
				(mid, left-arr.leaf, i).inner inserted
			as find-scapegoat f
				(a.size + 1, f.height + 1) find-scapegoat

.handle-scapegoat<a> add-result a(a inner-node a, value a, other-subtree node a, f find-scapegoat) compare<a>
	size-here = f.size + 1 + other-subtree.walk-size
	height-here = f.height + 1
	if height-here > size-here.get-max-height
		(a tree-to-array value, size-here).leaf inserted
	else
		(size-here, height-here) find-scapegoat

.walk-size<a> nat64(a node a)
	match a
	as inner i
		i.left.walk-size + 1 + i.right.walk-size
	as leaf l
		l size

.tree-to-array<a> array a(a inner-node a, value a, size nat64) trusted compare<a>
	with out : size build-array
		out tree-to-array-recur a.inner, value
.tree-to-array<a> array a(a inner-node a, size nat64) trusted compare<a>
	with out : size build-array
		out tree-to-array-recur a.inner
.tree-to-array-recur<a> void(out array-builder a, a node a, value a) compare<a> unsafe
	match a
	as inner i
		match value <=> i.value
		as less
			out tree-to-array-recur i.left, value
			out ~= i.value
			out tree-to-array-recur i.right
		as equal
			unreachable
		as greater
			out tree-to-array-recur i.left
			out ~= i.value
			out tree-to-array-recur i.right, value
	as leaf l
		# Find first x > value, insert it before there
		index = (l binary-search-insert-pointer value) - l.begin-pointer
		out ~~= l[0 .. index]
		out ~= value
		out ~~= l[index .. l.size]
# Version where we know we don't have to insert value
.tree-to-array-recur<a> void(out array-builder a, a node a) unsafe
	match a
	as inner i
		out tree-to-array-recur i.left
		out ~= i.value
		out tree-to-array-recur i.right
	as leaf l
		out ~~= l

# TODO:PERF
.get-max-height nat64(size nat64) trusted
	if size >= 4
		(size / 2).get-max-height + 1

region iteration

for-loop<a> void(a tree-set a, f act void(a)) is-data<a> compare<a>
	a.root for-loop-recur f
.for-loop-recur<a> void(a node a, f act void(a))
	match a
	as inner i
		i each-inner f
	as leaf l
		l for-loop f
.each-inner<a> void(i inner-node a, f act void(a))
	i.left for-loop-recur f
	f[i.value]
	i.right for-loop-recur f

.consume-rest<a> void(a iter a, out list-builder a)
	for x : a cur
		out ~= x
	a.stack consume-rest-recur out
.consume-rest-recur<a> void(stack mut-stack inner-node a, out list-builder a)
	if popped ?= stack pop
		popped each-inner x =>
			out ~= x
		stack consume-rest-recur out

for-loop<out, in> out[](a tree-set in, f act out(in)) trusted is-data<in> compare<in>
	with out : a.size build-list
		for value : a
			out ~= f[value]

for-loop<out, in> tree-set out(a tree-set in, f act out(in)) is-data<in> compare<in> is-data<out> compare<out>
	a for-loop f to-tree-set

filter<a> tree-set a(a tree-set a, f act bool(a)) is-data<a> compare<a>
	list a[] = with out : build-list
		for value : a
			if f[value]
				out ~= value
	list to-tree-set

# TODO: find-and-get

.dbg<a> string(a tree-set a) to-string<a>
	a.root dbg
.dbg<a> string(a node a) to-string<a>
	match a
	as inner i
		"({i.left dbg} {i value} {i.right dbg})"
	as leaf l
		parts = " " join for x : l.to-list; "{x}"
		"[{parts}]"

.verify void(a tree-set string, expected string)
	a.size is a.root.walk-size
	a.dbg is expected

test
	s tree-set string = "a", "c", "e", "g"
	s ~ "d" verify "([a c] d [e g])"

test
	s0 tree-set string = new
	s0 verify "[]"

	s1 = s0 ~ "h"
	s1 verify "[h]"

	s2 = s1 ~ "k"
	s2 verify "[h k]"

	s3 = s2 ~ "i"
	s3 verify "[h i k]"

	s4 = s3 ~ "j"
	s4 verify "[h i j k]"

	assert "h" in s4
	s4 ~ "i" verify "[h i j k]"

	s5 = s4 ~ "l"
	s5 verify "([h i] j [k l])"

	(s5 - "i") verify "([h] j [k l])"
	(s5 - "j") verify "([h] i [k l])"
	(s5 - "k") verify "([h i] j [l])"
	s6 = s5 ~ "jj"
	s6 verify "([h i] j [jj k l])"

	s7 = s6 ~ "ji"
	s7 verify "([h i] j [ji jj k l])"

	s8 = s7 ~ "jk"
	s8 verify "([h i] j ([ji jj] jk [k l]))"

	s8-k = s8 - "k"
	s8-k verify "([h i] j ([ji jj] jk [l]))"
	s8-k-l = s8-k - "l"
	s8-k-l verify "([h i] j ([ji jj] jk []))"
	s8-k-l - "jk" verify "([h i] j [ji jj])"

	s9 = s8 ~ "m"
	s9 verify "([h i] j ([ji jj] jk [k l m]))"
	s10 = s9 ~ "n"
	s10 verify "([h i] j ([ji jj] jk [k l m n]))"
	s11 = s10 ~ "o"
	s11 verify "[h i j ji jj jk k l m n o]"

	s8 ~~ ("a", "jii", "z") verify "[a h i j ji jii jj jk k l z]"
	s8 - s4 verify "[ji jj jk l]"
	s8-k-l intersect s3 verify "[h i]"

	"-" join (for x : s8; x) is "h-i-j-ji-jj-jk-k-l"

	s8 filter (x => !(x starts-with "j")) verify "[h i k l]"

	(for x : s8; x first-char) verify "[h i j k l]"

.first-char string(a string)
	a.iter.next!.rest slice-left
