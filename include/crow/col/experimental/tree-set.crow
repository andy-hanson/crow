no-std
import
	../../bool: !, &&, bool, false, new, true
	../../compare: !=, <, <=, >, >=, compare
	../../exception: unreachable
	../../fun-util: subscript
	../../json: json
	../../misc: is-data, new, void
	../../number: ==, <=>, +, -, /, nat64, new
	../../option: !, new, option
	../../pointer: ==, <=>, +, -, *, const-pointer
	../../range: ..
	../../string: ==, <=>, ~~, iter, join, literal, next, slice-left, starts-with, string, to-string
	../../test-util: is
	../array:
		~=, ~~=, array, array-builder, begin-pointer, build, end-pointer, for-loop, index-of,
		insert-at, is-empty, last, remove-at, rtail, size, subscript, tail, with-block
	../iter: rest
	../list: ~=, build, for-loop, list, list-builder, size, to-array, to-list, with-block
	../mut-stack: ~=, mut-stack, new, peek, pop
	../sort: sort-unique
	../private/sort-utils: binary-search-has, binary-search-insert-pointer

###
Set of unique values.
Unlike `array`, the values are always in sorted order, and there are never two of the same value.
###
tree-set[t] record
	.root t node
	.total-size nat64

.node[t] union
	inner t inner-node
	leaf t array

.inner-node[t] record by-ref
	value t
	left t node
	right t node

# True iff the set is empty.
is-empty[t] bool(a t tree-set) t is-data, t compare
	a.total-size == 0

# Number of values in the set.
size[t] nat64(a t tree-set) t is-data, t compare
	a total-size

# Empty `tree-set`.
new[t] t tree-set(...a t array) t is-data, t compare
	a.to-list to-tree-set

# Copy a list to a `tree-set`.
to-tree-set[t] t tree-set(a t[]) t is-data, t compare
	values = a sort-unique
	values.to-array.leaf, values.size

###
List of all values in the set, in sorted order.
This is O(n).
###
to-list[t] t[](a t tree-set) t is-data, t compare
	match a.root
	as inner i
		i tree-to-array a.size to-list
	as leaf l
		l to-list

# True iff the value is in the set.
in[t] bool(value t, a t tree-set) t is-data, t compare
	a.root has value
.has[t] bool(a t node, value t) trusted, t compare
	match a
	as inner i
		match value <=> i.value
		as less
			i.left has value
		as equal
			true
		as greater
			i.right has value
	as leaf l
		l binary-search-has value

###
Add a value to the set.
No effect if the value is already in the set.
This is O(a.size ln)
###
~[t] t tree-set(a t tree-set, value t) t is-data, t compare
	new-size = a.size + 1
	match a.root add-recur value, new-size.get-max-height
	as none
		a
	as inserted i
		i, a.size + 1
	as find-scapegoat _
		unreachable

###
Union of two sets.
This is O(n).
###
~~[t] t tree-set(a t tree-set, b t tree-set) trusted, t is-data, t compare
	list t[] = with out : a.size + b.size build
		b-iter = b iter
		for x : a
			out walk-iter-union x, b-iter
		b-iter consume-rest out
	list to-tree-set
.consume-rest[t] void(a t iter, out t list-builder)
	for x : a cur
		out ~= x
	loop
		if popped ?= a.stack pop
			popped each-inner x =>
				out ~= x
			continue
		else
			break

.walk-iter-union[t] void(out t list-builder, value t, a t iter) unsafe, t is-data, t compare
	if peek ?= a peek
		match value <=> peek
		as less
			out ~= value
		as equal
			out ~= value
			_ = a next
			()
		as greater
			out ~= peek
			_ = a next
			out walk-iter-union value, a
	else
		out ~= value

intersect[t] t tree-set(a t tree-set, b t tree-set) trusted, t is-data, t compare
	b-iter = b iter
	a filter x => b-iter walk-iter-has x

.walk-iter-has[t] bool(a t iter, value t) unsafe, t is-data, t compare
	if peek ?= a peek
		match value <=> peek
		as less
			false
		as equal
			_ = a next
			true
		as greater
			_ = a next
			a walk-iter-has value

###
Returns a set that does not contain 'b'.
If 'b' is not in the set, returns it unmodified.
This is O(a.size ln).
###
-[t] t tree-set(a t tree-set, b t) t is-data, t compare
	if res ?= a try-remove b
		res
	else
		a

###
If `value` is in `a`, returns `a` with the first instance of `value` removed.
Else, returns an empty option.
###
.try-remove[t] t array?(a t array, value t) t compare
	if index ?= a index-of value
		(a remove-at index),

###
If 'b' is in the set, returns `none~.
Else, returns a set with 'b' removed.
This is O(a.size ln).
###
try-remove[t] t tree-set?(a t tree-set, b t) t is-data, t compare
	if node ?= a.root try-remove-recur b
		(node, a.size - 1),

.try-remove-recur[t] t node?(a t node, b t) t compare
	match a
	as inner i
		match b <=> i.value
		as less
			if new-left ?= i.left try-remove-recur b
				(i.value, new-left, i.right).inner,
		as equal
			if i.right node-is-empty
				i.left,
			else
				# Remove the base of the tree -- making one of the sides take over.
				if popped ?= i.left pop-right
					(popped.value, popped.rest, i.right).inner,
				else
					i.right,
		as greater
			if new-right ?= i.right try-remove-recur b
				(i.value, i.left, new-right).inner,
	as leaf l
		# TODO: use a binary search (try-remove uses linear search since it's for arbitrary array)
		if l2 ?= l try-remove b
			l2.leaf,

.node-is-empty[t] bool(a t node)
	match a
	as inner _
		false
	as leaf l
		l is-empty

.popped[t] record
	value t
	rest t node

.pop-right[t] t popped?(a t node)
	match a
	as inner i
		if popped ?= i.right pop-right
			(popped.value, (i.value, i.left, popped.rest).inner),
		else
			# Then this is rightmost
			(i.value, i.left),
	as leaf l
		if last ?= l last
			(last, l.rtail.leaf),

-[t] t tree-set(a t tree-set, b t tree-set) trusted, t is-data, t compare
	b-iter = b iter
	a filter x => !(b-iter walk-iter-has x)

.iter[t] record mut
	cur mut t array
	# If a node is on the stack, we have yet to write out the middle and right.
	# TODO:PERF use a mut-array, initialized to the tree's height
	stack t inner-node mut-stack

.iter[t] t iter(a t tree-set) trusted
	stack t inner-node mut-stack = ()
	node mut = a root
	loop
		match node
		as inner i
			stack ~= i
			node := i left
			continue
		as leaf l
			break l, stack

.peek[t] t?(a t iter)
	if a.cur is-empty
		if x ?= a.stack peek
			x.value,
	else
		a.cur[0],

.next[t] t?(a t iter) trusted
	if a.cur is-empty
		if node ?= a.stack pop
			res = node value
			match node right
			as inner i
				a.stack ~= i
			as leaf l
				a.cur := l
			res,
	else
		res = a.cur[0]
		a.cur := a.cur tail
		res,

.find-scapegoat record
	# size of this subtree (including the new value)
	size nat64
	# height of this subtree
	height nat64

.add-result[t] union
	none
	inserted t node
	find-scapegoat find-scapegoat

.add-recur[t] t add-result(a t node, value t, max-height nat64) t compare
	match a
	as inner i
		i add-to-inner value, max-height
	as leaf l
		l add-to-array value, max-height

.add-to-inner[t] t add-result(a t inner-node, value t, max-height nat64) t compare
	match value <=> a.value
	as less
		match a.left add-recur value, max-height - 1
		as none
			none
		as inserted new-left
			(a.value, new-left, a.right).inner inserted
		as find-scapegoat f
			a handle-scapegoat value, a.right, f
	as equal
		none
	as greater
		match a.right add-recur value, max-height - 1
		as none
			none
		as inserted new-right
			(a.value, a.left, new-right).inner inserted
		as find-scapegoat f
			a handle-scapegoat value, a.left, f

.add-to-array[t] t add-result(a t array, value t, max-height nat64) trusted, t compare
	insert-pointer = a binary-search-insert-pointer value
	if insert-pointer != a.end-pointer && *insert-pointer == value
		none
	elif a.size < 4
		(a insert-at insert-pointer - a.begin-pointer, value).leaf inserted
	elif max-height == 0
		# Can't add new nodes
		(a.size + 1, 1) find-scapegoat
	else
		a break-up-arr value, insert-pointer, max-height

.break-up-arr[t] t add-result(a t array, value t, insert-pointer t*, max-height nat64) unsafe, t compare
	assert a.begin-pointer <= insert-pointer
	assert insert-pointer <= a.end-pointer
	# Break it up into nodes, adding to height
	mid-pointer = a.begin-pointer + (a.end-pointer - a.begin-pointer) / 2
	mid-index = mid-pointer - a.begin-pointer
	if insert-pointer == mid-pointer
		(value, a[0 .. mid-index].leaf, a[mid-index .. a.size].leaf).inner inserted
	else
		mid = *mid-pointer
		assert mid-index < a.size
		left-arr = a[0 .. mid-index]
		right-arr = a[mid-index + 1 .. a.size]
		forbid left-arr is-empty
		forbid right-arr is-empty
		if insert-pointer < mid-pointer
			# TODO:PERF: This redundantly finds insert-pointer again
			match left-arr add-to-array value, max-height - 1
			as none
				unreachable
			as inserted i
				(mid, i, right-arr.leaf).inner inserted
			as find-scapegoat f
				(a.size + 1, f.height + 1) find-scapegoat
		else
			match right-arr add-to-array value, max-height - 1
			as none
				unreachable
			as inserted i
				(mid, left-arr.leaf, i).inner inserted
			as find-scapegoat f
				(a.size + 1, f.height + 1) find-scapegoat

.handle-scapegoat[t] t add-result(a t inner-node, value t, other-subtree t node, f find-scapegoat) t compare
	size-here = f.size + 1 + other-subtree.walk-size
	height-here = f.height + 1
	if height-here > size-here.get-max-height
		(a tree-to-array value, size-here).leaf inserted
	else
		(size-here, height-here) find-scapegoat

.walk-size[t] nat64(a t node)
	match a
	as inner i
		i.left.walk-size + 1 + i.right.walk-size
	as leaf l
		l size

.tree-to-array[t] t array(a t inner-node, value t, size nat64) trusted, t compare
	with out : size build
		out tree-to-array-recur a.inner, value
.tree-to-array[t] t array(a t inner-node, size nat64) trusted, t compare
	with out : size build
		out tree-to-array-recur a.inner
.tree-to-array-recur[t] void(out t array-builder, a t node, value t) unsafe, t compare
	match a
	as inner i
		match value <=> i.value
		as less
			out tree-to-array-recur i.left, value
			out ~= i.value
			out tree-to-array-recur i.right
		as equal
			unreachable
		as greater
			out tree-to-array-recur i.left
			out ~= i.value
			out tree-to-array-recur i.right, value
	as leaf l
		# Find first x > value, insert it before there
		index = (l binary-search-insert-pointer value) - l.begin-pointer
		out ~~= l[0 .. index]
		out ~= value
		out ~~= l[index .. l.size]
# Version where we know we don't have to insert value
.tree-to-array-recur[t] void(out t array-builder, a t node) unsafe
	match a
	as inner i
		out tree-to-array-recur i.left
		out ~= i.value
		out tree-to-array-recur i.right
	as leaf l
		out ~~= l

# TODO:PERF
.get-max-height nat64(size nat64) trusted
	if size >= 4
		(size / 2).get-max-height + 1

region iteration

for-loop[t] void(a t tree-set, f act void(t)) t is-data, t compare
	a.root for-loop-recur f
.for-loop-recur[t] void(a t node, f act void(t))
	match a
	as inner i
		i each-inner f
	as leaf l
		l for-loop f
.each-inner[t] void(i t inner-node, f act void(t))
	i.left for-loop-recur f
	f[i.value]
	i.right for-loop-recur f

for-loop[out, in] out[](a in tree-set, f act out(in)) in is-data, in compare
	with out : a.size build
		for value : a
			out ~= f[value]

for-loop[out, in] out tree-set(a in tree-set, f act out(in)) in is-data, in compare, out is-data, out compare
	a for-loop f to-tree-set

filter[t] t tree-set(a t tree-set, f act bool(t)) t is-data, t compare
	list t[] = with out : build
		for value : a
			if f[value]
				out ~= value
	list to-tree-set

# TODO: find-and-get

.dbg[t] string(a t tree-set) t to-string
	a.root dbg
.dbg[t] string(a t node) t to-string
	match a
	as inner i
		"({i.left dbg} {i value} {i.right dbg})"
	as leaf l
		parts = " " join for x : l.to-list; "{x}"
		"[{parts}]"

.verify void(a string tree-set, expected string)
	a.size is a.root.walk-size
	a.dbg is expected

test
	s string tree-set = "a", "c", "e", "g"
	s ~ "d" verify "([a c] d [e g])"

test
	s0 string tree-set = new
	s0 verify "[]"

	s1 = s0 ~ "h"
	s1 verify "[h]"

	s2 = s1 ~ "k"
	s2 verify "[h k]"

	s3 = s2 ~ "i"
	s3 verify "[h i k]"

	s4 = s3 ~ "j"
	s4 verify "[h i j k]"

	assert "h" in s4
	s4 ~ "i" verify "[h i j k]"

	s5 = s4 ~ "l"
	s5 verify "([h i] j [k l])"

	(s5 - "i") verify "([h] j [k l])"
	(s5 - "j") verify "([h] i [k l])"
	(s5 - "k") verify "([h i] j [l])"
	s6 = s5 ~ "jj"
	s6 verify "([h i] j [jj k l])"

	s7 = s6 ~ "ji"
	s7 verify "([h i] j [ji jj k l])"

	s8 = s7 ~ "jk"
	s8 verify "([h i] j ([ji jj] jk [k l]))"

	s8-k = s8 - "k"
	s8-k verify "([h i] j ([ji jj] jk [l]))"
	s8-k-l = s8-k - "l"
	s8-k-l verify "([h i] j ([ji jj] jk []))"
	s8-k-l - "jk" verify "([h i] j [ji jj])"

	s9 = s8 ~ "m"
	s9 verify "([h i] j ([ji jj] jk [k l m]))"
	s10 = s9 ~ "n"
	s10 verify "([h i] j ([ji jj] jk [k l m n]))"
	s11 = s10 ~ "o"
	s11 verify "[h i j ji jj jk k l m n o]"

	s8 ~~ ("a", "jii", "z") verify "[a h i j ji jii jj jk k l z]"
	s8 - s4 verify "[ji jj jk l]"
	s8-k-l intersect s3 verify "[h i]"

	"-" join (for x : s8; x) is "h-i-j-ji-jj-jk-k-l"

	s8 filter (x => !(x starts-with "j")) verify "[h i k l]"

	(for x : s8; x first-char) verify "[h i j k l]"

.first-char string(a string)
	a.iter.next!.rest slice-left
