no-std
import
	../../bool: &&, bool, not
	../../compare: <=
	../../fun-util: subscript
	../../hash: hash
	../../misc: key, loop-break, new, void
	../../number: ==, <=>, +, -, /, %, nat64
	../../option: is-empty, new, option
	../../range: .., iterate, range
	../../tuple: a, b
	../array: +, -, array, begin, end, is-empty, iterate, new, next, size, slice
	../collection:
		.., build, build-options, end, exists, for-break, for-loop, indices, n-of, map=,
		set-subscript, subscript, swap-at, with-block, with-index
	../mut-array:
		~=, +, begin, build, cast-immutable, iterate, mut-array, mut-array-builder, next, set-next,
		size
	../list: list, to

###
Immutable map that is not efficient to update.
However, this is more compact than `map` and has faster lookups.
###
+frozen-map[k, v] record by-val
	# exposed for tests only
	pairs (k, v) array
	bucket-starts nat64 array

+new[k, v] (k, v) frozen-map(...a (k, v) array) k key
	a.to to

+to[k, v] (k, v) frozen-map(a (k, v)[]) k key
	trusted a.to as-frozen-map

# This is O(1).
+to[k, v] (k, v) array(a (k, v) frozen-map) bare
	a pairs
+to[k, v] (k, v)[](a (k, v) frozen-map) bare
	a.to::((k, v) array) to

+is-empty[k, v] bool(a (k, v) frozen-map)
	a.pairs is-empty

+size[k, v] nat64(a (k, v) frozen-map)
	a.pairs size

+subscript[k, v] v?(a (k, v) frozen-map, key k) k key
	if index ?= a try-get-unordered-index key
		a.pairs[index].b,

+in[k, v] bool(key k, a (k, v) frozen-map) k key
	!(a try-get-unordered-index key is-empty)

try-get-unordered-index[k, v] nat64?(a (k, v) frozen-map, key k) k key
	for i : a bucket-indices key
		if a.pairs[i].a == key
			break i

-bucket-indices[k, v] nat64 range(a (k, v) frozen-map, key k) k key
	if a.bucket-starts is-empty
		a.pairs indices
	else
		a bucket-indices-at-index key.hash % a.bucket-starts.size

# Returns a slice of 'a.pairs'
-bucket-indices-at-index[k, v] nat64 range(a (k, v) frozen-map, bucket-index nat64)
	bucket-start = a.bucket-starts[bucket-index]
	bucket-end = if bucket-index == a.bucket-starts.size - 1
		a.pairs size
	else
		a.bucket-starts[bucket-index + 1]
	bucket-start .. bucket-end

-bucket-at-index[k, v] (k, v) array(a (k, v) frozen-map, bucket-index nat64)
	a.pairs[a bucket-indices-at-index bucket-index]

-as-frozen-map[k, v] (k, v) frozen-map(a (k, v) mut-array) unsafe, k key
	a.mut-array-to-frozen-map-promise-no-duplicates remove-duplicates

mut-array-to-frozen-map-promise-no-duplicates[k, v] (k, v) frozen-map(
	a (k, v) mut-array,
) unsafe, k key
	if a.size <= 4
		a.cast-immutable, ()
	else
		n-buckets = a.size / 2
		bucket-starts = a get-bucket-starts n-buckets
		bucket-counts nat64 mut-array = n-buckets n-of 0
		cur mut = 0
		until cur == a.size
			bucket-index = a[cur].a get-bucket-index bucket-counts.size
			bucket-count = bucket-counts[bucket-index]
			bucket-start = bucket-starts[bucket-index]
			bucket-cur-end = bucket-start + bucket-count
			if bucket-start <= cur && cur <= bucket-cur-end
				if cur == bucket-cur-end
					bucket-counts[bucket-index] := bucket-count + 1
				cur +:= 1
			else
				bucket-counts[bucket-index] := bucket-count + 1
				a swap-at cur, bucket-cur-end
		a.cast-immutable, bucket-starts

-remove-duplicates[k, v] (k, v) frozen-map(a (k, v) frozen-map) unsafe, k key
	if a has-duplicates
		# Write out pairs from each bucket to a mut-array,
		# omitting a pair if its key appears later in the same bucket.
		# Then call mut-array-to-frozen-map-promise-no-duplicates
		xs (k, v) mut-array = with out : a.size build
			out write-without-duplicates a
		xs mut-array-to-frozen-map-promise-no-duplicates
	else
		a

-write-without-duplicates[k, v] void(out (k, v) mut-array-builder, a (k, v) frozen-map) k key
	if a.bucket-starts is-empty
		out write-bucket-without-duplicates a.pairs
	else
		for i : a.bucket-starts indices
			out write-bucket-without-duplicates (a bucket-at-index i)

-write-bucket-without-duplicates[k, v] void(out (k, v) mut-array-builder, pairs (k, v) array) k key
	for i, pair : pairs with-index
		unless pair.a key-in-range pairs[i + 1 .. end]
			out ~= pair

-has-duplicates[k, v] bool(a (k, v) frozen-map) k key
	if a.bucket-starts is-empty
		a.pairs bucket-has-duplicates
	else
		a.bucket-starts.indices exists i =>
			a bucket-at-index i bucket-has-duplicates

-bucket-has-duplicates[k, v] bool(pairs (k, v) array) k key
	pairs.with-index exists (i, (k, _)) =>
		k key-in-range pairs[i + 1 .. end]

-key-in-range[k, v] bool(key k, pairs (k, v) array) k key
	pairs exists (k, _) => k == key

-get-bucket-starts[k, v] nat64 array(a (k, v) mut-array, n-buckets nat64) unsafe, k key
	res nat64 mut-array = n-buckets n-of 0
	for k, _ : a
		res[k get-bucket-index n-buckets] +:= 1
	res running-sum
	res cast-immutable

-get-bucket-index[k] nat64(key k, n-buckets nat64) k key
	key.hash % n-buckets

-running-sum void(a nat64 mut-array)
	acc mut = 0
	a map= x =>
		start = acc
		acc +:= x
		start

region spec impls (see collection.crow)

+iterate[k, v] bool(a (k, v) frozen-map, f act bool(k, v))
	a.pairs iterate f

subregion build

+frozen-map-builder[k, v] record mut
	-inner (k, v) mut-array-builder
+build[k, v] (k, v) frozen-map(a build-options, f act void((k, v) frozen-map-builder)) k key
	trusted (a build out => f[out,]) as-frozen-map
+ ~=[k, v] void(a(k, v) frozen-map-builder, pair (k, v))
	a.inner ~= pair
+size[k, v] nat64(a (k, v) frozen-map-builder)
	a.inner size
