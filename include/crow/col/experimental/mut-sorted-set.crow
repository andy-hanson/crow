no-std
import
	../../bool: !, bool, new, true
	../../compare: compare
	../../fun-util: subscript
	../../misc: is-data, new, void
	../../number: nat64
	../../option: is-empty
	../../tuple: from, new
	../list: for-loop, list
	./mut-sorted-dict:
		clear, filter, for-loop, in, is-empty, move-to-list, mut-sorted-dict, new, remove-key,
		set-filter, set-map, set-subscript, size, subscript, to-mut-sorted-dict
	./sorted-set: sorted-set, to-sorted-set

###
Mutable sorted set of unique values.
This is like a `set` but mutable, or like a `mut-sorted-dict` with no values.
Unlike `mut-list`, values are in sorted order, not insertion order,
and it never stores two of the same value.
###
mut-sorted-set[t] record mut
	.inner (t, void) mut-sorted-dict

# New empty `mut-sorted-set`.
new[t] t mut-sorted-set() t is-data, t compare
	(),

to-mut-sorted-set[t] t mut-sorted-set(a t[]) t is-data, t compare
	(for x : a; x, ()).to-mut-sorted-dict,

# True iff the set has no elements.
is-empty[t] bool(a t mut-sorted-set) t is-data, t compare
	a.inner is-empty

# Removes all elements.
clear[t] void(a t mut-sorted-set) t is-data, t compare
	a.inner clear

# Number of values in the set.
size[t] nat64(a t mut-sorted-set) t is-data, t compare
	a.inner size

# True iff the value is in the set.
subscript[t] bool(a t mut-sorted-set, value t) t is-data, t compare
	value in a

in[t] bool(value t, a t mut-sorted-set) t is-data, t compare
	!a.inner[value].is-empty

###
Adds a value to the set.
Does nothing if the value is already in the set.
###
~=[t] void(a t mut-sorted-set, value t) t is-data, t compare
	a.inner[value] := ()

# Adds multiple values to the set.
~~=[t] void(a t mut-sorted-set, values t[]) t is-data, t compare
	for value : values
		a ~= value

try-add[t] bool(a t mut-sorted-set, value t) t is-data, t compare
	# TODO:PERF do it without two lookups
	unless value in a.inner
		a.inner[value] := ()
		true

###
Removes a value from the set.
If the value was present, removes it and returns `true`.
If the value was not present, does nothing and returns `false`.
###
remove[t] bool(a t mut-sorted-set, value t) t is-data, t compare
	!(a.inner remove-key value is-empty)

# Convert to a list, clearing the original `mut-sorted-set` in the process.
move-to-list[t] t[](a t mut-sorted-set) t is-data, t compare
	for pair : a.inner move-to-list
		pair from

# Convert to a `sorted-set`, clearning the original `mut-sorted-set` in the process.
move-to-sorted-set[t] t sorted-set(a t mut-sorted-set) t is-data, t compare
	# TODO:PERF avoid a copy: return a 'mut-list' which the sorted-set can move into to itself
	a.move-to-list to-sorted-set

region iteration

for-loop[t] void(a t mut-sorted-set, f act void(t)) t is-data, t compare
	for k, _ : a inner
		f[k]

for-loop[out, in] out mut-sorted-set(
	a in mut-sorted-set,
	f act out(in),
) in is-data, in compare, out is-data, out compare
	inner (out, void) mut-sorted-dict = for k, _ : a.inner
		f[k], ()
	inner,

filter[t] t mut-sorted-set(a t mut-sorted-set, f act bool(t)) t is-data, t compare
	(a.inner filter (k, _) => f[k]),

region mutating iteration

set-filter[t] void(a t mut-sorted-set, f fun bool(t)) t is-data, t compare
	a.inner set-filter (k, _) => f[k]

set-map[t] void(a t mut-sorted-set, f fun t(t)) t is-data, t compare
	a.inner set-map (k, _) => f[k], ()
