no-std
import
	../../bool: &&, ==, bool, false, not, true
	../../compare: <=, >=, equal, max, min
	../../exception: unreachable
	../../fun-util: subscript
	../../hash: hash-mix
	../../json: json
	../../misc: key, new, void
	../../number: ==, <=>, +, is-even, nat64
	../../option: ==, ||, force, is-empty, new, option
	../../string: ==, ~~, end-iter, join, literal, prev, string, to-string
	../../test-util: is
	../../tuple: ==, from, new, pair, to
	../array:
		~=, ~~=, array, array-builder, build, for-loop, is-empty, mut-iter, new, next, peek, size,
		slice-right, subscript, tail, with-block
	../mut-list: ~=, for-loop, is-empty, last, mut-list, new, pop, size, set-subscript, subscript
	../iter: value
	../list: ==, filter, for-loop, is-empty, list, new, to-array, to-list
	../sort: sort
	../private/sort-utils: binary-search-key

compact-sorted-dict[k, v] record by-val
	.impl (k, v) impl

.impl[k, v] union
	overlay (k, v) overlay
	end-node (k, v) array

.overlay[k, v] record by-ref
	# TODO: consider tracking the number of keys that are new, or change a value, or remove a value.
	# We should merge more frequently if removing keys, less frequently if adding keys.
	# never empty
	pairs (k, v?) array
	prev (k, v) impl

==[k, v] bool(a (k, v) compact-sorted-dict, b (k, v) compact-sorted-dict) k key, v equal
	a.to-sorted-pairs == b.to-sorted-pairs
.to-sorted-pairs[k, v] (k, v)[](a (k, v) compact-sorted-dict) k key
	a.to-list sort pair => pair from

json[k, v] json(a (k, v) compact-sorted-dict) k key, k json, v json
	a.to-sorted-pairs json

new[k, v] (k, v) compact-sorted-dict(...a (k, v) array) k key
	a.to-list to-compact-sorted-dict

to-compact-sorted-dict[k, v] (k, v) compact-sorted-dict(a (k, v)[]) k key
	sorted = a sort pair => pair from
	(sorted.to-array end-node),

is-empty[k, v] bool(a (k, v) compact-sorted-dict) k key
	match a impl
	as overlay _
		false
	as end-node e
		e is-empty

###
Number of pairs.
This is O(n).
###
size[k, v] nat64(a (k, v) compact-sorted-dict) k key
	res mut = 0
	for _, _ : a
		res := res + 1
	res

to-list[k, v] (k, v)[](a (k, v) compact-sorted-dict) k key
	# TODO:PERF Just use 'fold'?
	match a.compact.impl
	as overlay _
		unreachable
	as end-node e
		e to-list

~[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict, pair (k, v)) k key
	(a.impl add-or-remove pair.from, (pair.to,)),

~~[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict, b (k, v)[]) k key
	if b is-empty
		a
	elif a is-empty
		b to-compact-sorted-dict
	else
		# TODO: type annotation be unnecessary
		pairs (k, v?)[] = (for x : b; x.from, (x.to,)) sort pair => pair from
		# TODO: should not need type annotation
		(pairs.to-array, a.impl)::((k, v) overlay).merge-as-needed,

-[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict, key k) k key
	if key in a
		(a.impl add-or-remove key, ()),
	else
		a

subscript[k, v] v?(a (k, v) compact-sorted-dict, key k) k key
	cur mut = a impl
	loop
		match cur
		as overlay o
			if v ?= o.pairs binary-search-key key
				break v
			else
				cur := o prev
				continue
		as end-node e
			break e binary-search-key key

in[k, v] bool(key k, a (k, v) compact-sorted-dict) k key
	!a[key].is-empty

.add-or-remove[k, v] (k, v) impl(a (k, v) impl, key k, value v?) k key
	(((key, value),), a) merge-as-needed

.merge-as-needed[k, v] (k, v) impl(a (k, v) overlay) k key
	match a prev
	as overlay o
		if o.pairs.size should-merge a.pairs.size
			new-pairs = o.pairs merge-overlays a.pairs
			(new-pairs, o.prev) merge-as-needed
		else
			a overlay
	as end-node e
		if e.size should-merge a.pairs.size
			e merge-to-end a.pairs end-node
		else
			a overlay

.merge-unconditionally[k, v] (k, v) array(a (k, v) overlay) k key
	match a prev
	as overlay o
		((o.pairs merge-overlays a.pairs), o.prev) merge-unconditionally
	as end-node e
		e merge-to-end a.pairs

.should-merge bool(prev-size nat64, overlay-size nat64)
	prev-size <= (overlay-size max 3)

.merge-overlays[k, v] (k, v?) array(left (k, v?) array, right (k, v?) array) k key
	with out : left.size + right.size build
		l = left mut-iter
		r = right mut-iter
		loop
			if lv ?= l peek
				if rv ?= r peek
					match lv.from <=> rv.from
					as less
						out ~= l.next!
					as equal
						_ = l.next!
						out ~= r.next!
					as greater
						out ~= r.next!
					continue
				else
					out ~~= l slice-right
					break
			else
				out ~~= r slice-right
				break

.merge-to-end[k, v] (k, v) array(left (k, v) array, right (k, v?) array) k key
	with out : left.size + right.size build
		l = left mut-iter
		r = right mut-iter
		loop
			if lv ?= l peek
				if rv ?= r peek
					match lv.from <=> rv.from
					as less
						out ~= l.next!
					as equal
						_ = l.next!
						out add-if-has-value r.next!
					as greater
						out add-if-has-value r.next!
					continue
				else
					out ~~= l slice-right
					break
			else
				for pair : r slice-right
					out add-if-has-value pair
				break
.add-if-has-value[k, v] void(out (k, v) array-builder, pair (k, v?))
	if v ?= pair to
		out ~= (pair.from, v)

# Returns an equal dictionary that takes up less space.
compact[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict) k key
	node = match a.impl
	as overlay o
		o.merge-unconditionally end-node
	as end-node e
		e end-node
	node,

region iteration

for-loop[k, v] void(a (k, v) compact-sorted-dict, f act void(k, v)) k key
	overlays (k, v?) array mut[] = ()
	cur mut = a impl
	end-node mut (k, v) array = loop
		match cur
		as overlay o
			overlays ~= o pairs
			cur := o prev
			continue
		as end-node e
			break e
	loop
		if overlays is-empty
			for pair : end-node
				f[pair from, pair to]
			break
		else
			least-key = (end-node.is-empty ? overlays[0][0].from : end-node[0].from) find-least-key overlays
			take-from-end-node = !end-node.is-empty && least-key == end-node[0].from
			# TODO: should not need 'v?'
			val-from-end-node v? = if take-from-end-node
				end-node[0].to,
			if take-from-end-node
				end-node := end-node tail
			if val ?= (overlays take-key least-key) || val-from-end-node
				f[least-key, val]
			continue

.find-least-key[k, v] k(current-least-key k, overlays (k, v) array mut[]) k key
	res mut = current-least-key
	for overlay : overlays
		res := res min overlay[0].from
	res

###
Takes the key from the front of every overlay that has it.
Removes rightmost overlays from the mut-array (by returning a new, smaller mut-array).
Returns the rightmost value associated with that key.
###
.take-key[k, v] v?(overlays (k, v?) array mut[], key k) k key
	index mut = 0
	res mut v? = ()
	# Index can overshoot due to removing overlays
	loop
		if index >= overlays.size
			break res
		elif overlays[index][0].from == key
			res := overlays[index][0] to
			new-overlay = overlays[index] tail
			if new-overlay is-empty
				overlays[index] := overlays.last!
				_ = overlays.pop!
				()
			else
				overlays[index] := new-overlay
			index := index + 1
			continue
		else
			index := index + 1
			continue

.get-end[k, v] (k, v) array(a (k, v) impl)
	match a
	as overlay o
		o.prev get-end
	as end-node e
		e

for-loop[out, k, v] out[](a (k, v) compact-sorted-dict, f act out(k, v)) k key
	for pair : a to-list
		f[pair.from, pair.to]

for-loop[k-out, v-out, k-in, v-in] (k-out, v-out) compact-sorted-dict(
	a (k-in, v-in) compact-sorted-dict,
	f act (k-out, v-out)(k-in, v-in),
) k-in key, k-out key
	a for-loop f to-compact-sorted-dict

filter[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict, f act bool(k, v)) k key
	# No need to re-sort
	pairs = a.to-list filter pair =>
		f[pair.from, pair.to]
	(pairs.to-array end-node),

keys[k, v] k[](a (k, v) compact-sorted-dict) k key
	for k, _ : a
		k

map-values[v-out, k, v-in] (k, v-out) compact-sorted-dict(
	a (k, v-in) compact-sorted-dict,
	f act v-out(k, v-in),
) k key
	# No need to re-sort
	new-pairs (k, v-out) array = for pair : a to-list
		pair.from, f[pair.from, pair.to]
	(new-pairs end-node),

# TODO:PRIVATE
dbg[k, v] string(a (k, v) compact-sorted-dict) k to-string, v to-string
	a.impl dbg
.dbg[k, v] string(a (k, v) impl) k to-string, v to-string
	match a
	as overlay o
		pairs = ", " join for x : o.pairs to-list
			to = if t ?= x to
				t to-string
			else
				"_"
			"{x from} -> {to}"
		"{o.prev dbg}, [{pairs}]"
	as end-node e
		pairs = ", " join for x : e.to-list
			"{x from} -> {x to}"
		"[{pairs}]"

verify void(a (nat64, string) compact-sorted-dict, expected string)
	a.dbg is expected

test
	a (nat64, string) compact-sorted-dict = ()
	a.is-empty is true
	a.size is 0
	a verify "[]"
	a[10] is ()

	b = a ~ (10, "10")
	b verify "[10 -> 10]"
	b[10] is ("10",)

	c = b ~~ ((15, "15"), (5, "5"), (20, "20"))
	c verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20]"

	d = c ~ (11, "11")
	d verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	e - 15 is e
	e - 16 is e

	f = e - 10
	f verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> _, 11 -> 11, 15 -> _]"

	g = f ~ (10, "10b")
	g verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> 11, 15 -> _]"

	h = g - 11 - 12
	# Unfortunately we leave an unnecessary '11 -> _',
	# because we don't keep track of what a removal removes from, and it might be removing from the leftmost node.
	h verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> _, 15 -> _]"

	i = h ~~ ((11, "11"), (25, "25"))
	i verify "[5 -> 5, 10 -> 10b, 11 -> 11, 20 -> 20, 25 -> 25]"

	", " join (for key, value : h; "{key} -> {value}") is "5 -> 5, 10 -> 10b, 20 -> 20"

	h-filtered = h filter (k, _) =>
		k is-even
	h-filtered verify "[10 -> 10b, 20 -> 20]"

	h-mapped (nat64, string) compact-sorted-dict = h map-values (_, v) =>
		"{v.end-iter.prev! value}"
	h-mapped verify "[5 -> 5, 10 -> b, 20 -> 0]"

test
	a (nat64, string) compact-sorted-dict = (84, "84"),
	b = a ~ (84, "84b")
	b verify "[84 -> 84b]"
