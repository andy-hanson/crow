no-std
import
	../../bool: !, &&, ==, bool, false, true
	../../compare: <=, >=, compare, max, min
	../../exception: unreachable
	../../fun-util: subscript
	../../misc: is-data, new, void
	../../number: ==, <=>, +, is-even, nat64
	../../option: !, ||, is-empty, new, option, option-equal
	../../pointer: ==, ref-eq
	../../string: ==, ~~, end-iter, join, literal, prev, string, to-string
	../../test-util: is
	../../tuple: from, new, pair, to
	../array:
		~=, ~~=, array, array-builder, begin-pointer, build-array, for-loop, is-empty, mut-iter,
		new, next, peek, size, slice-right, subscript, tail, with-block
	../mut-list: ~=, for-loop, is-empty, last, mut-list, new, pop, size, set-subscript, subscript
	../iter: value
	../list: filter, for-loop, is-empty, list, new, to-array, to-list
	../sort: sort
	../private/sort-utils: binary-search-key

compact-sorted-dict<k, v> record by-val
	.impl impl<k, v>

.impl<k, v> union
	overlay overlay<k, v>
	end-node array (k, v)

.overlay<k, v> record by-ref
	# TODO: consider tracking the number of keys that are new, or change a value, or remove a value.
	# We should merge more frequently if removing keys, less frequently if adding keys.
	# never empty
	pairs array (k, v?)
	prev impl<k, v>

new<k, v> compact-sorted-dict<k, v>(...a array (k, v)) is-data<k> compare<k>
	a.to-list to-compact-sorted-dict

to-compact-sorted-dict<k, v> compact-sorted-dict<k, v>(a (k, v)[]) is-data<k> compare<k>
	sorted = a sort pair => pair from
	(sorted.to-array end-node),

is-empty<k, v> bool(a compact-sorted-dict<k, v>) is-data<k> compare<k>
	match a impl
	as overlay _
		false
	as end-node e
		e is-empty

###
Number of pairs.
This is O(n).
###
size<k, v> nat64(a compact-sorted-dict<k, v>) is-data<k> compare<k>
	res mut = 0
	for _, _ : a
		res := res + 1
	res

to-list<k, v> (k, v)[](a compact-sorted-dict<k, v>) is-data<k> compare<k>
	# TODO:PERF Just use 'fold'?
	match a.compact.impl
	as overlay _
		unreachable
	as end-node e
		e to-list

~ <k, v> compact-sorted-dict<k, v>(a compact-sorted-dict<k, v>, pair (k, v)) is-data<k> compare<k>
	(a.impl add-or-remove pair.from, (pair.to,)),

~~ <k, v> compact-sorted-dict<k, v>(a compact-sorted-dict<k, v>, b (k, v)[]) is-data<k> compare<k>
	if b is-empty
		a
	elif a is-empty
		b to-compact-sorted-dict
	else
		# TODO: type annotation be unnecessary
		pairs (k, v?)[] = (for x : b; x.from, (x.to,)) sort pair => pair from
		# TODO: should not need type annotation
		(pairs.to-array, a.impl)::overlay<k, v>.merge-as-needed,

- <k, v> compact-sorted-dict<k, v>(a compact-sorted-dict<k, v>, key k) is-data<k> compare<k>
	if key in a
		(a.impl add-or-remove key, ()),
	else
		a

subscript<k, v> v?(a compact-sorted-dict<k, v>, key k) is-data<k> compare<k>
	cur mut = a impl
	loop
		match cur
		as overlay o
			if v ?= o.pairs binary-search-key key
				break v
			else
				cur := o prev
				continue
		as end-node e
			break e binary-search-key key

in<k, v> bool(key k, a compact-sorted-dict<k, v>) is-data<k> compare<k>
	!a[key].is-empty

.add-or-remove<k, v> impl<k, v>(a impl<k, v>, key k, value v?) is-data<k> compare<k>
	(((key, value),), a) merge-as-needed

.merge-as-needed<k, v> impl<k, v>(a overlay<k, v>) is-data<k> compare<k>
	match a prev
	as overlay o
		if o.pairs.size should-merge a.pairs.size
			new-pairs = o.pairs merge-overlays a.pairs
			(new-pairs, o.prev) merge-as-needed
		else
			a overlay
	as end-node e
		if e.size should-merge a.pairs.size
			e merge-to-end a.pairs end-node
		else
			a overlay

.merge-unconditionally<k, v> array<(k, v)>(a overlay<k, v>) is-data<k> compare<k>
	match a prev
	as overlay o
		((o.pairs merge-overlays a.pairs), o.prev) merge-unconditionally
	as end-node e
		e merge-to-end a.pairs

.should-merge bool(prev-size nat64, overlay-size nat64)
	prev-size <= (overlay-size max 3)

.merge-overlays<k, v> array<(k, v?)>(left array (k, v?), right array (k, v?)) is-data<k> compare<k>
	with out : left.size + right.size build-array
		l = left mut-iter
		r = right mut-iter
		loop
			if lv ?= l peek
				if rv ?= r peek
					match lv.from <=> rv.from
					as less
						out ~= l.next!
					as equal
						_ = l.next!
						out ~= r.next!
					as greater
						out ~= r.next!
					continue
				else
					out ~~= l slice-right
					break
			else
				out ~~= r slice-right
				break

.merge-to-end<k, v> array<(k, v)>(left array (k, v), right array (k, v?)) is-data<k> compare<k>
	with out : left.size + right.size build-array
		l = left mut-iter
		r = right mut-iter
		loop
			if lv ?= l peek
				if rv ?= r peek
					match lv.from <=> rv.from
					as less
						out ~= l.next!
					as equal
						_ = l.next!
						out add-if-has-value r.next!
					as greater
						out add-if-has-value r.next!
					continue
				else
					out ~~= l slice-right
					break
			else
				for pair : r slice-right
					out add-if-has-value pair
				break
.add-if-has-value<k, v> void(out array-builder (k, v), pair (k, v?))
	if v ?= pair to
		out ~= (pair.from, v)

# Returns an equal dictionary that takes up less space.
compact<k, v> compact-sorted-dict<k, v>(a compact-sorted-dict<k, v>) is-data<k> compare<k>
	node = match a.impl
	as overlay o
		o.merge-unconditionally end-node
	as end-node e
		e end-node
	node,

region iteration

for-loop<k, v> void(a compact-sorted-dict<k, v>, f act void(k, v)) is-data<k> compare<k>
	overlays array<(k, v?)> mut[] = ()
	cur mut = a impl
	end-node mut array (k, v) = loop
		match cur
		as overlay o
			overlays ~= o pairs
			cur := o prev
			continue
		as end-node e
			break e
	loop
		if overlays is-empty
			for pair : end-node
				f[pair from, pair to]
			break
		else
			least-key = (end-node.is-empty ? overlays[0][0].from : end-node[0].from) find-least-key overlays
			take-from-end-node = !end-node.is-empty && least-key == end-node[0].from
			# TODO: should not need 'v?'
			val-from-end-node v? = if take-from-end-node
				end-node[0].to,
			if take-from-end-node
				end-node := end-node tail
			if val ?= (overlays take-key least-key) || val-from-end-node
				f[least-key, val]
			continue

.find-least-key<k, v> k(current-least-key k, overlays array<(k, v)> mut[]) is-data<k> compare<k>
	res mut = current-least-key
	for overlay : overlays
		res := res min overlay[0].from
	res

###
Takes the key from the front of every overlay that has it.
Removes rightmost overlays from the mut-array (by returning a new, smaller mut-array).
Returns the rightmost value associated with that key.
###
.take-key<k, v> v?(overlays array<(k, v?)> mut[], key k) is-data<k> compare<k>
	index mut = 0
	res mut v? = ()
	# Index can overshoot due to removing overlays
	loop
		if index >= overlays.size
			break res
		elif overlays[index][0].from == key
			res := overlays[index][0] to
			new-overlay = overlays[index] tail
			if new-overlay is-empty
				overlays[index] := overlays.last!
				_ = overlays.pop!
				()
			else
				overlays[index] := new-overlay
			index := index + 1
			continue
		else
			index := index + 1
			continue

.get-end<k, v> array<(k, v)>(a impl<k, v>)
	match a
	as overlay o
		o.prev get-end
	as end-node e
		e

for-loop<out, k, v> out[](a compact-sorted-dict<k, v>, f act out(k, v)) is-data<k> compare<k>
	for pair : a to-list
		f[pair.from, pair.to]

for-loop<k-out, v-out, k-in, v-in> compact-sorted-dict<k-out, v-out>(
	a compact-sorted-dict<k-in, v-in>,
	f act (k-out, v-out)(k-in, v-in),
) is-data<k-in> compare<k-in> is-data<k-out> compare<k-out>
	a for-loop f to-compact-sorted-dict

filter<k, v> compact-sorted-dict<k, v>(a compact-sorted-dict<k, v>, f act bool(k, v)) is-data<k> compare<k>
	# No need to re-sort
	pairs = a.to-list filter pair =>
		f[pair.from, pair.to]
	(pairs.to-array end-node),

keys<k, v> k[](a compact-sorted-dict<k, v>) is-data<k> compare<k>
	for k, _ : a
		k

map-values<v-out, k, v-in> compact-sorted-dict<k, v-out>(
	a compact-sorted-dict<k, v-in>,
	f act v-out(k, v-in),
) is-data<k> compare<k>
	# No need to re-sort
	new-pairs array (k, v-out) = for pair : a to-list
		pair.from, f[pair.from, pair.to]
	(new-pairs end-node),

# TODO:PRIVATE
dbg<k, v> string(a compact-sorted-dict<k, v>) to-string<k> to-string<v>
	a.impl dbg
.dbg<k, v> string(a impl<k, v>) to-string<k> to-string<v>
	match a
	as overlay o
		pairs = ", " join for x : o.pairs to-list
			to = if t ?= x to
				t to-string
			else
				"_"
			"{x from} -> {to}"
		"{o.prev dbg}, [{pairs}]"
	as end-node e
		pairs = ", " join for x : e.to-list
			"{x from} -> {x to}"
		"[{pairs}]"

verify void(a compact-sorted-dict<nat64, string>, expected string)
	a.dbg is expected

.array-ref-eq<a> bool(a array a, b array a) unsafe
	a.begin-pointer == b.begin-pointer && a.size == b.size

.exact-eq<k, v> bool(a compact-sorted-dict<k, v>, b compact-sorted-dict<k, v>) unsafe
	match a impl
	as overlay oa
		match b impl
		as overlay ob
			oa ref-eq ob
		as end-node _
			false
	as end-node ea
		match b impl
		as overlay _
			false
		as end-node eb
			ea array-ref-eq eb

.== bool(a string?, b string?)
	a option-equal b

test
	a compact-sorted-dict<nat64, string> = ()
	a.is-empty is true
	a.size is 0
	a verify "[]"
	a[10] is ()

	b = a ~ (10, "10")
	b verify "[10 -> 10]"
	b[10] is ("10",)

	c = b ~~ ((15, "15"), (5, "5"), (20, "20"))
	c verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20]"

	d = c ~ (11, "11")
	d verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	e - 15 exact-eq e is true
	e - 16 exact-eq e is true

	f = e - 10
	f verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> _, 11 -> 11, 15 -> _]"

	g = f ~ (10, "10b")
	g verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> 11, 15 -> _]"

	h = g - 11 - 12
	# Unfortunately we leave an unnecessary '11 -> _',
	# because we don't keep track of what a removal removes from, and it might be removing from the leftmost node.
	h verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> _, 15 -> _]"

	i = h ~~ ((11, "11"), (25, "25"))
	i verify "[5 -> 5, 10 -> 10b, 11 -> 11, 20 -> 20, 25 -> 25]"

	", " join (for key, value : h; "{key} -> {value}") is "5 -> 5, 10 -> 10b, 20 -> 20"

	h-filtered = h filter (k, _) =>
		k is-even
	h-filtered verify "[10 -> 10b, 20 -> 20]"

	h-mapped compact-sorted-dict<nat64, string> = h map-values (_, v) =>
		"{v.end-iter.prev! value}"
	h-mapped verify "[5 -> 5, 10 -> b, 20 -> 0]"

test
	a compact-sorted-dict<nat64, string> = (84, "84"),
	b = a ~ (84, "84b")
	b verify "[84 -> 84b]"
