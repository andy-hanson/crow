no-std
import
	../../bool: ||, ==, bool, false, new, not, true
	../../compare: <=, >, equal, max
	../../fun-util: subscript
	../../exception: unreachable
	../../hash: hash-mix
	../../json: json
	../../misc: key, new, void
	../../number: ==, <=>, +, nat64
	../../option: ==, is-empty, new, option
	../../string: ==, ~~, -, end, literal, new, next, string, to-string
	../../test-util: is
	../../tuple: ==, <=>, a, b, from, new, to, tuple2
	../array:
		~=, ~~=, +, -, array, array-builder, begin, build, collection, end, is-empty, iterate, new,
		next, size, slice
	../collection:
		.., -, build, build-options, end, for-loop, join, slice-right, subscript, with-block
	../mut-priority-queue: ~=, build, mut-priority-queue, pop, pop-if
	../list: ==, ~=, build, is-empty, iterate, list, list-builder, new, size, to-array, to-list
	../sort: sort
	../private/sort-utils: binary-search-key

compact-sorted-dict[k, v] record by-val
	-impl (k, v) impl

-impl[k, v] union
	overlay (k, v) overlay
	end-node (k, v) array

-overlay[k, v] record by-ref
	# TODO: consider tracking the number of keys that are new, or change a value, or remove a value.
	# We should merge more frequently if removing keys, less frequently if adding keys.
	# never empty
	pairs (k, v?) array
	prev (k, v) impl

==[k, v] bool(a (k, v) compact-sorted-dict, b (k, v) compact-sorted-dict) k key, v equal
	a.to-sorted-pairs == b.to-sorted-pairs
-to-sorted-pairs[k, v] (k, v)[](a (k, v) compact-sorted-dict) k key
	a.to-list sort pair => pair from

json[k, v] json(a (k, v) compact-sorted-dict) k key, k json, v json
	a.to-sorted-pairs json

new[k, v] (k, v) compact-sorted-dict(...a (k, v) array) k key
	a.to-list to-compact-sorted-dict

to-compact-sorted-dict[k, v] (k, v) compact-sorted-dict(a (k, v)[]) k key
	(a.to-array sort pair => pair from).end-node,

is-empty[k, v] bool(a (k, v) compact-sorted-dict) k key
	match a impl
	as overlay _
		false
	as end-node e
		e is-empty

###
Number of pairs.
This is O(n).
###
size[k, v] nat64(a (k, v) compact-sorted-dict) k key
	res mut = 0
	for _, _ : a
		res +:= 1
	res

to-list[k, v] (k, v)[](a (k, v) compact-sorted-dict) k key
	match a.compact impl
	as overlay _
		unreachable
	as end-node e
		e to-list

~ ~[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict, pair (k, v)) k key
	(a.impl add-or-remove pair.from, (pair.to,)),

~ ~~[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict, b (k, v)[]) k key
	if b is-empty
		a
	elif a is-empty
		b to-compact-sorted-dict
	else
		pairs (k, v?) array = (for x : b; x.from, (x.to,)) sort pair => pair from
		(pairs, a.impl).merge-as-needed,

~ -[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict, key k) k key
	if key in a
		(a.impl add-or-remove key, ()),
	else
		a

subscript[k, v] v?(a (k, v) compact-sorted-dict, key k) k key
	cur mut = a impl
	loop
		match cur
		as overlay o
			if v ?= o.pairs binary-search-key key
				break v
			else
				cur := o prev
				continue
		as end-node e
			break e binary-search-key key

in[k, v] bool(key k, a (k, v) compact-sorted-dict) k key
	!a[key].is-empty

-add-or-remove[k, v] (k, v) impl(a (k, v) impl, key k, value v?) k key
	(((key, value),), a) merge-as-needed

-merge-as-needed[k, v] (k, v) impl(a (k, v) overlay) k key
	match a prev
	as overlay o
		if o.pairs.size should-merge a.pairs.size
			new-pairs = o.pairs merge-overlays a.pairs
			(new-pairs, o.prev) merge-as-needed
		else
			a overlay
	as end-node e
		if e.size should-merge a.pairs.size
			e merge-to-end a.pairs end-node
		else
			a overlay

-merge-unconditionally[k, v] (k, v) array(a (k, v) overlay) k key
	match a prev
	as overlay o
		((o.pairs merge-overlays a.pairs), o.prev) merge-unconditionally
	as end-node e
		e merge-to-end a.pairs

-should-merge bool(prev-size nat64, overlay-size nat64)
	prev-size <= (overlay-size max 3)

-merge-overlays[k, v] (k, v?) array(left (k, v?) array, right (k, v?) array) k key
	with out : left.size + right.size build
		l mut = left begin
		r mut = right begin
		loop
			if lpair ?= l next
				if rpair ?= r next
					match lpair.a.from <=> rpair.a.from
					as less
						out ~= lpair a
						l := lpair b
					as equal
						out ~= rpair a
						l := lpair b
						r := rpair b
					as greater
						out ~= rpair a
						r := rpair b
					continue
				else
					out ~~= l slice-right
					break
			else
				out ~~= r slice-right
				break

-merge-to-end[k, v] (k, v) array(left (k, v) array, right (k, v?) array) k key
	with out : left.size + right.size build
		l mut = left begin
		r mut = right begin
		loop
			if lpair ?= l next
				if rpair ?= r next
					match lpair.a.from <=> rpair.a.from
					as less
						out ~= lpair a
						l := lpair b
					as equal
						out add-if-has-value rpair.a
						l := lpair b
						r := rpair b
					as greater
						out add-if-has-value rpair.a
						r := rpair b
					continue
				else
					out ~~= l slice-right
					break
			else
				for pair : r slice-right
					out add-if-has-value pair
				break
-add-if-has-value[k, v] void(out (k, v) array-builder, pair (k, v?))
	if v ?= pair to
		out ~= (pair.from, v)

# Returns an equal dictionary that takes up less space.
compact[k, v] (k, v) compact-sorted-dict(a (k, v) compact-sorted-dict) k key
	node = match a.impl
	as overlay o
		o.merge-unconditionally end-node
	as end-node e
		e end-node
	node,

region spec impls (see collection.crow)

iterate[k, v] bool(a (k, v) compact-sorted-dict, f act bool(k, v)) k key
	end-node mut (k, v) array = ()
	# Key has an index because overlays with a lower index (rightmost) should come first
	overlays ((k, nat64), (k, v?) array) mut-priority-queue = with out : build
		cur mut = a impl
		overlay-index mut = 0
		end-node := loop
			match cur
			as overlay o
				out ~= ((o.pairs[0].from, overlay-index), o pairs)
				cur := o prev
				overlay-index +:= 1
				continue
			as end-node e
				break e
	res = overlays iterate-overlays (k, opt-v) =>
		res bool = loop
			if end-node is-empty
				break false
			else
				match end-node[0].from <=> k
				as less
					if f[end-node[0].from, end-node[0].to]
						break true
					else
						end-node := end-node[1 .. end]
						continue
				as equal
					end-node := end-node[1 .. end]
					break false
				as greater
					break false
		if res
			true
		elif v ?= opt-v
			f[k, v]
	res || end-node iterate pair => f[pair from, pair to]

-iterate-overlays[k, v] bool(overlays ((k, nat64), (k, v?) array) mut-priority-queue, f act bool(k, v?)) k key
	loop
		if popped ?= overlays pop
			key k = popped.a a
			overlays drop-overlays-with-key key
			overlays maybe-add-back popped
			if !popped.b.is-empty
				if f[key, popped.b[0] to]
					break true
				else
					continue
			else
				continue
		else
			break false

-maybe-add-back[k, v] void(
	overlays ((k, nat64), (k, v?) array) mut-priority-queue,
	last-popped ((k, nat64), (k, v?) array),
) k key
	if last-popped.b.size > 1
		overlays ~= ((last-popped.b[1].from, last-popped.a.b), last-popped.b[1 .. end])

-drop-overlays-with-key[k, v] void(overlays ((k, nat64), (k, v?) array) mut-priority-queue, key k) k key
	loop
		# TODO: use 'drop-while'
		if popped2 ?= overlays pop-if pair => pair.a.a == key
			overlays maybe-add-back popped2
			continue
		else
			break

-get-end[k, v] (k, v) array(a (k, v) impl)
	match a
	as overlay o
		o.prev get-end
	as end-node e
		e

region build

compact-sorted-dict-builder[k, v] record mut
	-inner (k, v) list-builder
build[k, v] (k, v) compact-sorted-dict(a build-options, f act void((k, v) compact-sorted-dict-builder)) k key
	a build (out => f[(out,)]) to-compact-sorted-dict
+ ~=[k, v] void(a (k, v) compact-sorted-dict-builder, value (k, v)) k key
	a.inner ~= value

region test

-dbg[k, v] string(a (k, v) compact-sorted-dict) k to-string, v to-string
	a.impl dbg
-dbg[k, v] string(a (k, v) impl) k to-string, v to-string
	match a
	as overlay o
		pairs = ", " join for x : o pairs
			to = if t ?= x to
				t to-string
			else
				"_"
			"{x from} -> {to}"
		"{o.prev dbg}, [{pairs}]"
	as end-node e
		pairs = ", " join for x : e
			"{x from} -> {x to}"
		"[{pairs}]"

verify void(a (nat64, string) compact-sorted-dict, expected string)
	a.dbg is expected

test
	a (nat64, string) compact-sorted-dict = ()
	a.is-empty is true
	a.size is 0
	a verify "[]"
	a[10] is ()

	b = a ~ (10, "10")
	b verify "[10 -> 10]"
	b[10] is ("10",)

	c = b ~~ ((15, "15"), (5, "5"), (20, "20"))
	c verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20]"

	d = c ~ (11, "11")
	d verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	e - 15 is e
	e - 16 is e

	f = e - 10
	f verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> _, 11 -> 11, 15 -> _]"

	g = f ~ (10, "10b")
	g verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> 11, 15 -> _]"

	h = g - 11 - 12
	# Unfortunately we leave an unnecessary '11 -> _',
	# because we don't keep track of what a removal removes from, and it might be removing from the leftmost node.
	h verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> _, 15 -> _]"

	i = h ~~ ((11, "11"), (25, "25"))
	i verify "[5 -> 5, 10 -> 10b, 11 -> 11, 20 -> 20, 25 -> 25]"

	", " join (for key, value : h; "{key} -> {value}") is "5 -> 5, 10 -> 10b, 20 -> 20"

	h-mapped (nat64, string) compact-sorted-dict = for k, v : h
		k, "{v[end - 1]}"
	h-mapped verify "[5 -> 5, 10 -> b, 20 -> 0]"

test
	a (nat64, string) compact-sorted-dict = (84, "84"),
	b = a ~ (84, "84b")
	b verify "[84 -> 84b]"
