no-std
import
	../../bool: bool, not
	../../fun-util: subscript
	../../misc: key, new, void
	../../number: nat64
	../../option: is-empty, new, option
	../../tuple: a, b, new
	../array: array
	../collection: for-loop
	../dict: ~=, build, dict, get-or-add, is-empty, iterate, size, subscript, try-remove
	../list: iterate, list, size, to-list

hamt-set[t] record
	-inner void[t]

new[t] t hamt-set(...values t array) t key
	values.to-list to-hamt-set

to-hamt-set[t] t hamt-set(a t[]) t key
	inner void[t] = for x : a; x, ()
	inner,

is-empty[t] bool(a t hamt-set) t key
	a.inner is-empty

size[t] nat64(a t hamt-set) t key
	a.inner size

in[t] bool(value t, a t hamt-set) t key
	!a.inner[value].is-empty

~ ~[t] t hamt-set(a t hamt-set, value t) t key
	if res ?= a try-add value
		res
	else
		a

try-add[t] t hamt-set?(a t hamt-set, value t) t key
	match a.inner get-or-add value, () => ()
	as got _
		()
	as added res
		(res.a,),

~ -[t] t hamt-set(a t hamt-set, value t) t key
	if res ?= a try-remove value
		res
	else
		a

try-remove[t] t hamt-set?(a t hamt-set, value t) t key
	if res ?= a.inner try-remove value
		(res.b,),

region spec impls (see collection.crow)

iterate[t] bool(a t hamt-set, f act bool(t)) t key
	a.inner iterate (k, _) => f[k]
