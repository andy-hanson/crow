no-std
import
	../../bool: !, bool
	../../compare: compare
	../../fun-util: subscript
	../../hash: hash-mix
	../../misc: is-data, new, void
	../../number: nat64
	../../option: is-empty, new, option
	../../tuple: a, new
	../dict: dict, for-loop, get-or-add, is-empty, new, rest, size, subscript, to-dict, try-remove
	../list: for-loop, list

hamt-set[t] record
	.inner void[t]

new[t] t hamt-set() t is-data, t compare, t hash-mix
	(),

to-hamt-set[t] t hamt-set(a t[]) t is-data, t compare, t hash-mix
	((for x : a; x, ()) to-dict),

is-empty[t] bool(a t hamt-set) t is-data, t compare, t hash-mix
	a.inner is-empty

size[t] nat64(a t hamt-set) t is-data, t compare, t hash-mix
	a.inner size

in[t] bool(value t, a t hamt-set) t is-data, t compare, t hash-mix
	!a.inner[value].is-empty

~[t] t hamt-set(a t hamt-set, value t) t is-data, t compare, t hash-mix
	if res ?= a try-add value
		res
	else
		a

try-add[t] t hamt-set?(a t hamt-set, value t) t is-data, t compare, t hash-mix
	match a.inner get-or-add value, () => ()
	as got _
		()
	as added res
		(res.a,),

-[t] t hamt-set(a t hamt-set, value t) t is-data, t compare, t hash-mix
	if res ?= a try-remove value
		res
	else
		a

try-remove[t] t hamt-set?(a t hamt-set, value t) t is-data, t compare, t hash-mix
	if res ?= a.inner try-remove value
		(res.rest,),

region iteration

for-loop[t] void(a t hamt-set, f act void(t)) t is-data, t compare, t hash-mix
	for k, _ : a inner
		f[k]
