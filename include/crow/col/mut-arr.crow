no-std
import
	string: memcpy
	../bool: !, bool
	../compare: !=, <, <=, equal
	../fun: subscript
	../misc: ->, arrow, drop, from, to, void
	../opt: opt, some
	../ptr: ==, <=>, +, -, as-any-ptr, ptr, set-subscript, size-of, subscript
	../private/alloc: alloc-uninitialized, fill-ptr-range, set-zero-range
	../private/exception-low-level: assert, forbid
	../private/number-low-level: ==, <=>, nat64, wrap-mul, wrap-sub
	./arr: arr, arr-from-begin-end, begin-ptr, size, subscript
	./arr-util: each, each-with-index, exists, find-index, fold, fold-reverse

###
Like `arr` but mutable.
`mut-arr` is fixed-size, unlike `mut-list`. It can change elements but can't add or remove them.
###
mut-arr<a> record mut
	by-val
	# Adding a dummy field so the constructor won't conflict with mut-arr from arr
	ignore void
	# TODO:PRIVATE
	inner a[]

# Empty `mut-arr`.
mut-arr<a> mut-arr a() noctx
	mut-arr: void, []

# `mut-arr` from a pointer and size.
mut-arr<a> mut-arr a(size nat64, begin-ptr ptr a) noctx unsafe
	mut-arr: void, arr: size, begin-ptr

###
Copies an `arr` to a `mut-arr`.
Writing to the result won't affect the original.
###
mut-arr<a> mut-arr a(a a[])
	a.size make-mut-arr<a> i => a[i]

###
Copies a `mut-arr` to an `arr`.
Further writes to the `mut-arr` won't affect the `arr` that was copied from it.
###
arr<a> a[](a mut-arr a)
	a.copy.inner

mut-arr-from-begin-end<a> mut-arr a(begin ptr a, end ptr a) unsafe
	assert: begin <= end
	mut-arr: void, arr-from-begin-end: begin, end

###
Copies the elements of a `mut-arr`.
Writing to the result won't affect the original.
###
copy<a> mut-arr a(a mut-arr a)
	a.size make-mut-arr<a> i => a[i]

copy-to-arr<a> a[](a mut-arr a) trusted
	a.copy cast-immutable

copy-from!<a> void(dest mut-arr a, source a[]) trusted
	assert: dest.size == source.size
	drop: memcpy: dest.begin-ptr.as-any-ptr, source.begin-ptr.as-any-ptr, dest.size wrap-mul size-of<a>

copy-from!<a> void(dest mut-arr a, source mut-arr a) trusted
	dest copy-from! source.cast-immutable

is-empty<a> bool(a mut-arr a) noctx
	a.size == 0

size<a> nat64(a mut-arr a) noctx
	a.inner size

# Pointer to the beginning of the `mut-arr`.
begin-ptr<a> ptr a(a mut-arr a) noctx unsafe
	a.inner begin-ptr

###
Pointer to the end of the `mut-arr`.
This is one past the last valid pointer.
###
end-ptr<a> ptr a(a mut-arr a) noctx unsafe
	a.begin-ptr + a.size

###
Gets the element at the index.
Throws if `index >= a.size`.
###
subscript<a> a(a mut-arr a, index nat64) trusted
	assert: index < a.size
	a unsafe-at index

unsafe-at<a> a(a mut-arr a, index nat64) unsafe
	a.begin-ptr[index]

###
Slices the mut-arr.
This is O(1).
Writes to the slice will affect the original. (If you don't want that, use `copy`.)
Throws if `range.from > range.to`.
Throws if the slice would exceed the bounds of the `mut-arr`.
###
subscript<a> mut-arr a(a mut-arr a, range arrow<nat64, nat64>)
	assert: range.from <= range.to
	assert: range.to <= a.size
	mut-arr: void, a.inner[range]

###
Write to a single element.
Throws if `index >= a.size`.
###
set-subscript<a> void(a mut-arr a, index nat64, value a) trusted
	assert: index < a.size
	a unsafe-set-at! index, value

unsafe-set-at!<a> void(a mut-arr a, index nat64, value a) unsafe
	a.begin-ptr[index] := value


first<a> a?(a mut-arr a)
	if !a.is-empty
		a[0] some

last<a> a?(a mut-arr a)
	if !a.is-empty
		a[0] some

tail<a> mut-arr a(a mut-arr a)
	forbid: a is-empty
	a[1 -> a.size]

rtail<a> mut-arr a(a mut-arr a)
	forbid: a is-empty
	a[0 -> (a.size wrap-sub 1)]

# Allocates a `mut-arr` without initializing any of its elements.
uninitialized-mut-arr<a> mut-arr a(size nat64) unsafe
	mut-arr: size, alloc-uninitialized<a>: size

###
`mut-arr` where each element is `f[i]`.
Equivalent to `mut-arr: [f[0], f[1], ...]`.
###
make-mut-arr<a> mut-arr a(size nat64, f act a(nat64)) trusted
	res = size uninitialized-mut-arr<a>
	res.begin-ptr fill-ptr-range size, f
	res

###
`mut-arr` where every element is `value`.
Equivalent to `mut-arr: [value, value, ...]`.
###
fill-mut-arr<a> mut-arr a(size nat64, value a)
	size make-mut-arr ignore => value

zeroed-mut-arr<a> mut-arr a(size nat64) unsafe
	res = size uninitialized-mut-arr<a>
	res set-zero-elements
	res

fill!<a> void(a mut-arr a, value a)
	a map! ignore => value

###
Unsafe cast a mut-arr to arr.
Called "temp" because it is UB if the mut-arr is written to while the `arr` is in use.
###
temp-as-arr<a> a[](a mut-arr a) noctx unsafe
	a inner

###
Unsafe cast a mut-arr to arr.
Equivalent to `temp-as-arr`, but the implication is that
the `mut-arr` will never be written to again, so the `arr` can be used forever.
###
cast-immutable<a> a[](a mut-arr a) noctx unsafe
	a inner

###
Fill the `mut-arr` with 0 bits.
This prevents the garbage collector from tracing those elements.
Data structures that use a `mut-arr` should `set-zero-elements` on any elements they don't use.
###
set-zero-elements<a> void(a mut-arr a) noctx unsafe
	a.begin-ptr set-zero-range a.size

# Equivalent to `a.temp-as-arr index-of value`.
index-of<a> nat64?(a mut-arr a, value a) equal<a>
	a find-index x => x == value

# Equivalent to `a.temp-as-arr find-index f`.
find-index<a> nat64?(a mut-arr a, f act bool(a)) trusted
	a.temp-as-arr find-index f

reverse!<a> void(a mut-arr a) trusted
	a.begin-ptr reverse-recur! a.end-ptr - 1
.reverse-recur!<a> void(left ptr a, right ptr a) unsafe
	if left < right
		tmp = left[]
		left[] := right[]
		right[] := tmp
		left + 1 reverse-recur! right - 1

region iteration

exists<a> bool(a mut-arr a, f act bool(a)) trusted
	a.temp-as-arr exists f

# Calls 'f' on each element in the mut-arr.
each<a> void(a mut-arr a, f act void(a)) trusted
	a.temp-as-arr each f

each-with-index<a> void(a mut-arr a, f act void(a, nat64)) trusted
	a.temp-as-arr each-with-index f

fold<a, b> a(acc a, a mut-arr b, f act a(a, b)) trusted
	acc fold a.temp-as-arr, f
fold-reverse<a, b> a(acc a, a mut-arr b, f act a(a, b)) trusted
	acc fold-reverse a.temp-as-arr, f

map!<a> void(a mut-arr a, f act a(a)) trusted
	a.begin-ptr map-recur! a.end-ptr, f
.map-recur!<a> void(cur ptr a, end ptr a, f act a(a)) unsafe
	if cur != end
		cur[] := f[cur[]]
		cur + 1 map-recur! end, f

map<out, in> mut-arr out(a mut-arr in, f act out(in)) trusted
	a.size make-mut-arr i => f[a[i]]

map-with-index<out, in> mut-arr out(a mut-arr in, f act out(in, nat64)) trusted
	a.size make-mut-arr i => f[a[i], i]

map-to-arr<out, in> out[](a mut-arr in, f act out(in)) trusted
	a map f cast-immutable

map-to-arr-with-index<out, in> out[](a mut-arr in, f act out(in, nat64)) trusted
	a map-with-index f cast-immutable
