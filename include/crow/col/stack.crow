no-std
import
	../bool: bool
	../cell: *, cell, new, set-deref
	../compare: !=
	../fun-util: subscript
	../misc: new, void
	../number: ==, +, nat64
	../option: !, ==, is-empty, new, option, option-equal
	../pointer: ==, +, mut-pointer, set-deref
	../string: ==, literal, string
	../test-util: is
	../test-util/spy: calls, fn, new, spy-act1
	./array: array
	./mut-array: begin-pointer, cast-immutable, end-pointer, mut-array, uninitialized-mut-array
	./list: ==, fold, list, new, to-list

###
Immutable stack type.
Iteration functions move from the bottom to the top.
###
stack<a> record
	.last-node node<a>?

.node<a> record
	prev node<a>?
	value a

###
Stack containing the given elements.

The first element of `a` goes on the bottom and the last element of `a` goes on the top.
###
new<a> stack a(...a array a)
	a.to-list to-stack

###
Stack containing the given elements.

The first element of `a` goes on the bottom and the last element of `a` goes on the top.
###
to-stack<a> stack a(a a[])
	# TODO: type annotation should not be necessary
	empty stack a = (()::node<a>?,)
	empty fold a, (stack, x) => stack ~ x

# Copy elements a list.
to-list<a> a[](a stack a) trusted
	for x : a; x

# `true` iff `a.size == 0`.
is-empty<a> bool(a stack a)
	a.last-node is-empty

###
Appends an element to the stack.
This is O(1).
###
~ <a> stack a(a stack a, b a)
	# TODO: type annotation should not be necessary
	((a.last-node, b),)::node<a>?,

###
Number of elements in the stack.
This is O(1).
###
size<a> nat64(a stack a)
	0 fold a, (acc, _) => acc + 1

###
Top element.
Returns an empty option iff `a` is empty.
This is O(1).
###
peek<a> a?(a stack a)
	if node ?= a last-node
		node.value,

popped<a> record
	value a
	rest stack a

###
Returns the top element of the stack and a new stack with all elements but the top.
Returns an empty option iff `a` is empty.
###
pop<a> popped<a>?(a stack a)
	if node ?= a last-node
		(node.value, (node.prev,)),

region iteration

for-loop<a> void(a stack a, f act void(a))
	a.last-node for-loop-recur f
.for-loop-recur<a> void(a node<a>?, f act void(a))
	if node ?= a
		node.prev for-loop-recur f
		f[node value]


reversed-stack<a> record
	.inner stack a
reversed<a> reversed-stack a(a stack a)
	a,

for-loop<a> void(a reversed-stack a, f act void(a))
	cur mut = a.inner last-node
	loop
		if node ?= cur
			f[node value]
			cur := node prev
			continue
		else
			break

for-loop<out, in> out[](a reversed-stack in, f act out(in)) trusted
	res mut-array out = a.inner.size uninitialized-mut-array
	out cell out mut* = res.begin-pointer,
	for x : a
		*(*out) := f[x]
		*out := *out + 1
	assert *out == res.end-pointer
	res.cast-immutable to-list

# Copy elements to a list, from top to bottom.
to-list<a> a[](a reversed-stack a) trusted
	for x : a
		x

fold<a, b> a(acc a, a reversed-stack b, f act a(a, b))
	acc fold-reverse-recur a.inner.last-node, f
.fold-reverse-recur<a, b> a(acc a, a node<b>?, f act a(a, b))
	if node ?= a
		f[acc, node.value] fold-reverse-recur node.prev, f
	else
		acc

# Call a function for each element in the stack and accumulate.
fold<a, b> a(acc a, a stack b, f act a(a, b))
	acc fold-recur a.last-node, f
.fold-recur<a, b> a(acc a, a node<b>?, f act a(a, b))
	if node ?= a
		prev-val = acc fold-recur node.prev, f
		f[prev-val, node.value]
	else
		acc

for-loop<out, in> out[](a stack in, f act out(in)) trusted
	res mut-array out = a.size uninitialized-mut-array
	out cell out mut* = res.begin-pointer,
	for x : a
		*(*out) := f[x]
		*out := *out + 1
	assert *out == res.end-pointer
	res.cast-immutable to-list

# Produce a stack with `f[x]` applied to each element `x` in the input.
for-loop<out, in> stack out(a stack in, f act out(in))
	(a.last-node map-recur f),
.map-recur<out, in> node<out>?(a node<in>?, f act out(in))
	if node ?= a
		((node.prev map-recur f), f[node value]),

filter<a> stack a(a stack a, f act bool(a))
	(a.last-node filter-recur f),
.filter-recur<a> node<a>?(a node<a>?, f act bool(a))
	if node ?= a
		prev = node.prev filter-recur f
		if f[node value]
			(prev, node.value),
		else
			prev

find-and-get<out, in> out?(a stack in, f act out?(in))
	a.last-node find-and-get-recur f
.find-and-get-recur<out, in> out?(a node<in>?, f act out?(in))
	if node ?= a
		if x ?= node.prev find-and-get-recur f
			x,
		else
			f[node value]

test
	a stack nat64 = ()
	assert a is-empty
	a.to-list is ()
	a.peek is ()

	b = a ~ 1
	b.to-list is (1,)
	b.peek is (1,)
	b.pop!.rest.to-list is ()
	forbid b is-empty

	c = b ~ 2
	c.to-list is (1, 2)
	c.peek is (2,)
	c.pop!.rest.to-list is (1,)

	d = c ~ 3
	d.to-list is (1, 2, 3)

	for-loop-spy spy-act1<void, nat64> = (_ => ()),
	d for-loop for-loop-spy.fn
	for-loop-spy.calls is (1, 2, 3)

	for x : d.reversed; for-loop-spy.fn[x]
	for-loop-spy.calls is (3, 2, 1)

	(for x : d; x + 10)::nat64[] is (11, 12, 13)

	d3 = d filter x => x != 2
	d3.to-list is (1, 3)

	folded = 5 fold d, (x, y) => x + y
	folded is 11

	(d find-and-get x => x if-eq 2, "two") is ("two",)
	(d find-and-get x => x if-eq 5, "five") is ()

.== bool(a string?, b string?)
	a option-equal b

.if-eq string?(actual nat64, expected nat64, result string)
	if actual == expected
		result,
