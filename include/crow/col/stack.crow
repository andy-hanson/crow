no-std
import
	../bool: bool
	../compare: !=
	../fun-util: subscript
	../json: json
	../misc: new, void
	../number: ==, +, nat64
	../option: !, ==, is-empty, new, option
	../pointer: ==, +, mut-pointer, set-deref
	../string: ==, literal, string
	../test-util: is
	../test-util/spy: calls, fn, new, spy-act1
	./array: array
	./mut-array: begin-pointer, cast-immutable, end-pointer, mut-array, uninitialized-mut-array
	./list: ==, for-loop, list, new, to-list

###
Immutable stack type.
Iteration functions move from the bottom to the top.
###
stack[t] record
	.last-node t node?

.node[t] record
	prev t node?
	value t

###
Stack containing the given elements.

The first element of `a` goes on the bottom and the last element of `a` goes on the top.
###
new[t] t stack(...a t array)
	a.to-list to-stack

###
Stack containing the given elements.

The first element of `a` goes on the bottom and the last element of `a` goes on the top.
###
to-stack[t] t stack(a t[])
	res mut t stack = ()::(t node?),
	for x : a
		res := res ~ x
	res

# Copy elements a list.
to-list[t] t[](a t stack) trusted
	for x : a; x

# `true` iff `a.size == 0`.
is-empty[t] bool(a t stack)
	a.last-node is-empty

###
Appends an element to the stack.
This is O(1).
###
~[t] t stack(a t stack, b t)
	# TODO: type annotation should not be necessary
	((a.last-node, b),)::(t node?),

###
Number of elements in the stack.
This is O(1).
###
size[t] nat64(a t stack)
	res mut = 0
	for _ : a
		res := res + 1
	res

###
Top element.
Returns an empty option iff `a` is empty.
This is O(1).
###
peek[t] t?(a t stack)
	if node ?= a last-node
		node.value,

popped[t] record
	value t
	rest t stack

###
Returns the top element of the a stacknd a new stack with all elements but the top.
Returns an empty option iff `a` is empty.
###
pop[t] t popped?(a t stack)
	if node ?= a last-node
		(node.value, (node.prev,)),

region iteration

for-loop[t] void(a t stack, f act void(t))
	a.last-node for-loop-recur f
.for-loop-recur[t] void(a t node?, f act void(t))
	if node ?= a
		node.prev for-loop-recur f
		f[node value]

reversed-stack[t] record
	.inner t stack
reversed[t] t reversed-stack(a t stack)
	a,

for-loop[t] void(a t reversed-stack, f act void(t))
	cur mut = a.inner last-node
	loop
		if node ?= cur
			f[node value]
			cur := node prev
			continue
		else
			break

for-loop[out, in] out[](a in reversed-stack, f act out(in)) trusted
	res out mut-array = a.inner.size uninitialized-mut-array
	out mut out mut* = res begin-pointer
	for x : a
		*out := f[x]
		out := out + 1
	assert out == res.end-pointer
	res.cast-immutable to-list

# Copy elements to a list, from top to bottom.
to-list[t] t[](a t reversed-stack) trusted
	for x : a
		x

for-loop[out, in] out[](a in stack, f act out(in)) trusted
	res out mut-array = a.size uninitialized-mut-array
	out mut out mut* = res begin-pointer
	for x : a
		*out := f[x]
		out := out + 1
	assert out == res.end-pointer
	res.cast-immutable to-list

# Produce a stack with `f[x]` applied to each element `x` in the input.
for-loop[out, in] out stack(a in stack, f act out(in))
	(a.last-node map-recur f),
.map-recur[out, in] out node?(a in node?, f act out(in))
	if node ?= a
		((node.prev map-recur f), f[node value]),

filter[t] t stack(a t stack, f act bool(t))
	(a.last-node filter-recur f),
.filter-recur[t] t node?(a t node?, f act bool(t))
	if node ?= a
		prev = node.prev filter-recur f
		if f[node value]
			(prev, node.value),
		else
			prev

find-and-get[out, in] out?(a in stack, f act out?(in))
	a.last-node find-and-get-recur f
.find-and-get-recur[out, in] out?(a in node?, f act out?(in))
	if node ?= a
		if x ?= node.prev find-and-get-recur f
			x,
		else
			f[node value]

test
	a nat64 stack = ()
	assert a is-empty
	a.to-list is ()
	a.peek is ()

	b = a ~ 1
	b.to-list is (1,)
	b.peek is (1,)
	b.pop!.rest.to-list is ()
	forbid b is-empty

	c = b ~ 2
	c.to-list is (1, 2)
	c.peek is (2,)
	c.pop!.rest.to-list is (1,)

	d = c ~ 3
	d.to-list is (1, 2, 3)

	for-loop-spy (void, nat64) spy-act1 = (_ => ()),
	d for-loop for-loop-spy.fn
	for-loop-spy.calls is (1, 2, 3)

	for x : d.reversed; for-loop-spy.fn[x]
	for-loop-spy.calls is (3, 2, 1)

	(for x : d; x + 10)::nat64[] is (11, 12, 13)

	d3 = d filter x => x != 2
	d3.to-list is (1, 3)

	(d find-and-get x => x if-eq 2, "two") is ("two",)
	(d find-and-get x => x if-eq 5, "five") is ()

.if-eq string?(actual nat64, expected nat64, result string)
	if actual == expected
		result,
