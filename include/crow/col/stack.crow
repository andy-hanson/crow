no-std
import
	../bool: bool
	../compare: !=
	../fun-util: subscript
	../json: json
	../misc: new, void
	../number: ==, +, nat64
	../option: ==, force, is-empty, new, option
	../test-util: is
	../tuple: a, b, new, pair
	./array: array
	./list: ~=, ==, build, for-loop, list, new, to-list, with-block

###
Immutable stack type.
Iteration functions move from the bottom to the top.
###
!stack[t] record
	.last-node t node?

.node[t] record
	prev t node?
	value t

###
Stack containing the given elements.

The first element of `a` goes on the bottom and the last element of `a` goes on the top.
###
!new[t] t stack(...a t array)
	a.to-list to-stack

###
Stack containing the given elements.

The first element of `a` goes on the bottom and the last element of `a` goes on the top.
###
!to-stack[t] t stack(a t[])
	res mut t stack = ()::(t node?),
	for x : a
		res := res ~ x
	res

# Copy elements a list.
!to-list[t] t[](a t stack)
	for x : a; x

# `true` iff `a.size == 0`.
!is-empty[t] bool(a t stack)
	a.last-node is-empty

###
Appends an element to the stack.
This is O(1).
###
!~[t] t stack(a t stack, b t)
	# TODO: type annotation should not be necessary
	((a.last-node, b),)::(t node?),

###
Number of elements in the stack.
This is O(1).
###
!size[t] nat64(a t stack)
	res mut = 0
	for _ : a
		res := res + 1
	res

###
Top element.
Returns an empty option iff `a` is empty.
This is O(1).
###
!peek[t] t?(a t stack)
	if node ?= a last-node
		node.value,

###
Returns the top element of the a stacknd a new stack with all elements but the top.
Returns an empty option iff `a` is empty.
###
!pop[t] (t stack, t)?(a t stack)
	if node ?= a last-node
		((node.prev,), node.value),

region iteration

!for-loop[t] void(a t stack, f act void(t))
	a.last-node for-loop-recur f
.for-loop-recur[t] void(a t node?, f act void(t))
	if node ?= a
		node.prev for-loop-recur f
		f[node value]

!reversed-stack[t] record
	.inner t stack
reversed[t] t reversed-stack(a t stack)
	a,

!for-loop[t] void(a t reversed-stack, f act void(t))
	cur mut = a.inner last-node
	loop
		if node ?= cur
			f[node value]
			cur := node prev
			continue
		else
			break

!for-loop[out, in] out[](a in reversed-stack, f act out(in)) 
	with out : a.inner.size build
		for x : a
			out ~= f[x]

# Copy elements to a list, from top to bottom.
!to-list[t] t[](a t reversed-stack)
	for x : a
		x

!for-loop[out, in] out[](a in stack, f act out(in))
	with out : a.size build
		for x : a
			out ~= f[x]

# Produce a stack with `f[x]` applied to each element `x` in the input.
!for-loop[out, in] out stack(a in stack, f act out(in))
	(a.last-node map-recur f),
.map-recur[out, in] out node?(a in node?, f act out(in))
	if node ?= a
		((node.prev map-recur f), f[node value]),

!filter[t] t stack(a t stack, f act bool(t))
	(a.last-node filter-recur f),
.filter-recur[t] t node?(a t node?, f act bool(t))
	if node ?= a
		prev = node.prev filter-recur f
		if f[node value]
			(prev, node.value),
		else
			prev

test
	a nat64 stack = ()
	assert a is-empty
	a.to-list is ()
	a.peek is ()

	b = a ~ 1
	b.to-list is (1,)
	b.peek is (1,)
	b-popped = b.pop!
	b.pop!.a.to-list is ()
	b-popped.b is 1
	forbid b is-empty

	c = b ~ 2
	c.to-list is (1, 2)
	c.peek is (2,)
	c-popped = c.pop!
	c-popped.a.to-list is (1,)
	c-popped.b is 2

	d = c ~ 3
	d.to-list is (1, 2, 3)

	(for x : d; x)::nat64[] is (1, 2, 3)

	(for x : d.reversed; x)::nat64[] is (3, 2, 1)

	(for x : d; x + 10)::nat64[] is (11, 12, 13)

	d3 = d filter x => x != 2
	d3.to-list is (1, 3)
