no-std
import
	../bool: !, &&, ||, bool
	../compare: !=, >, >=, compare
	../exception: assert, forbid
	../fun: subscript
	../hash: hash, hash-mix
	../misc: ->, arrow, data, drop, from, to, void
	../opt: ==, is-empty, none, opt, some
	../ptr: ==, +, *, mut-ptr, set-deref
	../str: ==, str
	../str-conv: finish, interp, to-str, with-str, with-value
	../test: is
	../writer: ~=, backup!, move-to-str!, writer
	../private/number-low-level: ==, <=>, nat64, unsafe-mod, wrap-add, wrap-mul, wrap-sub
	./arr: ==, arr, size
	./arr-util: each, map
	./dict: dict
	./fix-arr:
		begin-ptr, cast-immutable, each, end-ptr, fill!, fill-fix-arr, fold, is-empty, map,
		fix-arr, set-subscript, size, subscript, uninitialized-fix-arr
	./mut-arr:
		~=, copy, each, filter!, find-index, fold, is-at-capacity, is-empty, map!, mut-arr,
		remove-unordered-at!, set-subscript, size, subscript

mut-dict<k, v> record mut
	# TODO:PRIVATE
	ignore void
	entries mut fix-arr entry<k, v>
	total-size mut nat64

.entry<k, v> union mut
	none
	arrow<k, v>
	mut-arr<arrow<k, v>>

mut-dict<k, v> v mut[k]() data<k> compare<k> hash-mix<k>
	void mut-dict fix-arr, 0

mut-dict<k, v> v mut[k](a arrow<k, v>[]) data<k> compare<k> hash-mix<k>
	res = a.size mut-dict-with-capacity<k, v>
	a each pair =>
		res[pair from] := pair to
	res

###
New dict with `capacity` empty entries.
WARN: Due to hash conflicts, this doesn't guarantee that allocations won't be needed.
###
mut-dict-with-capacity<k, v> v mut[k](capacity nat64) data<k> compare<k> hash-mix<k>
	void mut-dict (capacity fill-fix-arr none), 0

arr<k, v> arrow<k, v>[](a v mut[k]) data<k> compare<k> hash-mix<k>
	a map-to-arr (key, value) => key -> value

copy<k, v> v mut[k](a v mut[k]) data<k> compare<k> hash-mix<k>
	entries fix-arr entry<k, v> = a.entries map entry =>
		match entry
		as none
			none
		as arrow ar
			ar
		as mut-arr m
			m copy
	void mut-dict entries, a.total-size
test
	a = [1 -> "1", 2 -> "2", 5 -> "5"] mut-dict
	a verify "_ (1 -> 1) [2 -> 2, 5 -> 5]"

	b = a copy
	b verify "_ (1 -> 1) [2 -> 2, 5 -> 5]"

	a[6] := "6"
	a verify "(6 -> 6) (1 -> 1) [2 -> 2, 5 -> 5]"
	b verify "_ (1 -> 1) [2 -> 2, 5 -> 5]"

is-empty<k, v> bool(a v mut[k]) data<k> compare<k> hash-mix<k>
	a.size == 0

size<k, v> nat64(a v mut[k]) data<k> compare<k> hash-mix<k>
	a total-size

subscript<k, v> v?(a v mut[k], key k) trusted data<k> compare<k> hash-mix<k>
	if !a.is-empty
		match a.entries[key.hash unsafe-mod a.entries.size]
		as none
			none
		as arrow ar
			if ar.from == key
				ar.to some
		as mut-arr m
			if index ?= m find-index pair => pair.from == key
				m[index].to some

in<k, v> bool(key k, a v mut[k]) data<k> compare<k> hash-mix<k>
	!a[key].is-empty

set-subscript<k, v> void(a v mut[k], key k, value v) data<k> compare<k> hash-mix<k>
	drop: a update! key, value.some

empty!<k, v> void(a v mut[k]) data<k> compare<k> hash-mix<k>
	a.entries fill! none
	a.total-size := 0

swap!<k, v> void(a v mut[k], b v mut[k]) data<k> compare<k> hash-mix<k>
	temp-entries = a.entries
	a.entries := b.entries
	b.entries := temp-entries
	temp-size = a.total-size
	a.total-size := b.total-size
	b.total-size := temp-size

remove-key!<k, v> v?(a v mut[k], key k) data<k> compare<k> hash-mix<k>
	a update! key, none

###
f: Takes the value (if it exists), returns the new value (or none to remove).
Returns the old value (if it exists).
###
.update!<k, v> v?(a v mut[k], key k, new-value v?) trusted data<k> compare<k> hash-mix<k>
	if a.entries is-empty
		if value ?= new-value
			a.entries := fix-arr: [key -> value]
			a.total-size := 1
		none
	else
		entry-index = key.hash unsafe-mod a.entries.size
		match a.entries[entry-index]
		as none
			if value ?= new-value
				a.entries[entry-index] := key -> value
				a.total-size := a.total-size wrap-add 1
			none
		as arrow ar
			if ar.from == key
				a.entries[entry-index] := if value ?= new-value
					key -> value
				else
					a.total-size := a.total-size wrap-sub 1
					none
				ar.to some
			else
				if value ?= new-value
					if a should-expand
						a expand!
						a[key] := value
					else
						a.entries[entry-index] := mut-arr: [ar, key -> value]
						a.total-size := a.total-size wrap-add 1
				none
		as mut-arr m
			if index ?= m find-index pair => pair.from == key
				old-value = m[index] to
				if value ?= new-value
					m[index] := key -> value
				else
					drop: m remove-unordered-at! index
					if m is-empty
						a.entries[entry-index] := none
					elif m.size == 1
						# TODO: should not need a local
						z = m[0]
						a.entries[entry-index] := z
					a.total-size := a.total-size wrap-sub 1
				old-value some
			else
				if value ?= new-value
					if m.is-at-capacity && a.should-expand
						a expand!
						a[key] := value
					else
						m ~= key -> value
						a.total-size := a.total-size wrap-add 1
				none

~= <k, v> void(a v mut[k], b arrow<k, v>) data<k> compare<k> hash-mix<k>
	a[b from] := b to

~= <k, v> void(a v mut[k], b arrow<k, v>[]) data<k> compare<k> hash-mix<k>
	b each pair =>
		a ~= pair

# Called when we're about to allocate a bigger bucket -- maybe we should expand the table instead
.should-expand<k, v> bool(a v mut[k])
	a.total-size >= a.entries.size

.expand!<k, v> void(a v mut[k]) data<k> compare<k> hash-mix<k>
	forbid: a.entries.size == 0
	new-size = a.entries.size wrap-mul 2
	bigger = new-size mut-dict-with-capacity<k, v>
	a each (key, value) =>
		bigger[key] := value
	a swap! bigger
	assert: a.entries.size == new-size

region iteration

each<k, v> void(a v mut[k], f act void(k, v)) data<k> compare<k> hash-mix<k>
	void fold a, (ignore, key, value) => f[key, value]

fold<a, k, v> a(acc a, a v mut[k], f act a(a, k, v)) data<k> compare<k> hash-mix<k>
	acc fold a.entries, (cur, entry) =>
		match entry
		as none
			cur
		as arrow ar
			f[cur, ar.from, ar.to]
		as mut-arr m
			cur fold m, (cur2, pair) => f[cur2, pair.from, pair.to]

filter!<k, v> void(a v mut[k], f act bool(k, v)) trusted data<k> compare<k> hash-mix<k>
	a.entries.begin-ptr filter-recur! a.entries.end-ptr, f
.filter-recur!<k, v> void(entry-ptr entry<k, v> mut*, entry-end entry<k, v> mut*, f act bool(k, v)) unsafe
	if entry-ptr != entry-end
		match *entry-ptr
		as none
			void
		as arrow ar
			if !f[ar.from, ar.to]
				*entry-ptr := none
		as mut-arr m
			m filter! pair => f[pair.from, pair.to]
			if m is-empty
				*entry-ptr := none
			elif m.size == 1
				# TODO: should not need a local
				z = m[0]
				*entry-ptr := z
		entry-ptr + 1 filter-recur! entry-end, f


map-to-arr<out, k, v> out[](a v mut[k], f act out(k, v)) trusted data<k> compare<k> hash-mix<k>
	out = a.size uninitialized-fix-arr<out>
	end = out.begin-ptr fold a, (cur, key, value) =>
		*cur := f[key, value]
		cur + 1
	assert: end == out.end-ptr
	out cast-immutable

move-to-dict!<k, v> v[k](a v mut[k]) data<k> compare<k> hash-mix<k>
	res = a map-to-arr ((k, v) => k -> v) dict
	a empty!
	res

map-values!<k, v> void(a v mut[k], f act v(k, v)) trusted data<k> compare<k> hash-mix<k>
	a.entries.begin-ptr map-values-recur! a.entries.end-ptr, f
.map-values-recur!<k, v> void(entry-ptr entry<k, v> mut*, entry-end entry<k, v> mut*, f act v(k, v)) unsafe
	if entry-ptr != entry-end
		match *entry-ptr
		as none
			void
		as arrow ar
			*entry-ptr := ar.from -> f[ar.from, ar.to]
		as mut-arr m
			m map! pair => pair.from -> f[pair.from, pair.to]
		entry-ptr + 1 map-values-recur! entry-end, f

.dbg str(a str mut[nat64])
	out = writer
	a.entries each entry =>
		match entry
		as none
			out ~= "_"
		as arrow ar
			out ~= "("
			out ~= ar.from to-str
			out ~= " -> "
			out ~= ar to
			out ~= ")"
		as mut-arr m
			out ~= "["
			m each pair =>
				out ~= pair.from to-str
				out ~= " -> "
				out ~= pair to
				out ~= ", "
			out backup! 2
			out ~= "]"
		out ~= " "
	out backup!
	out move-to-str!

.verify void(a str mut[nat64], expected str)
	a.dbg is expected

test
	a = mut-dict<nat64, str>

	a[6] := "6"
	a[5] is none
	a[6] is "6".some
	a.size is 1
	# TODO: a.arr is [6 -> "6"]
	a.arr map (pair => pair from) is [6]
	a.arr map (pair => pair to) is ["6"]

	a verify "(6 -> 6)"

	a[6] := "six"
	a verify "(6 -> six)"

	a[3] := "3"
	a verify "(6 -> six) (3 -> 3)"

	a[4] := "4"
	a verify "(4 -> 4) _ (6 -> six) (3 -> 3)"

	a[8] := "8"
	a verify "[4 -> 4, 8 -> 8] _ (6 -> six) (3 -> 3)"

	a[4] is "4".some
	a[8] is "8".some
	a[5] is none

	# TODO: a.arr is [4 -> "4", 8 -> "8", 6 -> "six", 3 -> "3"]
	a.arr map (pair => pair from) is [4, 8, 6, 3]
	a.arr map (pair => pair to) is ["4", "8", "six", "3"]

	a[12] := "12"
	a verify "(8 -> 8) _ _ (3 -> 3) [4 -> 4, 12 -> 12] _ (6 -> six) _"

	a remove-key! 5 is none
	a remove-key! 4 is "4".some

	a verify "(8 -> 8) _ _ (3 -> 3) (12 -> 12) _ (6 -> six) _"

	a[11] := "11"
	a verify "(8 -> 8) _ _ [3 -> 3, 11 -> 11] (12 -> 12) _ (6 -> six) _"

	a filter! (key, value) => key > 10 || value == "six"
	a verify "_ _ _ (11 -> 11) (12 -> 12) _ (6 -> six) _"

	a map-values! (key, value) => "{key}-{value}"
	a verify "_ _ _ (11 -> 11-11) (12 -> 12-12) _ (6 -> 6-six) _"
