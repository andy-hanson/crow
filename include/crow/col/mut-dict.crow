no-std
import
	../bool: !, &&, bool, false, true
	../compare: !=, <, >, <=, compare
	../exception: assert
	../fun: subscript
	../misc: ->, arrow, as, data, from, to, void
	../number: ==, <=>, +, -, *, nat64
	../opt: ==, force, is-empty, none, opt, or-default, size, some
	../ptr: ==, -, ptr, set-subscript, subscript
	../str: ==, chars, str
	../test: is
	../writer: ~=, backup!, move-to-str!, writer
	./arr: arr, subscript
	./arr-util: each
	./dict: dict
	./mut-list:
		~=, begin-ptr, each, empty!, end-ptr, filter, filter!, fold, is-empty, map, map!,
		map-to-arr, mut-list, remove-at!, set-subscript, size, subscript
	./sort: sort-by!
	./private/sort-utils:
		assert-comparison-not-equal, binary-search-exact-ptr, binary-search-insert-ptr,
		merge-no-duplicates!

###
Mutable dict: A list of key-value pairs, sorted by key, supporting efficient lookup.
###
mut-dict<?k, ?v> record mut
	by-ref
	# TODO:PRIVATE
	# TODO: by-val
	# Values are none if they have been deleted.
	pairs mut-list arrow<?k, opt ?v>
	# Number of pairs in this node that are not `none`.
	# Does not include sizes of other nodes.
	node-size mut nat64
	next mut opt mut-dict<?k, ?v>

# New empty `mut-dict`.
mut-dict mut-dict<?k, ?v>() data<?k> compare<?k>
	mut-dict: mut-list, 0, none

# Copies an `arr` to a `mut-dict`.
mut-dict mut-dict<?k, ?v>(a arr arrow<?k, ?v>) data<?k> compare<?k>
	res = mut-dict<?k, ?v>
	a each pair =>
		res[pair from] := pair to
	res

###
True if the `mut-dict` has no elements.
This is O(1).
###
is-empty bool(a mut-dict<?k, ?v>)
	a.pairs is-empty

empty! void(a mut-dict<?k, ?v>)
	a.next := none
	a.pairs empty!

###
Number of pairs in the `mut-dict`.
This is O(n).
###
size nat64(a mut-dict<?k, ?v>)
	0 size-recur a
.size-recur nat64(acc nat64, a mut-dict<?k, ?v>)
	mid = acc + a.node-size
	if next ?= a next
		mid size-recur next
	else
		mid

###
Look up a value from a key.
Returns `none` if the key is not in the dict.
This is O(a.size ln).
###
subscript opt ?v(a mut-dict<?k, ?v>, key ?k) trusted data<?k> compare<?k>
	if ptr ?= a find-exact-ptr key
		ptr[] to

# Adds a key-value pair, replacing any existing one with that key.
set-subscript void(a mut-dict<?k, ?v>, key ?k, value ?v) data<?k> compare<?k>
	if !(a insert-into-key-match-or-empty-slot! key, value)
		a add-pair! key, value

###
Adds many key-value pairs, replacing existing ones with the same keys.
Equivalent to adding each element of `b` separately.
###
~= void(a mut-dict<?k, ?v>, b arr arrow<?k, ?v>) data<?k> compare<?k>
	b each pair =>
		a[pair from] := pair to

###
Traverses nodes left-to-right looking for the key.
If that fails, traverses back right-to-left and inserts into an empty slot if possible.
Returns true if it succeeded.
###
.insert-into-key-match-or-empty-slot! bool(a mut-dict<?k, ?v>, key ?k, value ?v) trusted data<?k> compare<?k>
	insert-ptr = a find-insert-ptr key
	can-insert = insert-ptr != a.pairs.end-ptr
	if can-insert && insert-ptr[].from == key
		if insert-ptr[].to is-empty
			a.node-size := a.node-size + 1
		insert-ptr[] := key -> value.some
		true
	else
		inserted = if next ?= a next
			next insert-into-key-match-or-empty-slot! key, value
		else
			false

		if inserted
			true
		elif can-insert && insert-ptr[].to.is-empty
			assert: key < insert-ptr[].from
			a.node-size := a.node-size + 1
			insert-ptr[] := key -> value.some
			true
		elif can-insert && insert-ptr != a.pairs.begin-ptr && (insert-ptr - 1)[].to.is-empty
			assert: key < insert-ptr[].from
			# overwrite empty slot even though key doesn't match
			a.node-size := a.node-size + 1
			(insert-ptr - 1)[] := key -> value.some
			true
		else
			false

# Returns the new physical size of this node and all nodes to the right
.add-pair! void(a mut-dict<?k, ?v>, key ?k, value ?v) data<?k> compare<?k>
	if a.node-size < 4
		if a.pairs is-empty
			# TODO: '.as<opt ?v>' should not be necessary
			a.pairs ~= key -> value.some.as<opt ?v>
		else
			# List has a small absolute size, so even if we can't insert near the end,
			# there's an empty slot somewhere so we don't have to do much moving.
			a.pairs insert-linear! 0, key, value
		a.node-size := a.node-size + 1
	elif key > a.pairs[a.pairs.size - 4].from
		# We can insert it near the end
		a.pairs insert-linear! a.pairs.size - 4, key, value
		a.node-size := a.node-size + 1
	else
		if next ?= a next
			next add-pair! key, value
			a compact-if-needed!
		else
			new-pairs = mut-list<arrow<?k, opt ?v>>
			# TODO: '.as<opt ?v>' should not be necessary
			new-pairs ~= key -> value.some.as<opt ?v>
			a.next := some: mut-dict: new-pairs, 1, none

# Insert at the last place where the key is < that value.
.insert-linear! void(a mut-list arrow<?k, opt ?v>, index nat64, key ?k, value ?v) data<?k> compare<?k>
	if key < a[index].from
		a move-right! index
		a[index] := key -> value.some
	elif index == a.size - 1
		# TODO: '.as<opt ?v>' should not be necessary
		a ~= key -> value.some.as<opt ?v>
	else
		a insert-linear! index + 1, key, value

# If there's something here, move it so something else can be inserted.
.move-right! void(a mut-list arrow<?k, opt ?v>, index nat64)
	if !a[index].to.is-empty
		# If this is the last value, push it
		if index == a.size - 1
			a ~= a[index]
		else
			a move-right! index + 1
			a[index + 1] := a[index]

# Convert to an `arr`, clearning the original `mut-dict` in the process.
move-to-arr! arr arrow<?k, ?v>(a mut-dict<?k, ?v>) data<?k> compare<?k>
	res = a map-to-arr (key, value) => key -> value
	a empty!
	res

# Convert to a `dict`, clearning the original `mut-set` in the process.
move-to-dict! dict<?k, ?v>(a mut-dict<?k, ?v>) data<?k> compare<?k>
	dict: a.move-to-arr!

###
Remove the pair with the given key, if it exists.
Returns the old value (if it exists).
###
remove-key! opt ?v(a mut-dict<?k, ?v>, key ?k) trusted data<?k> compare<?k>
	if ptr ?= a find-exact-ptr key
		res = if a.pairs.end-ptr - ptr < 4
			a.pairs remove-at! ptr to
		else
			old-value = ptr[] to
			ptr[] := key -> none
			old-value
		if !res.is-empty
			a.node-size := a.node-size - 1
		a compact-if-needed!
		res
	elif next ?= a next
		next remove-key! key

.compact-if-needed! void(a mut-dict<?k, ?v>) data<?k> compare<?k>
	physical-size = a total-pairs-size
	if a.node-size * 2 <= physical-size
		a compact!
		assert: a.node-size == a.total-pairs-size

.total-pairs-size nat64(a mut-dict<?k, ?v>)
	0 total-pairs-size-recur a
.total-pairs-size-recur nat64(acc nat64, a mut-dict<?k, ?v>)
	mid = acc + a.pairs.size
	if next ?= a next
		mid total-pairs-size-recur next
	else
		mid


.compact! void(a mut-dict<?k, ?v>) data<?k> compare<?k>
	if next ?= a next
		next compact!
		a.pairs filter! pair => !pair.to.is-empty
		a.pairs merge-no-duplicates! next.pairs, (x, y) =>
			x.from <=> y.from assert-comparison-not-equal
		a.next := none
		a.node-size := a.pairs.size

.find-exact-ptr opt ptr arrow<?k, opt ?v>(a mut-dict<?k, ?v>, key ?k) data<?k> compare<?k> unsafe
	a.pairs binary-search-exact-ptr pair => key <=> pair.from

.find-insert-ptr ptr arrow<?k, opt ?v>(a mut-dict<?k, ?v>, key ?k) data<?k> compare<?k> unsafe
	a.pairs binary-search-insert-ptr pair => key <=> pair.from

region iteration

each void(a mut-dict<?k, ?v>, f act void(?k, ?v)) data<?k> compare<?k>
	void fold a, (ignore, k, v) =>
		f[k, v]

fold ?a(acc ?a, a mut-dict<?k, ?v>, f act ?a(?a, ?k, ?v)) data<?k> compare<?k>
	a compact!
	acc fold a.pairs, (cur, pair) =>
		f[cur, pair.from, pair.to.force]

filter mut-dict<?k, ?v>(a mut-dict<?k, ?v>, f act bool(?k, ?v)) data<?k> compare<?k>
	a compact!
	from-sorted-pairs: a.pairs filter pair =>
		f[pair.from, pair.to.force]

map mut-dict<?k-out, ?v-out>
	a mut-dict<?k-in, ?v-in>
	f act arrow<?k-out, ?v-out>(?k-in, ?v-in)
spec
	data<?k-in>
	compare<?k-in>
	data<?k-out>
	compare<?k-out>
body
	mut-dict: a map-to-arr (k, v) => f[k, v]

map-values mut-dict<?k, ?v-out>(a mut-dict<?k, ?v-in>, f act ?v-out(?k, ?v-in)) data<?k> compare<?k>
	a compact!
	from-sorted-pairs: a.pairs map pair =>
		# TODO: 'as' should be unnecessary
		pair.from -> f[pair.from, pair.to.force].some.as<opt ?v-out>

.from-sorted-pairs mut-dict<?k, ?v>(a mut-list<arrow<?k, opt ?v>>)
	mut-dict: a, a.size, none

map-to-arr arr ?out(a mut-dict<?k, ?v>, f act ?out(?k, ?v)) data<?k> compare<?k>
	a compact!
	a.pairs map-to-arr pair =>
		f[pair.from, pair.to.force]

region mutating iteration

filter! void(a mut-dict<?k, ?v>, f act bool(?k, ?v)) data<?k> compare<?k>
	a compact!
	a.pairs filter! pair =>
		f[pair.from, pair.to.force]

map! void(a mut-dict<?k, ?v>, f act arrow<?k, ?v>(?k, ?v)) data<?k> compare<?k>
	a compact!
	a.pairs map! pair =>
		new-pair = f[pair.from, pair.to.force]
		new-pair.from -> new-pair.to.some
	a.pairs sort-by! pair => pair from

test
	a = mut-dict: [3 -> "30", 6 -> "60"]
	a verify "[3 -> 30, 6 -> 60]"
	a map! (k, v) =>
		10 - k -> v.chars[0 -> 1].str
	a verify "[4 -> 6, 7 -> 3]"

map-values! void(a mut-dict<?k, ?v>, f act ?v(?k, ?v)) data<?k> compare<?k>
	a compact!
	a.pairs map! pair =>
		pair.from -> f[pair.from, pair.to.force].some


.dbg str(a mut-dict<nat64, str>)
	out = writer
	out dbg-recur! a
	out move-to-str!

.dbg-recur! void(out writer, a mut-dict<nat64, str>)
	out ~= "["
	a.pairs each pair =>
		out ~= pair from
		out ~= " -> "
		out ~= pair.to or-default "_"
		out ~= ", "
	if a.pairs is-empty
		out ~= "]"
	else
		out backup! 2
		out ~= "]"

	if next ?= a next
		out ~= ", "
		out dbg-recur! next

.verify void(a mut-dict<nat64, str>, expected str)
	a.dbg is expected
	a verify-node-size

.verify-node-size void(a mut-dict<?k, ?v>)
	actual = 0 fold a.pairs, (acc, x) =>
		acc + x.to.size
	a.node-size is actual
	if next ?= a next
		next verify-node-size

test
	a = mut-dict<nat64, str>: [3 -> "3", 5 -> "5", 7 -> "7", 8 -> "8", 9 -> "9", 10 -> "10"]
	a verify "[3 -> 3, 5 -> 5, 7 -> 7, 8 -> 8, 9 -> 9, 10 -> 10]"

	# Insert into the previous slot
	a remove-key! 5 is "5".some
	a verify "[3 -> 3, 5 -> _, 7 -> 7, 8 -> 8, 9 -> 9, 10 -> 10]"
	a[6] := "6"
	a verify "[3 -> 3, 6 -> 6, 7 -> 7, 8 -> 8, 9 -> 9, 10 -> 10]"

	# Insert into the particular slot
	a remove-key! 6 is "6".some
	a verify "[3 -> 3, 6 -> _, 7 -> 7, 8 -> 8, 9 -> 9, 10 -> 10]"
	a[5] := "5"
	a verify "[3 -> 3, 5 -> 5, 7 -> 7, 8 -> 8, 9 -> 9, 10 -> 10]"

test
	a = mut-dict<nat64, str>
	a verify "[]"

	a[5] := "5"
	a verify "[5 -> 5]"
	a[5] is "5".some

	a[8] := "8"
	a verify "[5 -> 5, 8 -> 8]"

	a[11] := "11"
	a[10] := "10"
	a verify "[5 -> 5, 8 -> 8, 10 -> 10, 11 -> 11]"

	a[2] := "2"
	a verify "[5 -> 5, 8 -> 8, 10 -> 10, 11 -> 11], [2 -> 2]"

	# Pushes near the end of a node if possible, even if that node is big
	a[7] := "7"
	a verify "[5 -> 5, 7 -> 7, 8 -> 8, 10 -> 10, 11 -> 11], [2 -> 2]"

	a[0] := "0"
	a[6] := "6"
	a[1] := "1"
	a verify "[5 -> 5, 7 -> 7, 8 -> 8, 10 -> 10, 11 -> 11], [0 -> 0, 1 -> 1, 2 -> 2, 6 -> 6]"
	a[1] := "one"
	a verify "[5 -> 5, 7 -> 7, 8 -> 8, 10 -> 10, 11 -> 11], [0 -> 0, 1 -> one, 2 -> 2, 6 -> 6]"

	# If near end, removes completely
	a remove-key! 1 is "one".some
	a verify "[5 -> 5, 7 -> 7, 8 -> 8, 10 -> 10, 11 -> 11], [0 -> 0, 2 -> 2, 6 -> 6]"
	a remove-key! 1 is none

	# Adding some more values so removals can't fully remove
	a ~= [13 -> "13", 15 -> "15", 17 -> "17"]
	a verify "[5 -> 5, 7 -> 7, 8 -> 8, 10 -> 10, 11 -> 11, 13 -> 13, 15 -> 15, 17 -> 17], [0 -> 0, 2 -> 2, 6 -> 6]"

	a remove-key! 5 is "5".some
	a verify "[5 -> _, 7 -> 7, 8 -> 8, 10 -> 10, 11 -> 11, 13 -> 13, 15 -> 15, 17 -> 17], [0 -> 0, 2 -> 2, 6 -> 6]"
	a remove-key! 5 is none

	a remove-key! 8 is "8".some
	a verify "[5 -> _, 7 -> 7, 8 -> _, 10 -> 10, 11 -> 11, 13 -> 13, 15 -> 15, 17 -> 17], [0 -> 0, 2 -> 2, 6 -> 6]"

	# Setting near a deleted value re-uses the slot
	a[9] := "9"
	a verify "[5 -> _, 7 -> 7, 9 -> 9, 10 -> 10, 11 -> 11, 13 -> 13, 15 -> 15, 17 -> 17], [0 -> 0, 2 -> 2, 6 -> 6]"

	# Removing enough values makes us compact
	a remove-key! 9 is "9".some
	a verify "[5 -> _, 7 -> 7, 9 -> _, 10 -> 10, 11 -> 11, 13 -> 13, 15 -> 15, 17 -> 17], [0 -> 0, 2 -> 2, 6 -> 6]"

	# Before, physical sizes are 8 and 3, and first logical size size is 6.
	# After the removal, first node size is 5 and total physical size is 10, so we compact.
	a remove-key! 10 is "10".some
	a verify "[0 -> 0, 2 -> 2, 6 -> 6, 7 -> 7, 11 -> 11, 13 -> 13, 15 -> 15, 17 -> 17]"

	# Now test compaction for another reason -- enough items are inserted on the right

	# First get 'a' down to size
	a remove-key! 7 is "7".some
	a remove-key! 13 is "13".some
	a remove-key! 15 is "15".some
	a verify "[0 -> 0, 2 -> 2, 6 -> 6, 7 -> _, 11 -> 11, 17 -> 17]"

	# Now physical size of a is 6, logical size is 5.
	a ~= [1 -> "1", 5 -> "5", 3 -> "3"]
	a verify "[0 -> 0, 2 -> 2, 6 -> 6, 7 -> _, 11 -> 11, 17 -> 17], [1 -> 1, 3 -> 3, 5 -> 5]"

	a[4] := "4"
	a verify "[0 -> 0, 1 -> 1, 2 -> 2, 3 -> 3, 4 -> 4, 5 -> 5, 6 -> 6, 11 -> 11, 17 -> 17]"
