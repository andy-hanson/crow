no-std
import
	string: memcpy
	../bool: &&, bool, false, true
	../compare: !=, <, <=, equal
	../fun-util: subscript
	../misc: new, void
	../number: ==, <=>, +, -, *, /, %, nat64
	../option: new, option
	../pointer:
		==, <=>, +, -, *, as-any-const-pointer, as-any-mut-pointer, as-const, as-mut, mut-pointer,
		pointer-cast, set-deref, set-subscript, size-of, subscript, swap
	../private/alloc:
		alloc-uninitialized, set-zero-range, unmanaged-alloc-elements, unmanaged-free-elements
	../range: .., for-loop, high, low, range
	./array:
		~=, ~~=, array, array-builder, as-array, begin-pointer, build, exists, find-index, for-loop,
		index-of, new, reference-equal, size, subscript, with-block

###
`mut-array` is a low-level type mostly useful for implementing other collections.
For normal code, a `mut[]` is preferable.

A `mut-array` is like a `mut[]`, but while a `mut[]` has capacity for pushing elements, `mut-array` is fixed-size.
This has a small performance benefit, since (like an immutable array)
a `mut-array` is just a pointer and size which can be stored by value.

You can't change what range of addresses a `mut-array` points to, though you can write to its elements.

Like an immutable array, and unlike a `mut[]`, it's cheap to take a slice of a `mut-array`.
Taking a slice aliases the elements, so writing to the slice writes to the original.
###
mut-array[t] record mut by-val
	.inner t array

==[t] bool(a t mut-array, b t mut-array)
	trusted a.inner reference-equal b.inner

empty-mut-array[t] t mut-array() noctx, no-doc
	# TODO: should not need type annotation
	inner t array = ()
	inner,

###
Creates a new `mut-array` with the given elements.
###
new[t] t mut-array(...a t array)
	a to-mut-array

###
Copies the array elements to a new `mut-array`.

This is O(n).
###
to-mut-array[t] t mut-array(a t array)
	a.size make-mut-array i => a[i]

###
Treat a mutable as an array. Only do this if you are done mutating it.
###
as-const[t] t array(a t mut-array) noctx, unsafe
	a inner

###
Copies the elements to an immutable array.

This is O(n).

There is no `move-to-array` for `mut-array` since there might be slices that still refer to its elements.
###
to-array[t] t array(a t mut-array)
	a.copy.inner

# Get a `mut-array` from a poitner and range of indices.
subscript[t] t mut-array(a t mut*, indices nat64 range) noctx, unsafe
	a.as-const[indices],

# Creates a `mut-array` from a range of pointers.
as-mut-array[t] t mut-array(a t mut* range) noctx, unsafe
	assert a.low <= a.high
	(a.low .. a.high).as-array,

pointers[t] t mut* range(a t mut-array) noctx, unsafe
	a.begin-pointer .. a.end-pointer

###
Gets the element at the index.
Throws if `index >= a.size`.
###
subscript[t] t(a t mut-array, index nat64) noctx
	assert index < a.size
	trusted a.begin-pointer[index]

###
Slices the mut-array.
This is O(1).

Slices alias the original: Writes to the slice will affect the original.
(If you don't want that, slice then use `copy`.)

Throws if the slice would be out of bounds.
###
subscript[t] t mut-array(a t mut-array, indices nat64 range)
	a.inner[indices],

###
Write to a single element.
Throws if `index >= a.size`.
###
set-subscript[t] void(a t mut-array, index nat64, value t) noctx
	assert index < a.size
	trusted
		a.begin-pointer[index] := value

# `true` iff `a.size == 0`.
is-empty[t] bool(a t mut-array) noctx
	a.size == 0

# Number of elements.
size[t] nat64(a t mut-array) noctx
	a.inner size

# Pointer to the beginning of the `mut-array`.
begin-pointer[t] t mut*(a t mut-array) noctx, unsafe
	a.inner.begin-pointer as-mut

###
Pointer to the end of the `mut-array`.
This is one past the last valid pointer.
###
end-pointer[t] t mut*(a t mut-array) noctx, unsafe
	a.begin-pointer + a.size

###
Copies the elements to a new `mut-array`.

This is O(n).
###
copy[t] t mut-array(a t mut-array)
	for x : a
		x

###
Copies elements from `source` to `dest`.

Throws if `dest` and `source` are not the same size.
(Hint: Both `dest` and `source` can be slices of bigger arrays.)

This is O(n).
###
copy-from[t] void(dest t mut-array, source t array)
	assert dest.size == source.size
	trusted
		dest-ptr = dest.begin-pointer as-any-mut-pointer
		src-ptr = source.begin-pointer as-any-const-pointer
		_ = dest-ptr memcpy src-ptr, dest.size * size-of@t
		()

###
Copies elements from `source` to `dest`.

This is O(n).
###
copy-from[t] void(dest t mut-array, source t mut-array)
	dest copy-from trusted source.temp-as-array

###
Allocates a `mut-array` without initializing any of its elements.

Since `mut-array` is garbage-collected, this will cause problems unless either:
* You write to all the elements before the current task ends.
* You don't keep a reference to the `mut-array` or to any uninitialized slice.

Keep exceptions in mind: Don't store a reference to the result until it's initialized,
since initialization code might throw an exception.

See `zeroed-mut-array` for a safer alternative, or `make-mut-array` for a fully safe alternative.
###
uninitialized-mut-array[t] t mut-array(size nat64) unsafe
	pointer t mut* = size alloc-uninitialized
	pointer[0 .. size]

unmanaged-uninitialized-mut-array[t] t mut-array(size nat64) noctx, no-doc, unsafe
	pointer t mut* = size unmanaged-alloc-elements
	pointer[0 .. size]

free-unmanaged-mut-array[t] void(a t mut-array) noctx, no-doc, unsafe
	a.begin-pointer unmanaged-free-elements a.size

###
This is like `uninitialized-mut-array` but fills memory with zeroes.

Zeroed memory is GC-safe, since the GC ignores null pointers,
but is still not safe to expose to readers (who may try to dereference the null pointers).

This is used by collections like `mut[]` that need some excess capacity that will be GC-safe.
###
zeroed-mut-array[t] t mut-array(size nat64) unsafe
	res t mut-array = size uninitialized-mut-array
	res set-zero-elements
	res

###
Sets every element to `zeroed`. See comment on `zeroed-mut-array` for why this is useful.
###
set-zero-elements[t] void(a t mut-array) noctx, unsafe
	a.begin-pointer set-zero-range a.size

###
`mut-array` where each element is `f[i]`.
Equivalent to `f[0], f[1], ...`.
###
.make-mut-array[t] t mut-array(size nat64, f act t(nat64))
	trusted
		res t mut-array = size uninitialized-mut-array
		out mut = res begin-pointer
		i mut = 0
		loop
			if i == size
				assert out == res.end-pointer
				break res
			else
				*out := f[i]
				out := out + 1
				i := i + 1
				continue

###
`mut-array` where every element is `value`.
Equivalent to `value, value, ...`.
###
fill-mut-array[t] t mut-array(size nat64, value t)
	size make-mut-array _ => value

# Sets every element to `value`.
fill[t] void(a t mut-array, value t) noctx
	unless a is-empty
		trusted
			*a.begin-pointer := value
			(a.begin-pointer + 1 .. a.end-pointer).as-mut-array fill value

in[t] bool(value t, a t mut-array) noctx, t equal
	trusted
		cur mut = a.begin-pointer as-const
		end = a.end-pointer as-const
		loop
			if cur == end
				break false
			elif *cur == value
				break true
			else
				cur := cur + 1
				continue

###
Unsafe cast a mut-array to arr.
Equivalent to `temp-as-array`, but the implication is that
the `mut-array` will never be written to again, so the `arr` can be used forever.
###
cast-immutable[t] t array(a t mut-array) noctx, unsafe
	a inner

first[t] t?(a t mut-array)
	unless a is-empty
		a[0],

last[t] t?(a t mut-array)
	unless a is-empty
		a[0],

tail[t] t mut-array(a t mut-array)
	forbid a is-empty
	a[1 .. a.size]

rtail[t] t mut-array(a t mut-array)
	forbid a is-empty
	a[0 .. a.size - 1]

###
Unsafe cast to immutable array.

This is O(1).

Unsafe because an array is expected to be fully immutable (meaning: no mutable references exist),
so this value should only be used temporarily.
###
temp-as-array[t] t array(a t mut-array) noctx, unsafe
	a inner

# Equivalent to `a.temp-as-array index-of value`.
index-of[t] nat64?(a t mut-array, value t) noctx, t equal
	trusted a.temp-as-array index-of value

# Equivalent to `a.temp-as-array find-index f`.
find-index[t] nat64?(a t mut-array, f act bool(t))
	trusted a.temp-as-array find-index f

set-reverse[t] void(a t mut-array)
	# avoid 'a.end-pointer - 1' overflowing for null arrays
	unless a is-empty
		trusted
			left mut = a begin-pointer
			right mut = a.end-pointer - 1
			while left < right
				left swap right
				left := left + 1
				right := right - 1

region iteration

exists[t] bool(a t mut-array, f act bool(t))
	trusted a.temp-as-array exists f

# Calls 'f' on each element in the mut-array.
for-loop[t] void(a t mut-array, f act void(t))
	trusted a.temp-as-array for-loop f

for-loop[t] void(a t mut-array, f act void(t, nat64))
	trusted a.temp-as-array for-loop f

set-map[t] void(a t mut-array, f act t(t))
	trusted for cur : a.begin-pointer .. a.end-pointer
		*cur := f[*cur]

for-loop[out, in] out mut-array(a in mut-array, f act out(in))
	a.size make-mut-array i => f[a[i]]

for-loop[out, in] out mut-array(a in mut-array, f act out(nat64, in))
	a.size make-mut-array i => f[i, a[i]]

###
Casts elements to a different type.
If the element type is different, adjusts the size so that the number of bytes is the same.
###
cast-mut-array[out, in] out mut-array(a in mut-array) noctx, unsafe
	assert size-of@in != 0 && size-of@out != 0
	size-bytes = a.size * size-of@in
	assert size-bytes % size-of@out == 0
	size-out = size-bytes / size-of@out
	# TODO: shouldn't need parentheses
	(a.begin-pointer.pointer-cast::out mut*)[0 .. size-out]

for-loop[out, in] out array(a in mut-array, f act out(in))
	trusted a for-loop f cast-immutable

region builder

build-mut-array record
	.size-hint nat64
build build-mut-array()
	0,
build build-mut-array(size-hint nat64)
	size-hint,

mut-array-builder[t] record mut
	.inner t array-builder

with-block[t] t mut-array(a build-mut-array, f act void(t mut-array-builder))
	(with out : a.size-hint build; f[(out,)])::(t array),

~=[t] void(a t mut-array-builder, value t)
	a.inner ~= value

~~=[t] void(a t mut-array-builder, values t array)
	a.inner ~~= values

size[t] nat64(a t mut-array-builder)
	a.inner size

region iter

mut-array-iter[t] record by-val mut
	.xs t mut-array
	index nat64

iter[t] t mut-array-iter(a t mut-array) noctx
	a, 0

*[t] t(a t mut-array-iter)
	a.xs[a index]

set-deref[t] void(a t mut-array-iter, value t)
	a.xs[a index] := value

+[t] t mut-array-iter(a t mut-array-iter, b nat64)
	new-index = a.index + b
	assert new-index <= a.xs.size
	a.xs, new-index

-[t] nat64(a t mut-array-iter, b t mut-array-iter)
	assert a.xs == b.xs
	a.index - b.index
