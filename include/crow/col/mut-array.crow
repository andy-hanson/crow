no-std
import
	../bool: &&, bool, false, true
	../compare: !=, <, <=, equal
	../fun-util: subscript
	../js: as-js, as-t, call, call-property, get, js-cast, js-global, set
	../misc: new, void
	../number: ==, <=>, +, -, *, /, %, float64, nat64, to
	../option: new, option
	../pointer:
		==, <=>, +, -, as-const, as-mut, mem-clear, mem-move, mut-pointer, pointer-cast,
		set-subscript, size-of, subscript, gc-safe-value
	../private/alloc: allocate
	../private/bootstrap: new-array, new-mut-array, mut-array-pointer, mut-array-size, todo
	../range: .., high, is-empty, iterate, low, range, size, subscript
	../tuple: new
	./array: ~=, ~~=, array, array-builder, begin-pointer, build, iterate, size, subscript
	./private/array-low-level: array-reference-equal
	./collection:
		build-options, for-loop, index-too-big, iterator-not-comparable, range-relative-to-end,
		slice-out-of-order, to-range
export
	../private/bootstrap: mut-array

# True if they are identical.
+==[t] bool(a t mut-array, b t mut-array) bare, trusted
	a.cast-immutable array-reference-equal b.cast-immutable

###
Creates a new `mut-array` with the given elements.
###
+new[t] t mut-array(...a t array) bare, trusted
	# A spread argument is always a new array
	a cast-mutable

# Get a `mut-array` from a pointer and range of indices.
+subscript[t] t mut-array(a t mut*, indices nat64 range) bare, unsafe, native extern
	a.as-const[indices] cast-mutable

###
Copies the array elements to a new `mut-array`.

This is O(n).
###
+to[t] t mut-array(a t array) trusted
	# Not using a 'for' loop because the compiler may think it may yield (due to the virtual call)
	res t mut-array = a.size gc-safe-mut-array
	res.as-slice copy-from a
	res

###
Copies the elements to an immutable array.

This is O(n).

There is no `move-to` for `mut-array` since there might be slices that still refer to its elements.
###
+to[t] t array(a t mut-array) trusted
	a.copy cast-immutable
+to[t] t array(a t mut-slice) trusted
	for x : a; x

# Creates a `mut-array` from a range of pointers.
+as-mut-array[t] t mut-array(a t mut* range) bare, unsafe, native extern
	assert a.low <= a.high
	(a.high - a.low) new-mut-array a.low

+pointers[t] t mut* range(a t mut-array) bare, unsafe, native extern
	a.begin-pointer .. a.end-pointer

# Number of elements.
+size[t] nat64(a t mut-array) bare
	a mut-array-size

# `true` iff `a.size == 0`.
+is-empty[t] bool(a t mut-array) bare
	a.size == 0

# Pointer to the beginning of the `mut-array`.
+begin-pointer[t] t mut*(a t mut-array) bare, unsafe, native extern
	a mut-array-pointer

###
Pointer to the end of the `mut-array`.
This is one past the last valid pointer.
###
+end-pointer[t] t mut*(a t mut-array) bare, unsafe, native extern
	a.begin-pointer + a.size

###
Copies the elements to a new `mut-array`.

This is O(n).
###
+copy[t] t mut-array(a t mut-array)
	for x : a; x

+subscript[t] t(a t mut-array, index nat64) bare, trusted
	assert index < a.size : index index-too-big a.size
	if extern native
		a.begin-pointer[index]
	elif extern js
		a.as-js get index as-t
	else
		todo

+set-subscript[t] void(a t mut-array, index nat64, value t) bare, trusted
	assert index < a.size : index index-too-big a.size
	if extern native
		a.begin-pointer[index] := value
	elif extern js
		a.as-js set index, value.as-js
	else
		todo

###
Copies elements from `source` to `dest`.
Throws if `dest` and `source` are not the same size.
###
+set-subscript[t] void(dest t mut-array, range nat64 range, source t array) bare
	dest[range] copy-from source
+set-subscript[t] void(dest t mut-array, range nat64 range, source t mut-array) bare
	dest[range] := trusted source temp-as-array
+set-subscript[t] void(dest t mut-array, range nat64 range, source t mut-slice) bare
	dest[range] := trusted source temp-as-array
+set-subscript[t] void(dest t mut-array, range range-relative-to-end, source t array) bare
	dest[range to-range dest.size] := source
+set-subscript[t] void(dest t mut-array, range range-relative-to-end, source t mut-array) bare
	dest[range] := trusted source temp-as-array
+set-subscript[t] void(dest t mut-array, range range-relative-to-end, source t mut-slice) bare
	dest[range] := trusted source temp-as-array
+set-subscript[t] void(dest t mut-slice, range nat64 range, source t array) bare
	dest[range] copy-from source
+set-subscript[t] void(dest t mut-slice, range nat64 range, source t mut-array) bare
	dest[range] := trusted source temp-as-array
+set-subscript[t] void(dest t mut-slice, range nat64 range, source t mut-slice) bare
	dest[range] := trusted source temp-as-array
+set-subscript[t] void(dest t mut-slice, range range-relative-to-end, source t array) bare
	dest[range to-range dest.size] := source
+set-subscript[t] void(dest t mut-slice, range range-relative-to-end, source t mut-array) bare
	dest[range to-range dest.size] := source
+set-subscript[t] void(dest t mut-slice, range range-relative-to-end, source t mut-slice) bare
	dest[range to-range dest.size] := source

+swap[t] void(a t mut-slice, i nat64, j nat64) bare
	temp = a[i]
	a[i] := a[j]
	a[j] := temp

+mut-slice[t] record by-val
	-inner t mut-array
	-range nat64 range
+is-empty[t] bool(a t mut-slice) bare
	a.range is-empty
+size[t] nat64(a t mut-slice) bare
	a.range size
+subscript[t] t(a t mut-slice, index nat64) bare
	a.inner[a.range[index]]
+subscript[t] t mut-slice(a t mut-slice, range nat64 range) bare
	a.inner, a.range[range]
+set-subscript[t] void(a t mut-slice, index nat64, value t) bare
	a.inner[a.range[index]] := value
+as-slice[t] t mut-slice(a t mut-array) bare
	a, 0 .. a.size
+subscript[t] t mut-slice(a t mut-array, indices nat64 range) bare
	assert indices.high <= a.size : indices.high index-too-big a.size
	a, indices
+subscript[t] t mut-slice(a t mut-array, indices range-relative-to-end) bare
	a[indices to-range a.size]
+begin-pointer[t] t mut*(a t mut-slice) bare, unsafe, native extern
	a.inner.begin-pointer + a.range.low
+temp-as-array[t] t array(a t mut-slice) bare, unsafe
	if extern native
		a.begin-pointer[0 .. a.size] temp-as-array
	elif extern js
		i float64 = a.range.low to
		j float64 = a.range.high to
		a.inner.as-js call-property "slice", i, j as-t
	else
		todo
+iterate[t] bool(a t mut-slice, f bool mut(x t))
	a.range iterate i => f[a.inner[i]]
+copy-to[t] t mut-array(a t mut-slice) trusted
	res t mut-array = a.size gc-safe-mut-array
	res[0 .. a.size] := a
	res

-copy-from[t] void(dest t mut-slice, source t array) bare
	assert dest.size == source.size
	trusted if extern native
		dest.begin-pointer mem-move source.begin-pointer, source.size
	else
		i mut nat64 = 0
		until i == source.size
			dest[i] := source[i]
			i +:= 1

###
Allocates a `mut-array` full of GC-safe values. See `gc-safe-value`.
If you just want to create a `mut-array`, use a `for` loop instead.

Keep exceptions in mind: Don't store a reference to the result until it's initialized,
since initialization code might throw an exception.

This is used by collections like `mut[]` that need some excess capacity that will be GC-safe.
###
+gc-safe-mut-array[t] t mut-array(size nat64) unsafe
	if extern native
		(size.allocate::t mut*)[0 .. size]
	elif extern js
		# Array(size).fill(null)
		"Array".js-global call size.to::float64 call-property "fill", gc-safe-value::t as-t
	else
		todo

###
Sets every element to `gc-safe-value`.
See `gc-safe-mut-array` for why this is unsafe.
###
+clear-memory[t] void(a t mut-array) bare, unsafe
	a.as-slice clear-memory
+clear-memory[t] void(a t mut-slice) bare, unsafe
	if extern native
		a.begin-pointer mem-clear a.size
	elif extern js
		i mut nat64 = a.range low
		until i == a.range.high
			a.inner[i] := gc-safe-value
			i +:= 1
	else
		todo

+in[t] bool(value t, a t mut-array) bare, t equal, trusted
	cur mut nat64 = 0
	loop
		if cur == a.size
			break false
		elif a[cur] == value
			break true
		else
			cur +:= 1
			continue

###
Unsafe cast a mut-array to an array.
It must never be written to again.
###
+cast-immutable[t] t array(a t mut-array) bare, unsafe
	if extern native
		a.as-slice cast-immutable
	elif extern js
		a js-cast
	else
		todo
+cast-immutable[t] t array(a t mut-slice) bare, unsafe
	if extern native
		a.size new-array a.begin-pointer.as-const
	elif extern js
		a temp-as-array
	else
		todo

~cast-mutable[t] t mut-array(a t array) bare, unsafe
	if extern native
		a.size new-mut-array a.begin-pointer.as-mut
	elif extern js
		a js-cast
	else
		todo

###
Unsafe cast to immutable array.

This is O(1).

Unsafe because an array is expected to be fully immutable (meaning: no mutable references exist),
so this value must only be used temporarily.
###
+temp-as-array[t] t array(a t mut-array) bare, unsafe
	a cast-immutable

###
Casts elements to a different type.
If the element type is different, adjusts the size so that the number of bytes is the same.
###
+cast-mut-array[out, in] out mut-array(a in mut-array) bare, unsafe, native extern
	assert size-of@in != 0 && size-of@out != 0
	size-bytes = a.size * size-of@in
	assert size-bytes % size-of@out == 0
	size-out = size-bytes / size-of@out
	# TODO: shouldn't need parentheses
	(a.begin-pointer.pointer-cast::out mut*)[0 .. size-out]

region spec impls (see collection.crow)

# Calls 'f' on each element in the mut-array.
+iterate[t] bool(a t mut-array, f bool mut(elem t))
	trusted a.temp-as-array iterate f

+mut-array-iterator[t] record by-val, mut
	~collection t mut-array
	~next-index nat64

+begin[t] t mut-array-iterator(a t mut-array) bare
	a, 0

+end[t] t mut-array-iterator(a t mut-array) bare
	a, a.size

+ +[t] t mut-array-iterator(a t mut-array-iterator, b nat64) bare
	new-index = a.next-index + b
	assert new-index <= a.collection.size
	a.collection, new-index

+-[t] t mut-array-iterator(a t mut-array-iterator, b nat64) bare
	a.collection, a.next-index - b

+-[t] nat64(a t mut-array-iterator, b t mut-array-iterator) bare
	assert a.collection == b.collection
	a.next-index - b.next-index

+prev[t] (t mut-array-iterator, t)?(a t mut-array-iterator) bare
	guard a.next-index != 0
	assert a.next-index <= a.collection.size
	value = a.collection[a.next-index - 1]
	((a.collection, a.next-index - 1), value),

+next[t] (t, t mut-array-iterator)?(a t mut-array-iterator) bare
	guard a.next-index < a.collection.size
	value = a.collection[a next-index]
	(value, (a.collection, a.next-index + 1)),

+set-prev[t] void(a t mut-array-iterator, value t) bare
	assert a.next-index != 0 && a.next-index <= a.collection.size
	a.collection[a.next-index - 1] := value

+set-next[t] void(a t mut-array-iterator, value t) bare
	assert a.next-index < a.collection.size
	a.collection[a next-index] := value

# JS can't slice a 'mut-array', so this is only available in native code.
+slice[t] t mut-slice(begin t mut-array-iterator, end t mut-array-iterator) bare, trusted
	assert begin.collection == end.collection : iterator-not-comparable
	assert begin.next-index <= end.next-index : slice-out-of-order
	begin.collection[begin.next-index .. end.next-index]

+mut-array-builder[t] record mut
	-inner t array-builder
+build[t] t mut-array(a build-options, f void mut(out t mut-array-builder)) trusted
	(a build out => f[out,]) cast-mutable
+~=[t] void(a t mut-array-builder, value t)
	a.inner ~= value
+~~=[t] void(a t mut-array-builder, values t array)
	a.inner ~~= values
+size[t] nat64(a t mut-array-builder)
	a.inner size
