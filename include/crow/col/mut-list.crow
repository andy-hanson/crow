no-std
import
	string: memcpy, memmove
	../bool: bool
	../compare: <, <=, >, >=, equal
	../fun-util: subscript
	../misc: new, void
	../number: ==, <=>, +, -, *, nat64
	../option: new, option
	../pointer:
		+, -, as-any-const-pointer, as-any-mut-pointer, as-const, by-val, mut-pointer, ref-eq, set-deref,
		set-subscript, size-of, subscript, zeroed
	../private/alloc:
		alloc-uninitialized, copy-data-from, set-zero-range, unmanaged-alloc-zeroed-elements
	../private/number-low-level: round-up-to-power-of-two
	../range: .., for-loop, reverse
	./array: array, exists, find-index, for-loop, in, index-of, subscript
	./mut-array:
		begin-pointer, cast-immutable, empty-mut-array, mut-array, for-loop, n-of, set-map,
		set-reverse, set-zero-elements, size, subscript, temp-as-array, uninitialized-mut-array
	./list: for-loop, list, to-list

###
Mutable array type that can change in size.
This is represented as a reference to a `mut-array` with extra capacity.
Appending (or removing) elements to the end is amortized O(1),
but appending (or removing) from the beginning is always O(N).
###
!mut-list[t] record mut
	# backing.size is the capacity
	# For the GC's sake, unused parts of backing are filled with 'zeroed'
	.backing .mut t mut-array
	size .mut nat64

# True if they are identical.
!==[t] bool(a t mut[], b t mut[])
	# TODO: this should be generated for all mut by-ref records
	trusted a ref-eq b

###
Pointer to the first element.
Since `mut-list` changes its underlying data occasionally,
it's UB if this is used after the size of `a` changes.
###
begin-pointer[t] t mut*(a t mut[]) noctx, unsafe
	a.backing begin-pointer

end-pointer[t] t mut*(a t mut[]) noctx, unsafe
	a.begin-pointer + a.size

is-at-capacity[t] bool(a t mut[]) noctx, unsafe
	a.capacity == a.size

capacity[t] nat64(a t mut[]) noctx, unsafe
	a.backing size

mut-list-by-val[t] t mut[] by-val() noctx
	empty-mut-array, 0

mut-list-by-val-with-capacity-from-unmanaged-memory[t] t mut[] by-val(capacity nat64) noctx, unsafe
	backing t mut* = capacity unmanaged-alloc-zeroed-elements
	backing[0 .. capacity], 0

###
`mut-list` where every element is `value`.
###
n-of[t] t mut[](size nat64, value t)
	(size n-of value), size

###
Creates a new list with the given elements.
###
!new[t] t mut[](...a t array)
	a.to-list to-mut-list

!to-mut-list[t] t mut[](a t[])
	backing t mut-array = empty-mut-array
	res t mut[] = backing, 0
	res ~~= a
	res

!clear[t] void(a t mut[]) noctx
	trusted
		# TODO: zero the memory for GC
		a.begin-pointer set-zero-range a.size
		a.size := 0

###
Copies the `mut-list`.
Writes to the original won't affect the copy.
###
!copy[t] t mut[](a t mut[])
	trusted a.temp-as-array.to-list to-mut-list

###
Copies a `mut-list` to a `list`.
Writes to the `mut-list` won't affect the `list`.
###
!to-list[t] t[](a t mut[])
	a.copy move-to-list

###
Convert to a `dict`, clearning the original `mut-list` in the process.
(This avoids copying but still ensures that the result is immutable.)
###
!move-to-list[t] t[](a t mut[]) noctx
	a.move-to-array to-list

!move-to-array[t] t array(a t mut[]) noctx
	trusted a.move-to-mut-array cast-immutable

!move-to-mut-array[t] t mut-array(a t mut[]) noctx
	trusted
		res = a.begin-pointer[0 .. a.size]
		a.backing := empty-mut-array
		a.size := 0
		res

!swap[t] void(a t mut[], b t mut[])
	a-backing = a backing
	a-size = a size
	a.backing := b backing
	a.size := b size
	b.backing := a-backing
	b.size := a-size

.check-index[t] void(a t mut[], index nat64) noctx
	assert index < a.size : "index out of bounds"

###
Gets the element at the index.
Throws if `index >= a.size`.
###
!subscript[t] t(a t mut[], index nat64) noctx
	a check-index index
	trusted a.begin-pointer[index]

!first[t] t?(a t mut[])
	unless a is-empty
		a[0],

!last[t] t?(a t mut[])
	unless a is-empty
		a[a.size - 1],

###
Sets the last element.
Throws if the list is empty.
###
set-last[t] void(a t mut[], value t)
	a[a.size - 1] := value

###
Converts to an `mut-array`.
"Temp" because it's UB if the result is used after ths size of `a` changes.
###
temp-as-mut-array[t] t mut-array(a t mut[]) noctx, unsafe
	a.begin-pointer[0 .. a.size]

###
Converts to an `array`.
"Temp" because it's UB if the result is used after `a` is written to.
###
temp-as-array[t] t array(a t mut[]) noctx, unsafe
	a.temp-as-mut-array temp-as-array

# True iff `a.size == 0`.
!is-empty[t] bool(a t mut[]) noctx
	a.size == 0

###
Sets the element at the index.
Throws if `index >= a.size`.
###
!set-subscript[t] void(a t mut[], index nat64, value t) noctx
	a check-index index
	trusted
		a.begin-pointer[index] := value

###
True iff `a[i] == value` for some `i`.
###
!in[t] bool(value t, a t mut[]) noctx, t equal
	trusted value in a.temp-as-array

# TODO: this should be 'subscript' with a range. And return a list.
.copy-range-to-array[t] t array(a t mut[], begin nat64, size nat64)
	assert begin + size <= a.size : "range out of bounds"
	trusted
		res t mut* = size alloc-uninitialized
		src = a.begin-pointer + begin
		_ = res.as-any-mut-pointer memcpy src.as-any-const-pointer, size * size-of@t
		res.as-const[0 .. size]

###
Removes the first `n` elements and returns them as an array.
This is O(a.size - n) because of the cost of copying, and all remaining elements must be shifted.
Throws if `n > a.size`.
###
!pop-n-from-start[t] t[](a t mut[], n nat64)
	assert n <= a.size : "can't pop more than size of array"
	res = a copy-range-to-array 0, n
	trusted
		dest = a.begin-pointer as-any-mut-pointer
		src = a.begin-pointer + n as-any-const-pointer
		new-size = a.size - n
		_ = dest memmove src, new-size * size-of@t
		a.size := new-size
	res to-list

###
Removes the last element and returns it.
Returns `none` if `a` is empty.
###
!pop[t] t?(a t mut[])
	unless a is-empty
		new-size = a.size - 1
		res = a[new-size]
		trusted
			# Ensure GC doesn't hold on to the memory there
			a[new-size] := zeroed
			a.size := new-size
			res,

###
Pops `n` times, discarding the result.
Throws if `n > a.size`.
###
!pop-n[t] void(a t mut[], n nat64)
	assert n <= a.size : "can't pop more than size of array"
	new-size = a.size - n
	trusted
		a.begin-pointer + new-size set-zero-range n
		a.size := new-size

# Push a value onto the end of the list.
!~=[t] void(a t mut[], value t)
	trusted
		a incr-capacity
		assert a.size < a.capacity
		a.begin-pointer[a size] := value
		a.size := a.size + 1

# TODO: Use an 'each' spec..
# Push multiple values onto the end of the list.
!~~=[t] void(a t mut[], values t array)
	for x : values
		a ~= x
!~~=[t] void(a t mut[], values t[])
	for x : values
		a ~= x
!~~=[t] void(a t mut[], values t mut-array)
	for x : values
		a ~= x
!~~=[t] void(a t mut[], values t mut[])
	for x : values
		a ~= x

.incr-capacity[t] void(a t mut[]) unsafe
	a ensure-capacity (a.size + 1 round-up-to-power-of-two)

push-capacity-must-be-sufficient[t] void(a t mut[], value t) noctx, unsafe
	assert a.size < a.capacity
	a.begin-pointer[a size] := value
	a.size := a.size + 1

.increase-capacity-to[t] void(a t mut[], new-capacity nat64) unsafe
	assert new-capacity > a.capacity
	old-begin = a begin-pointer
	a.backing := new-capacity uninitialized-mut-array
	a.begin-pointer copy-data-from old-begin.as-const, a.size
	a.backing[a.size + 1 .. a.backing.size] set-zero-elements

.ensure-capacity[t] void(a t mut[], min-capacity nat64) unsafe
	if a.capacity < min-capacity
		a increase-capacity-to min-capacity

###
Ensure that the mut-list can grow to a size of `reserved` without reallocating.
Does nothing if the capacity is already sufficient.
This may reserve more space than requested, so calling `reserve` repeatedly for slowly increasing sizes
doesn't reallocate every time, and is no worse than pushing repeatedly.
###
.reserve[t] void(a t mut[], reserved nat64) unsafe
	a ensure-capacity reserved.round-up-to-power-of-two

###
Removes `a[index]`, replaces it with the last value, and returns the old `a[index]`.
If `a[index]` is the last value, simply pops it.
This is more efficient than `a remove-at index`,
which has to shift all values past `index` to the left.
Throws if `index >= a.size`.
###
remove-unordered-at[t] t(a t mut[], index nat64) noctx
	a check-index index
	trusted
		res = a.begin-pointer[index]
		new-size = a.size - 1
		a.begin-pointer[index] := a.begin-pointer[new-size]
		a.size := new-size
		res

uninitialized-mut-list[t] t mut[](size nat64) unsafe
	res t mut[] = ()
	res unsafe-set-size size
	res

###
Directly sets the `size` without touching the data.
Unsafe because if this increases the size, it exposes uninitialized data.
If this decreases the size, it doesn't zero out the rest of the data, so the garbage collector will keep it alive.
###
unsafe-set-size[t] void(a t mut[], new-size nat64) unsafe
	a reserve new-size
	a.size := new-size

###
Pops elements until the size is <= `new-size`.
Does nothing if `a.size <= new-size` already.
###
reduce-size-if-more-than[t] void(a t mut[], new-size nat64)
	if new-size < a.size
		_ = a.pop
		a reduce-size-if-more-than new-size

# Returns the first index where `a[i] == value`, or returns `none`.
!index-of[t] nat64?(a t mut[], value t) noctx, t equal
	trusted a.temp-as-array index-of value

###
Sets `a[index] := value`, but first shifts all elements from `index` onwards to the right to make room.
Increases the size by 1.
This is O(a.size - index) due to having to move other elements.
Throws if `index > a.size`.
###
!insert-at[t] void(a t mut[], index nat64, value t)
	assert index <= a.size : "index out of bounds"
	trusted
		a incr-capacity
		dest = a.begin-pointer + index + 1
		src = a.begin-pointer + index
		n = a.size - index
		_ = dest.as-any-mut-pointer memmove src.as-any-const-pointer, n * size-of@t
		a.size := a.size + 1
		a[index] := value
		assert a.size <= a.capacity

insert-at[t] void(a t mut[], pointer t mut*, value t) unsafe
	a insert-at pointer - a.begin-pointer, value

###
Removes `a[index]`, and shifts all values from `index` onwards to the left to fill the hole.
Returns the old `a[index]`.
Decreases the size by 1.
This is O(a.size - index) due to having to move other elements.
Throws if `index >= a.size`.
###
!remove-at[t] t(a t mut[], index nat64)
	a check-index index
	res = a[index]
	trusted
		dest = a.begin-pointer + index
		src = a.begin-pointer + index + 1
		n = a.size - index - 1
		_ = dest.as-any-mut-pointer memmove src.as-any-const-pointer, n * size-of@t
		a.size := a.size - 1
	res

remove-at[t] t(a t mut[], pointer t mut*) unsafe
	a remove-at pointer - a.begin-pointer

!set-reverse[t] void(a t mut[])
	trusted a.temp-as-mut-array set-reverse

region iteration

# TODO: What if it's mutated while searching ?
!find-index[t] nat64?(a t mut[], f act bool(t))
	# TODO: dangerous if mutated while looping
	trusted a.temp-as-array find-index f

!exists[t] bool(a t mut[], f act bool(t))
	# TODO: dangerous if mutated while looping
	trusted a.temp-as-array exists f

!reversed-mut-list[t] record mut
	.inner t mut[]
!reversed[t] t reversed-mut-list(a t mut[])
	a,
!for-loop[t] void(a t reversed-mut-list, f act void(t))
	m = a inner
	for i : 0 .. m.size reverse
		f[m[i]]

!filter[t] t mut[](a t mut[], f act bool(t))
	res = a copy
	res set-filter f
	res

# Calls `f` for each element in `a`.
!for-loop[t] void(a t mut[], f act void(t))
	# TODO: dangerous if mutated while looping
	trusted a.temp-as-array for-loop f

!for-loop[t] void(a t mut[], f act void(nat64, t))
	# TODO: dangerous if mutated while looping
	trusted a.temp-as-array for-loop f

!for-loop[out, in] out mut[](a in mut[], f act out(in))
	trusted a map-to-mut-array f as-mut-list

!for-loop[out, in] out[](a in mut[], f act out(in))
	trusted (a map-to-mut-array f).cast-immutable to-list

.map-to-mut-array[out, in] out mut-array(a in mut[], f act out(in))
	# TODO: dangerous if mutated while looping
	for x : a.backing[0 .. a.size]
		f[x]

.as-mut-list[t] t mut[](a t mut-array) unsafe
	a, a.size

region mutating iteration

# TODO: what happens if data accessed during filtering?
###
Removes every element `x` where `!f[x]`.
This can be written as `a.filter := f`.
###
!set-filter[t] void(a t mut[], f act bool(t))
	# TOOD: this is unsafe if 'f' accesses to the list. Make it a 'fun' instead?
	trusted
		out mut = a begin-pointer
		for x : a
			if f[x]
				*out := x
				out := out + 1
		new-size = out - a.begin-pointer
		a.backing[new-size .. a.size] set-zero-elements
		a.size := new-size

###
Overwrites every element `x` with `f[x]`.
###
!set-map[t] void(a t mut[], f act t(t))
	# TOOD: this is unsafe if 'f' accesses to the list. Make it a 'fun' instead?
	trusted a.temp-as-mut-array set-map f

region iter

!mut-list-iter[t] record by-val mut
	.xs t mut[]
	index nat64

!is-at-end[t] bool(a t mut-list-iter)
	a.index >= a.xs.size

!iter[t] t mut-list-iter(a t mut[]) noctx
	a, 0

!end-iter[t] t mut-list-iter(a t mut[]) noctx
	a, a.size

!*[t] t(a t mut-list-iter)
	a.xs[a index]

!set-deref[t] void(a t mut-list-iter, value t)
	a.xs[a index] := value

!+[t] t mut-list-iter(a t mut-list-iter, n nat64)
	new-index = a.index + n
	assert new-index <= a.xs.size
	a.xs, new-index

!-[t] t mut-list-iter(a t mut-list-iter, b nat64)
	a.xs, a.index - b

!-[t] nat64(a t mut-list-iter, b t mut-list-iter)
	assert a.xs == b.xs
	a.index - b.index
