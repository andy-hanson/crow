no-std
import
	../bool: bool, not
	../compare: !=, <, <=, >
	../fun-util: subscript
	../js: as-js-any, as-t, call-property, set
	../misc: new, void
	../number: ==, <=>, +, -, /, float64, max-value, nat64, to
	../option: force, new, option
	../pointer:
		+, as-const, gc-safe-value, mem-copy, mem-move, mut-pointer, reference-equal, set-deref,
		set-subscript
	../private/bootstrap: todo
	../private/number-low-level: round-up-to-power-of-two
	../range: .., iterate
	../tuple: a, b, new
	./array: array, size
	./collection:
		.., -, build-options, end, for-loop, index-too-big, iterate, size-hint, slice-out-of-order,
		subscript
	./mut-array:
		+, begin, begin-pointer, cast-immutable, cast-mutable, clear-memory, copy-to,
		gc-safe-mut-array, mut-array, mut-array-iterator, mut-slice, prev, new, next, next-index,
		set-next, set-prev, set-subscript, size, subscript, temp-as-array, to
	./list: iterate, list, to

###
Mutable array type that can change in size.
This is represented as a reference to a `mut-array` with extra capacity.
Appending (or removing) elements to the end is amortized O(1),
but appending (or removing) from the beginning is always O(N).
###
+mut-list[t] record mut
	# Fields should only be used in mut-list.crow
	# backing.size is the capacity
	# For the GC's sake, unused parts of backing are filled with 'gc-safe-value'
	-backing mut t mut-array
	# Not used for JS
	-mut-list-size mut nat64

+size[t] nat64(a t mut[]) bare
	if trusted extern js
		a.backing size
	else
		a mut-list-size
-set-size[t] void(a t mut[], size nat64) bare, native extern
	a.mut-list-size := size

+subscript[t] t(a t mut[], index nat64) bare
	unless trusted extern js
		assert index < a.mut-list-size : index index-too-big a.mut-list-size
	a.backing[index]
+set-subscript[t] void(a t mut[], index nat64, value t) bare
	unless trusted extern js
		assert index < a.mut-list-size : index index-too-big a.mut-list-size
	a.backing[index] := value

# True if they are identical.
+==[t] bool(a t mut[], b t mut[]) bare
	# TODO: this should be generated for all mut by-ref records
	trusted a reference-equal b

###
Pointer to the first element.
Since `mut-list` changes its underlying data occasionally,
it's unsafe to use this after the size of `a` changes.
###
+begin-pointer[t] t mut*(a t mut[]) bare, unsafe, native extern
	a.backing begin-pointer

+end-pointer[t] t mut*(a t mut[]) bare, unsafe, native extern
	a.begin-pointer + a.size

is-at-capacity[t] bool(a t mut[]) bare, unsafe, native extern
	a.capacity == a.size

capacity[t] nat64(a t mut[]) bare, unsafe, native extern
	a.backing size

###
Creates a new list with the given elements.
###
+new[t] t mut[](...a t array) trusted
	# Spread always creates a new array
	a.cast-mutable, a.size

+to[t] t mut[](a t array)
	backing t mut-array = ()
	res t mut[] = backing, 0
	res ~~= a.to::t[]
	res

+to[t] t mut[](a t[])
	backing t mut-array = ()
	res t mut[] = backing, 0
	res ~~= a
	res

+clear[t] void(a t mut[]) bare, trusted
	a reduce-size-to 0

+reduce-size-to[t] void(a t mut[], new-size nat64) bare, trusted
	assert new-size <= a.size
	if extern native
		a.backing[new-size .. a.size] clear-memory
		a.size := new-size
	elif extern js
		a.backing.as-js-any set "length", new-size.to::float64
	else
		todo

###
Copies the `mut-list`.
Writes to the original won't affect the copy.
###
+copy[t] t mut[](a t mut[])
	if trusted extern js
		new-backing t mut-array = trusted a.backing.as-js-any call-property "slice" as-t
		new-backing, max-value
	else
		a.begin slice a.end

###
Copies a `mut-list` to a `list`.
Writes to the `mut-list` won't affect the `list`.
###
+to[t] t[](a t mut[])
	a.copy move-to

###
'move-to' is like 'to' but sets the input to empty.
###
+move-to[t] t[](a t mut[])
	a.move-to::(t array) to
+move-to[t] t array(a t mut[]) bare
	trusted a.move-to cast-immutable
+move-to[t] t mut-array(a t mut[]) bare
	trusted if extern native
		res t mut-array = a.backing.begin-pointer[0 .. a.size]
		a.backing := ()
		a.size := 0
		res
	else
		res = a backing
		a.backing := ()
		res
+move-to[t] t mut[](a t mut[])
	if trusted extern js
		a.move-to, max-value
	else
		res t mut[] = a.backing, a.mut-list-size
		a.backing := ()
		a.mut-list-size := 0
		res

+swap[t] void(a t mut[], b t mut[])
	a-backing = a backing
	a-size = a size
	a.backing := b backing
	if trusted extern native
		a.size := b size
	b.backing := a-backing
	if trusted extern native
		b.size := a-size

-check-index[t] void(a t mut[], index nat64) bare
	assert index < a.size : index index-too-big a.size

###
Converts to an `mut-array`.
"Temp" because it's UB if the result is used after ths size of `a` changes.
###
temp-as-mut-array[t] t mut-array(a t mut[]) bare, unsafe
	if extern native
		a.backing.begin-pointer[0 .. a.size]
	else
		a backing

###
Converts to an `array`.
"Temp" because it's UB if the result is used after `a` is written to.
###
temp-as-array[t] t array(a t mut[]) bare, unsafe
	a.temp-as-mut-array temp-as-array

# True iff `a.size == 0`.
+is-empty[t] bool(a t mut[]) bare
	a.size == 0

###
Removes the first `n` elements and returns them as an array.
This is O(a.size - n) because of the cost of copying, and all remaining elements must be shifted.
Throws if `n > a.size`.
###
+pop-n-from-start[t] t[](a t mut[], n nat64)
	assert n <= a.size : n index-too-big a.size
	if trusted extern native
		res t array = a.backing[0 .. n] to
		new-size = a.size - n
		a.backing[0 .. new-size] := a.backing[n .. a.size]
		a.size := new-size
		res to
	elif trusted extern js
		res t array = trusted do
			a.backing.as-js-any call-property "splice", 0::float64, n.to::float64 as-t
		res to
	else
		todo

+peek[t] t?(a t mut[])
	guard !a.is-empty
	a[end - 1],

###
Removes the last element and returns it.
Returns `none` if `a` is empty.
###
+pop[t] t?(a t mut[]) bare
	guard !a.is-empty
	if trusted extern native
		new-size = a.size - 1
		res = a[new-size]
		# Ensure GC doesn't hold on to the memory there
		a[new-size] := trusted gc-safe-value
		a.size := new-size
		res,
	elif trusted extern js
		(trusted a.backing.as-js-any call-property "pop" as-t),
	else
		todo

###
Pops `n` times, discarding the result.
Throws if `n > a.size`.
###
+pop-n[t] void(a t mut[], n nat64)
	assert n <= a.size : n index-too-big a.size
	if trusted extern native
		new-size = a.size - n
		trusted a.backing[new-size .. a.size] clear-memory
		a.size := new-size
	elif trusted extern js
		trusted a.backing.as-js-any set "length", (a.size - n).to::float64
	else
		todo

+prepend=[t] void(a t mut[], value t) trusted
	if extern native
		a incr-capacity
		a.begin-pointer + 1 mem-move a.begin-pointer.as-const, a.size
		*a.begin-pointer := value
		a.size +:= 1
	elif extern js
		_ = a.backing.as-js-any call-property "unshift", value
	else
		todo

# Push a value onto the end of the list.
+~=[t] void(a t mut[], value t) trusted
	if extern native
		a incr-capacity
		assert a.size < a.capacity
		a.begin-pointer[a size] := value
		a.size +:= 1
	elif extern js
		_ = a.backing.as-js-any call-property "push", value
	else
		todo

# Push multiple values onto the end of the list.
+~~=[t, col] void(a t mut[], values col) (col, t) iterate
	for x : values
		a ~= x

-incr-capacity[t] void(a t mut[]) unsafe, native extern
	a ensure-capacity (a.size + 1 round-up-to-power-of-two)

push-capacity-must-be-sufficient[t] void(a t mut[], value t) bare, unsafe, native extern
	assert a.size < a.capacity
	a.begin-pointer[a size] := value
	a.size +:= 1

-increase-capacity-to[t] void(a t mut[], new-capacity nat64) trusted, native extern
	assert new-capacity > a.capacity
	old-begin = a begin-pointer
	a.backing := new-capacity gc-safe-mut-array
	a.begin-pointer mem-copy old-begin.as-const, a.size
	a.backing[a.size + 1 .. end] clear-memory

###
For performance, hint that the list will eventually reach 'eventual-size'.
This has no observable effect.
###
hint-size[t] void(a t mut[], eventual-size nat64)
	if trusted extern native
		a ensure-capacity eventual-size

-ensure-capacity[t] void(a t mut[], min-capacity nat64) native extern
	if trusted a.capacity < min-capacity
		a increase-capacity-to min-capacity

###
Ensure that the mut-list can grow to a size of `reserved` without reallocating.
Does nothing if the capacity is already sufficient.

This may reserve more space than requested,
so calling `reserve` repeatedly for slowly increasing sizes
doesn't reallocate every time, and is no worse than pushing repeatedly.
###
-reserve[t] void(a t mut[], reserved nat64) unsafe, native extern
	a ensure-capacity reserved.round-up-to-power-of-two

###
Removes `a[index]`, replaces it with the last value, and returns the old `a[index]`.
If `a[index]` is the last value, simply pops it.
This is more efficient than `a remove-at index`,
which has to shift all values past `index` to the left.
Throws if `index >= a.size`.
###
remove-unordered-at[t] t(a t mut[], index nat64) bare
	res = a[index]
	replacement = a.pop!
	unless index == a.size
		a[index] := replacement
	res

uninitialized-mut-list[t] t mut[](size nat64) unsafe, native extern
	res t mut[] = ()
	res unsafe-set-size size
	res

###
Directly sets the `size` without touching the data.
Unsafe because if this increases the size, it exposes uninitialized data.
If this decreases the size, it doesn't zero out the rest of the data,
so the garbage collector will keep it alive.
###
unsafe-set-size[t] void(a t mut[], new-size nat64) unsafe
	if extern native
		a reserve new-size
		a.size := new-size
	elif extern js
		if new-size < a.size
			a reduce-size-to new-size
		else
			while a.size != new-size
				a ~= gc-safe-value
	else
		todo

###
Sets `a[index] := value`,
but first shifts all elements from `index` onwards to the right to make room.
Increases the size by 1.
This is O(a.size - index) due to having to move other elements.
Throws if `index > a.size`.
###
+insert-at[t] void(a t mut[], index nat64, value t)
	assert index <= a.size : index index-too-big a.size
	trusted if extern native
		a incr-capacity
		a.backing[index + 1 .. a.size + 1] := a.backing[index .. a.size]
		a.size +:= 1
		assert a.size <= a.capacity
		a[index] := value
	elif extern js
		_ = a.backing.as-js-any call-property "splice", index.to::float64, 0::float64, value
	else
		todo

###
Removes `a[index]`, and shifts all values from `index` onwards to the left to fill the hole.
Returns the old `a[index]`.
Decreases the size by 1.
This is O(a.size - index) due to having to move other elements.
Throws if `index >= a.size`.
###
+remove-at[t] t(a t mut[], index nat64)
	a check-index index
	res = a[index]
	trusted if extern native
		a.backing[index .. a.size - 1] := a.backing[index + 1 .. a.size]
		a.size -:= 1
	elif extern js
		_ = a.backing.as-js-any call-property "splice", index.to::float64, 1::float64
	else
		todo
	res

+swap[t] void(a t mut[], i nat64, j nat64)
	temp = a[i]
	a[i] := a[j]
	a[j] := temp

+reverse-in-place[t] void(a t mut[])
	for i : 0::nat64 .. a.size / 2
		a swap i, a.size - 1 - i

region mutating iteration

# TODO: what happens if data accessed during filtering?
###
Removes every element `x` where `!f[x]`.
This can be written as `a.filter := f`.
###
+filter=[t] void(a t mut[], f bool mut(elem t))
	# TOOD: this is unsafe if 'f' accesses to the list. Make it a 'fun' instead?
	out mut nat64 = 0
	for x : a
		if f[x]
			a[out] := x
			out +:= 1
	a reduce-size-to out

region spec impls (see collection.crow)

+iterate[t] bool(a t mut[], f bool mut(elem t))
	0::nat64 .. a.size iterate i =>
		f[a[i]]

+mut-list-iterator[t] record(collection t mut[], next-index nat64) by-val, mut

+begin[t] t mut-list-iterator(a t mut[]) bare
	a, 0

+end[t] t mut-list-iterator(a t mut[]) bare
	a, a.size

-as-backing-iter[t] t mut-array-iterator(a t mut-list-iterator) bare
	assert a.next-index <= a.collection.size
	a.collection.backing.begin + a.next-index

+prev[t] (t mut-list-iterator, t)?(a t mut-list-iterator) bare
	if res ?= a.as-backing-iter prev
		((a.collection, res.a.next-index), res.b),

+next[t] (t, t mut-list-iterator)?(a t mut-list-iterator) bare
	if res ?= a.as-backing-iter next
		if res.b.next-index <= a.collection.size
			(res.a, (a.collection, res.b.next-index)),

+ +[t] t mut-list-iterator(a t mut-list-iterator, n nat64) bare
	new-next-index = a.next-index + n
	assert new-next-index <= a.collection.size
	a.collection, new-next-index

+-[t] t mut-list-iterator(a t mut-list-iterator, n nat64) bare
	a.collection, a.next-index - n

+-[t] nat64(a t mut-list-iterator, b t mut-list-iterator) bare
	assert a.collection == b.collection
	a.next-index - b.next-index

+set-prev[t] void(a t mut-list-iterator, value t) bare
	a.as-backing-iter set-prev value

+set-next[t] void(a t mut-list-iterator, value t) bare
	a.as-backing-iter set-next value

+slice[t] t mut[](a t mut-list-iterator, b t mut-list-iterator)
	assert a.next-index <= b.next-index : slice-out-of-order
	res t mut-slice = a.collection.backing[a.next-index .. b.next-index]
	res.copy-to, res.size

+build[t] t mut[](a build-options, f void mut(out t mut[]))
	res t mut[] = ()
	res hint-size a.size-hint
	f[res]
	res
