no-std
import
	../bits:
		&, |, <<, >>, add-bit, bit?, bits-diff, count-ones,
		filter-bits, fold-one-bits, nth-bit, sub-bit
	../bool: !, &&, ==, bool, false, true
	../compare: !=, <, <=
	../exception: assert
	../fun: subscript
	../log: info, log
	../misc: ->, drop, void
	../number: deep-size-bytes, each
	../opt: has?, none, opt, or-default, some
	../ptr: ==, +, set-subscript
	../str: ==, str
	../str-conv: to-hex
	../test: is
	../writer: ~=, backup!, move-to-str!, writer
	../private/number-low-level:
		==, <=>, nat64, unsafe-div, unsafe-mod, wrap-add, wrap-mul, wrap-sub
	./arr: ==, arr, empty?, size, subscript
	./arr-util:
		alloc-count, deep-size-bytes, each, fold, fold-with-index, last, make-arr, map-with-index,
		rtail, update, zip-larger, zip-smaller
	./mut-arr: begin-ptr, cast-immutable, end-ptr, uninitialized-mut-arr

index-set record
	# TODO:PRIVATE
	ignore void
	# TODO: use 'vector' type that supports efficient inserts to the middle
	values arr nat64

empty? bool(a index-set)
	a.values empty?

size nat64(a index-set)
	a.values count-ones-in-arr
.count-ones-in-arr nat64(a arr nat64)
	0 fold a, (acc, x) =>
		acc wrap-add x.count-ones

# Total number of bytes used.
deep-size-bytes nat64(a index-set) unsafe
	a.values deep-size-bytes

alloc-count nat64(a index-set) unsafe
	a.values alloc-count

index-set index-set()
	index-set: void, []

index-set index-set(a nat64)
	index-set: [a]

index-set index-set(a arr nat64)
	index-set fold a, (acc, x) => acc ~ x

arr arr nat64(a index-set)
	a map-to-arr (it => it)

subscript bool(a index-set, index nat64)
	nat64-index = index word-index
	if nat64-index < a.values.size
		a.values[nat64-index] bit? index.bit-index
	else
		false

~ index-set(a index-set, index nat64)
	a try-add index or-default a

try-add opt index-set(a index-set, index nat64)
	nat64-index = index word-index
	bit-index = index bit-index
	if nat64-index < a.values.size
		if !(a.values[nat64-index] bit? bit-index)
			new-values = a.values update: nat64-index, a.values[nat64-index] add-bit bit-index
			some: index-set: void, new-values
	else
		some: index-set: void, (nat64-index wrap-add 1) make-arr i =>
			if i < a.values.size
				a.values[i]
			elif i == nat64-index
				bit-index nth-bit
			else
				0

~ index-set(a index-set, indices arr nat64)
	a fold indices, (cur, index) => cur ~ index

- index-set(a index-set, index nat64)
	a try-remove index or-default a

try-remove opt index-set(a index-set, index nat64)
	nat64-index = index word-index
	if nat64-index < a.values.size
		bit-index = index bit-index
		old-value = a.values[nat64-index]
		new-value = old-value sub-bit bit-index
		if new-value == old-value
			none
		elif new-value == 0 && nat64-index == (a.values.size wrap-sub 1)
			some: index-set: void, a.values rtail
		else
			some: a.values update nat64-index, new-value strip-trailing-zeroes

~ index-set(a index-set, b index-set)
	index-set: void, a.values zip-larger b.values, (x, y) =>
		x or-default 0 |: y or-default 0

intersect index-set(a index-set, b index-set)
	strip-trailing-zeroes: a.values zip-smaller b.values, (x, y) =>
		x & y

- index-set(a index-set, b index-set)
	strip-trailing-zeroes: a.values zip-larger b.values, (x, y) =>
		x or-default 0 bits-diff: y or-default 0

.strip-trailing-zeroes index-set(a arr nat64)
	index-set: void, a.strip-trailing-zeroes
.strip-trailing-zeroes arr nat64(a arr nat64)
	if last ?= a last
		if last == 0
			a.rtail strip-trailing-zeroes
		else
			a
	else
		[]

# hi exclusive
count-range nat64(a index-set, lo nat64, hi nat64)
	assert: lo <= hi
	lo-nat64-index = lo word-index
	if lo-nat64-index < a.values.size
		hi-nat64-index = hi word-index
		lo-bit-index = lo bit-index
		hi-bit-index = hi bit-index
		if lo-nat64-index == hi-nat64-index
			a.values[lo-nat64-index] count-range-in-nat64 lo-bit-index, hi-bit-index
		else
			l = a.values[lo-nat64-index] count-gte-in-nat64 lo-bit-index
			mid = a.values[(lo-nat64-index wrap-add 1) -> hi-nat64-index] count-ones-in-arr
			r = a.values[hi-nat64-index] count-less-in-nat64 hi-bit-index
			l wrap-add mid wrap-add r
	else
		0

count-less nat64(a index-set, n nat64)
	nat64-index = n word-index
	if nat64-index < a.values.size
		here = a.values[nat64-index] count-less-in-nat64 n.bit-index
		here wrap-add a.values[0 -> nat64-index].count-ones-in-arr
	else
		a.size

count-greater-or-equal nat64(a index-set, n nat64)
	nat64-index = n word-index
	if nat64-index < a.values.size
		here = a.values[nat64-index] count-gte-in-nat64 n.bit-index
		here wrap-add a.values[(nat64-index wrap-add 1) -> a.values.size].count-ones-in-arr
	else
		0

.count-range-in-nat64 nat64(a nat64, lo-bit-index nat64, hi-bit-index nat64)
	a >> lo-bit-index count-less-in-nat64: hi-bit-index wrap-sub lo-bit-index

.count-less-in-nat64 nat64(a nat64, bit-index nat64)
	a << (64 wrap-sub bit-index) count-ones

.count-gte-in-nat64 nat64(a nat64, bit-index nat64)
	a >> bit-index count-ones

filter-less index-set(a index-set, n nat64)
	if n < a.values.size
		index-set: void, a.values[0 -> n]
	else
		a

.word-index nat64(a nat64) trusted
	a unsafe-div 64
.bit-index nat64(a nat64) trusted
	a unsafe-mod 64

region iteration

each void(a index-set, f act void(nat64))
	void fold a, (ignore, x) => f[x]

fold ?a(acc ?a, a index-set, f act ?a(?a, nat64))
	acc fold-with-index a.values, (cur, value, nat64-index) =>
		bit-index-offset = nat64-index wrap-mul 64
		cur fold-one-bits value, (inner-acc, bit-index) =>
			f[inner-acc, bit-index-offset wrap-add bit-index]

filter index-set(a index-set, f act bool(nat64))
	strip-trailing-zeroes: a.values map-with-index (value, nat64-index) =>
		bit-index-offset = nat64-index wrap-mul 64
		value filter-bits bit-index =>
			f[bit-index-offset wrap-add bit-index]

map index-set(a index-set, f act nat64(nat64))
	a map-to-arr f index-set

map-to-arr arr ?a(a index-set, f act ?a(nat64)) trusted
	res = a.size uninitialized-mut-arr<?a>
	end = res.begin-ptr fold a, (cur, x) =>
		cur[] := f[x]
		cur + 1
	assert: end == res.end-ptr
	res cast-immutable

debug str(a index-set)
	if a empty?
		"[]"
	else
		out = writer
		out ~= "["
		a each index =>
			out ~= index
			out ~= ", "
		out backup! 2
		out ~= "]"
		out move-to-str!

.dbg str(a index-set)
	if a empty?
		"[]"
	else
		out = writer
		out ~= "["
		a.values each value =>
			out ~= "x"
			out ~= value to-hex
			out ~= ", "
		out backup! 2
		out ~= "]"
		out move-to-str!

.verify void(a index-set, expected str, expected-arr arr nat64)
	a.dbg is expected
	r = a arr
	r is expected-arr
	drop: 0 fold a, (prev, cur) =>
		prev -> cur each x =>
			a[x] is false
		a[cur] is true
		cur wrap-add 1
	a.size is r.size

test
	info log "START INDEX SET TEST"

	a = index-set
	a verify "[]", []
	a[3] is false

	b = a ~ 8
	b verify "[x100]", [8]

	b count-less 8 is 0
	b count-greater-or-equal 8 is 1
	b count-range 4, 8 is 0
	b count-range 8, 9 is 1

	c = b ~ [4, 9]
	c verify "[x310]", [4, 8, 9]

	# TODO: 'is none'
	(c try-remove 7).has? is false
	(c try-add 8).has? is false

	d = c - 8
	d verify "[x210]", [4, 9]

	folded = 1 fold d, (cur, x) => cur wrap-add x
	folded is 14

	filtered = c filter it => it != 8
	filtered verify "[x210]", [4, 9]

	mapped = c map it => 10 wrap-sub it
	mapped verify "[x46]", [1, 2, 6]

	info log "DONE WITH INDEX SET TEST"
