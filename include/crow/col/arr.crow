no-std
import
	../bool: &&, bool
	../compare: !=, <, <=, compare, comparison, equal, greater, less
	../fun: subscript
	../misc: arrow, from, to
	../ptr: ==, <=>, +, -, as-const, by-val, const-ptr, ptr-cast, ref-of-ptr, size-of, subscript
	../private/alloc: alloc-uninitialized, copy-data-from!
	../private/bootstrap: hard-assert
	../private/exception-low-level: assert
	../private/number-low-level: ==, <=>, nat8, nat64, wrap-add, wrap-sub
export
	../private/bootstrap: arr, begin-ptr, size

end-ptr<a> const-ptr a(a a[]) noctx unsafe
	a.begin-ptr + a.size

# TODO: arr comparison should be generic
arr-equal<a> bool(a a[], b a[]) trusted noctx equal<a>
	a.begin-ptr equal-recur a.end-ptr, b.begin-ptr, b.end-ptr
.equal-recur<a> bool(a const-ptr a, a-end const-ptr a, b const-ptr a, b-end const-ptr a) unsafe noctx equal<a>
	if a == a-end
		b == b-end
	else
		b != b-end && a[] == b[] && a + 1 equal-recur a-end, b + 1, b-end

arr-equal<a> bool(a a[], b a[], eq act bool(a, a)) trusted
	a.begin-ptr equal-recur a.end-ptr, b.begin-ptr, b.end-ptr, eq
.equal-recur<a> bool(a const-ptr a, a-end const-ptr a, b const-ptr a, b-end const-ptr a, eq act bool(a, a)) unsafe
	if a == a-end
		b == b-end
	else
		b != b-end && eq[a[], b[]] && a + 1 equal-recur a-end, b + 1, b-end, eq

arr-compare<a> comparison(a a[], b a[]) trusted noctx compare<a>
	a.begin-ptr compare-recur a.end-ptr, b.begin-ptr, b.end-ptr
.compare-recur<a> comparison(a const-ptr a, a-end const-ptr a, b const-ptr a, b-end const-ptr a) unsafe noctx compare<a>
	if a == a-end
		if b == b-end
			equal
		else
			less
	elif b == b-end
		greater
	else
		match a[] <=> b[]
		as less
			less
		as equal
			a + 1 compare-recur a-end, b + 1, b-end
		as greater
			greater

== bool(a nat8[], b nat8[]) noctx
	a arr-equal b
<=> comparison(a nat8[], b nat8[]) noctx
	a arr-compare b

== bool(a nat64[], b nat64[]) noctx
	a arr-equal b
<=> comparison(a nat64[], b nat64[]) noctx
	a arr-compare b

###
Arr or the range from begin to end.
`begin` is inclusive and `end` is exclusive.
UB if begin > end.
###
arr-from-begin-end<a> a[](begin const-ptr a, end const-ptr a) unsafe noctx
	hard-assert: begin <= end
	arr: end - begin, begin

arr-cast<out, in> out[](a in[]) unsafe noctx
	hard-assert: size-of<out> == size-of<in>
	arr: a.size, a.begin-ptr.ptr-cast<out, in>

# True iff `a.size == 0`.
is-empty<a> bool(a a[]) noctx
	a.size == 0

noctx-at<a> a(a a[], index nat64) unsafe noctx
	hard-assert: index < a.size
	a unsafe-at index

unsafe-at<a> a(a a[], index nat64) unsafe noctx
	a.begin-ptr[index]

###
Gets the element at the index.
Fails if `index >= a.size`.
###
subscript<a> a(a a[], index nat64) trusted
	assert: index < a.size
	a unsafe-at index

###
Slices the arr.
`range.from` is inclusive and `range.to` is exclusive.
This works in O(1) without copying any elements.
Fails if `range.from > range.to`.
Fails if the slice would exceed the bounds of the arr.
###
subscript<a> a[](a a[], range arrow<nat64, nat64>) trusted
	assert: range.from <= range.to
	assert: range.to <= a.size
	range.to wrap-sub range.from arr a.begin-ptr + range.from

unsafe-slice<a> a[](a a[], begin nat64, end nat64) unsafe noctx
	a.begin-ptr + begin arr-from-begin-end a.begin-ptr + end

ref-of-val-at<a> a(a by-val<a>[], index nat64) trusted
	assert: index < a.size
	a.begin-ptr + index ref-of-ptr

###
Concatenates two arrs.
This involves copying every element from both arrs into the new arr.
If you need to concatenate often, consider using `mut-list`.
###
~ <a> a[](a a[], b a[]) trusted
	res-size = a.size wrap-add b.size
	res = res-size alloc-uninitialized<a>
	res copy-data-from! a.begin-ptr, a.size
	res + a.size copy-data-from! b.begin-ptr, b.size
	res-size arr res.as-const
