no-std
import
	../bool: !, &&, ==, bool, false, true
	../compare: !=, <=, compare
	../fun: subscript
	../hash: hash, hash-mix
	../misc: data, void
	../opt: is-empty, opt, some
	../ptr: ==, <=>, +, -, *, const-ptr, mut-ptr, set-deref, size-of, swap!
	../test: is
	../private/number-low-level: ==, <=>, nat64, unsafe-div, unsafe-mod, wrap-add, wrap-mul, wrap-sub
	./arr: ==, arr, arr-cast, arr-from-begin-end, begin-ptr, end-ptr, is-empty, size, unsafe-at
	./arr-util: alloc-count, fold, fold-with-index, index-of, map, overhead-bytes, ptr-of
	./mut-arr:
		begin-ptr, cast-immutable, each, end-ptr, fill!, fill-mut-arr, mut-arr,
		size, temp-as-arr, uninitialized-mut-arr, unsafe-at, unsafe-set-at!

frozen-unordered-set<a> record force-data
	# TODO:PRIVATE
	values a[]
	# These are pointers into 'values', so it's fine that 'ptr' isn't GC traced.
	bucket-starts a*[]

frozen-unordered-set<a> frozen-unordered-set a() data<a> compare<a> hash-mix<a>
	frozen-unordered-set: [], []

frozen-unordered-set<a> frozen-unordered-set a(a a[]) trusted data<a> compare<a> hash-mix<a>
	a.mut-arr unsafe-frozen-unordered-set-from-mut-arr-cast-immutable

# Values are stored as a contiguous array; order is arbitrary.
begin-ptr<a> a*(a frozen-unordered-set a) unsafe
	a.values begin-ptr

end-ptr<a> a*(a frozen-unordered-set a) unsafe
	a.values end-ptr

alloc-count<a> nat64(a frozen-unordered-set a) unsafe
	a.values.alloc-count wrap-add a.bucket-starts.alloc-count

overhead-bytes<a> nat64(a frozen-unordered-set a) unsafe
	buckets-size = a.bucket-starts.size wrap-mul size-of<a*>
	a.values.overhead-bytes wrap-add a.bucket-starts.overhead-bytes wrap-add buckets-size

is-empty<a> bool(a frozen-unordered-set a)
	a.values is-empty

size<a> nat64(a frozen-unordered-set a)
	a.values size

unordered-arr<a> a[](a frozen-unordered-set a)
	a values

subscript<a> bool(a frozen-unordered-set a, value a) trusted data<a> compare<a> hash-mix<a>
	!(a try-get-unordered-index value is-empty)

# WARN: The order of values is arbitrary,
# but consistent for *identical* (not ==) sets.
try-get-unordered-index<a> nat64?(a frozen-unordered-set a, value a) trusted data<a> compare<a> hash-mix<a>
	if a.bucket-starts is-empty
		a.values index-of value
	else
		bucket-index = value.hash unsafe-mod a.bucket-starts.size
		bucket-start = a.bucket-starts unsafe-at bucket-index
		bucket-end = if bucket-index == (a.bucket-starts.size wrap-sub 1)
			a.values end-ptr
		else
			a.bucket-starts unsafe-at: bucket-index wrap-add 1
		if ptr ?= bucket-start arr-from-begin-end bucket-end ptr-of value
			ptr - a.begin-ptr some

unsafe-frozen-unordered-set-from-mut-arr-cast-immutable<a> frozen-unordered-set a
	a mut-arr a
spec
	unsafe
	data<a>
	compare<a>
	hash-mix<a>
body
	if a.size <= 4
		frozen-unordered-set: a.cast-immutable, []
	else
		n-buckets = a.size unsafe-div 2
		bucket-counts = a get-bucket-counts n-buckets
		bucket-starts = a.begin-ptr running-sum bucket-counts.temp-as-arr
		bucket-counts fill! 0
		a.begin-ptr move-values-to-buckets-recur! a.end-ptr, bucket-counts, bucket-starts
		a.cast-immutable frozen-unordered-set bucket-starts.arr-cast<a*, a mut*>

.get-bucket-counts<a> mut-arr nat64(a mut-arr a, n-buckets nat64) unsafe hash-mix<a>
	res = n-buckets fill-mut-arr 0
	a each value =>
		bucket-index = value get-bucket-index n-buckets
		res unsafe-set-at!: bucket-index, res unsafe-at bucket-index wrap-add 1
	res

.move-values-to-buckets-recur!<a> void
	value-ptr a mut*
	value-end a mut*
	bucket-counts mut-arr nat64
	bucket-starts a mut*[]
spec
	unsafe
	hash-mix<a>
body
	if value-ptr != value-end
		bucket-index = *value-ptr get-bucket-index bucket-counts.size
		bucket-count = bucket-counts unsafe-at bucket-index
		bucket-start = bucket-starts unsafe-at bucket-index
		bucket-cur-end = bucket-start + bucket-count
		if bucket-start <= value-ptr && value-ptr <= bucket-cur-end
			if value-ptr == bucket-cur-end
				bucket-counts unsafe-set-at!: bucket-index, bucket-count wrap-add 1
				value-ptr + 1 move-values-to-buckets-recur! value-end, bucket-counts, bucket-starts
			else
				value-ptr + 1 move-values-to-buckets-recur! value-end, bucket-counts, bucket-starts
		else
			bucket-counts unsafe-set-at!: bucket-index, bucket-count wrap-add 1
			value-ptr swap! bucket-cur-end
			value-ptr + 1 move-values-to-buckets-recur! value-end, bucket-counts, bucket-starts

.get-bucket-index<a> nat64(value a, n-buckets nat64) unsafe hash-mix<a>
	value.hash unsafe-mod n-buckets

.running-sum<a> a mut*[](acc a mut*, a nat64[]) trusted
	out = a.size uninitialized-mut-arr<a mut*>
	acc running-sum-recur! out.begin-ptr, out.end-ptr, a.begin-ptr
	out cast-immutable
.running-sum-recur!<a> void
	acc a mut*
	out a mut* mut*
	out-end a mut* mut*
	read nat64*
spec
	unsafe
body
	*out := acc
	if out + 1 != out-end
		acc + *read running-sum-recur! out + 1, out-end, read + 1

region iteration

each-unordered<a> void(a frozen-unordered-set a, f act void(a))
	void fold-unordered a, (ignore, x) =>
		f[x]

fold-unordered<a, b> a(acc a, a frozen-unordered-set b, f act a(a, b))
	acc fold a.values, f

fold-unordered-with-index<a, b> a(acc a, a frozen-unordered-set b, f act a(a, b, nat64))
	acc fold-with-index a.values, f

.verify void(a frozen-unordered-set nat64, values nat64[], bucket-starts nat64[]) unsafe
	a.values is values
	a.bucket-starts map (ptr => ptr - a.values.begin-ptr) is bucket-starts

test
	a = frozen-unordered-set<nat64>
	a.is-empty is true
	a.size is 0
	a verify [], []
	a[0] is false

	b = frozen-unordered-set: [3, 1, 5, 2]
	b verify [3, 1, 5, 2], []
	b[0] is false
	b[1] is true
	b[2] is true
	b[3] is true
	b[4] is false
	b[5] is true
	b[6] is false

	c = frozen-unordered-set: [3, 1, 5, 2, 8]
	c verify [8, 2, 3, 1, 5], [0, 2]
	c[0] is false
	c[1] is true
	c[2] is true
	c[3] is true
	c[4] is false
	c[5] is true
	c[6] is false
	c[7] is false
	c[8] is true
	c[9] is false
