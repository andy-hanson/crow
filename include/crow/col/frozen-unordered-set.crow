no-std
import
	..bool: &&, ==, bool, false, true
	..compare: !=, <=, compare
	..fun: subscript
	..hash: hash, hash-mix
	..misc: data, void
	..opt: has?, opt, some
	..ptr: ==, <=>, +, -, ptr, set-subscript, size-of, subscript, swap!
	..test: is
	..private.number-low-level: ==, <=>, nat64, unsafe-div, unsafe-mod, wrap-add, wrap-mul, wrap-sub
	.arr: ==, arr, arr-from-begin-end, begin-ptr, empty?, end-ptr, size, unsafe-at
	.arr-util: alloc-count, fold, fold-with-index, index-of, map, overhead-bytes, ptr-of
	.mut-arr:
		begin-ptr, cast-immutable, each, end-ptr, fill!, fill-mut-arr, mut-arr,
		size, uninitialized-mut-arr, unsafe-at, unsafe-set-at!

frozen-unordered-set<?a> record force-data
	# TODO:PRIVATE
	values arr ?a
	# These are pointers into 'values', so it's fine that 'ptr' isn't GC traced.
	bucket-starts arr ptr ?a

frozen-unordered-set frozen-unordered-set ?a() data<?a> compare<?a> hash-mix<?a>
	frozen-unordered-set: [], []

frozen-unordered-set frozen-unordered-set ?a(a arr ?a) trusted data<?a> compare<?a> hash-mix<?a>
	a.mut-arr unsafe-frozen-unordered-set-from-mut-arr-cast-immutable

# Values are stored as a contiguous array; order is arbitrary.
begin-ptr ptr ?a(a frozen-unordered-set ?a) unsafe
	a.values begin-ptr

end-ptr ptr ?a(a frozen-unordered-set ?a) unsafe
	a.values end-ptr

alloc-count nat64(a frozen-unordered-set<?a>) unsafe
	a.values.alloc-count wrap-add a.bucket-starts.alloc-count

overhead-bytes nat64(a frozen-unordered-set ?a) unsafe
	buckets-size = a.bucket-starts.size wrap-mul size-of<ptr ?a>
	a.values.overhead-bytes wrap-add a.bucket-starts.overhead-bytes wrap-add buckets-size

empty? bool(a frozen-unordered-set ?a)
	a.values empty?

size nat64(a frozen-unordered-set ?a)
	a.values size

unordered-arr arr ?a(a frozen-unordered-set ?a)
	a values

subscript bool(a frozen-unordered-set ?a, value ?a) trusted data<?a> compare<?a> hash-mix<?a>
	a try-get-unordered-index value has?

# WARN: The order of values is arbitrary,
# but consistent for *identical* (not ==) sets.
try-get-unordered-index opt nat64(a frozen-unordered-set ?a, value ?a) trusted data<?a> compare<?a> hash-mix<?a>
	if a.bucket-starts empty?
		a.values index-of value
	else
		bucket-index = value.hash unsafe-mod a.bucket-starts.size
		bucket-start = a.bucket-starts unsafe-at bucket-index
		bucket-end = if bucket-index == (a.bucket-starts.size wrap-sub 1)
			a.values end-ptr
		else
			a.bucket-starts unsafe-at: bucket-index wrap-add 1
		if ptr ?= bucket-start arr-from-begin-end bucket-end ptr-of value
			ptr - a.begin-ptr some

unsafe-frozen-unordered-set-from-mut-arr-cast-immutable frozen-unordered-set ?a
	a mut-arr ?a
spec
	unsafe
	data<?a>
	compare<?a>
	hash-mix<?a>
body
	if a.size <= 4
		frozen-unordered-set: a.cast-immutable, []
	else
		n-buckets = a.size unsafe-div 2
		bucket-counts = a get-bucket-counts n-buckets
		bucket-starts = a.begin-ptr running-sum bucket-counts
		bucket-counts fill! 0
		a.begin-ptr move-values-to-buckets-recur! a.end-ptr, bucket-counts, bucket-starts
		frozen-unordered-set: a.cast-immutable, bucket-starts

.get-bucket-counts mut-arr nat64(a mut-arr ?a, n-buckets nat64) unsafe hash-mix<?a>
	res = n-buckets fill-mut-arr 0
	a each value =>
		bucket-index = value get-bucket-index n-buckets
		res unsafe-set-at!: bucket-index, res unsafe-at bucket-index wrap-add 1
	res

.move-values-to-buckets-recur! void
	value-ptr ptr ?a
	value-end ptr ?a
	bucket-counts mut-arr nat64
	bucket-starts arr ptr ?a
spec
	unsafe
	hash-mix<?a>
body
	if value-ptr != value-end
		bucket-index = value-ptr[] get-bucket-index bucket-counts.size
		bucket-count = bucket-counts unsafe-at bucket-index
		bucket-start = bucket-starts unsafe-at bucket-index
		bucket-cur-end = bucket-start + bucket-count
		if bucket-start <= value-ptr && value-ptr <= bucket-cur-end
			if value-ptr == bucket-cur-end
				bucket-counts unsafe-set-at!: bucket-index, bucket-count wrap-add 1
				value-ptr + 1 move-values-to-buckets-recur! value-end, bucket-counts, bucket-starts
			else
				value-ptr + 1 move-values-to-buckets-recur! value-end, bucket-counts, bucket-starts
		else
			bucket-counts unsafe-set-at!: bucket-index, bucket-count wrap-add 1
			value-ptr swap! bucket-cur-end
			value-ptr + 1 move-values-to-buckets-recur! value-end, bucket-counts, bucket-starts

.get-bucket-index nat64(value ?a, n-buckets nat64) unsafe hash-mix<?a>
	value.hash unsafe-mod n-buckets

.running-sum arr ptr ?a(acc ptr ?a, a mut-arr nat64) trusted
	out = a.size uninitialized-mut-arr<ptr ?a>
	acc running-sum-recur! out.begin-ptr, out.end-ptr, a.begin-ptr
	out cast-immutable
.running-sum-recur! void(acc ptr ?a, out ptr ptr ?a, out-end ptr ptr ?a, read ptr nat64) unsafe
	out[] := acc
	if out + 1 != out-end
		acc + read[] running-sum-recur! out + 1, out-end, read + 1

region iteration

each-unordered void(a frozen-unordered-set ?a, f act void(?a))
	void fold-unordered a, (ignore, x) =>
		f[x]

fold-unordered ?a(acc ?a, a frozen-unordered-set ?b, f act ?a(?a, ?b))
	acc fold a.values, f

fold-unordered-with-index ?a(acc ?a, a frozen-unordered-set ?b, f act ?a(?a, ?b, nat64))
	acc fold-with-index a.values, f

.verify void(a frozen-unordered-set nat64, values arr nat64, bucket-starts arr nat64) unsafe
	a.values is values
	a.bucket-starts map (ptr => ptr - a.values.begin-ptr) is bucket-starts

test
	a = frozen-unordered-set<nat64>
	a.empty? is true
	a.size is 0
	a verify [], []
	a[0] is false

	b = frozen-unordered-set: [3, 1, 5, 2]
	b verify [3, 1, 5, 2], []
	b[0] is false
	b[1] is true
	b[2] is true
	b[3] is true
	b[4] is false
	b[5] is true
	b[6] is false

	c = frozen-unordered-set: [3, 1, 5, 2, 8]
	c verify [8, 2, 3, 1, 5], [0, 2]
	c[0] is false
	c[1] is true
	c[2] is true
	c[3] is true
	c[4] is false
	c[5] is true
	c[6] is false
	c[7] is false
	c[8] is true
	c[9] is false
