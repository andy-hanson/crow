no-std
import
	../bool: &&, ==, bool, false, true
	../col/arr-util: zip-larger
	../compare: <, compare
	../misc: is-data, new, void
	../number: ==, <=>, +, nat64
	../opt: !, is-empty, new, opt
	../ptr: -
	../range: .., for-loop
	../str: ==, literal, new, str
	../str-conv: interp, finish, to-str, with-str, with-value
	../str-util: join
	../test-util: is
	../tuple: from, new, pair, pair-equal, to
	./arr: arr, size, subscript
	./mut-arr:
		~=, ~~=, begin-ptr, clear, copy, fold, for-loop, is-empty, move-to-array, mut-arr, new,
		pop, reversed, size, subscript, temp-as-array, to-list, to-mut-arr
	./list: list, list-equal, new, reverse, to-list
	./sort: set-sort-by, set-sort-by-reverse
	./private/sort-utils: binary-search-insert-ptr

###
Mutable priority queue.

Elements are key-value pairs. Pairs are sorted by key.
Popping removes the pair with the lowest key.

If two pairs have the same key, the second pair added will be popped second.
###
mut-priority-queue<k, v> record mut by-ref
	# TODO: Use by-val
	# The smallest value goes on the right
	.mins pair<k, v> mut[]
	# This may be shorter than mins -- buckets on the right considered missing.
	.buckets pair<k, v> mut[] mut[]

# New priority queue containing the given pairs.
new<k, v> mut-priority-queue<k, v>(...a arr pair<k, v>) is-data<k> compare<k>
	a.to-list to-mut-priority-queue

# Copies a list to a new priority queue.
to-mut-priority-queue<k, v> mut-priority-queue<k, v>(a list pair<k, v>) is-data<k> compare<k>
	mins = a to-mut-arr
	mins.sort-by-reverse := pair => pair from
	mins, ()

# Removes all pairs from the queue.
clear<k, v> void(a mut-priority-queue<k, v>) is-data<k> compare<k>
	a.mins clear
	a.buckets clear

# True iff `a.size == 0`.
is-empty<k, v> bool(a mut-priority-queue<k, v>) is-data<k> compare<k>
	a.mins is-empty

###
Number of pairs in the queue.
This is O(n).
###
size<k, v> nat64(a mut-priority-queue<k, v>) is-data<k> compare<k>
	a.mins.size fold a.buckets, (acc, b) =>
		acc + b.size

###
Adds a pair to the queue.
This is O(log n).
###
~= <k, v> void(a mut-priority-queue<k, v>, pair pair<k, v>) trusted is-data<k> compare<k>
	# Highest min is on the right, so comparing in reverse
	ptr = a.mins binary-search-insert-ptr it => it.from <=> pair.from
	index = ptr - a.mins.begin-ptr
	if index == a.mins.size
		a.mins ~= pair
	else
		a.buckets add-to-bucket index, pair

###
Removes and returns the pair with the lowest key.

Returns an empty option iff the queue was empty (before calling `pop`).

This is amortized O(log n).
###
pop<k, v> pair<k, v>?(a mut-priority-queue<k, v>) is-data<k> compare<k>
	res = a.mins pop
	if a.mins.size < a.buckets.size
		assert a.mins.size + 1 == a.buckets.size
		bucket = a.buckets.pop!
		# Mins are popped off from the right.
		# This preserves insertion order: 'sort-by' doesn't change that,
		# then we reverse, then popping from the right reverses it again.
		bucket.sort-by-reverse := it => it from
		a.mins ~~= bucket
	res

# Like `pop`, but discards the key.
pop-value<k, v> v?(a mut-priority-queue<k, v>) is-data<k> compare<k>
	if pair ?= a pop
		pair.to,

###
Copy pairs to a new priority queue.
This is O(n).
###
copy<k, v> mut-priority-queue<k, v>(a mut-priority-queue<k, v>) is-data<k> compare<k>
	a spread-all-buckets
	a.mins.copy, ()

to-list<k, v> list pair<k, v>(a mut-priority-queue<k, v>) trusted is-data<k> compare<k>
	a spread-all-buckets
	a.mins.to-list reverse

.spread-all-buckets<k, v> void(a mut-priority-queue<k, v>) is-data<k> compare<k>
	old-mins = a.mins move-to-array
	for index : 0 .. old-mins.size
		if index < a.buckets.size
			bucket = a.buckets[index]
			bucket.sort-by := it => it from
			for x : bucket reversed
				a.mins ~= x
		a.mins ~= old-mins[index]
	a.buckets clear

.add-to-bucket<k, v> void(buckets pair<k, v> mut[] mut[], index nat64, pair pair<k, v>)
	if index < buckets.size
		buckets[index] ~= pair
	else
		buckets ~= ()
		buckets add-to-bucket index, pair

.dbg<k, v> str(a mut-priority-queue<k, v>) to-str<k> to-str<v> trusted
	# TODO: should be able to infer type arguments
	mins = a.mins temp-as-array
	buckets = a.buckets temp-as-array
	parts = mins zip-larger@<str, pair<k, v>, pair<k, v> mut[]> buckets, (opt-min, opt-bucket) =>
		min = opt-min!
		show-bucket = if bucket ?= opt-bucket
			unless bucket is-empty
				parts = ", " join for pair : bucket; pair dbg
				" [{parts}]"
		"{min dbg}{show-bucket}"
	", " join parts.to-list

.dbg<k, v> str(a pair<k, v>) to-str<k> to-str<v>
	"{a from} -> {a to}"

.verify void(a mut-priority-queue<nat64, str>, expected str)
	a.dbg is expected

test
	a mut-priority-queue<nat64, str> = ()
	a.is-empty is true
	a.pop is ()
	a verify ""

	a ~= (5, "5")
	a.is-empty is false
	a verify "5 -> 5"

	a ~= (6, "6")
	a verify "5 -> 5 [6 -> 6]"

	a ~= (2, "2")
	a verify "5 -> 5 [6 -> 6], 2 -> 2"

	a ~= (3, "3a")
	a verify "5 -> 5 [6 -> 6], 2 -> 2 [3 -> 3a]"

	a ~= (4, "4")
	a ~= (3, "3b")
	a verify "5 -> 5 [6 -> 6], 2 -> 2 [3 -> 3a, 4 -> 4, 3 -> 3b]"

	a.pop is ((2, "2"),)
	a verify "5 -> 5 [6 -> 6], 4 -> 4, 3 -> 3b, 3 -> 3a"

	a ~= (4, "4b")
	a verify "5 -> 5 [6 -> 6], 4 -> 4 [4 -> 4b], 3 -> 3b, 3 -> 3a"

	a.pop is ((3, "3a"),)
	a.pop is ((3, "3b"),)
	a verify "5 -> 5 [6 -> 6], 4 -> 4 [4 -> 4b]"
	a.pop is ((4, "4"),)
	a verify "5 -> 5 [6 -> 6], 4 -> 4b"

	a.to-list is ((4, "4b"), (5, "5"), (6, "6"))
	a verify "6 -> 6, 5 -> 5, 4 -> 4b"
	a is ((4, "4b"), (5, "5"), (6, "6"))

test
	a mut-priority-queue<nat64, str> = ()
	a ~= (5, "5")
	a ~= (5, "five")
	a.pop is ((5, "5"),)
	a.pop is ((5, "five"),)
	a.is-empty is true

# TODO: opt should have generic ==
.== bool(a pair<nat64, str>?, b pair<nat64, str>?)
	if va ?= a
		if vb ?= b
			va.from == vb.from && va.to == vb.to
		else
			false
	else
		b is-empty

.== bool(a mut-priority-queue<nat64, str>, b mut-priority-queue<nat64, str>)
	a.to-list == b.to-list

.== bool(a list pair<nat64, str>, b list pair<nat64, str>)
	a list-equal b

.== bool(a pair<nat64, str>, b pair<nat64, str>)
	a pair-equal b
