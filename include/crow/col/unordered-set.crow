no-std
import
	../bool: !, bool
	../compare: compare
	../hash: hash-mix
	../misc: ->, data, void
	../number: nat64
	../opt: is-empty, none, opt, some
	./arr: arr
	./arr-util: map
	./lookup:
		alloc-count, each-key-unordered, fold-keys-unordered, is-empty, lookup, new-lookup, overhead-bytes, size,
		subscript, try-add, try-remove

unordered-set<a> record
	inner lookup<a, void>

unordered-set<a> unordered-set a() data<a> compare<a> hash-mix<a>
	unordered-set: lookup<a, void>

unordered-set<a> unordered-set a(a a[]) data<a> compare<a> hash-mix<a>
	unordered-set: lookup: a map x => x -> void

alloc-count<a> nat64(a unordered-set a) unsafe
	a.inner alloc-count

overhead-bytes<a> nat64(a unordered-set a) unsafe
	a.inner overhead-bytes

is-empty<a> bool(a unordered-set a) data<a> compare<a> hash-mix<a>
	a.inner is-empty

size<a> nat64(a unordered-set a) data<a> compare<a> hash-mix<a>
	a.inner size

subscript<a> bool(a unordered-set a, value a) data<a> compare<a> hash-mix<a>
	!a.inner[value].is-empty

~ <a> unordered-set a(a unordered-set a, value a) data<a> compare<a> hash-mix<a>
	if res ?= a try-add value
		res
	else
		a

try-add<a> unordered-set<a>?(a unordered-set a, value a) data<a> compare<a> hash-mix<a>
	match a.inner try-add value, () => void
	as already-has-key
		none
	as lookup l
		l.unordered-set some

- <a> unordered-set a(a unordered-set a, value a) data<a> compare<a> hash-mix<a>
	if res ?= a try-remove value
		res
	else
		a

try-remove<a> unordered-set<a>?(a unordered-set a, value a) data<a> compare<a> hash-mix<a>
	if res ?= a.inner try-remove value
		res.new-lookup.unordered-set some

region iteration

each-unordered<a> void(a unordered-set a, f act void(a))
	a.inner each-key-unordered f

fold-unordered<a, b> a(acc a, a unordered-set b, f act a(a, b))
	acc fold-keys-unordered a.inner, f
