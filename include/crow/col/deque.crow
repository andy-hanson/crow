no-std
import
	../bool: &&, ==, bool, true
	../fun-util: subscript
	../misc: void
	../number: ==, <=>, +, is-even, nat64
	../opt: !, is-empty, new, opt
	../ptr: ==, +, -, set-deref
	../range: ..
	../str: ==, ~~, literal, str
	../str-conv: to-str
	../str-util: join
	../test-util: is
	./array: array, first, fold, for-loop, is-empty, last, rtail, size, tail
	./mut-array: begin-ptr, cast-immutable, end-ptr, mut-array, subscript, uninitialized-mut-array
	./list: ==, for-loop, list, new, to-array, to-list
	./stack:
		~, is-empty, fold, for-loop, new, pop, rest, reversed, size, stack, to-list, value

# Immutable double-ended queue.
deque<a> record
	# NOTE: This is in reverse (top of the stack furthest left)
	.left stack a
	.mid array a
	.right stack a

###
Deque containing the given elements.
###
new<a> deque a(...a array a)
	a.to-list to-deque

###
Convert a list to a deque. 
This is O(1).
###
to-deque<a> deque a(a a[])
	# TODO: should not need type annotation
	()::stack<a>, a.to-array, ()

# Copy elements to a list.
to-list<a> a[](a deque a) trusted
	res mut-array a = a.size uninitialized-mut-array
	end = res.begin-ptr fold a, (out, x) =>
		*out := x
		out + 1
	assert end == res.end-ptr
	res.cast-immutable to-list

###
`true` iff `a.size == 0`.
This is O(1).
###
is-empty<a> bool(a deque a)
	a.left.is-empty && a.mid.is-empty && a.right.is-empty

###
Number of elements in the deque.
This is O(n).
###
size<a> nat64(a deque a)
	a.left.size + a.mid.size + a.right.size

# Pushes an element on the right.
~ <a> deque a(a deque a, value a)
	a.left, a.mid, a.right ~ value

# Pushes an element on the left.
~ <a> deque a(value a, a deque a)
	a.left ~ value, a.mid, a.right

# Result of popping (left or right): The value popped and remaining values.
popped<a> record
	value a
	rest deque a

###
Remove a value from the left.
Returns an empty option iff `a` is empty.
###
pop-left<a> popped<a>?(a deque a)
	if popped ?= a.left pop
		(popped.value, (popped.rest, a.mid, a.right)),
	elif first ?= a.mid first
		(first, (()::stack<a>, a.mid.tail, a.right)),
	else
		right-arr = a.right.to-list to-array
		if first ?= right-arr first
			(first, right-arr.tail.to-list.to-deque),

###
Remove a value from the right.
Returns an empty option iff `a` is empty.
###
pop-right<a> popped<a>?(a deque a)
	if popped ?= a.right pop
		(popped.value, (a.left, a.mid, popped.rest)),
	elif last ?= a.mid last
		(last, (a.left, a.mid.rtail, ())),
	else
		left-arr = a.left.reversed.to-list to-array
		if last ?= left-arr last
			(last, left-arr.rtail.to-list.to-deque),

region iteration

for-loop<a> void(a deque a, f act void(a))
	a.left.reversed for-loop f
	a.mid for-loop f
	a.right for-loop f

fold<a, b> a(acc a, a deque b, f act a(a, b))
	acc fold a.left.reversed, f fold a.mid, f fold a.right, f

filter<a> deque a(a deque a, f act bool(a)) trusted
	res mut-array a = a.size uninitialized-mut-array
	end = res.begin-ptr fold a, (out, x) =>
		if f[x]
			*out := x
			out + 1
		else
			out
	res[0 .. end - res.begin-ptr].cast-immutable.to-list to-deque

for-loop<out, in> out[](a deque in, f act out(in)) trusted
	res mut-array out = a.size uninitialized-mut-array
	end = res.begin-ptr fold a, (out, x) =>
		*out := f[x]
		out + 1
	assert end == res.end-ptr
	res.cast-immutable to-list

for-loop<out, in> deque out(a deque in, f act out(in))
	a for-loop f to-deque

.dbg str(a deque nat64)
	left = "" join for x : a.left.reversed; "{x} "
	mid = " " join for x : a.mid.to-list; "{x}"
	right = "" join for x : a.right; " {x}"
	"{left}[{mid}]{right}"

test
	a deque nat64 = ()
	assert a is-empty
	a.dbg is "[]"
	a.to-list is ()
	# TODO: 'a.pop-left is ()'
	a.pop-left.is-empty is true
	a.pop-right.is-empty is true

	bl = 1 ~ a
	bl.dbg is "1 []"
	bl.to-list is (1,)
	bl-pop-left = bl.pop-left!
	bl-pop-left.value is 1
	# TODO: 'is deque'
	bl-pop-left.rest.to-list is ()
	bl-pop-right = bl.pop-right!
	bl-pop-right.value is 1
	bl-pop-right.rest.to-list is ()

	br = a ~ 1
	br.dbg is "[] 1"
	br.to-list is bl.to-list
	br-pop-left = br.pop-left!
	br-pop-left.value is 1
	br-pop-left.rest.to-list is ()
	br-pop-right = br.pop-right!
	br-pop-right.value is 1
	br-pop-right.rest.to-list is ()

	c = bl ~ 2 ~ 3
	c.dbg is "1 [] 2 3"
	c-pop = c.pop-left!
	c-pop.value is 1

	# Forces it to convert to an array
	d = c-pop rest
	d.dbg is "[] 2 3"
	d-pop-left = d.pop-left!
	d-pop-left.value is 2
	d-pop-left.rest.to-list is (3,)

	d-pop = d.pop-left!
	d-pop.value is 2
	d-pop.rest.dbg is "[3]"

	# Test converting right stack to array
	e = 1 ~ (2 ~ (3 ~ ()))
	e.to-list is (1, 2, 3)
	e.dbg is "1 2 3 []"
	e-pop = e.pop-right!
	e-pop.value is 3
	e-pop.rest.dbg is "[1 2]"

	six deque nat64 = 1 ~ (2 ~ (3, 4)) ~ 5 ~ 6
	six.dbg is "1 2 [3 4] 5 6"
	folded = 10 fold six, (x, y) => x + y
	folded is 31
	(six filter it => it is-even).to-list is (2, 4, 6)
	(for x : six; x + 10)::nat64[] is (11, 12, 13, 14, 15, 16)
