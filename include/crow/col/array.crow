###
More functions on arrays are in the `crow/col/array-util` module.
###

no-std
import
	../bool: !, &&, ||, bool, false, true
	../compare: !=, <, <=, >, compare, comparison, equal, greater, less
	../fun-util: subscript
	../misc: break-or-continue, loop-break, new, void
	../number: ==, <=>, +, -, *, nat64, round-up-to-power-of-two
	../option: new, option
	../private/alloc: alloc-uninitialized, copy-data-from
	../private/bootstrap: new
	../private/range-low-level: .., high, low, range, size
	../pointer:
		==, <=>, +, -, *, as-const, const-pointer, mut-pointer, null, pointer-cast, set-deref,
		size-of, subscript
	./iter: new, value-and-rest
export
	../private/bootstrap: array, begin-pointer, size

# Create an array with the given elements.
new<a> array a(...a array a) noctx
	a

# Make an array from a range
for-loop<out> array out(a range nat64, f act out(nat64)) trusted
	with out : a.size build-array
		n mut = a low
		loop
			if n == a.high
				break
			else
				out ~= f[n]
				n := n + 1
				continue

# `true` iff `a.size == 0`.
is-empty<a> bool(a array a) noctx
	a.size == 0

###
Gets the element at the index.
Throws if `index >= a.size`.
###
subscript<a> a(a array a, index nat64) noctx trusted
	assert index < a.size : "index out of bounds"
	a.begin-pointer[index]

###
Gets an array elements from 'range.low' (inclusive) to 'range.height' (exclusive).
This works in O(1) without copying any elements.
Throws if the slice would exceed the bounds of the array.
###
subscript<a> array a(a array a, range range nat64) noctx trusted
	assert range.high <= a.size : "slice out of bounds"
	a.begin-pointer + range.low .. a.begin-pointer + range.high as-array

###
Prepend an element to an array.
This is O(n).
###
~ <a> array a(a a, b array a)
	(a,) ~~ b

###
Append an element to an array.
This is O(n).
###
~ <a> array a(a array a, b a)
	a ~~ (b,)

###
Concatenates two arrays.
This is O(n).

If you need concatenate many arrays, use a `mut[]` to accumulate elements, then call `move-to-array`.
###
~~ <a> array a(a array a, b array a) trusted
	res-size = a.size + b.size
	res a mut* = res-size alloc-uninitialized
	res copy-data-from a.begin-pointer, a.size
	res + a.size copy-data-from b.begin-pointer, b.size
	res.as-const[0 .. res-size]

# TODO: array comparison should be generic
array-equal<a> bool(a array a, b array a) no-doc trusted noctx equal<a>
	a.begin-pointer equal-recur a.end-pointer, b.begin-pointer, b.end-pointer
.equal-recur<a> bool(a a*, a-end a*, b a*, b-end a*) unsafe noctx equal<a>
	if a == a-end
		b == b-end
	else
		b != b-end && *a == *b && a + 1 equal-recur a-end, b + 1, b-end

array-equal<a> bool(a array a, b array a, eq act bool(a, a)) no-doc trusted
	a.begin-pointer equal-recur a.end-pointer, b.begin-pointer, b.end-pointer, eq
.equal-recur<a> bool(a a*, a-end a*, b a*, b-end a*, eq act bool(a, a)) unsafe
	if a == a-end
		b == b-end
	else
		b != b-end && eq[*a, *b] && a + 1 equal-recur a-end, b + 1, b-end, eq

array-compare<a> comparison(a array a, b array a) no-doc trusted noctx compare<a>
	a.begin-pointer compare-recur a.end-pointer, b.begin-pointer, b.end-pointer
.compare-recur<a> comparison(a a*, a-end a*, b a*, b-end a*) unsafe noctx compare<a>
	if a == a-end
		if b == b-end
			equal
		else
			less
	elif b == b-end
		greater
	else
		match *a <=> *b
		as less
			less
		as equal
			a + 1 compare-recur a-end, b + 1, b-end
		as greater
			greater

# region basic array operations

###
Returns a new array like `a` but where `a[index]` is `new-value`.
This is O(n).

`index` must be a valid index into `a`. This can't be used to add a value to the end.
###
update-at<a> array a(a array a, index nat64, new-value a)
	assert index < a.size : "index out of bounds"
	# TODO:PERF (only concat once)
	a[0 .. index] ~ new-value ~~ a[index + 1 .. a.size]

###
Inserts an element at index `index`, all elements there and after to the right.
Unlike for `update-at`, `index` can be `a.size`, though it still can't be higher.
###
insert-at<a> array a(a array a, index nat64, value a)
	assert index <= a.size : "index out of bounds"
	# TODO:PERF (only concat once)
	a[0 .. index] ~ value ~~ a[index .. a.size]

# Removes the element at index `index`, shifting all later elements to the left.
remove-at<a> array a(a array a, index nat64)
	assert index < a.size : "index out of bounds"
	a[0 .. index] ~~ a[index + 1 .. a.size]

# Same as `a[0]`, but returns an empty option if `a` is empty.
first<a> a?(a array a)
	unless a is-empty
		a[0],

# Same as `a[a.size - 1]`, but returns an empty option if `a` is empty.
last<a> a?(a array a)
	unless a is-empty
		a[a.size - 1],

###
All but the first element.
Same as `a[1 .. a.size]`.
Throws if `a` is empty.
###
tail<a> array a(a array a)
	forbid a is-empty : "tail of empty array"
	a[1 .. a.size]

###
All but the last element.
Same as `a[0 .. a.size - 1]`.
Throws if `a` is empty.
###
rtail<a> array a(a array a)
	forbid a is-empty : "rtail of empty array"
	a[0 .. a.size - 1]

region search

# TODO: only written this way to be `noctx`, else could defer to `exists`
###
Equivalent to `a[0] == value || a[1] == value || ... || a[a.size - 1] == value`.
Also equivalent to `a exists x => x == value`.
###
in<a> bool(value a, a array a) noctx trusted equal<a>
	cur mut = a begin-pointer
	end = a end-pointer
	loop
		if cur == end
			break false
		elif *cur == value
			break true
		else
			cur := cur + 1
			continue

###
Returns the first index `i` where `a[i] == value`.

Equivalent to `a find-index x => x == value`.
Returns an empty option iff `value` is not in the array.
###
index-of<a> nat64?(a array a, value a) noctx trusted equal<a>
	if v ?= a pointer-of value
		v - a.begin-pointer,

###
Returns a pointer to the first element equal to `value`.
Returns an empty option iff `value` is not in the array.
###
pointer-of<a> a*?(a array a, value a) no-doc noctx unsafe equal<a>
	cur mut = a begin-pointer
	end = a end-pointer
	loop
		if cur == end
			break
		elif *cur == value
			break cur,
		else
			cur := cur + 1
			continue

###
Returns the first index `i` for which `f[a[i]]` is true.
Returns an empty option iff `f` returns `false` for every element of `a`.
###
find-index<a> nat64?(a array a, f act bool(a)) no-doc trusted
	for x, i : a
		if f[x]
			break i

region iteration

###
Equivalent to `f[a[0]] || f[a[1]] || ... || f[a[a.size - 1]]`

Calls `f` on each element of `a` and returns `true` the first time `f` does.
Returns `false` iff `f` returned `false` every time.
###
exists<a> bool(a array a, f act bool(a))
	!a.is-empty && (f[a[0]] || (a.tail exists f))

###
Equivalent to `f[a[0]] && f[a[1]] && ... && f[a[a.size - 1]]`.

Calls `f` on each element of `a` and returns `false` the fist time `f` does.
Returns `true` iff `f` returned `true` every time.
###
every<a> bool(a array a, f act bool(a))
	a.is-empty || (f[a[0]] && (a.tail every f))

###
Equivalent to calling `f[a[0]]`, `f[a[1]]`, etc.

Calls `f` for each element in `a`.
###
for-loop<a> void(a array a, f act void(a)) trusted
	if size-of@<a> == 0
		i mut = 0
		until i == a.size
			f[a[i]]
			i := i + 1
	else
		cur mut = a begin-pointer
		end = a end-pointer
		until cur == end
			f[*cur]
			cur := cur + 1

###
Equivalent to `f[a[0]], f[a[1]], ...`.
Array containing `f[x]` for each `x` in `a`.
###
for-loop<out, in> array out(a array in, f act out(in))
	with out : a.size build-array
		for x : a
			out ~= f[x]

###
Equivalent to calling `f[a[0], 0]`, `f[a[1], 1]`, etc.

Calls `f` for each element in `a`, also providing the index.
###
for-loop<a> void(a array a, f act void(a, nat64))
	i mut = 0
	until i == a.size
		f[a[i], i]
		i := i + 1

for-loop<out, in> array out(a array in, f act out(in, nat64))
	with out : a.size build-array
		for x, i : a
			out ~= f[x, i]

for-break<out, in> out?(a array in, f act break-or-continue out(in))
	i mut nat64 = 0
	loop
		if i == a.size
			break
		else
			match f[a[i]]
			as loop-break x
				break x,
			as loop-continue
				i := i + 1
				continue
for-break<out, in> out(a array in, f-loop act break-or-continue out(in), f-else act out())
	i mut nat64 = 0
	loop
		if i == a.size
			break f-else[]
		else
			match f-loop[a[i]]
			as loop-break x
				break x
			as loop-continue
				i := i + 1
				continue
for-break<out, in> out?(a array in, f act break-or-continue out(in, nat64))
	i mut nat64 = 0
	loop
		if i == a.size
			break
		else
			match f[a[i], i]
			as loop-break x
				break x,
			as loop-continue
				i := i + 1
				continue
for-break<out, in> out(a array in, f-loop act break-or-continue out(in, nat64), f-else act out())
	i mut nat64 = 0
	loop
		if i == a.size
			break f-else[]
		else
			match f-loop[a[i], i]
			as loop-break x
				break x
			as loop-continue
				i := i + 1
				continue

# Array containing only the elements of `a` for which `f[a[i]]` returns true.
filter<a> array a(a array a, f act bool(a))
	a filter (cur, _) => f[cur]

# Like `filter`, but also provides the element index.
filter<a> array a(a array a, f act bool(a, nat64))
	with out : build-array
		for x, i : a
			if f[x, i]
				out ~= x

region iter

array-iter<a> record by-val
	.xs array a
	# Index of the next value to return.
	# If at the end of the array, this iterator is empty.
	.index nat64

new<a> array-iter a() noctx
	(), 0

iter<a> array-iter<a>(a array a) noctx
	a, 0

# Iterator at the end, suitable for iterating over `a` by calling `prev`.
end-iter<a> array-iter<a>(a array a) noctx
	a, a.size

next<a> value-and-rest<a, array-iter a>?(a array-iter a) trusted noctx
	assert a.index <= a.xs.size
	if a.index != a.xs.size
		(a.xs[a index], (a.xs, a.index + 1)),

prev<a> value-and-rest<a, array-iter a>?(a array-iter a) trusted noctx
	assert a.index <= a.xs.size
	if a.index != 0
		prev-index = a.index - 1
		(a.xs[prev-index], (a.xs, prev-index)),

slice-left<a> array a(a array-iter a)
	a.xs[0 .. a.index]

slice-right<a> array a(a array-iter a)
	a.xs[a.index .. a.xs.size]

region low-level

# Pointer to the end of an array.
end-pointer<a> a*(a array a) noctx unsafe
	a.begin-pointer + a.size

###
Arr or the range from begin to end.
`begin` is inclusive and `end` is exclusive.
UB if begin > end.
###
as-array<a> array a(pointers range a*) unsafe noctx
	pointers.size, pointers.low
as-array<a> array a(pointers range a mut*) unsafe noctx
	pointers.size, pointers.low.as-const

array-cast<out, in> array out(a array in) no-doc unsafe noctx
	assert size-of@<out> == size-of@<in>
	a.size, a.begin-pointer.pointer-cast

# Create an array from a range of pointers.
subscript<a> array a(a a*, r range nat64) noctx unsafe
	r.high - r.low, a + r.low

region builder

build-array record
	.size-hint nat64
build-array build-array()
	0,
build-array build-array(size-hint nat64)
	size-hint,

array-builder<a> record mut
	.begin mut a mut*
	.cur mut a mut*
	.end mut a mut*

with-block<a> array a(a build-array, f act void(array-builder a)) trusted
	begin a mut* = a.size-hint alloc-uninitialized
	builder array-builder a = begin, begin, begin + a.size-hint
	f[builder]
	res = builder.begin .. builder.cur as-array
	builder.begin := null
	builder.cur := null
	builder.end := null
	res

~=<a> void(a array-builder a, value a) trusted
	forbid a.begin == null
	assert a.cur <= a.end
	if a.cur == a.end
		cur-size = a.end - a.begin
		new-capacity = cur-size == 0 ? 4 : cur-size * 2
		new-begin a mut* = new-capacity alloc-uninitialized
		new-begin copy-data-from a.begin.as-const, cur-size
		a.begin := new-begin
		a.cur := new-begin + cur-size
		a.end := new-begin + new-capacity
	*a.cur := value
	a.cur := a.cur + 1

~~=<a> void(a array-builder a, values array a) trusted
	forbid a.begin == null
	assert a.cur <= a.end
	if a.cur + values.size > a.end
		cur-size = a.cur - a.begin
		min-size = cur-size + values.size
		new-capacity = min-size.round-up-to-power-of-two
		new-begin a mut* = new-capacity alloc-uninitialized
		new-begin copy-data-from a.begin.as-const, cur-size
		a.begin := new-begin
		a.cur := new-begin + cur-size
		a.end := new-begin + new-capacity
	a.cur copy-data-from values.begin-pointer, values.size
	a.cur := a.cur + values.size
