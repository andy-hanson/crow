no-std
import
	../bool: &&, bool
	../compare: <, >, <=, compare
	../fun-util: subscript
	../json: json
	../misc: is-data, new, void
	../number: ==, <=>, +, -, nat64
	../option: !, is-empty, new, option
	../pointer: ==, +, mut-pointer, set-deref
	../string: ~~, ==, join, literal, new, string, to-string
	../test-util: is
	../test-util/spy: calls, fn, new, spy-act2
	../tuple: ==, from, new, pair, to
	./array: array, first, for-loop, is-empty, new, size, tail
	./mut-array:
		begin-pointer, cast-immutable, end-pointer, first, mut-array, set-subscript, size, subscript,
		tail, uninitialized-mut-array
	./list: ==, ~=, build, first, for-loop, is-empty, list, new, tail, to-array, to-list, with-block
	./sort: set-sort, sort

###
Immutable priority queue.

Elements are key-value pairs. Pairs are sorted by key.
Popping removes the pair with the lowest key.

If two pairs have the same key, the second pair added will be popped second.
###
priority-queue[k, v] record
	.root (k, v) node?

###
Priority queue consists of a linked list of nodes with two parts.
First part is recently inserted values. These all have a single pair in 'min' and nothing in 'pairs'.
Next part is compacted arrays of pairs. These are sorted biggest to smallest.
They grow exponentially from right to left, so total # of these nodes is logarithmic in queue size.

So node sizes might look like:

	1 1 1 8 4 2 1

A push operation just adds to the left.
Then right before a pop operation, we will compact all the left nodes into a big node,
and also compact any nodes of the same size or less with it.
(This applies recursively, so if the 3 1s were compacted,
they would join with the `1` on the right to size 4, then with the `2` on the right to size 6,
then with the `4` to size 10, then with the `8` to size 18, leaving only one node.)
###

.node[k, v] record
	min (k, v)
	pairs (k, v) array
	next (k, v) node?

# New priority queue containing the given pairs.
new[k, v] (k, v) priority-queue(...a (k, v) array) k is-data, k compare
	a.to-list to-priority-queue

# New priority queue containing the given pairs.
to-priority-queue[k, v] (k, v) priority-queue(a (k, v)[]) k is-data, k compare
	if a is-empty
		# TODO: type annotation should not be necessary
		()::((k, v) node?),
	else
		sorted = a sort pair => pair from
		root (k, v) node = sorted.first!, sorted.tail.to-array, ()
		# TODO: type annotation should not be necessary
		(root,)::((k, v) node?),

to-list[k, v] (k, v)[](a (k, v) priority-queue) k is-data, k compare
	for k, v : a
		k, v

# True iff `a.size == 0`.
is-empty[k, v] bool(a (k, v) priority-queue) k is-data, k compare
	a.root is-empty

###
Number of pairs in the priority queue.

This is O(n).
###
size[k, v] nat64(a (k, v) priority-queue) k is-data, k compare
	acc mut = 0
	cur mut = a root
	loop
		if node ?= cur
			acc := acc + 1 + node.pairs.size
			cur := node next
			continue
		else
			break acc

###
Adds a pair to the queue.

This is O(1), since the work of sorting pairs is actually done in `pop`.
###
~[k, v] (k, v) priority-queue(a (k, v) priority-queue, b (k, v)) k is-data, k compare
	root (k, v) node = b, (), a.root
	# TODO: type annotation should not be necessary
	(root,)::((k, v) node?),

popped[k, v] record
	popped (k, v)
	rest (k, v) priority-queue

###
Removes and returns the pair with the lowest key.

Returns an empty option iff `a` is empty.

This is amortized O(log n).
###
pop[k, v] (k, v) popped?(a (k, v) priority-queue) k is-data, k compare
	if root ?= a.compact-leading-nodes root
		if next ?= root next
			if popped ?= next pop-no-compact-recur root.min.from
				(root combine-with-popped popped),
			else
				root.pop-from-node,
		else
			root.pop-from-node,

.pop-from-node[k, v] (k, v) popped(a (k, v) node)
	# TODO: type annotation should not be necessary
	rest (k, v) node? = if first ?= a.pairs first
		(first, a.pairs.tail, a.next),
	else
		a next
	a.min, (rest,)

# Returns none if this (or any following node) did not have a lower min.
.pop-no-compact-recur[k, v] (k, v) popped?(a (k, v) node, min k) k compare
	is-min = a.min.from < min
	next-popped = if next ?= a next
		next pop-no-compact-recur if is-min
			a.min from
		else
			min
	if next ?= next-popped
		(a combine-with-popped next),
	elif is-min
		a.pop-from-node,

.combine-with-popped[k, v] (k, v) popped(a (k, v) node, popped (k, v) popped)
	root (k, v) node = a.min, a.pairs, popped.rest.root
	# TODO: type annotation should not be necessary
	popped.popped, ((root,)::((k, v) node?),)

.compact-leading-nodes[k, v] (k, v) priority-queue(a (k, v) priority-queue) trusted, k compare
	mid = a.root find-mid 0
	if mid.n-before-mid == 0
		a
	else
		root = a.root!
		match mid.mid plan root, mid.n-before-mid
		as plan-did-compact compacted
			# TODO: type annotation should not be necessary
			(compacted,)::((k, v) node)?,
		as plan-will-compact n
			# TODO: type annotation should not be necessary
			((root do-compact n, mid.mid),)::((k, v) node)?,

.found-mid[k, v] record
	mid (k, v) node?
	n-before-mid nat64

# Finds the first node with 'pairs' non-empty.
# Also returns the # of nodes before that
.find-mid[k, v] (k, v) found-mid(a (k, v) node?, n-before nat64)
	if node ?= a
		if node.pairs is-empty
			node.next find-mid n-before + 1
		else
			(node,), n-before
	else
		(), n-before

.plan[k, v] union
	plan-did-compact (k, v) node
	# has the number of elements to compact
	plan-will-compact nat64

# We only call this if we will definitely compact something,
# TODO: 'plan' is misnamed, this now does the compaction during the recursion
.plan[k, v] (k, v) plan(a (k, v) node?, root (k, v) node, n-singles nat64) k compare
	if node ?= a
		match node.next plan root, n-singles
		as plan-did-compact compacted
			(node.min, node.pairs, (compacted,)) plan-did-compact
		as plan-will-compact n-elements-to-compact
			node-size-here = 1 + node.pairs.size
			if node-size-here <= n-elements-to-compact
				n-elements-to-compact + node-size-here plan-will-compact
			else
				compacted = root do-compact n-elements-to-compact, node.next
				(node.min, node.pairs, (compacted,)) plan-did-compact
	else
		n-singles plan-will-compact

.do-compact[k, v] (k, v) node(root (k, v) node, n-to-compact nat64, nodes-to-compact (k, v) node?) trusted, k compare
	compacted (k, v) mut-array = n-to-compact uninitialized-mut-array
	mid = compacted.begin-pointer compact-non-singles nodes-to-compact
	end = mid compact-singles root
	assert end == compacted.end-pointer
	compacted set-sort pair => pair from
	arr = compacted cast-immutable
	arr.first!, arr.tail, ()

.compact-singles[k, v] (k, v) mut*(out (k, v) mut*, a (k, v) node) unsafe
	if a.pairs is-empty
		# Output later nodes first to preserve insertion order (since they're inserted to the front)
		pos = if next ?= a next
			out compact-singles next
		else
			out
		*pos := a.min
		pos + 1
	else
		out

.compact-non-singles[k, v] (k, v) mut*(out (k, v) mut*, a (k, v) node?) unsafe
	if node ?= a
		*out := node min
		cur mut = out + 1
		for x : node pairs
			*cur := x
			cur := cur + 1
		cur compact-non-singles node.next
	else
		out

.dbg string(a (nat64, string) priority-queue)
	a.root dbg
.dbg string(a (nat64, string) node?)
	if node ?= a
		pairs = ", " join for pair : node.pairs to-list
			"{pair from} {pair to}"
		rest = node.next.is-empty ? "" : "; {node.next dbg}"
		"{node.min from} {node.min to} [{pairs}]{rest}"

region iteration

for-loop[k, v] void(a (k, v) priority-queue, f act void(k, v)) k is-data, k compare
	a.each-arr walk f

.each-part[k, v] record mut
	min mut (k, v)
	pairs mut (k, v) array

.each-arr[k, v] (k, v) each-part mut-array(a (k, v) priority-queue) trusted, k compare
	res (k, v) each-part mut-array = a.node-count uninitialized-mut-array
	end = res.begin-pointer fill-each-arr a.root
	assert end == res.end-pointer
	res set-sort it => it.min from
	res

.node-count[k, v] nat64(a (k, v) priority-queue)
	0 node-count a.root

.node-count[k, v] nat64(acc nat64, a (k, v) node?)
	if node ?= a
		acc + 1 node-count node.next
	else
		acc

.fill-each-arr[k, v] (k, v) each-part mut*(out (k, v) each-part mut*, a (k, v) node?) unsafe
	if node ?= a
		*out := node.min, node.pairs
		out + 1 fill-each-arr node.next
	else
		out

.walk[k, v] void(a (k, v) each-part mut-array, f act void(k, v)) k compare
	if head ?= a first
		min = head min
		f[min from, min to]
		if first-pair ?= head.pairs first
			head.min := first-pair
			head.pairs := head.pairs tail
			a swap-sorted
			a walk f
		else
			a.tail walk f

.swap-sorted[k, v] void(a (k, v) each-part mut-array) k compare
	if a.size > 1 && a[0].min.from > a[1].min.from
		# TODO: use a swap function
		temp = a[0]
		a[0] := a[1]
		a[1] := temp
		a.tail swap-sorted

filter[k, v] (k, v) priority-queue(a (k, v) priority-queue, f act bool(k, v)) trusted, k is-data, k compare
	pairs (k, v)[] = with out : build
		for k, v : a
			if f[k, v]
				out ~= (k, v)
	pairs to-priority-queue

for-loop[k-out, v-out, k-in, v-in] (k-out, v-out) priority-queue(
	a (k-in, v-in) priority-queue,
	f act (k-out, v-out)(k-in, v-in),
) k-in is-data, k-in compare, k-out is-data, k-out compare
	a for-loop f to-priority-queue

for-loop[out, k, v] out[](a (k, v) priority-queue, f act out(k, v)) trusted, k is-data, k compare
	with out : a.size build
		for k, v : a
			out ~= f[k, v]

keys[k, v] k[](a (k, v) priority-queue) k is-data, k compare
	for k, _ : a
		k

values[k, v] v[](a (k, v) priority-queue) k is-data, k compare
	for _, v : a
		v

test
	p (nat64, string) priority-queue = ()

	p1 = p ~ (5, "5")
	p1.dbg is "5 5 []"

	p2 = p1 ~ (6, "6")
	p2.dbg is "6 6 []; 5 5 []"
	p2.compact-leading-nodes.dbg is "5 5 [6 6]"

	p2pop = p2.pop!
	p2pop.popped is (5, "5")
	p2pop.rest.dbg is "6 6 []"

	p3 = p2 ~ (4, "4")
	p4 = p3 ~ (7, "7")

	p4.dbg is "7 7 []; 4 4 []; 6 6 []; 5 5 []"

	p4pop = p4.pop!
	p4pop.popped is (4, "4")
	p4pop.rest.dbg is "5 5 [6 6, 7 7]"

	p5 = p4pop.rest ~ (6, "6b") ~ (6, "6c")
	p5.dbg is "6 6c []; 6 6b []; 5 5 [6 6, 7 7]"

	p5pop = p5.pop!
	p5pop.popped is (5, "5")
	p5pop.rest.dbg is "6 6 [7 7]; 6 6b [6 6c]"

	p6 = p5pop.rest ~ (7, "7b") ~ (8, "8")
	p6.dbg is "8 8 []; 7 7b []; 6 6 [7 7]; 6 6b [6 6c]"
	p6.size is 6
	p6-pairs (nat64, string)[] = (6, "6"), (6, "6b"), (6, "6c"), (7, "7"), (7, "7b"), (8, "8")
	p6.to-list is p6-pairs
	p6.keys is (6, 6, 6, 7, 7, 8)
	p6.values is ("6", "6b", "6c", "7", "7b", "8")

	p6pop = p6.pop!
	p6pop.rest.dbg is "6 6b [6 6c, 7 7, 7 7b, 8 8]"

	joined = ", " join for k, v : p6
		"{k} -> {v}"
	joined is "6 -> 6, 6 -> 6b, 6 -> 6c, 7 -> 7, 7 -> 7b, 8 -> 8"

	filter-order (bool, nat64, string) spy-act2 = ((k, _) => k == 6),
	filtered = p6 filter filter-order.fn
	filter-calls = filter-order calls
	filter-calls is p6-pairs
	filtered.dbg is "6 6 [6 6b, 6 6c]"

	map-order ((nat64, string), nat64, string) spy-act2 = ((k, v) => (10 - k), "{v}x"),
	mapped (nat64, string) priority-queue = p6 for-loop map-order.fn
	map-calls = map-order calls
	map-calls is p6-pairs
	mapped.dbg is "2 8x [3 7x, 3 7bx, 4 6x, 4 6bx, 4 6cx]"
