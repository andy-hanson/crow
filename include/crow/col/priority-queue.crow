no-std
import
	../bool: !, &&, bool, false, true
	../compare: <, >, <=, compare
	../fun: subscript
	../misc: ->, arrow, data, from, to, void
	../opt: force, is-empty, none, opt, some
	../ptr: ==, +, -, mut-ptr, set-deref
	../range: ..
	../str: ==, str
	../str-conv: finish, interp, to-str, with-str, with-value
	../test: is
	../test/spy: calls, fn, spy-act
	../tuple: a, b, pair
	../writer: ~=, backup!, move-to-str!, writer
	../private/bootstrap: hard-assert
	../private/number-low-level: ==, <=>, nat64, wrap-add, wrap-sub
	./arr: ==, arr, is-empty, size
	./arr-util: each, first, fold, map, tail
	./fix-arr:
		begin-ptr, cast-immutable, end-ptr, first, fix-arr, set-subscript, size, subscript,
		tail, uninitialized-fix-arr
	./sort: sort-by, sort-by!

priority-queue<k, v> record
	# TODO: PRIVATE
	ignore void
	root node<k, v>?

###
Priority queue consists of a linked list of nodes with two parts.
First part is recently inserted values. These all have a single pair in 'min' and nothing in 'pairs'.
Next part is compacted arrays of pairs. These are sorted biggest to smallest.
They grow exponentially from right to left, so total # of these nodes is logarithmic in queue size.

So node sizes might look like:

	1 1 1 8 4 2 1

A push operation just adds to the left.
Then right before a pop operation, we will compact all the left nodes into a big node,
and also compact any nodes of the same size or less with it.
(This applies recursively, so if the 3 1s were compacted,
they would join with the `1` on the right to size 4, then with the `2` on the right to size 6,
then with the `4` to size 10, then with the `8` to size 18, leaving only one node.)
###

.node<k, v> record
	min arrow<k, v>
	pairs arrow<k, v>[]
	next node<k, v>?

priority-queue<k, v> priority-queue<k, v>() data<k> compare<k>
	void priority-queue none

priority-queue<k, v> priority-queue<k, v>(a arrow<k, v>[]) data<k> compare<k>
	if a is-empty
		priority-queue
	else
		sorted = a sort-by pair => pair from
		void priority-queue (sorted.first.force node sorted.tail, none).some

is-empty<k, v> bool(a priority-queue<k, v>) data<k> compare<k>
	a.root is-empty

size<k, v> nat64(a priority-queue<k, v>) data<k> compare<k>
	0 size-recur a.root
.size-recur<k, v> nat64(acc nat64, a node<k, v>?)
	if node ?= a
		acc wrap-add 1 wrap-add node.pairs.size size-recur node.next
	else
		acc

###
Add a pair to the queue.
This is O(1).
###
~ <k, v> priority-queue<k, v>(a priority-queue<k, v>, b arrow<k, v>) data<k> compare<k>
	void priority-queue (b node [], a.root).some

popped<k, v> record
	popped arrow<k, v>
	rest priority-queue<k, v>

pop<k, v> popped<k, v>?(a priority-queue<k, v>) data<k> compare<k>
	if root ?= a.compact-leading-nodes root
		if next ?= root next
			some: if popped ?= next pop-no-compact-recur root.min.from
				root combine-with-popped popped
			else
				root pop-from-node
		else
			root.pop-from-node some

.pop-from-node<k, v> popped<k, v>(a node<k, v>)
	# TODO: node<k, v>? should not be necessary
	rest node<k, v>? = if first ?= a.pairs first
		first node a.pairs.tail, a.next some
	else
		a next
	a.min popped (void priority-queue rest)

# Returns none if this (or any following node) did not have a lower min.
.pop-no-compact-recur<k, v> popped<k, v>?(a node<k, v>, min k) compare<k>
	is-min = a.min.from < min
	next-popped = if next ?= a next
		next pop-no-compact-recur if is-min
			a.min from
		else
			min
	if next ?= next-popped
		a combine-with-popped next some
	elif is-min
		a.pop-from-node some
	else
		none

combine-with-popped<k, v> popped<k, v>(a node<k, v>, popped popped<k, v>)
	node = a.min node<k, v> a.pairs, popped.rest.root
	popped.popped popped (void priority-queue node.some)

.compact-leading-nodes<k, v> priority-queue<k, v>(a priority-queue<k, v>) compare<k> trusted
	mid = a.root find-mid 0
	if mid.n-before-mid == 0
		a
	else
		root = a.root force
		void priority-queue some: match mid.mid plan root, mid.n-before-mid
		as plan-did-compact compacted
			compacted
		as plan-will-compact n
			root do-compact n, mid.mid

.found-mid<k, v> record
	mid node<k, v>?
	n-before-mid nat64

# Finds the first node with 'pairs' non-empty.
# Also returns the # of nodes before that
.find-mid<k, v> found-mid<k, v>(a node<k, v>?, n-before nat64)
	if node ?= a
		if node.pairs is-empty
			node.next find-mid (n-before wrap-add 1)
		else
			node.some found-mid n-before
	else
		none found-mid n-before

.plan<k, v> union
	plan-did-compact node<k, v>
	# has the number of elements to compact
	plan-will-compact nat64

# We only call this if we will definitely compact something,
# TODO: 'plan' is misnamed, this now does the compaction during the recursion
.plan<k, v> plan<k, v>(a node<k, v>?, root node<k, v>, n-singles nat64) compare<k>
	if node ?= a
		match node.next plan root, n-singles
		as plan-did-compact compacted
			node.min node<k, v> node.pairs, compacted.some plan-did-compact
		as plan-will-compact n-elements-to-compact
			node-size-here = 1 wrap-add node.pairs.size
			if node-size-here <= n-elements-to-compact
				n-elements-to-compact wrap-add node-size-here plan-will-compact
			else
				compacted = root do-compact n-elements-to-compact, node.next
				node.min node node.pairs, compacted.some plan-did-compact
	else
		n-singles plan-will-compact<k, v>

.do-compact<k, v> node<k, v>(root node<k, v>, n-to-compact nat64, nodes-to-compact node<k, v>?) trusted compare<k>
	compacted = n-to-compact uninitialized-fix-arr<arrow<k, v>>
	mid = compacted.begin-ptr compact-non-singles! nodes-to-compact
	end = mid compact-singles! root
	hard-assert: end == compacted.end-ptr
	compacted sort-by! pair => pair from
	arr = compacted cast-immutable
	arr.first.force node arr.tail, none

.compact-singles!<k, v> arrow<k, v> mut*(out arrow<k, v> mut*, a node<k, v>) unsafe
	if a.pairs is-empty
		# Output later nodes first to preserve insertion order (since they're inserted to the front)
		pos = if next ?= a next
			out compact-singles! next
		else
			out
		*pos := a.min
		pos + 1
	else
		out

.compact-non-singles!<k, v> arrow<k, v> mut*(out arrow<k, v> mut*, a node<k, v>?) unsafe
	if node ?= a
		*out := node min
		out2 = out + 1 fold node.pairs, (cur, x) =>
			*cur := x
			cur + 1
		out2 compact-non-singles! node.next
	else
		out

.dbg str(a priority-queue<nat64, str>)
	res = writer
	res dbg-recur! a.root, true
	res move-to-str!
.dbg-recur! void(out writer, a node<nat64, str>?, first bool)
	if node ?= a
		if !first
			out ~= "; "
		out ~= node.min from
		out ~= " "
		out ~= node.min to
		out ~= " ["
		if !node.pairs.is-empty
			node.pairs each pair =>
				out ~= pair from
				out ~= " "
				out ~= pair to
				out ~= ", "
			out backup! 2
		out ~= "]"
		out dbg-recur! node.next, false

region iteration

each<k, v> void(a priority-queue<k, v>, f act void(k, v)) data<k> compare<k>
	void fold a, (ignore, k, v) => f[k, v]

fold<a, k, v> a(acc a, a priority-queue<k, v>, f act a(a, k, v)) data<k> compare<k>
	acc walk-fold a.each-arr, f

.each-part<k, v> record mut
	min mut arrow<k, v>
	pairs mut arrow<k, v>[]

.each-arr<k, v> fix-arr each-part<k, v>(a priority-queue<k, v>) trusted compare<k>
	res = a.node-count uninitialized-fix-arr<each-part<k, v>>
	end = res.begin-ptr fill-each-arr! a.root
	hard-assert: end == res.end-ptr
	res sort-by! it => it.min from
	res

.node-count<k, v> nat64(a priority-queue<k, v>)
	0 node-count a.root

.node-count<k, v> nat64(acc nat64, a node<k, v>?)
	if node ?= a
		acc wrap-add 1 node-count node.next
	else
		acc

.fill-each-arr!<k, v> each-part<k, v> mut*(out each-part<k, v> mut*, a node<k, v>?) unsafe
	if node ?= a
		*out := node.min each-part node.pairs
		out + 1 fill-each-arr! node.next
	else
		out

.walk-fold<a, k, v> a(acc a, a fix-arr each-part<k, v>, f act a(a, k, v)) compare<k>
	if head ?= a first
		min = head min
		next-acc = f[acc, min from, min to]
		if first-pair ?= head.pairs first
			head.min := first-pair
			head.pairs := head.pairs tail
			a swap-sorted!
			next-acc walk-fold a, f
		else
			next-acc walk-fold a.tail, f
	else
		acc

.swap-sorted!<k, v> void(a fix-arr each-part<k, v>) compare<k>
	if a.size > 1 && a[0].min.from > a[1].min.from
		# TODO: use a swap! function
		temp = a[0]
		a[0] := a[1]
		a[1] := temp
		a.tail swap-sorted!

filter<k, v> priority-queue<k, v>(a priority-queue<k, v>, f act bool(k, v)) trusted data<k> compare<k>
	out = a.size uninitialized-fix-arr<arrow<k, v>>
	end = out.begin-ptr fold a, (cur, k, v) =>
		if f[k, v]
			*cur := k -> v
			cur + 1
		else
			cur
	out[0 .. end - out.begin-ptr].cast-immutable priority-queue

map<k-out, v-out, k-in, v-in> priority-queue<k-out, v-out>
	a priority-queue<k-in, v-in>
	f act arrow<k-out, v-out>(k-in, v-in)
spec
	data<k-in>
	compare<k-in>
	data<k-out>
	compare<k-out>
body
	a map-to-arr f priority-queue

map-to-arr<out, k, v> out[](a priority-queue<k, v>, f act out(k, v)) data<k> compare<k> trusted
	out = a.size uninitialized-fix-arr<out>
	end = out.begin-ptr fold a, (cur, k, v) =>
		*cur := f[k, v]
		cur + 1
	hard-assert: end == out.end-ptr
	arr = out.cast-immutable
	arr

keys<k, v> k[](a priority-queue<k, v>) data<k> compare<k>
	a map-to-arr (k, v) => k

values<k, v> v[](a priority-queue<k, v>) data<k> compare<k>
	a map-to-arr (k, v) => v

test
	p = priority-queue<nat64, str>

	p1 = p ~ (5 -> "5")
	p1.dbg is "5 5 []"

	p2 = p1 ~ (6 -> "6")
	p2.dbg is "6 6 []; 5 5 []"
	p2.compact-leading-nodes.dbg is "5 5 [6 6]"

	p2pop = p2.pop force
	p2pop.popped is 5 -> "5"
	p2pop.rest.dbg is "6 6 []"

	p3 = p2 ~ (4 -> "4")
	p4 = p3 ~ (7 -> "7")

	p4.dbg is "7 7 []; 4 4 []; 6 6 []; 5 5 []"

	p4pop = p4.pop force
	p4pop.popped is 4 -> "4"
	p4pop.rest.dbg is "5 5 [6 6, 7 7]"

	p5 = p4pop.rest ~ (6 -> "6b") ~ (6 -> "6c")
	p5.dbg is "6 6c []; 6 6b []; 5 5 [6 6, 7 7]"

	p5pop = p5.pop force
	p5pop.popped is 5 -> "5"
	p5pop.rest.dbg is "6 6 [7 7]; 6 6b [6 6c]"

	p6 = p5pop.rest ~ (7 -> "7b") ~ (8 -> "8")
	p6.dbg is "8 8 []; 7 7b []; 6 6 [7 7]; 6 6b [6 6c]"
	p6.size is 6

	p6pop = p6.pop force
	p6pop.rest.dbg is "6 6b [6 6c, 7 7, 7 7b, 8 8]"

	folded = "init" fold p6, (acc, k, v) => "{acc}, {k} -> {v}"
	folded is "init, 6 -> 6, 6 -> 6b, 6 -> 6c, 7 -> 7, 7 -> 7b, 8 -> 8"

	p6-pairs = [6 -> "6", 6 -> "6b", 6 -> "6c", 7 -> "7", 7 -> "7b", 8 -> "8"] map x => x pair
	filter-order = spy-act<bool, nat64, str>: (k, v) => k == 6
	filtered = p6 filter filter-order.fn
	filter-calls = filter-order calls
	# TODO: filter-order.calls is p6-pairs
	filter-calls map (x => x a) is (p6-pairs map x => x a)
	filter-calls map (x => x b) is (p6-pairs map x => x b)
	filtered.dbg is "6 6 [6 6b, 6 6c]"

	map-order = spy-act<arrow<nat64, str>, nat64, str>: (k, v) => (10 wrap-sub k) -> "{v}x"
	mapped = p6 map map-order.fn
	map-calls = map-order calls
	# TODO: map-order.calls is p6-pairs
	map-calls map (x => x a) is (p6-pairs map x => x a)
	map-calls map (x => x b) is (p6-pairs map x => x b)
	mapped.dbg is "2 8x [3 7x, 3 7bx, 4 6x, 4 6bx, 4 6cx]"

	p6.keys is [6, 6, 6, 7, 7, 8]
	p6.values is ["6", "6b", "6c", "7", "7b", "8"]

# TODO: arrow should be equatable
== bool(a arrow<nat64, str>, b arrow<nat64, str>) noctx
	a.from == b.from && a.to == b.to
