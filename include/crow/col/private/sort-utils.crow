no-std
import
	../../bool: bool
	../../compare: ==, !=, <, >=, compare, comparison, equal
	../../exception: unreachable
	../../fun-util: subscript
	../../misc: new, void
	../../number: ==, <=>, +, /
	../../option: new, option
	../../pointer: ==, +, -, *, as-const, as-mut, const-pointer, mut-pointer, null, set-deref
	../../test-util: is
	../../tuple: from, pair, to
	../../private/bootstrap: nat64
	../array: array
	../mut-array:
		begin-pointer, cast-immutable, copy-from, end-pointer, mut-array, mut-array-from-begin-end, new
	../list: ==, list, new
	../mut-list:
		begin-pointer, clear, end-pointer, is-empty, move-to-list, mut-list, size, swap, temp-as-mut-array,
		to-mut-list, unsafe-set-size
	./array-low-level: array-from-begin-end, begin-pointer, end-pointer

binary-search-has<a> bool(a array a, value a) compare<a> trusted
	(a.begin-pointer binary-search-exact-pointer-recur a.end-pointer, value) != null

binary-search-key<k, v> v?(a array (k, v), key k) trusted compare<k>
	a.begin-pointer binary-search-key-recur a.end-pointer, key
.binary-search-key-recur<k, v> v?(left (k, v)*, right (k, v)*, key k) trusted compare<k>
	diff = right - left
	if diff < 4
		left linear-search-key-recur right, key
	else
		mid = left + diff / 2
		match key <=> mid->from
		as less
			left binary-search-key-recur mid, key
		as equal
			mid->to,
		as greater
			mid + 1 binary-search-key-recur right, key
.linear-search-key-recur<k, v> v?(left (k, v)*, right (k, v)*, key k) trusted compare<k>
	if left == right
		()
	elif left->from == key
		left->to,
	else
		left + 1 linear-search-key-recur right, key

binary-search-exact-index<a> nat64?(a array a, value a) trusted compare<a>
	pointer = a.begin-pointer binary-search-exact-pointer-recur a.end-pointer, value
	unless pointer == null
		pointer - a.begin-pointer,

binary-search-exact-pointer<a> a mut*?(a a mut[], compare act comparison(a)) unsafe
	a.temp-as-mut-array binary-search-exact-pointer compare

binary-search-exact-pointer<a> a mut*?(a mut-array a, compare act comparison(a)) unsafe
	if x ?= a.cast-immutable binary-search-exact-pointer compare
		x.as-mut,

binary-search-exact-pointer<a> a*?(a array a, value a) compare<a> unsafe
	res = a.begin-pointer binary-search-exact-pointer-recur a.end-pointer, value
	unless res == null
		res,

binary-search-exact-pointer<a> a*?(a array a, compare act comparison(a)) unsafe
	pointer = a.begin-pointer binary-search-compare-recur a.end-pointer, compare
	if pointer == a.end-pointer
		()
	elif compare[*pointer] == equal
		pointer,

binary-search-insert-pointer<a> a mut*(a a mut[], compare act comparison(a)) unsafe
	a.temp-as-mut-array binary-search-insert-pointer compare

###
Returns the pointer to the least value that is compared equal or greater.
Returns `a end-pointer` if all values compare less.
###
binary-search-insert-pointer<a> a mut*(a mut-array a, compare act comparison(a)) unsafe
	a.begin-pointer.as-const binary-search-compare-recur a.end-pointer.as-const, compare as-mut

binary-search-insert-pointer<a> a*(a array a, value a) unsafe compare<a>
	a.begin-pointer binary-search-insert-pointer-recur a.end-pointer, value

test
	a mut-array nat64 = 1, 3, 5, 7
	(a binary-search-insert-pointer x => 0 <=> x) - a.begin-pointer is 0
	(a binary-search-insert-pointer x => 3 <=> x) - a.begin-pointer is 1
	(a binary-search-insert-pointer x => 4 <=> x) - a.begin-pointer is 2
	(a binary-search-insert-pointer x => 5 <=> x) - a.begin-pointer is 2
	(a binary-search-insert-pointer x => 6 <=> x) - a.begin-pointer is 3
	(a binary-search-insert-pointer x => 7 <=> x) - a.begin-pointer is 3
	(a binary-search-insert-pointer x => 8 <=> x) - a.begin-pointer is 4

# Left inclusive, right exclusive
.binary-search-exact-pointer-recur<a> a*(left a*, right a*, value a) unsafe compare<a>
	diff = right - left
	if diff < 4
		left linear-search-exact-pointer-recur right, value
	else
		mid = left + diff / 2
		match value <=> *mid
		as less
			left binary-search-exact-pointer-recur mid, value
		as equal
			mid
		as greater
			mid + 1 binary-search-exact-pointer-recur right, value

.linear-search-exact-pointer-recur<a> a*(left a*, right a*, value a) unsafe compare<a>
	if left == right
		null
	elif *left == value
		left
	else
		left + 1 linear-search-exact-pointer-recur right, value

# Left inclusive, right exclusive
.binary-search-insert-pointer-recur<a> a*(left a*, right a*, value a) unsafe compare<a>
	if left == right
		left
	else
		mid = left + (right - left) / 2
		match value <=> *mid
		as less
			left binary-search-insert-pointer-recur mid, value
		as equal
			mid
		as greater
			mid + 1 binary-search-insert-pointer-recur right, value


# Left inclusive, right exclusive
.binary-search-compare-recur<a> a*(left a*, right a*, compare act comparison(a)) unsafe
	if left == right
		left
	else
		mid = left + (right - left) / 2
		match compare[*mid]
		as less
			left binary-search-compare-recur mid, compare
		as equal
			mid
		as greater
			mid + 1 binary-search-compare-recur right, compare

unique-comparison enum
	less
	greater

assert-comparison-not-equal unique-comparison(a comparison) unsafe
	match a
	as less
		less
	as equal
		unreachable
	as greater
		greater

# 'a' and 'b' must be sorted. Moves contents of 'b' into 'a' and preserves sorting.
merge-no-duplicates<a> void(a a mut[], b a mut[], compare act unique-comparison(a, a)) trusted
	if a.size < b.size
		a swap b
	assert a.size >= b.size
	unless b is-empty
		a-old-size = a size
		a unsafe-set-size a-old-size + b.size
		a-read = a.begin-pointer.as-const + a-old-size - 1
		a-write = a.end-pointer - 1
		bb = b.begin-pointer as-const
		a.begin-pointer merge-reverse-recur a-read, a-write, bb, b.end-pointer.as-const - 1, compare
		b clear

###
Merge right-to-left so we never overwrite anything we still have to read.
In condition: a-read, a-write, b-read are all valid pointers.
###
.merge-reverse-recur<a> void(
	a-begin a mut*,
	a-read a*,
	a-write a mut*,
	b-begin a*,
	b-read a*,
	compare act unique-comparison(a, a),
) unsafe
	match compare[*a-read, *b-read]
	as less
		*a-write := *b-read
		unless b-read == b-begin
			a-begin merge-reverse-recur a-read, a-write - 1, b-begin, b-read - 1, compare
		# Else -- we are done, don't need to touch 'a' any more
	as greater
		*a-write := *a-read
		if a-read == a-begin.as-const
			dest = a-begin mut-array-from-begin-end a-write
			src = b-begin array-from-begin-end b-read + 1
			dest copy-from src
		else
			a-begin merge-reverse-recur a-read - 1, a-write - 1, b-begin, b-read, compare

.test-one void(a nat64[], b nat64[], expected nat64[]) unsafe
	a-mut = a to-mut-list
	b-mut = b to-mut-list
	a-mut merge-no-duplicates b-mut, (x, y) =>
		x <=> y assert-comparison-not-equal
	a-mut.move-to-list is expected

test
	(1, 2, 3) test-one (4, 5, 6), (1, 2, 3, 4, 5, 6)
	(4, 5, 6) test-one (1, 2, 3), (1, 2, 3, 4, 5, 6)
	(1, 3, 5) test-one (2, 4, 6), (1, 2, 3, 4, 5, 6)
	(2, 4, 6) test-one (1, 3, 5), (1, 2, 3, 4, 5, 6)
	(3, 4, 5) test-one (1, 2, 6), (1, 2, 3, 4, 5, 6)
