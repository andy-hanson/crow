no-std
import
	../../bool: !, bool
	../../compare: ==, <, >=, compare, comparison, equal
	../../exception: unreachable
	../../fun-util: subscript
	../../json: json
	../../misc: loop-break, new, void
	../../number: ==, <=>, +, /
	../../option: is-empty, new, option
	../../pointer: ==, <=>, +, -, *, as-const, as-mut, const-pointer, mut-pointer, set-deref
	../../range: .., for-break
	../../test-util: is
	../../tuple: from, pair, to
	../../private/bootstrap: nat64
	../array: array, as-array, begin-pointer, end-pointer, for-break
	../mut-array:
		as-mut-array, begin-pointer, cast-immutable, copy-from, mut-array, new, temp-as-array
	../list: ==, list, new
	../mut-list:
		begin-pointer, clear, end-pointer, is-empty, move-to-list, mut-list, size, swap, temp-as-mut-array,
		to-mut-list, unsafe-set-size

binary-search-has[t] bool(a t array, value t) t compare
	!(a binary-search-exact-index value is-empty)

binary-search-key[k, v] v?(a (k, v) array, key k) k compare
	trusted
		left mut = a begin-pointer
		right mut = a end-pointer
		loop
			diff = right - left
			if diff < 4
				break for pair : (left .. right).as-array
					if pair.from == key
						break pair.to
			else
				mid = left + diff / 2
				match key <=> mid->from
				as less
					right := mid
					continue
				as equal
					break mid->to,
				as greater
					left := mid + 1
					continue

binary-search-exact-index[t] nat64?(a t array, value t) t compare
	trusted if pointer ?= a binary-search-exact-pointer value
		pointer - a.begin-pointer,

binary-search-exact-index[t] nat64?(a t mut[], compare act comparison(t))
	trusted if pointer ?= a binary-search-exact-pointer compare
		pointer - a.begin-pointer,

binary-search-exact-pointer[t] t mut*?(a t mut[], compare act comparison(t)) unsafe
	a.temp-as-mut-array binary-search-exact-pointer compare

binary-search-exact-pointer[t] t mut*?(a t mut-array, compare act comparison(t)) unsafe
	if x ?= a.cast-immutable binary-search-exact-pointer compare
		x.as-mut,

binary-search-exact-pointer[t] t*?(a t array, value t) unsafe, t compare
	left mut = a begin-pointer
	right mut = a end-pointer
	loop
		diff = right - left
		if diff < 4
			break for x : left .. right
				if *x == value
					break x
		else
			mid = left + diff / 2
			match value <=> *mid
			as less
				right := mid
				continue
			as equal
				break mid,
			as greater
				left := mid + 1
				continue

binary-search-exact-pointer[t] t*?(a t array, compare act comparison(t)) unsafe
	pointer = a binary-search-compare compare
	if pointer == a.end-pointer
		()
	elif compare[*pointer] == equal
		pointer,

binary-search-insert-index[t] nat64(a t mut[], compare act comparison(t))
	trusted (a binary-search-insert-pointer compare) - a.begin-pointer

binary-search-insert-pointer[t] t mut*(a t mut[], compare act comparison(t)) unsafe
	a.temp-as-mut-array binary-search-insert-pointer compare

###
Returns the pointer to the least value that is compared equal or greater.
Returns `a end-pointer` if all values compare less.
###
binary-search-insert-pointer[t] t mut*(a t mut-array, compare act comparison(t)) unsafe
	a.temp-as-array binary-search-compare compare as-mut

binary-search-insert-index[t] nat64(a t array, value t) t compare
	trusted (a binary-search-insert-pointer value) - a.begin-pointer

binary-search-insert-pointer[t] t*(a t array, value t) unsafe, t compare
	# Left inclusive, right exclusive
	left mut = a begin-pointer
	right mut = a end-pointer
	loop
		if left == right
			break left
		else
			mid = left + (right - left) / 2
			match value <=> *mid
			as less
				right := mid
				continue
			as equal
				break mid
			as greater
				left := mid + 1
				continue

test
	a nat64 mut-array = 1, 3, 5, 7
	(a binary-search-insert-pointer x => 0 <=> x) - a.begin-pointer is 0
	(a binary-search-insert-pointer x => 3 <=> x) - a.begin-pointer is 1
	(a binary-search-insert-pointer x => 4 <=> x) - a.begin-pointer is 2
	(a binary-search-insert-pointer x => 5 <=> x) - a.begin-pointer is 2
	(a binary-search-insert-pointer x => 6 <=> x) - a.begin-pointer is 3
	(a binary-search-insert-pointer x => 7 <=> x) - a.begin-pointer is 3
	(a binary-search-insert-pointer x => 8 <=> x) - a.begin-pointer is 4

.binary-search-compare[t] t*(a t array, compare act comparison(t)) unsafe
	# Left inclusive, right exclusive
	left mut = a begin-pointer
	right mut = a end-pointer
	loop
		if left == right
			break left
		else
			mid = left + (right - left) / 2
			match compare[*mid]
			as less
				right := mid
				continue
			as equal
				break mid
			as greater
				left := mid + 1
				continue

unique-comparison enum
	less
	greater

assert-comparison-not-equal unique-comparison(a comparison)
	match a
	as less
		less
	as equal
		unreachable
	as greater
		greater

# 'a' and 'b' must be sorted. Moves contents of 'b' into 'a' and preserves sorting.
merge-no-duplicates[t] void(a t mut[], b t mut[], compare act unique-comparison(t, t))
	if a.size < b.size
		a swap b
	assert a.size >= b.size
	trusted unless b is-empty
		a-old-size = a size
		a unsafe-set-size a-old-size + b.size
		a-read mut = a.begin-pointer.as-const + a-old-size - 1
		a-write mut = a.end-pointer - 1
		b-begin = b.begin-pointer as-const
		b-read mut = b.end-pointer.as-const - 1
		# Merge right-to-left so we never overwrite anything we still have to read.
		# Invariant: a-read, a-write, b-read are all valid pointers.
		loop
			match compare[*a-read, *b-read]
			as less
				*a-write := *b-read
				if b-read == b-begin
					break
				else
					a-write := a-write - 1
					b-read := b-read - 1
					continue
			as greater
				*a-write := *a-read
				if a-read == a.begin-pointer.as-const
					(a.begin-pointer .. a-write).as-mut-array copy-from (b-begin .. b-read + 1).as-array
					break
				else
					a-read := a-read - 1
					a-write := a-write - 1
					continue
		b clear

.test-one void(a nat64[], b nat64[], expected nat64[]) unsafe
	a-mut = a to-mut-list
	b-mut = b to-mut-list
	a-mut merge-no-duplicates b-mut, (x, y) =>
		x <=> y assert-comparison-not-equal
	a-mut.move-to-list is expected

test
	(1, 2, 3) test-one (4, 5, 6), (1, 2, 3, 4, 5, 6)
	(4, 5, 6) test-one (1, 2, 3), (1, 2, 3, 4, 5, 6)
	(1, 3, 5) test-one (2, 4, 6), (1, 2, 3, 4, 5, 6)
	(2, 4, 6) test-one (1, 3, 5), (1, 2, 3, 4, 5, 6)
	(3, 4, 5) test-one (1, 2, 6), (1, 2, 3, 4, 5, 6)
