no-std
import
	../../bool: &&, bool, false, true
	../../compare: <, <=, >
	../collection: index-too-big
	../../fun-util: subscript
	../../js: as-js-any, as-t, call-property, call-property-spread, get, js-cast, js-eq-eq-eq
	../../misc: new, void
	../../number: ==, <=>, +, -, *, float64, nat64, round-up-to-power-of-two, to
	../../pointer:
		==, <=>, +, -, *, as-const, const-pointer, gc-safe-value, mem-copy, null, pointer-cast,
		set-subscript, size-of, subscript
	../../range: .., high, low, range, size
	../../private/alloc: allocate
	../../private/bootstrap:
		array-pointer, array-size, mut-array, mut-array-pointer, mut-array-size, new-array,
		new-mut-array
	../../private/number-low-level: max-value
	./build: build-options, size-hint
export
	../../private/bootstrap: array, todo

array-reference-equal[t] bool(a t array, b t array) bare, unsafe
	if extern native
		a.array-pointer == b.array-pointer && a.array-size == b.array-size
	elif extern js
		a js-eq-eq-eq b
	else
		todo

+begin-pointer[t] t*(a t array) bare, unsafe, native extern
	a array-pointer

# Pointer to the end of an array.
+end-pointer[t] t*(a t array) bare, unsafe, native extern
	a.array-pointer + a.array-size

###
Arr or the range from begin to end.
`begin` is inclusive and `end` is exclusive.
UB if begin > end.
###
+as-array[t] t array(pointers t* range) bare, unsafe, native extern
	pointers.size new-array pointers.low

+pointers[t] t* range(a t array) bare, unsafe, native extern
	a.begin-pointer .. a.end-pointer

array-cast[out, in] out array(a in array) bare, unsafe
	if extern native
		assert size-of@out == size-of@in
		a.array-size new-array a.begin-pointer.pointer-cast
	elif extern js
		a js-cast
	else
		todo

+subscript[t] t(a t array, index nat64) bare, trusted
	assert index < a.array-size : index index-too-big a.array-size
	if extern native
		a.array-pointer[index]
	elif extern js
		a.as-js-any get index as-t
	else
		todo

+subscript[t] t array(a t array, indices nat64 range) bare
	assert indices.high <= a.array-size : indices.high index-too-big a.array-size
	trusted if extern native
		indices.size new-array a.begin-pointer + indices.low
	elif extern js
		a.as-js-any call-property "slice", indices.low.to::float64, indices.high.to::float64 as-t
	else
		todo

# Create an array from a range of pointers.
+subscript[t] t array(a t*, r nat64 range) bare, unsafe, native extern
	r.size new-array a + r.low

###
Equivalent to calling `f[a[0]]`, `f[a[1]]`, etc.

Calls `f` for each element in `a`.
###
+iterate[t] bool(a t array, f bool mut(elem t)) trusted
	if extern native
		if size-of@t == 0
			i mut nat64 = 0
			loop
				if i == a.array-size
					break false
				elif f[gc-safe-value]
					break true
				else
					i +:= 1
					continue
		else
			cur mut = a begin-pointer
			end = a end-pointer
			loop
				if cur == end
					break false
				elif f[*cur]
					break true
				else
					cur +:= 1
					continue
	elif extern js
		i mut nat64 = 0
		loop
			if i == a.array-size
				break false
			elif f[a[i]]
				break true
			else
				i +:= 1
				continue
	else
		todo

+array-builder[t] record mut
	-buffer mut t mut-array
	# Not used in JS
	-cur-size mut nat64
+build[t] t array(a build-options, f void mut(out t array-builder)) trusted
	if extern native
		builder t array-builder = a.size-hint.gc-safe-mut-array, 0
		f[builder]
		res t array = builder.cur-size new-array builder.buffer.mut-array-pointer.as-const
		builder.buffer := 0 new-mut-array null
		builder.cur-size := max-value
		res
	elif extern js
		builder t array-builder = (), max-value
		f[builder]
		assert builder.cur-size == max-value
		builder.buffer.js-cast
	else
		todo

-new[t] t mut-array(...a t array) trusted, js extern
	a js-cast

+size[t] nat64(a t array-builder) trusted
	if extern js
		assert a.cur-size == max-value
		a.buffer.mut-array-size
	else
		forbid a.cur-size == max-value
		a cur-size

+~=[t] void(a t array-builder, value t) trusted
	if extern native
		forbid a.cur-size == max-value
		capacity = a.buffer mut-array-size
		if a.cur-size == capacity
			new-capacity nat64 = capacity == 0 ? 4 : capacity * 2
			new-buffer t mut-array = new-capacity gc-safe-mut-array
			new-buffer.mut-array-pointer mem-copy a.buffer.mut-array-pointer.as-const, capacity
			a.buffer := new-buffer
		a.buffer.mut-array-pointer[a.cur-size] := value
		a.cur-size +:= 1
	elif extern js
		a.buffer.as-js-any call-property "push", value as-t
	else
		todo

+~~=[t] void(a t array-builder, values t array) trusted
	if extern native
		forbid a.cur-size == max-value
		capacity = a.buffer mut-array-size
		if a.cur-size + values.array-size > capacity
			new-size = a.cur-size + values.array-size
			new-capacity = new-size round-up-to-power-of-two
			new-buffer t mut-array = new-capacity gc-safe-mut-array
			new-buffer.mut-array-pointer mem-copy a.buffer.mut-array-pointer.as-const, a.cur-size
			a.buffer := new-buffer
		a.buffer.mut-array-pointer + a.cur-size mem-copy values.begin-pointer, values.array-size
		a.cur-size +:= values array-size
	elif extern js
		a.buffer.as-js-any call-property-spread "push", values as-t
	else
		todo

-gc-safe-mut-array[t] t mut-array(size nat64) unsafe, native extern
	size new-mut-array size.allocate
