no-std
import
	../../bool: &&, bool, false, true
	../../compare: >
	../../fun-util: subscript
	../../misc: new, void
	../../number: ==, <=>, +, -, *, nat64, round-up-to-power-of-two
	../../pointer:
		==, <=>, +, -, *, as-const, const-pointer, mem-copy, mut-pointer, null, pointer-cast, set-subscript, size-of
	../../range: .., low, range, size
	../../private/alloc: allocate
	../../private/bootstrap: array-pointer, array-size, mut-array, mut-array-pointer, mut-array-size, new-array, new-mut-array, zeroed
	../../private/number-low-level: max-value
	./build: build-options, size-hint
export
	../../private/bootstrap: array, todo

array-reference-equal[t] bool(a t array, b t array) bare, unsafe
	if extern native
		a.array-pointer == b.array-pointer && a.array-size == b.array-size
	else
		todo # Use native JS '===' ------------------------------------------------------------------------------------------------

+begin-pointer[t] t*(a t array) bare, unsafe, native extern
	a array-pointer

# Pointer to the end of an array.
+end-pointer[t] t*(a t array) bare, unsafe, native extern
	a.array-pointer + a.array-size

###
Arr or the range from begin to end.
`begin` is inclusive and `end` is exclusive.
UB if begin > end.
###
+as-array[t] t array(pointers t* range) bare, unsafe, native extern
	pointers.size new-array pointers.low
+as-array[t] t array(pointers t mut* range) bare, unsafe, native extern # TODO: why does this return array and not mut-array?
	pointers.size new-array pointers.low.as-const

+pointers[t] t* range(a t array) bare, unsafe, native extern
	a.begin-pointer .. a.end-pointer

array-cast[out, in] out array(a in array) bare, unsafe, native extern
	assert size-of@out == size-of@in
	a.array-size new-array a.begin-pointer.pointer-cast

# Create an array from a range of pointers.
+subscript[t] t array(a t*, r nat64 range) bare, unsafe, native extern
	r.size new-array a + r.low

###
Equivalent to calling `f[a[0]]`, `f[a[1]]`, etc.

Calls `f` for each element in `a`.
###
+iterate[t] bool(a t array, f bool mut(elem t)) trusted
	if extern native
		if size-of@t == 0
			i mut nat64 = 0
			loop
				if i == a.array-size
					break false
				elif f[zeroed]
					break true
				else
					i +:= 1
					continue
		else
			cur mut = a begin-pointer
			end = a end-pointer
			loop
				if cur == end
					break false
				elif f[*cur]
					break true
				else
					cur +:= 1
					continue
	else
		todo # Use native JS 'array.some(f)' ------------------------------------------------------------------------------------------------------------

+array-builder[t] record mut
	-buffer mut t mut-array
	-cur-size mut nat64
+build[t] t array(a build-options, f void mut(out t array-builder)) trusted
	if extern native
		builder t array-builder = a.size-hint.zeroed-mut-array, 0
		f[builder]
		res t array = builder.cur-size new-array builder.buffer.mut-array-pointer.as-const
		builder.buffer := 0 new-mut-array null
		builder.cur-size := max-value
		res
	else
		todo # -------------------------------------------------------------------------------------------------------------

+size[t] nat64(a t array-builder)
	forbid a.cur-size == max-value
	a cur-size

+~=[t] void(a t array-builder, value t) trusted
	forbid a.cur-size == max-value
	if extern native
		capacity = a.buffer mut-array-size
		if a.cur-size == capacity
			new-capacity nat64 = capacity == 0 ? 4 : capacity * 2
			new-buffer t mut-array = new-capacity zeroed-mut-array
			new-buffer.mut-array-pointer mem-copy a.buffer.mut-array-pointer.as-const, capacity
			a.buffer := new-buffer
		a.buffer.mut-array-pointer[a.cur-size] := value
		a.cur-size +:= 1
	else
		todo # ----------------------------------------------------------------------------------------------------------

+~~=[t] void(a t array-builder, values t array) trusted
	forbid a.cur-size == max-value
	if extern native
		capacity = a.buffer mut-array-size
		if a.cur-size + values.array-size > capacity
			new-size = a.cur-size + values.array-size
			new-capacity = new-size round-up-to-power-of-two
			new-buffer t mut-array = new-capacity zeroed-mut-array
			new-buffer.mut-array-pointer mem-copy a.buffer.mut-array-pointer.as-const, a.cur-size
			a.buffer := new-buffer
		a.buffer.mut-array-pointer + a.cur-size mem-copy values.begin-pointer, values.array-size
		a.cur-size +:= values array-size
	else
		todo # ----------------------------------------------------------------------------------------------------------

-zeroed-mut-array[t] t mut-array(size nat64) unsafe, native extern
	size new-mut-array size.allocate
