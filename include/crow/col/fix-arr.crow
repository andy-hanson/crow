no-std
import
	string: memcpy
	../bool: &&, bool, false, true
	../compare: !=, <, <=, equal
	../fun-util: subscript
	../misc: new, void
	../number: ==, <=>, +, -, *, /, %, nat64
	../opt: new, opt
	../ptr:
		==, <=>, +, -, *, as-any-const-ptr, as-any-mut-ptr, as-const, as-mut, mut-ptr, ptr-cast,
		set-deref, set-subscript, size-of, subscript, swap
	../private/alloc: alloc-uninitialized, set-zero-range, unmanaged-alloc-elements, unmanaged-free-elements
	../private/range-low-level: .., range
	./arr: arr, for-loop, new, size, subscript
	./private/arr-low-level: arr-from-begin-end, begin-ptr, subscript
	./arr-util: each-with-index, exists, find-index, fold, fold-reverse, index-of

###
`fix-arr` is a low-level type mostly useful for implementing other collections.
For normal code, a `mut[]` is preferable.

A `fix-arr` is like a `mut[]`, but while a `mut[]` has capacity for pushing elements, `fix-arr` is fixed-size.
This has a small performance benefit, since (like an immutable array)
a `fix-arr` is just a pointer and size which can be stored by value.

You can't change what range of addresses a `fix-arr` points to, though you can write to its elements.

Like an immutable array, and unlike a `mut[]`, it's cheap to take a slice of a `fix-arr`.
Taking a slice aliases the elements, so writing to the slice writes to the original.
###
fix-arr<a> record mut by-val
	.inner arr a

# TODO:INTERNAL (or fix-arr-low-level)
empty-fix-arr<a> fix-arr a() no-doc noctx
	# TODO: should not need type annotation
	inner arr a = ()
	inner,

###
Creates a new `fix-arr` with the given elements.
###
new<a> fix-arr a(...a arr a)
	a to-fix-arr

###
Copies the array elements to a new `fix-arr`.

This is O(n).
###
to-fix-arr<a> fix-arr a(a arr a)
	a.size make-fix-arr i => a[i]

###
Copies the elements to an immutable array.

This is O(n).

There is no `move-to-arr` possible for `fix-arr` there might be slices that still refer to its elements.
###
to-arr<a> arr a(a fix-arr a)
	a.copy.inner

# Get a `fix-arr` from a poitner and range of indices.
subscript<a> fix-arr a(a a mut*, range range nat64) noctx unsafe
	a.as-const[range],

# Creates a `fix-arr` from a range of pointers.
fix-arr-from-begin-end<a> fix-arr a(begin a mut*, end a mut*) no-doc unsafe noctx
	assert begin <= end
	(begin.as-const arr-from-begin-end end.as-const),

###
Gets the element at the index.
Throws if `index >= a.size`.
###
subscript<a> a(a fix-arr a, index nat64) noctx trusted
	assert index < a.size
	a.begin-ptr[index]

###
Slices the fix-arr.
This is O(1).

Slices alias the original: Writes to the slice will affect the original.
(If you don't want that, slice then use `copy`.)

Throws if the slice would be out of bounds.
###
subscript<a> fix-arr a(a fix-arr a, range range nat64)
	a.inner[range],

###
Write to a single element.
Throws if `index >= a.size`.
###
set-subscript<a> void(a fix-arr a, index nat64, value a) noctx trusted
	assert index < a.size
	a.begin-ptr[index] := value

# `true` iff `a.size == 0`.
is-empty<a> bool(a fix-arr a) noctx
	a.size == 0

# Number of elements.
size<a> nat64(a fix-arr a) noctx
	a.inner size

# Pointer to the beginning of the `fix-arr`.
begin-ptr<a> a mut*(a fix-arr a) noctx unsafe
	a.inner.begin-ptr as-mut

###
Pointer to the end of the `fix-arr`.
This is one past the last valid pointer.
###
end-ptr<a> a mut*(a fix-arr a) noctx unsafe
	a.begin-ptr + a.size

###
Copies the elements to a new `fix-arr`.

This is O(n).
###
copy<a> fix-arr a(a fix-arr a)
	for x : a
		x

###
Copies elements from `source` to `dest`.

Throws if `dest` and `source` are not the same size.
(Hint: Both `dest` and `source` can be slices of bigger arrays.)

This is O(n).
###
copy-from<a> void(dest fix-arr a, source arr a) trusted
	assert dest.size == source.size
	_ = dest.begin-ptr.as-any-mut-ptr memcpy source.begin-ptr.as-any-const-ptr, dest.size * size-of@<a>
	()

###
Copies elements from `source` to `dest`.

This is O(n).
###
copy-from<a> void(dest fix-arr a, source fix-arr a) trusted
	dest copy-from source.temp-as-arr

###
Allocates a `fix-arr` without initializing any of its elements.

Since `fix-arr` is garbage-collected, this will cause problems unless either:
* You write to all the elements before the current task ends.
* You don't keep a reference to the `fix-arr` or to any uninitialized slice.

Keep exceptions in mind: Don't store a reference to the result until it's initialized,
since initialization code might throw an exception.

See `zeroed-fix-arr` for a safer alternative, or `make-fix-arr` for a fully safe alternative.
###
uninitialized-fix-arr<a> fix-arr a(size nat64) unsafe
	ptr a mut* = size alloc-uninitialized
	ptr[0 .. size]

unmanaged-uninitialized-fix-arr<a> fix-arr a(size nat64) no-doc noctx unsafe
	ptr a mut* = size unmanaged-alloc-elements
	ptr[0 .. size]

free-unmanaged-fix-arr<a> void(a fix-arr a) no-doc noctx unsafe
	a.begin-ptr unmanaged-free-elements a.size

###
This is like `uninitialized-fix-arr` but fills memory with zeroes.

Zeroed memory is GC-safe, since the GC ignores null pointers,
but is still not safe to expose to readers (who may try to dereference the null pointers).

This is used by collections like `mut[]` that need some excess capacity that will be GC-safe.
###
zeroed-fix-arr<a> fix-arr a(size nat64) unsafe
	res fix-arr a = size uninitialized-fix-arr
	res set-zero-elements
	res

###
Sets every element to `zeroed`. See comment on `zeroed-fix-arr` for why this is useful.
###
set-zero-elements<a> void(a fix-arr a) noctx unsafe
	a.begin-ptr set-zero-range a.size

###
`fix-arr` where each element is `f[i]`.
Equivalent to `f[0], f[1], ...`.
###
.make-fix-arr<a> fix-arr a(size nat64, f act a(nat64)) trusted
	res fix-arr a = size uninitialized-fix-arr
	out mut = res begin-ptr
	i mut = 0
	loop
		if i == size
			assert out == res.end-ptr
			break res
		else
			*out := f[i]
			out := out + 1
			i := i + 1
			continue

###
`fix-arr` where every element is `value`.
Equivalent to `value, value, ...`.
###
fill-fix-arr<a> fix-arr a(size nat64, value a)
	size make-fix-arr _ => value

# Sets every element to `value`.
fill<a> void(a fix-arr a, value a) noctx trusted
	unless a is-empty
		*a.begin-ptr := value
		a.begin-ptr + 1 fix-arr-from-begin-end a.end-ptr fill value

in<a> bool(value a, a fix-arr a) noctx trusted equal<a>
	cur mut = a.begin-ptr as-const
	end = a.end-ptr as-const
	loop
		if cur == end
			break false
		elif *cur == value
			break true
		else
			cur := cur + 1
			continue

###
Unsafe cast a fix-arr to arr.
Equivalent to `temp-as-arr`, but the implication is that
the `fix-arr` will never be written to again, so the `arr` can be used forever.
###
cast-immutable<a> arr a(a fix-arr a) noctx unsafe
	a inner

first<a> a?(a fix-arr a)
	unless a is-empty
		a[0],

last<a> a?(a fix-arr a)
	unless a is-empty
		a[0],

tail<a> fix-arr a(a fix-arr a)
	forbid a is-empty
	a[1 .. a.size]

rtail<a> fix-arr a(a fix-arr a)
	forbid a is-empty
	a[0 .. a.size - 1]

###
Unsafe cast to immutable array.

This is O(1).

Unsafe because an array is expected to be fully immutable (meaning: no mutable references exist),
so this value should only be used temporarily.
###
temp-as-arr<a> arr a(a fix-arr a) noctx unsafe
	a inner

# Equivalent to `a.temp-as-arr index-of value`.
index-of<a> nat64?(a fix-arr a, value a) trusted noctx equal<a>
	a.temp-as-arr index-of value

# Equivalent to `a.temp-as-arr find-index f`.
find-index<a> nat64?(a fix-arr a, f act bool(a)) trusted
	a.temp-as-arr find-index f

set-reverse<a> void(a fix-arr a) trusted
	# avoid 'a.end-ptr - 1' overflowing for null arrays
	unless a is-empty
		a.begin-ptr set-reverse-recur a.end-ptr - 1
.set-reverse-recur<a> void(left a mut*, right a mut*) unsafe
	if left < right
		left swap right
		left + 1 set-reverse-recur right - 1

region iteration

exists<a> bool(a fix-arr a, f act bool(a)) trusted
	a.temp-as-arr exists f

# Calls 'f' on each element in the fix-arr.
for-loop<a> void(a fix-arr a, f act void(a)) trusted
	a.temp-as-arr for-loop f

each-with-index<a> void(a fix-arr a, f act void(a, nat64)) trusted
	a.temp-as-arr each-with-index f

fold<a, b> a(acc a, a fix-arr b, f act a(a, b)) trusted
	acc fold a.temp-as-arr, f
fold-reverse<a, b> a(acc a, a fix-arr b, f act a(a, b)) trusted
	acc fold-reverse a.temp-as-arr, f

set-map<a> void(a fix-arr a, f act a(a)) trusted
	a.begin-ptr set-map-recur a.end-ptr, f
.set-map-recur<a> void(cur a mut*, end a mut*, f act a(a)) unsafe
	unless cur == end
		*cur := f[*cur]
		cur + 1 set-map-recur end, f

for-loop<out, in> fix-arr out(a fix-arr in, f act out(in)) trusted
	a.size make-fix-arr i => f[a[i]]

map-with-index<out, in> fix-arr out(a fix-arr in, f act out(in, nat64)) trusted
	a.size make-fix-arr i => f[a[i], i]

###
Casts elements to a different type.
If the element type is different, adjusts the size so that the number of bytes is the same.
###
cast-fix-arr<out, in> fix-arr out(a fix-arr in) noctx unsafe
	assert size-of@<in> != 0 && size-of@<out> != 0
	size-bytes = a.size * size-of@<in>
	assert size-bytes % size-of@<out> == 0
	size-out = size-bytes / size-of@<out>
	a.begin-ptr.ptr-cast@<out, in>[0 .. size-out]

for-loop<out, in> arr out(a fix-arr in, f act out(in)) trusted
	a for-loop f cast-immutable

map-to-arr-with-index<out, in> arr out(a fix-arr in, f act out(in, nat64)) trusted
	a map-with-index f cast-immutable
