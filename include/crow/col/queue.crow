no-std
import
	../bool: &&, ==, bool, true
	../compare: !=
	../exception: assert
	../fun: subscript
	../misc: void
	../opt: force, is-empty, opt, some
	../private/number-low-level: ==, <=>, nat64, wrap-add
	../ptr: ==, +, -, set-deref
	../test: is
	../range: ..
	./arr: ==, arr, is-empty, size
	./arr-util: each, first, fold, tail
	./fix-arr: begin-ptr, cast-immutable, end-ptr, subscript, uninitialized-fix-arr
	./stack: ~, arr, each, fold, is-empty, new, size, stack

queue<a> record
	left a[]
	right stack a

# Empty queue.
new<a> queue a()
	[], new

###
Convert an arr to a queue.
This is O(1).
###
queue<a> queue a(a a[])
	a, new

arr<a> a[](a queue a) trusted
	res = a.size uninitialized-fix-arr<a>
	end = res.begin-ptr fold a, (out, x) =>
		*out := x
		out + 1
	assert: end == res.end-ptr
	res cast-immutable

size<a> nat64(a queue a)
	a.left.size wrap-add a.right.size

~ <a> queue a(a queue a, value a)
	a.left, a.right ~ value

is-empty<a> bool(a queue a)
	a.left.is-empty && a.right.is-empty

dequeued<a> record
	value a
	rest queue a

dequeue<a> dequeued<a>?(a queue a)
	if first ?= a.left first
		(first, (a.left.tail, a.right)) some
	else
		right-arr = a.right arr
		if first ?= right-arr first
			(first, (right-arr.tail, new)) some

region iteration

each<a> void(a queue a, f act void(a))
	a.left each f
	a.right each f

fold<a, b> a(acc a, a queue b, f act a(a, b))
	acc fold a.left, f fold a.right, f

filter<a> queue a(a queue a, f act bool(a)) trusted
	res = a.size uninitialized-fix-arr<a>
	end = res.begin-ptr fold a, (out, x) =>
		if f[x]
			*out := x
			out + 1
		else
			out
	res[0 .. end - res.begin-ptr].cast-immutable queue

map<out, in> queue out(a queue in, f act out(in)) trusted
	res = a.size uninitialized-fix-arr<out>
	end = res.begin-ptr fold a, (out, x) =>
		*out := f[x]
		out + 1
	assert: end == res.end-ptr
	res.cast-immutable queue

test
	a queue nat64 = new
	assert: a is-empty
	a.arr is []
	a.dequeue.is-empty is true

	b = a ~ 1
	b.arr is [1]
	bd = b.dequeue force
	bd.value is 1
	assert: bd.rest is-empty

	c = b ~ 2
	c.arr is [1, 2]
	cd = c.dequeue force
	cd.value is 1
	cdr = cd rest

	cdr.arr is [2]
	cdd = cdr.dequeue force
	cdd.value is 2
	assert: cdd.rest is-empty

	d = c ~ 3
	d.arr is [1, 2, 3]

	(d filter x => x != 2).arr is [1, 3]
	(d map x => x wrap-add 10).arr is [11, 12, 13]
