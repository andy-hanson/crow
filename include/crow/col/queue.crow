no-std
import
	../bool: &&, ==, bool, true
	../compare: !=
	../fun-util: subscript
	../json: json
	../misc: new, void
	../number: ==, +, nat64
	../option: !, is-empty, new, option
	../test-util: is
	./array: array, first, for-loop, is-empty, new, size, tail
	./list: ==, ~=, build, list, new, to-array, with-block
	./stack: ~, for-loop, is-empty, new, size, stack, to-list

###
Immutable queue.

Supports efficient removal from the left and insertion to the right.
###
queue[t] record
	.left t array
	.right t stack

# Empty queue.
new[t] t queue()
	(), ()

to-queue[t] t queue(a t[])
	a.to-array, ()

###
Copies queue elements to an array.

This is O(n).
###
to-list[t] t[](a t queue)
	for x : a
		x

# `true` iff `a.size == 0`.
is-empty[t] bool(a t queue)
	a.left.is-empty && a.right.is-empty

# Number of elements in the queue.
size[t] nat64(a t queue)
	a.left.size + a.right.size

# Adds a new element on the right.
~[t] t queue(a t queue, value t)
	a.left, a.right ~ value

dequeued[t] record
	value t
	rest t queue

###
Removes and returns an element from the left.
Returns an empty option iff `a` is empty.
###
dequeue[t] t dequeued?(a t queue)
	if first ?= a.left first
		(first, (a.left.tail, a.right)),
	else
		right-array = a.right.to-list to-array
		if first ?= right-array first
			(first, (right-array.tail, ())),

region iteration

for-loop[t] void(a t queue, f act void(t))
	a.left for-loop f
	a.right for-loop f

for-loop[out, in] out[](a in queue, f act out(in))
	with out : a.size build
		for x : a
			out ~= f[x]

for-loop[out, in] out queue(a in queue, f act out(in))
	a for-loop f to-queue

filter[t] t queue(a t queue, f act bool(t))
	list t[] = with out : build
		for x : a
			if f[x]
				out ~= x
	list to-queue

test
	a nat64 queue = ()
	assert a is-empty
	a.to-list is ()
	a.dequeue.is-empty is true

	b = a ~ 1
	b.to-list is (1,)
	bd = b.dequeue!
	bd.value is 1
	assert bd.rest is-empty

	c = b ~ 2
	c.to-list is (1, 2)
	cd = c.dequeue!
	cd.value is 1
	cdr = cd rest

	cdr.to-list is (2,)
	cdd = cdr.dequeue!
	cdd.value is 2
	assert cdd.rest is-empty

	d = c ~ 3
	d.to-list is (1, 2, 3)

	(d filter x => x != 2).to-list is (1, 3)
	(for x : d; x + 10)::(nat64 queue).to-list is (11, 12, 13)
