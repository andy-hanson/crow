no-std
import
	../bool: !, &&, ==, bool, false, true
	../compare: <, <=, >=, compare, comparison, equal, max, min
	../exception: assert
	../fun: subscript
	../misc: ->, arrow, as, data, from, to, void
	../number: ==, <=>, +, -, is-even, nat64
	../opt: ==, is-empty, none, opt, opt-or, or-default, some
	../ptr: ==, <=>, +, -, const-ptr, mut-ptr, set-subscript, subscript
	../str: ==, chars, is-empty, size-bytes, str
	../str-conv: interp, finish, to-str, with-str, with-value
	../test: is
	../writer: ~=, backup!, move-to-str!, writer
	./arr: arr, arr-equal, arr-from-begin-end, begin-ptr, is-empty, end-ptr, size, subscript
	./arr-util: each, filter, fold, map, tail
	./mut-arr:
		begin-ptr, cast-immutable, copy-from!, is-empty, end-ptr, fold, mut-arr,
		mut-arr-from-begin-end, set-subscript, size, subscript, tail, uninitialized-mut-arr
	./sort: sort-by
	./private/sort-utils: binary-search-value

dict<k, v> record
	by-val
	# TODO:PRIVATE
	ignore void
	impl dict-impl<k, v>

# TODO: comparison should be generic
dict-equal<k, v> bool(a dict<k, v>, b dict<k, v>) data<k> compare<k> equal<v>
	# TODO:PERF
	a.arr arr-equal b.arr, (x, y) =>
		x.from == y.from && x.to == y.to

.dict-impl<k, v> union
	overlay<k, v>
	end-node<k, v>

.overlay<k, v> record
	by-ref
	# TODO: consider tracking the number of keys that are new, or change a value, or remove a value.
	# We should merge more frequently if removing keys, less frequently if adding keys.
	# never empty
	pairs arrow<k, v?>[]
	prev dict-impl<k, v>

# Leftmost node. Values are non-optional as there is nothing left of this to remove from.
.end-node<k, v> record
	by-val
	pairs arrow<k, v>[]

dict<k, v> dict<k, v>() data<k> compare<k>
	dict: void, end-node: []

dict<k, v> dict<k, v>(a arrow<k, v>[]) data<k> compare<k>
	dict: void, end-node: a sort-by pair => pair from

is-empty<k, v> bool(a dict<k, v>) data<k> compare<k>
	match a impl
	as overlay
		false
	as end-node e
		e.pairs is-empty

###
Number of pairs.
This is O(n).
###
size<k, v> nat64(a dict<k, v>) data<k> compare<k>
	0 fold a, (acc, k, v) => acc + 1

arr<k, v> arrow<k, v>[](a dict<k, v>) data<k> compare<k> trusted
	match a impl
	as overlay
		out = a.size uninitialized-mut-arr<arrow<k, v>>
		end = out.begin-ptr fold a, (cur, k, v) =>
			cur[] := k -> v
			cur + 1
		assert: end == out.end-ptr
		out cast-immutable
	as end-node e
		e pairs

~ <k, v> dict<k, v>(a dict<k, v>, pair arrow<k, v>) data<k> compare<k>
	dict: void, a.impl add-or-remove pair.from, pair.to.some

~ <k, v> dict<k, v>(a dict<k, v>, b dict<k, v>) data<k> compare<k>
	a ~ b.arr

~ <k, v> dict<k, v>(a dict<k, v>, b arrow<k, v>[]) data<k> compare<k>
	if b is-empty
		a
	elif a is-empty
		dict: b
	else
		# TODO: 'as' should be unnecessary
		pairs = as<arrow<k, v?>[]>: b map (it => it.from -> it.to.some) sort-by it => it from
		dict: void, merge-as-needed: pairs overlay a.impl

- <k, v> dict<k, v>(a dict<k, v>, key k) data<k> compare<k>
	if a has-key key
		dict: void, a.impl add-or-remove key, none
	else
		a

- <k, v> dict<k, v>(a dict<k, v>, keys k[]) data<k> compare<k>
	a fold keys, (cur, key) =>
		cur - key

subscript<k, v> v?(a dict<k, v>, key k) data<k> compare<k>
	a.impl subscript-recur key
.subscript-recur<k, v> v?(a dict-impl<k, v>, key k) trusted data<k> compare<k>
	match a
	as overlay o
		if pair ?= o.pairs binary-search-value pair => key <=> pair.from
			pair to
		else
			o.prev subscript-recur key
	as end-node e
		if pair ?= e.pairs binary-search-value pair => key <=> pair.from
			pair.to some

has-key<k, v> bool(a dict<k, v>, key k) trusted data<k> compare<k>
	!a[key].is-empty

.add-or-remove<k, v> dict-impl<k, v>(a dict-impl<k, v>, key k, value v?) data<k> compare<k>
	merge-as-needed: overlay: [key -> value], a

.merge-as-needed<k, v> dict-impl<k, v>(a overlay<k, v>) data<k> compare<k>
	match a prev
	as overlay o
		if o.pairs.size should-merge a.pairs.size
			new-pairs = o.pairs merge-overlays a.pairs
			merge-as-needed: overlay: new-pairs, o.prev
		else
			a
	as end-node e
		if e.pairs.size should-merge a.pairs.size
			new-pairs = e.pairs merge-to-end a.pairs
			end-node: new-pairs
		else
			a

.should-merge bool(prev-size nat64, overlay-size nat64)
	prev-size <=: overlay-size max 3

.merge-overlays<k, v> arrow<k, v?>[](l arrow<k, v?>[], r arrow<k, v?>[]) trusted data<k> compare<k>
	res = l.size + r.size uninitialized-mut-arr<arrow<k, v?>>
	end = res.begin-ptr merge-keep-right l.begin-ptr, l.end-ptr, r.begin-ptr, r.end-ptr, (x, y) =>
		x.from <=> y.from
	res[0 -> end - res.begin-ptr] cast-immutable

.merge-keep-right<a> a mut*
	out a mut*
	l a*
	l-end a*
	r a*
	r-end a*
	compare act comparison(a, a)
spec
	unsafe
body
	assert: l < l-end
	assert: r < r-end
	match compare[l[], r[]]
	as less
		out[] := l[]
		if l + 1 == l-end
			out + 1 finish-rest r, r-end
		else
			out + 1 merge-keep-right l + 1, l-end, r, r-end, compare
	as equal
		out[] := r[]
		if l + 1 == l-end
			out + 1 finish-rest r + 1, r-end
		elif r + 1 == r-end
			out + 1 finish-rest l + 1, l-end
		else
			out + 1 merge-keep-right l + 1, l-end, r + 1, r-end, compare
	as greater
		out[] := r[]
		if r + 1 == r-end
			out + 1 finish-rest l, l-end
		else
			out + 1 merge-keep-right l, l-end, r + 1, r-end, compare

.merge-to-end<k, v> arrow<k, v>[](l arrow<k, v>[], r arrow<k, v?>[]) trusted data<k> compare<k>
	res = l.size + r.size uninitialized-mut-arr<arrow<k, v>>
	end = if l is-empty
		res.begin-ptr finish-rest-ignore-none r.begin-ptr, r.end-ptr
	else
		res.begin-ptr merge-to-end-recur l.begin-ptr, l.end-ptr, r.begin-ptr, r.end-ptr
	res[0 -> end - res.begin-ptr] cast-immutable

.merge-to-end-recur<k, v> arrow<k, v> mut*
	out arrow<k, v> mut*
	l arrow<k, v>*
	l-end arrow<k, v>*
	r arrow<k, v?>*
	r-end arrow<k, v?>*
spec
	unsafe
	data<k>
	compare<k>
body
	assert: l < l-end
	assert: r < r-end
	match l[].from <=> r[].from
	as less
		out[] := l[]
		if l + 1 == l-end
			out + 1 finish-rest-ignore-none r, r-end
		else
			out + 1 merge-to-end-recur l + 1, l-end, r, r-end
	as equal
		new-out = if r-value ?= r[] to
			out[] := r[].from -> r-value
			out + 1
		else
			out

		if l + 1 == l-end
			new-out finish-rest-ignore-none r, r-end
		elif r + 1 == r-end
			new-out finish-rest l, l-end
		else
			new-out merge-to-end-recur l + 1, l-end, r + 1, r-end
	as greater
		new-out = if r-value ?= r[] to
			out[] := r[].from -> r-value
			out + 1
		else
			out

		if r + 1 == r-end
			new-out finish-rest l, l-end
		else
			new-out merge-to-end-recur l, l-end, r + 1, r-end

.finish-rest<a> a mut*(out a mut*, cur a*, end a*) unsafe
	rest-size = end - cur
	out-end = out + rest-size
	out mut-arr-from-begin-end out-end copy-from!: cur arr-from-begin-end end
	out-end

.finish-rest-ignore-none<k, v> arrow<k, v> mut*
	out arrow<k, v> mut*
	r arrow<k, v?>*
	r-end arrow<k, v?>*
spec
	unsafe
body
	if r == r-end
		out
	else
		new-out = if r-value ?= r[] to
			out[] := r[].from -> r-value
			out + 1
		else
			out
		new-out finish-rest-ignore-none r + 1, r-end

region iteration

each<k, v> void(a dict<k, v>, f act void(k, v)) data<k> compare<k>
	void fold a, (ignore, k, v) =>
		f[k, v]

fold<a, k, v> a(acc a, a dict<k, v>, f act a(a, k, v)) data<k> compare<k>
	iters = a init-iters
	acc fold-recur iters.end-pairs, iters.overlays, f

.fold-recur<a, k, v> a
	acc a
	end-node arrow<k, v>[]
	overlays mut-arr arrow<k, v?>[]
	f act a(a, k, v)
spec
	data<k>
	compare<k>
body
	# Invariant: Nothing in 'overlays' is empty.
	if overlays is-empty
		if end-node is-empty
			acc
		else
			pair = end-node[0]
			f[acc, pair.from, pair.to] fold-recur end-node.tail, overlays, f
	else
		least-key = if end-node is-empty
			overlays[0][0].from find-least-key overlays.tail
		else
			end-node[0].from
		take-from-end-node = !end-node.is-empty && least-key == end-node[0].from
		# TODO: should not need 'as'
		val-from-end-node = as<v?>: if take-from-end-node
			end-node[0].to some
		new-end-node = if take-from-end-node
			end-node tail
		else
			end-node
		took-from-overlays = overlays take-key least-key
		new-acc = if val ?= took-from-overlays.rightmost-value opt-or val-from-end-node
			f[acc, least-key, val]
		else
			acc
		new-acc fold-recur new-end-node, took-from-overlays.overlays, f

.find-least-key<k, v> k(current-least-key k, overlays mut-arr arrow<k, v>[]) data<k> compare<k>
	current-least-key fold overlays, (cur, overlay) =>
		cur min overlay[0].from

.took-key<k, v> record mut
	rightmost-value v?
	overlays mut-arr arrow<k, v?>[]

###
Takes the key from the front of every overlay that has it.
Removes rightmost overlays from the mut-arr (by returning a new, smaller mut-arr).
Returns the rightmost value associated with that key.
###
.take-key<k, v> took-key<k, v>(overlays mut-arr arrow<k, v?>[], key k) data<k> compare<k>
	overlays take-key-recur key, 0, none
.take-key-recur<k, v> took-key<k, v>
	overlays mut-arr arrow<k, v?>[]
	key k
	index nat64
	rightmost-value v?
spec
	data<k>
	compare<k>
body
	# Index can overshoot due to removing overlays
	if index >= overlays.size
		took-key: rightmost-value, overlays
	elif overlays[index][0].from == key
		new-rightmost-value = overlays[index][0] to
		new-overlay = overlays[index] tail
		if new-overlay is-empty
			overlays[index] := overlays[overlays.size - 1]
			overlays[0 -> overlays.size - 1] take-key-recur key, index + 1, new-rightmost-value
		else
			overlays[index] := new-overlay
			overlays take-key-recur key, index + 1, new-rightmost-value
	else
		overlays take-key-recur key, index + 1, rightmost-value

.get-end<k, v> end-node<k, v>(a dict-impl<k, v>)
	match a
	as overlay o
		o.prev get-end
	as end-node e
		e

.iters<k, v> record mut
	end-pairs arrow<k, v>[]
	overlays mut-arr arrow<k, v?>[]

.init-iters<k, v> iters<k, v>(a dict<k, v>) trusted
	overlay-iters = 0 overlay-count a.impl uninitialized-mut-arr<arrow<k, v?>[]>
	end-pairs = overlay-iters.begin-ptr init-overlay-iters-recur! a.impl
	iters: end-pairs, overlay-iters

.overlay-count<k, v> nat64(acc nat64, a dict-impl<k, v>)
	match a
	as overlay o
		acc + 1 overlay-count o.prev
	as end-node
		acc

.init-overlay-iters-recur!<k, v> arrow<k, v>[](out arrow<k, v?>[] mut*, a dict-impl<k, v>) unsafe
	match a
	as overlay o
		out[] := o.pairs
		out + 1 init-overlay-iters-recur! o.prev
	as end-node e
		e pairs

filter<k, v> dict<k, v>(a dict<k, v>, f act bool(k, v)) data<k> compare<k>
	# No need to re-sort
	dict: void, end-node: a.arr filter pair =>
		f[pair.from, pair.to]

map<k-out, v-out, k-in, v-in> dict<k-out, v-out>
	a dict<k-in, v-in>
	f act arrow<k-out, v-out>(k-in, v-in)
spec
	data<k-in>
	compare<k-in>
	data<k-out>
	compare<k-out>
body
	dict: a map-to-arr f

map-to-arr<out, k, v> out[](a dict<k, v>, f act out(k, v)) data<k> compare<k>
	a.arr map pair => f[pair.from, pair.to]

map-values<v-out, k, v-in> dict<k, v-out>(a dict<k, v-in>, f act v-out(k, v-in)) data<k> compare<k>
	# No need to re-sort
	dict: void, end-node: a.arr map pair =>
		pair.from -> f[pair.from, pair.to]

.dbg str(a dict<nat64, str>)
	out = writer
	out dbg-recur! a.impl
	out move-to-str!

.dbg-recur! void(out writer, a dict-impl<nat64, str>)
	match a
	as overlay o
		out dbg-recur! o.prev
		out ~= ", "
		out ~= "["
		o.pairs each pair =>
			out ~= pair.from
			out ~= " -> "
			out ~= pair.to or-default "_"
			out ~= ", "
		if o.pairs is-empty
			out ~= "]"
		else
			out backup! 2
			out ~= "]"
	as end-node e
		out ~= "["
		e.pairs each pair =>
			out ~= pair.from to-str
			out ~= " -> "
			out ~= pair to
			out ~= ", "
		if e.pairs is-empty
			out ~= "]"
		else
			out backup! 2
			out ~= "]"

verify void(a dict<nat64, str>, expected str)
	a.dbg is expected

test
	a = dict<nat64, str>
	a.is-empty is true
	a.size is 0
	a verify "[]"
	a[10] is none

	b = a ~ (10 -> "10")
	b verify "[10 -> 10]"
	b[10] is "10".some

	c = b ~ [15 -> "15", 5 -> "5", 20 -> "20"]
	c verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20]"

	d = c ~ (11 -> "11")
	d verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11]"

	e = d - 15
	e verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	f = e - 16
	f verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	g = f - 15
	g verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [11 -> 11, 15 -> _]"

	h = g - 10
	h verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> _, 11 -> 11, 15 -> _]"

	i = h ~ (10 -> "10b")
	i verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> 11, 15 -> _]"

	j = i - [11, 12]
	# Unfortunately we leave an unnecessary '11 -> _',
	# because we don't keep track of what a removal removes from, and it might be removing from the leftmost node.
	j verify "[5 -> 5, 10 -> 10, 15 -> 15, 20 -> 20], [10 -> 10b, 11 -> _, 15 -> _]"

	k = j ~ [11 -> "11", 25 -> "25"]
	k verify "[5 -> 5, 10 -> 10b, 11 -> 11, 20 -> 20, 25 -> 25]"

	j-folded = "" fold j, (cur, key, value) =>
		pair = "{key} -> {value}"
		if cur.is-empty
			pair
		else
			"{cur}, {pair}"
	j-folded is "5 -> 5, 10 -> 10b, 15 -> 15, 20 -> 20"

	j-filtered = j filter (k, v) =>
		k is-even
	j-filtered verify "[10 -> 10b, 20 -> 20]"

	j-mapped = j map-values (k, v) =>
		v.chars[v.size-bytes - 1 -> v.size-bytes] str
	j-mapped verify "[5 -> 5, 10 -> b, 15 -> 5, 20 -> 0]"
