no-std
import
	../bits: &, >>
	../bool: !, &&, bool, false, new, true
	../compare: !=, <, <=, >=, equal, max
	../exception: unreachable
	../fun-util: subscript
	../hash: hash
	../misc: key, loop-break, new, void
	../number: ==, <=>, +, -, nat64
	../option: !, is-empty, new, option
	../range: .., for-loop
	../string: ~~, literal, join, string, to-string
	../tuple: from, new, pair, to
	../private/bootstrap: todo
	./array:
		~, ~=, array, array-builder, build, every, find-index, for-break, for-loop, is-empty, new,
		remove-at, rtail, size, subscript, update-at, with-block
	./mut-array:
		cast-immutable, copy-from, fill-mut-array, mut-array, set-subscript, size, subscript,
		uninitialized-mut-array
	./list:
		~=, build, every, first, for-loop, join, list, new, size, tail, to-array, to-list,
		with-block

###
Immutable unordered dictionary type.
A dictionary is logically a collection of key-value pairs (`(k, v)`).
A key can appear at most once, and given a key, you can access the associated value in O(1).

There should be `==`, `<=>`, and `hash-mix` functions defined for the key type `k`.

This is unordered;
functions dealing with multiple elements (like `to-list` or `for-loop`) work in arbitrary order.
###
dict[k, v] record by-val
	.root (k, v) node

==[k, v] bool(a v[k], b v[k]) k key, v equal
	# TODO:PERF `a every` nto `a.to-list every`
	a.size == b.size && a.to-list every pair =>
		if bv ?= b[pair from]
			bv == pair.to

.node[k, v] union
	inner-node (k, v) node array
	leaf-node (k, v) array

.empty-leaf-node[k, v] (k, v) node() noctx
	() leaf-node

.low-bits nat64(a nat64)
	a & 0b111

.inner-node-n-bits nat64()
	3

.leaf-max-size nat64()
	8

empty-dict[k, v] v[k]() noctx, no-doc
	# TODO: type annotation should be unnecessary
	empty-leaf-node::((k, v) node),

###
Creates a new dict from the given key-value pairs.

Later pairs overwrite earlier pairs with the same key.
###
new[k, v] v[k](...a (k, v) array) k key
	a.to-list to-dict

###
Converts a list of pairs to a dictionary.
Later pairs overwrite earlier pairs with the same key.
###
to-dict[k, v] v[k](a (k, v)[]) k key
	if a.size <= 4 && a.no-duplicate-keys
		a.to-array.leaf-node,
	else
		res mut v[k] = empty-leaf-node::((k, v) node),
		for x : a
			res := res ~ x
		res

# Returns all pairs in the dictionary.
to-list[k, v] (k, v)[](a v[k]) k key
	for k, v : a; k, v

.no-duplicate-keys[k, v] bool(a (k, v)[]) k key
	# O(n^2) but it doesn't matter since n <= 4
	if a.size <= 1
		true
	else
		key = a.first! from
		a.tail every (it => it.from != key) && a.tail.no-duplicate-keys

# True iff the dict has no entries.
is-empty[k, v] bool(a v[k]) k key
	a.root node-is-empty
.node-is-empty[k, v] bool(a (k, v) node)
	match a
	as inner-node _
		false
	as leaf-node l
		l is-empty

# Number of pairs.
size[k, v] nat64(a v[k]) k key
	a.root size
.size[k, v] nat64(a (k, v) node)
	match a
	as inner-node i
		acc mut = 0
		for child : i
			acc := acc + child.size
		acc
	as leaf-node l
		l size

###
Gets the value associated with a key.
Returns an empty option if the key is not in `a`.
###
subscript[k, v] v?(a v[k], key k) k key
	cur mut = a root
	remaining-hash mut = key hash
	loop
		match cur
		as inner-node i
			which = remaining-hash low-bits
			if which < i.size
				cur := i[which]
				remaining-hash := remaining-hash >> inner-node-n-bits
				continue
			else
				break
		as leaf-node l
			break for pair : l
				if pair.from == key
					break pair.to

# `true` iff the key is in the dictionary.
in[k, v] bool(key k, a v[k]) k key
	!a[key].is-empty

###
Associates the key `pair.a` with the value `pair.b`.
This may overwrite the key if it's already in `a`, or add a new entry.
###
~[k, v] v[k](a v[k], pair (k, v)) k key
	res = a get-or-update pair.from, _ =>
		pair.to insert
	if node ?= res new-node
		node,
	else
		a

###
Adds/updates many entries to `a`.
###
~~[k, v] v[k](a v[k], pairs (k, v)[]) k key
	res mut = a
	for pair : pairs
		res := res ~ pair
	res

got-or-added[k, v] union
	got v
	added (v[k], v)

###
If `key` is already in `a`, return `already-has-key` with the old value.
Else, add a new pair `key, get-value[]` return `added`.
###
get-or-add[k, v] (k, v) got-or-added(a v[k], key k, get-value act v()) k key
	res = a get-or-update key, old-value =>
		if old-value is-empty
			get-value[] insert
		else
			no-change
	if v ?= res old-value
		v got
	else
		((res.new-node!,), res.new-value!) added

###
Removes a key and its associated value.

If the key is not in the dictionary, returns `a` unmodified.
(To distinguish that case, and to get the removed value, use `try-remove`.)
###
-[k, v] v[k](a v[k], key k) k key
	if res ?= a try-remove key
		res rest
	else
		a

# Value removed from the dictionary, and the new dictionary.
try-remove-result[k, v] record by-val
	value v
	rest v[k]

###
Removes a key and its associated value, and returns the value and the new dictionary.

If the key is not in the dictionary, returns an empty option.
###
try-remove[k, v] (k, v) try-remove-result?(a v[k], key k) k key
	res = a get-or-update key, _ => remove
	if value ?= res old-value
		(value, (res.new-node!,)),

.get-or-update-result[k, v] record by-val
	# If none, don't update anything
	new-node (k, v) node?
	old-value v?
	new-value v?

.get-or-update-action[v] union
	no-change
	remove
	insert v

###
`f` takes the old value and returns the new value, or 'none' to choose to preserve the old value.
###
.get-or-update[k, v] (k, v) get-or-update-result(
	a v[k],
	key k,
	f act v get-or-update-action(v?),
) k key
	hash = key hash
	match a root
	as inner-node _
		a.root get-or-update-recur key, hash, 0, f
	as leaf-node l
		l get-or-update-leaf key, hash, 0, f

.get-or-update-recur[k, v] (k, v) get-or-update-result(
	a (k, v) node,
	key k,
	remaining-hash nat64,
	hash-shift nat64,
	f act v get-or-update-action(v?),
) k key
	match a
	as inner-node i
		which = remaining-hash low-bits
		if which < i.size
			next-hash = remaining-hash >> 3
			child-res = i[which] get-or-update-recur key, next-hash, hash-shift + 3, f
			if node ?= child-res new-node
				new-inner = i update-child which, node
				(new-inner,), child-res.old-value, child-res.new-value
			else
				child-res
		else
			match f[()]
			as no-change
				(), (), ()
			as remove
				(), (), ()
			as insert ins
				# TODO: type annotation should not be necessary
				new-leaf (k, v) node = ((key, ins),) leaf-node
				# TODO: type annotation should not be necessary
				new-node (k, v) node = i update-at-with-default which, new-leaf, empty-leaf-node inner-node
				(new-node,), (), (ins,)
	as leaf-node l
		l get-or-update-leaf key, remaining-hash, hash-shift, f

###
Unlike `update-at`, `index` doesn't need to be a valid index.
If `index > a.size`, entries between the and of `a` and the new entries will be `default`.
###
.update-at-with-default[t] t array(a t array, index nat64, new-value t, default t) no-doc
	if index < a.size
		a update-at index, new-value
	else
		for i : 0 .. index + 1
			if i < a.size
				a[i]
			elif i == index
				new-value
			else
				default

.update-child[k, v] (k, v) node(a (k, v) node array, which nat64, new-child (k, v) node)
	if leaf ?= a inner-node-to-leaf which, new-child
		leaf
	elif new-child node-is-empty
		if which == a.size - 1
			new-children = a rtail
			new-children.size == 1 ? new-children[0] : new-children.inner-node
		else
			new-children = a update-at which, new-child
			if child ?= new-children find-only-non-empty-child
				child
			else
				new-children inner-node
	else
		a update-at which, new-child inner-node

# Returns 'some' if we should change this to a leaf.
.inner-node-to-leaf[k, v] (k, v) node?(a (k, v) node array , which nat64, new-child (k, v) node)
	total-size mut = 0
	for child-index, child : a
		total-size := match child-index == which ? new-child : child
		as inner-node _
			leaf-max-size + 1
		as leaf-node l
			total-size + l.size
	if total-size <= leaf-max-size
		# TODO: if only one non-empty leaf, don't copy..
		trusted
			out (k, v) mut-array = total-size uninitialized-mut-array
			out-index mut = 0
			for child-index, child : a
				match child-index == which ? new-child : child
				as inner-node _
					unreachable
				as leaf-node l
					new-out-index = out-index + l.size
					out[out-index .. new-out-index] copy-from l
					out-index := new-out-index
			assert out-index == out.size
			out.cast-immutable.leaf-node,

.find-only-non-empty-child[k, v] (k, v) node?(children (k, v) node array)
	first-non-empty-index = (children find-index it => !it.node-is-empty)!
	if children[first-non-empty-index + 1 .. children.size] every it => it node-is-empty
		children[first-non-empty-index],

.get-or-update-leaf[k, v] (k, v) get-or-update-result(
	a (k, v) array,
	key k,
	remaining-hash nat64,
	hash-shift nat64,
	f act v get-or-update-action(v?),
) k key
	if index ?= a find-index it => it.from == key
		old-value = a[index] to
		match f[(old-value,)]
		as no-change
			(), (old-value,), ()
		as remove
			((a remove-at index leaf-node),), (old-value,), ()
		as insert ins
			new-node (k, v) node = a update-at index, (key, ins) leaf-node
			(new-node,), (old-value,), (ins,)
	else
		match f[()]
		as no-change
			(), (), ()
		as remove
			(), (), ()
		as insert ins
			new-node (k, v) node = if a.size >= leaf-max-size
				if hash-shift >= 64
					# We've exhausted the hash.
					# TODO: fall back to a sorted dict ?
					todo
				# If we get here, it's guaranteed that we don't need to recursively create leaves.
				# Just group by hash.
				a new-inner-node key, ins, remaining-hash, hash-shift
			else
				a ~ (key, ins) leaf-node
			(new-node,), (), (ins,)

# In order to get the hash, we need to know the shift amount
.new-inner-node[k, v] (k, v) node(
	a (k, v) array,
	key k,
	value v,
	hash nat64,
	hash-shift nat64,
) k key
	key-hash = hash low-bits
	max-hash mut = key-hash
	for pair : a
		max-hash := max-hash max (pair.from.hash >> hash-shift low-bits)
	trusted
		res (k, v) node mut-array = max-hash + 1 fill-mut-array empty-leaf-node
		# TODO: avoid allocating the same leaf twice...
		res[key-hash] := ((key, value),) leaf-node
		for pair : a
			x = pair.from.hash >> hash-shift low-bits
			res[x] := match res[x]
			as inner-node _
				unreachable
			as leaf-node l
				l ~ pair leaf-node
		res.cast-immutable inner-node

region iteration

for-loop[k, v] void(a v[k], f act void(k, v)) k key
	a.root for-loop f
.for-loop[k, v] void(a (k, v) node, f act void(k, v)) k key
	match a
	as inner-node i
		for child : i
			child for-loop f
	as leaf-node l
		for pair : l
			f[pair.from, pair.to]

# Calls `f` on every pair in the dictionary and returns an array of the results.
for-loop[out, k, v] out[](a v[k], f act out(k, v)) k key
	with out : build
		for k, v : a
			out ~= f[k, v]

for-loop[k-out, v-out, k, v] v-out[k-out](a v[k], f act (k-out, v-out)(k, v)) k key, k-out key
	a for-loop f to-dict

for-loop[k, v, in] v[k](a in[], f act (k, v)(in)) k key
	a for-loop f to-dict
for-loop[k, v, in] v[k](a in[], f act (k, v)(nat64, in)) k key
	a for-loop f to-dict

region builder

build-dict record
	.size-hint nat64
build build-dict()
	0,
build build-dict(size-hint nat64)
	size-hint,

dict-builder[k, v] record mut
	.inner (k, v) array-builder

with-block[k, v] v[k](a build-dict, f act void((k, v) dict-builder)) k key
	(with out : a.size-hint build; f[(out,)])::((k, v) array).to-list to-dict

~=[k, v] void(a (k, v) dict-builder, pair (k, v))
	a.inner ~= pair

dbg[k, v] string(a v[k]) no-doc, k to-string, v to-string
	a.root dbg ""

.dbg[k, v] string(a (k, v) node, path string) k to-string, v to-string
	match a
	as inner-node node
		parts string[] = () join for index : 0 .. node.size
			child = node[index]
			unless child node-is-empty
				(child dbg "{path}{index}"),
		" " join parts
	as leaf-node l
		parts = ", " join for pair : l to-list
			"{pair from} -> {pair to}"
		"{path}[{parts}]"
