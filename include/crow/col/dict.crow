no-std
import
	../bits: &, unsafe-bit-shift-right
	../bool: !, &&, ==, bool, false, true
	../compare: !=, <, <=, >=, compare, equal, max
	../exception: assert, unreachable
	../fun: subscript
	../hash: hash, hash-mix
	../misc: ->, arrow, as, data, from, to, void
	../opt: ==, force, is-empty, none, opt, some
	../ptr: ==, +, set-deref
	../str: ==, ~, str
	../str-conv: to-str
	../test: is
	../writer: ~=, backup!, move-to-str!, writer
	../private/bootstrap: hard-assert, todo
	../private/number-low-level: ==, <=>, nat64, wrap-add, wrap-sub
	./arr: ~, arr, arr-equal, is-empty, size, subscript
	./arr-util:
		each, each-with-index, every, find-index, fold, fold-with-index,
		remove-at, rtail, tail, update, update-with-default
	./fix-arr:
		begin-ptr, cast-immutable, copy-from!, end-ptr, fill-fix-arr, set-subscript, size,
		subscript, uninitialized-fix-arr
	./sort: sort-by

dict<k, v> record
	by-val
	# TODO:PRIVATE
	ignore void
	root node<k, v>

# TODO: comparison should be generic
dict-equal<k, v> bool(a dict<k, v>, b dict<k, v>) data<k> compare<k> hash-mix<k> equal<v>
	# TODO:PERF
	a.arr-sorted arr-equal b.arr-sorted, (x, y) =>
		x.from == y.from && x.to == y.to

node<k, v> union
	inner-node<k, v>
	leaf-node<k, v>

.inner-node<k, v> record
	by-val
	# Nodes keyed by the next 3 bits of the hash.
	# An inner-node should always have at least 2 non-empty children.
	children node<k, v>[]

.leaf-node<k, v> record
	by-val
	# No particular order
	pairs arrow<k, v>[]

.empty-leaf-node<k, v> leaf-node<k, v>()
	[] leaf-node

.low-bits nat64(a nat64)
	a & 0b111

.inner-node-n-bits nat64()
	3

.leaf-max-size nat64()
	8

dict<k, v> dict<k, v>() data<k> compare<k> hash-mix<k>
	void dict empty-leaf-node

dict<k, v> dict<k, v>(a arrow<k, v>[]) data<k> compare<k> hash-mix<k>
	if a.size <= 4 && a.no-duplicate-keys
		void dict a.leaf-node
	else
		dict fold a, (cur, x) => cur ~ x

arr<k, v> arrow<k, v>[](a dict<k, v>) data<k> compare<k> hash-mix<k>
	a map-to-arr (k, v) => k -> v

arr-sorted<k, v> arrow<k, v>[](a dict<k, v>) data<k> compare<k> hash-mix<k>
	a.arr sort-by pair => pair.from

.no-duplicate-keys<k, v> bool(a arrow<k, v>[]) compare<k>
	if a.size <= 1
		true
	else
		key = a[0] from
		a.tail every (it => it.from != key) && a.tail.no-duplicate-keys

is-empty<k, v> bool(a dict<k, v>) data<k> compare<k> hash-mix<k>
	a.root node-is-empty
.node-is-empty<k, v> bool(a node<k, v>)
	match a
	as inner-node
		false
	as leaf-node l
		l.pairs is-empty

size<k, v> nat64(a dict<k, v>) data<k> compare<k> hash-mix<k>
	0 size-recur a.root
.size-recur<k, v> nat64(acc nat64, a node<k, v>)
	match a
	as inner-node i
		acc fold i.children, (cur, child) => cur size-recur child
	as leaf-node l
		acc wrap-add l.pairs.size

subscript<k, v> v?(a dict<k, v>, key k) data<k> compare<k> hash-mix<k>
	match a root
	as inner-node
		hash = key hash
		a.root subscript-recur key, hash
	as leaf-node l
		l.pairs subscript-leaf-recur key
.subscript-recur<k, v> v?(a node<k, v>, key k, remaining-hash nat64) trusted data<k> compare<k> hash-mix<k>
	match a
	as inner-node i
		which = remaining-hash low-bits
		if which < i.children.size
			i.children[which] subscript-recur: key, remaining-hash unsafe-bit-shift-right inner-node-n-bits
	as leaf-node l
		l.pairs subscript-leaf-recur key
.subscript-leaf-recur<k, v> v?(a arrow<k, v>[], key k) compare<k>
	if a is-empty
		none
	elif a[0].from == key
		a[0].to some
	else
		a.tail subscript-leaf-recur key

in<k, v> bool(key k, a dict<k, v>) data<k> compare<k> hash-mix<k>
	!a[key].is-empty

~ <k, v> dict<k, v>(a dict<k, v>, pair arrow<k, v>) data<k> compare<k> hash-mix<k>
	res = a get-or-update pair.from, old-value =>
		pair.to insert
	if node ?= res new-node
		void dict node
	else
		a

~ <k, v> dict<k, v>(a dict<k, v>, pairs arrow<k, v>[]) data<k> compare<k> hash-mix<k>
	a fold pairs, (cur, pair) => cur ~ pair

try-add-result<k, v> union
	already-has-key<v>
	dict<k, v>

already-has-key<v> record
	value v

# Adds a value if the key doesn't already exist
try-add<k, v> try-add-result<k, v>(a dict<k, v>, key k, get-value act v()) data<k> compare<k> hash-mix<k>
	res = a get-or-update key, old-value =>
		if old-value is-empty
			get-value[] insert
		else
			no-change
	if value ?= res old-value
		value already-has-key
	else
		void dict res.new-node.force

- <k, v> dict<k, v>(a dict<k, v>, key k) data<k> compare<k> hash-mix<k>
	if res ?= a try-remove key
		res new-dict
	else
		a

try-remove-result<k, v> record
	by-val
	old-value v
	new-dict dict<k, v>

try-remove<k, v> try-remove-result<k, v>?(a dict<k, v>, key k) data<k> compare<k> hash-mix<k>
	res = a get-or-update key, old-value => remove
	if value ?= res old-value
		value try-remove-result (void dict res.new-node.force) some

.get-or-update-result<k, v> record
	by-val
	# If none, don't update anything
	new-node node<k, v>?
	old-value v?

.get-or-update-action<v> union
	no-change
	remove
	insert<v>
.no-change record
.remove record
.insert<v> record
	value v

###
`f` takes the old value and returns the new value, or 'none' to choose to preserve the old value.
###
.get-or-update<k, v> get-or-update-result<k, v>
	a dict<k, v>
	key k
	f act get-or-update-action v(v?)
spec
	compare<k>
	hash-mix<k>
body
	hash = key hash
	match a root
	as inner-node
		a.root get-or-update-recur key, hash, 0, f
	as leaf-node l
		l get-or-update-leaf key, hash, 0, f

.get-or-update-recur<k, v> get-or-update-result<k, v>
	a node<k, v>
	key k
	remaining-hash nat64
	hash-shift nat64
	f act get-or-update-action v(v?)
spec
	trusted
	compare<k>
	hash-mix<k>
body
	match a
	as inner-node i
		which = remaining-hash low-bits
		if which < i.children.size
			next-hash = remaining-hash unsafe-bit-shift-right 3
			child-res = i.children[which] get-or-update-recur: key, next-hash, (hash-shift wrap-add 3), f
			if node ?= child-res new-node
				new-inner = i update-child which, node
				get-or-update-result: new-inner.some, child-res.old-value
			else
				child-res
		else
			match f[none]
			as no-change
				get-or-update-result: none, none
			as remove
				get-or-update-result: none, none
			as insert ins
				# TODO: should be able to write this inline
				pair = key -> ins.value
				# TODO: type args should not be necessary
				new-leaf = leaf-node<k, v>: [pair]
				# TODO: type args should not be necessary
				new-node = inner-node<k, v>: i.children update-with-default which, new-leaf, empty-leaf-node
				get-or-update-result: new-node.some, none
	as leaf-node l
		l get-or-update-leaf key, remaining-hash, hash-shift, f

.update-child<k, v> node<k, v>(a inner-node<k, v>, which nat64, new-child node<k, v>)
	if leaf ?= a inner-node-to-leaf which, new-child
		leaf
	elif new-child node-is-empty
		if which ==: a.children.size wrap-sub 1
			new-children = a.children rtail
			if new-children.size == 1
				new-children[0]
			else
				inner-node: new-children
		else
			new-children = a.children update which, new-child
			if child ?= new-children find-only-non-empty-child
				child
			else
				new-children inner-node
	else
		inner-node: a.children update which, new-child

# Returns 'some' if we should change this to a leaf.
.inner-node-to-leaf<k, v> leaf-node<k, v>?(a inner-node<k, v>, which nat64, new-child node<k, v>) trusted
	total-size = 0 fold-with-index a.children, (cur, child, child-index) =>
		new-child-here = if child-index == which
			new-child
		else
			child
		match new-child-here
		as inner-node
			99
		as leaf-node l
			cur wrap-add l.pairs.size
	if total-size <= leaf-max-size
		# TODO: if only one non-empty leaf, don't copy..
		out = total-size uninitialized-fix-arr<arrow<k, v>>
		end = 0 fold-with-index a.children, (out-index, child, child-index) =>
			new-child-here = if child-index == which
				new-child
			else
				child
			match new-child-here
			as inner-node
				unreachable
			as leaf-node l
				new-out-index = out-index wrap-add l.pairs.size
				out[out-index -> new-out-index] copy-from! l.pairs
				new-out-index
		assert: end == out.size
		some: leaf-node: out cast-immutable

.find-only-non-empty-child<k, v> node<k, v>?(children node<k, v>[])
	first-non-empty-index = force: children find-index it => !it.node-is-empty
	if children[(first-non-empty-index wrap-add 1) -> children.size] every it => it node-is-empty
		children[first-non-empty-index] some

.get-or-update-leaf<k, v> get-or-update-result<k, v>
	a leaf-node<k, v>
	key k
	remaining-hash nat64
	hash-shift nat64
	f act get-or-update-action v(v?)
spec
	compare<k>
	hash-mix<k>
body
	if index ?= a.pairs find-index it => it.from == key
		old-value = a.pairs[index] to
		new-node = match f[old-value some]
		as no-change
			none as<node<k, v>?>
		as remove
			some: leaf-node: a.pairs remove-at index
		as insert ins
			some: leaf-node: a.pairs update index, key -> ins.value
		get-or-update-result: new-node, old-value.some
	else
		new-node = as<node<k, v>?>: match f[none]
		as no-change
			none
		as remove
			none
		as insert ins
			some: if a.pairs.size >= leaf-max-size
				if hash-shift >= 64
					# We've exhausted the hash.
					# TODO: fall back to a sorted dict ?
					todo
				# If we get here, it's guaranteed that we don't need to recursively create leaves.
				# Just group by hash.
				a new-inner-node key, ins.value, remaining-hash, hash-shift
			else
				leaf-node: a.pairs ~ [key -> ins.value]
		get-or-update-result: new-node, none

# In order to get the hash, we need to know the shift amount
.new-inner-node<k, v> inner-node<k, v>
	a leaf-node<k, v>
	key k
	value v
	hash nat64
	hash-shift nat64
spec
	trusted
	hash-mix<k>
body
	key-hash = hash low-bits
	max-hash = key-hash fold a.pairs, (cur, pair) =>
		cur max: pair.from.hash unsafe-bit-shift-right hash-shift low-bits
	res = max-hash wrap-add 1 fill-fix-arr<node<k, v>> empty-leaf-node
	# TODO: avoid allocating the same leaf twice...
	res[key-hash] := leaf-node: [key -> value]
	a.pairs each pair =>
		x = pair.from.hash unsafe-bit-shift-right hash-shift low-bits
		res[x] := match res[x]
		as inner-node
			unreachable
		as leaf-node l
			leaf-node: l.pairs ~ [pair]
	inner-node: res cast-immutable

region iteration

each<k, v> void(a dict<k, v>, f act void(k, v)) data<k> compare<k> hash-mix<k>
	void fold a, (ignore, key, value) => f[key, value]

each-key<k, v> void(a dict<k, v>, f act void(k)) data<k> compare<k> hash-mix<k>
	void fold-keys a, (ignore, key) => f[key]

fold<a, k, v> a(acc a, a dict<k, v>, f act a(a, k, v)) data<k> compare<k> hash-mix<k>
	acc fold-recur a.root, f
.fold-recur<a, k, v> a(acc a, a node<k, v>, f act a(a, k, v))
	match a
	as inner-node i
		acc fold i.children, (cur, child) => cur fold-recur child, f
	as leaf-node l
		acc fold l.pairs, (cur, pair) => f[cur, pair.from, pair.to]

fold-keys<a, k, v> a(acc a, a dict<k, v>, f act a(a, k)) data<k> compare<k> hash-mix<k>
	acc fold a, (cur, key, value) => f[cur, key]

# TODO: map
# TODO: map-values

map-to-arr<a, k, v> a[](a dict<k, v>, f act a(k, v)) trusted data<k> compare<k> hash-mix<k>
	res = a.size uninitialized-fix-arr<a>
	end = res.begin-ptr fold a, (cur, k, v) =>
		*cur := f[k, v]
		cur + 1
	hard-assert: end == res.end-ptr
	res cast-immutable

.dbg str(a dict<nat64, str>)
	res = writer
	res dbg-recur a.root, ""
	res move-to-str!

.dbg-recur void(out writer, a node<nat64, str>, path str)
	match a
	as inner-node i
		i.children each-with-index (child, index) =>
			if !child.node-is-empty
				out dbg-recur child, path ~ index.to-str
				out ~= " "
		out backup!
	as leaf-node l
		out ~= path
		out ~= "["
		l.pairs each pair =>
			out ~= pair from
			out ~= " -> "
			out ~= pair to
			out ~= ", "
		if l.pairs is-empty
			out ~= "]"
		else
			out backup! 2
			out ~= "]"

# TODO:PRIVATE
dbg str(a dict<nat64, void>)
	res = writer
	res dbg-recur a.root, ""
	res move-to-str!

.dbg-recur void(out writer, a node<nat64, void>, path str)
	match a
	as inner-node i
		i.children each-with-index (child, index) =>
			if !child.node-is-empty
				out dbg-recur child, path ~ index.to-str
				out ~= " "
		out backup!
	as leaf-node l
		out ~= path
		out ~= "["
		l.pairs each pair =>
			out ~= pair from
			out ~= ", "
		if l.pairs is-empty
			out ~= "]"
		else
			out backup! 2
			out ~= "]"

verify void(a dict<nat64, str>, expected str)
	a.dbg is expected

test
	l0 = dict<nat64, str>
	l0.is-empty is true
	l0.size is 0
	l0 verify "[]"
	l0[0] is none

	l1 = l0 ~ (5 -> "5")
	l1.is-empty is false
	l1.size is 1
	l1 verify "[5 -> 5]"
	
	l2 = l1 ~ [1 -> "1", 3 -> "3", 9 -> "9"]
	l2 verify "[5 -> 5, 1 -> 1, 3 -> 3, 9 -> 9]"

	l3 = l2 ~ (13 -> "13")
	l3 verify "[5 -> 5, 1 -> 1, 3 -> 3, 9 -> 9, 13 -> 13]"
	#l3 verify "1[1 -> 1, 9 -> 9] 3[3 -> 3] 5[13 -> 13, 5 -> 5]"

	#l3[3] is "3".some
	#l3[4] is none

	#l3 - 3 verify "[1 -> 1, 9 -> 9, 13 -> 13, 5 -> 5]"

	# TODO: lots more tests. Be sure to test removal can remove inner nodes.
