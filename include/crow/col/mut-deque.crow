no-std
import
	../bool: bool
	../compare: !=, <
	../misc: new, void
	../number: ==, <=>, +, *, nat64, new
	../opt: ==, new, opt
	../ptr: ==, <=>, +, -, *, as-const, mut-ptr, null, set-deref, zeroed
	../range: .., for-loop
	../str: ==, ~~, literal, new, str
	../str-conv: to-str
	../str-util: join
	../test-util: is
	./mut-array:
		begin-ptr, cast-immutable, copy-from, end-ptr, mut-array, is-empty, new, set-zero-elements,
		size, subscript, uninitialized-mut-array, zeroed-mut-array
	./list: ==, first, last, list, new, size, to-list
	./private/array-low-level: array-from-begin-end

# Mutable double-ended queue.
mut-deque<a> record mut
	.inner .mut mut-array a
	# Points to the first element. Null for an empty queue.
	.left .mut a mut*
	# Points to the element after the last. Null for an empty queue.
	# This should never be inner.end-ptr; it wraps around to inner.begin-ptr
	.right .mut a mut*

# New empty `mut-deque`.
new<a> mut-deque a() trusted
	(), null, null

###
Copy elements to a list.

This is O(n).
###
to-list<a> a[](a mut-deque a) trusted
	a.to-mut-array.cast-immutable to-list

.to-mut-array<a> mut-array a(a mut-deque a) no-doc trusted
	unless a is-empty
		res mut-array a = a.size uninitialized-mut-array
		res copy-from-deque a
		res

# Copy elements to a new deque.
copy<a> mut-deque a(a mut-deque a) trusted
	inner = a to-mut-array
	inner, inner.begin-ptr, inner.begin-ptr

# `true` iff `a.size == 0`.
is-empty<a> bool(a mut-deque a) trusted
	a.left == null

# Number of elements in the deque.
size<a> nat64(a mut-deque a) trusted
	match a.left <=> a.right
	as less
		a.right - a.left
	as equal
		unless a.left == null
			a.inner size
	as greater
		(a.inner.end-ptr - a.left) + (a.right - a.inner.begin-ptr)

# Push a value to the left.
push<a> void(value a, a mut-deque a) trusted
	a ensure-capacity
	if a.left == a.inner.begin-ptr
		a.left := a.inner end-ptr
	a.left := a.left - 1
	*a.left := value

# Push a value to the right.
push<a> void(a mut-deque a, value a) trusted
	a ensure-capacity
	assert a.right < a.inner.end-ptr
	*a.right := value
	a.right := a.right + 1

###
Returns the leftmost element without removing it.

Returns an empty option iff `a` is empty.
###
peek-left<a> a?(a mut-deque a) trusted
	unless a.left == null
		*a.left,

###
Returns the rightmost element without removing it.

Returns an empty option iff `a` is empty.
###
peek-right<a> a?(a mut-deque a) trusted
	unless a.right == null
		fixed-right = if a.right == a.inner.begin-ptr
			a.inner end-ptr
		else
			a right
		*(fixed-right - 1),

###
Removes and returns the leftmost element.

Returns an empty option iff `a` was empty (before calling `pop-left`).
###
pop-left<a> a?(a mut-deque a) trusted
	unless a.left == null
		res = *a.left
		*a.left := zeroed
		a.left := a.left + 1
		if a.left == a.inner.end-ptr
			a.left := a.inner begin-ptr
		if a.left == a.right
			a.left := null
			a.right := null
			# Still hold on to `a inner`
		res,

###
Removes and returns the rightmost element.

Returns an empty option iff `a` was empty (before calling `pop-right`).
###
pop-right<a> a?(a mut-deque a) trusted
	unless a.right == null
		if a.right == a.inner.begin-ptr
			a.right := a.inner end-ptr
		a.right := a.right - 1
		res = *a.right
		*a.right := zeroed
		if a.right == a.left
			a.left := null
			a.right := null
			# Still hold on to `a inner`
		res,

# This temporarily breaks the invariant that a.left and a.right are null for an empty queue.
.ensure-capacity<a> void(a mut-deque a) unsafe
	if a.left == null
		assert a.right == null
		if a.inner is-empty
			a.inner := 2 zeroed-mut-array
		a.left := a.inner begin-ptr
		a.right := a.left
	else
		assert a.right != null
		forbid a.inner is-empty
		if a.left == a.right
			old-inner = a inner
			old-capacity = old-inner size
			new-capacity = old-capacity * 2
			new-inner mut-array a = new-capacity uninitialized-mut-array
			new-inner[0 .. old-capacity] copy-from-deque a
			new-inner[old-capacity .. new-capacity] set-zero-elements
			a.inner := new-inner
			a.left := a.inner begin-ptr
			a.right := a.left + old-capacity

.copy-from-deque<a> void(dest mut-array a, a mut-deque a) trusted
	assert dest.size == a.size
	if a.left < a.right
		dest copy-from (a.left.as-const array-from-begin-end a.right.as-const)
	else
		left-to-end-size = a.inner.end-ptr - a.left
		dest[0 .. left-to-end-size] copy-from (a.left.as-const array-from-begin-end a.inner.end-ptr.as-const)
		dest[left-to-end-size .. dest.size] copy-from (a.inner.begin-ptr.as-const array-from-begin-end a.right.as-const)

.dbg str(a mut-deque nat64) trusted
	right = a.right - a.inner.begin-ptr
	left = a.left - a.inner.begin-ptr
	# Note: can come in any order...
	" " join for i : 0 .. a.inner.size
		"{i == right ? "<-R "}{i == left ? "L-> "}{a.inner[i]}"

.verify void(a mut-deque nat64, expected nat64[], expected-dbg str)
	a.peek-left is expected.first
	a.peek-right is expected.last
	a.size is expected.size
	a.to-list is expected
	a.dbg is expected-dbg

test
	a mut-deque nat64 = ()
	a.pop-left is ()
	a.pop-right is ()
	a verify (), ""
	1 push a
	a verify (1,), "<-R 0 L-> 1"
	a push 2
	a verify (1, 2), "2 <-R L-> 1"

	a-copy = a copy
	a-copy verify (1, 2), "<-R L-> 1 2"

	a.pop-right is (2,)
	a verify (1,), "<-R 0 L-> 1"

	a.pop-right is (1,)
	assert a.left == null
	assert a.right == null
	a verify (), "0 0"

	a push 1
	a verify (1,), "L-> 1 <-R 0"

	2 push a
	a verify (2, 1), "1 <-R L-> 2"

	3 push a
	a verify (3, 2, 1), "2 1 <-R 0 L-> 3"
