no-std
import
	../bool: bool
	../compare: !=, <
	../json: json
	../misc: new, void
	../number: ==, <=>, +, *, nat64, new
	../option: ==, new, option
	../pointer: ==, <=>, +, -, *, mut-pointer, null, set-deref, zeroed
	../range: ..
	../string: ==, ~~, literal, new, string, to-string
	../test-util: is
	./array: as-array
	./collection: .., -, end, for-loop, join, subscript
	./mut-array:
		+, -, begin, begin-pointer, cast-immutable, copy-from, end, end-pointer, iterate, mut-array,
		is-empty, new, set-zero-elements, size, slice, uninitialized-mut-array, zeroed-mut-array
	./list:
		==, ~=, +, -, begin, build, end, is-empty, iterate, list, new, next, size, to-list

# Mutable double-ended queue.
+mut-deque[t] record mut
	-inner .mut t mut-array
	# Points to the first element. Null for an empty queue.
	-left .mut t mut*
	# Points to the element after the last. Null for an empty queue.
	# This should never be inner.end-pointer; it wraps around to inner.begin-pointer
	-right .mut t mut*

# New empty `mut-deque`.
+new[t] t mut-deque()
	trusted (), null, null

###
Copy elements to a list.

This is O(n).
###
+to-list[t] t[](a t mut-deque)
	trusted a.to-mut-array.cast-immutable to-list

-to-mut-array[t] t mut-array(a t mut-deque)
	trusted unless a is-empty
		res t mut-array = a.size uninitialized-mut-array
		res copy-from-deque a
		res

# Copy elements to a new deque.
+copy[t] t mut-deque(a t mut-deque)
	inner = a to-mut-array
	trusted inner, inner.begin-pointer, inner.begin-pointer

# `true` iff `a.size == 0`.
+is-empty[t] bool(a t mut-deque)
	trusted a.left == null

# Number of elements in the deque.
+size[t] nat64(a t mut-deque)
	trusted
		match a.left <=> a.right
		as less
			a.right - a.left
		as equal
			unless a.left == null
				a.inner size
		as greater
			(a.inner.end-pointer - a.left) + (a.right - a.inner.begin-pointer)

# Push a value to the left.
+push[t] void(value t, a t mut-deque)
	trusted
		a ensure-capacity
		if a.left == a.inner.begin-pointer
			a.left := a.inner end-pointer
		a.left := a.left - 1
		*a.left := value

# Push a value to the right.
+push[t] void(a t mut-deque, value t)
	trusted
		a ensure-capacity
		assert a.right < a.inner.end-pointer
		*a.right := value
		a.right := a.right + 1

###
Returns the leftmost element without removing it.

Returns an empty option iff `a` is empty.
###
+peek-left[t] t?(a t mut-deque)
	trusted unless a.left == null
		*a.left,

###
Returns the rightmost element without removing it.

Returns an empty option iff `a` is empty.
###
+peek-right[t] t?(a t mut-deque)
	trusted unless a.right == null
		fixed-right = if a.right == a.inner.begin-pointer
			a.inner end-pointer
		else
			a right
		*(fixed-right - 1),

###
Removes and returns the leftmost element.

Returns an empty option iff `a` was empty (before calling `pop-left`).
###
+pop-left[t] t?(a t mut-deque)
	trusted unless a.left == null
		res = *a.left
		*a.left := zeroed
		a.left := a.left + 1
		if a.left == a.inner.end-pointer
			a.left := a.inner begin-pointer
		if a.left == a.right
			a.left := null
			a.right := null
			# Still hold on to `a inner`
		res,

###
Removes and returns the rightmost element.

Returns an empty option iff `a` was empty (before calling `pop-right`).
###
+pop-right[t] t?(a t mut-deque)
	trusted unless a.right == null
		if a.right == a.inner.begin-pointer
			a.right := a.inner end-pointer
		a.right := a.right - 1
		res = *a.right
		*a.right := zeroed
		if a.right == a.left
			a.left := null
			a.right := null
			# Still hold on to `a inner`
		res,

# This temporarily breaks the invariant that a.left and a.right are null for an empty queue.
-ensure-capacity[t] void(a t mut-deque) unsafe
	if a.left == null
		assert a.right == null
		if a.inner is-empty
			a.inner := 2 zeroed-mut-array
		a.left := a.inner begin-pointer
		a.right := a.left
	else
		assert a.right != null
		forbid a.inner is-empty
		if a.left == a.right
			old-inner = a inner
			old-capacity = old-inner size
			new-capacity = old-capacity * 2
			new-inner t mut-array = new-capacity uninitialized-mut-array
			new-inner[0 .. old-capacity] copy-from-deque a
			new-inner[old-capacity .. new-capacity] set-zero-elements
			a.inner := new-inner
			a.left := a.inner begin-pointer
			a.right := a.left + old-capacity

-copy-from-deque[t] void(dest t mut-array, a t mut-deque)
	assert dest.size == a.size
	trusted if a.left < a.right
		dest copy-from (a.left .. a.right).as-array
	else
		left-to-end-size = a.inner.end-pointer - a.left
		dest[0 .. left-to-end-size] copy-from (a.left .. a.inner.end-pointer).as-array
		dest[left-to-end-size .. end] copy-from (a.inner.begin-pointer .. a.right).as-array

-dbg string(a nat64 mut-deque)
	trusted
		right = a.right - a.inner.begin-pointer
		left = a.left - a.inner.begin-pointer
		# Note: can come in any order...
		" " join for i, x : a inner
			"{i == right ? "<-R "}{i == left ? "L-> "}{x}"

-verify void(a nat64 mut-deque, expected nat64[], expected-dbg string)
	a.peek-left is (expected.is-empty ? () : (expected[0],))
	a.peek-right is (expected.is-empty ? () : (expected[end - 1],))
	a.size is expected.size
	a.to-list is expected
	a.dbg is expected-dbg

test
	a nat64 mut-deque = ()
	a.pop-left is ()
	a.pop-right is ()
	a verify (), ""
	1 push a
	a verify (1,), "<-R 0 L-> 1"
	a push 2
	a verify (1, 2), "2 <-R L-> 1"

	a-copy = a copy
	a-copy verify (1, 2), "<-R L-> 1 2"

	a.pop-right is (2,)
	a verify (1,), "<-R 0 L-> 1"

	a.pop-right is (1,)
	assert a.left == null
	assert a.right == null
	a verify (), "0 0"

	a push 1
	a verify (1,), "L-> 1 <-R 0"

	2 push a
	a verify (2, 1), "1 <-R L-> 2"

	3 push a
	a verify (3, 2, 1), "2 1 <-R 0 L-> 3"
