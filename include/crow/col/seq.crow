no-std
import
	../bool: !, &&, bool, false, new
	../compare: ==, <, <=, compare, comparison, equal, greater, less
	../fun-util: subscript
	../misc: new, void
	../number: +, -, *, ==, <=>, nat64
	../opt: ??, ||, is-empty, new, opt
	../private/exception-low-level: unreachable
	../ptr: ==, +, *, set-deref, size-of
	../tuple: a, b, new, pair
	./arr: ~, ~~, arr, arr-equal, is-empty, new, size, subscript
	./arr-util:
		arr-iter, end-iter, find-and-get, flatten, fold, iter, new, next, prev, repeat, reverse, rtail,
		slice-left, slice-right, tail
	./fix-arr: begin-ptr, cast-immutable, end-ptr, fix-arr, uninitialized-fix-arr
	./iter: new, rest, value, value-and-rest
	./mut-arr: ~=, move-to-arr, mut-arr, new
	./private/arr-builder: ~=, arr-builder, finish, new
	./private/arr-low-level: begin-ptr, end-ptr

###
Immutable sequence type.

This type is designed so concatenation (`~` and `~~`) will be efficient.
It also is efficient to split from an iterator.

It does not support efficient access by an index, so iterators should be used instead.
###
seq<a> record by-val
	.root l0 a

get-root<a> l0 a(a seq a) no-doc
	a.root

# TODO: no-doc
l0<a> record by-val
	node node<a, l1 a>

# TODO: no-doc
l1<a> record by-val
	node node<a[], l2 a>

# TODO: no-doc
l2<a> record by-val
	nodes a[][][]

# TODO: no-doc
node<a, lower> union
	leaf a[]
	branch branch<a, lower>

###
TODO: no-doc
'left', 'down', and 'right' should all be non-empty.
(Else, this layer should be a leaf. See `branch-or-leaf`.)
###
branch<a, lower> record
	left a[]
	down lower
	right a[]

.new<a, lower> node<a, lower>()
	() leaf

.new<a> l1 a()
	(),
.new<a> l2 a()
	(),

.is-empty<a> bool(a l1 a)
	match a node
	as leaf xs
		xs is-empty
	as branch _
		false

.is-empty<a> bool(a l2 a)
	a.nodes is-empty

.depth<a> nat64(a seq a)
	match a.root.node
	as leaf _
		0
	as branch b
		b.down depth-l1

.depth-l1<a> nat64(a l1 a)
	match a node
	as leaf _
		1
	as branch b
		b.down depth-l2

.depth-l2<a> nat64(_ l2 a)
	2

.as-branch<a, lower> branch<a, lower>(a node<a, lower>) unsafe noctx
	match a
	as leaf _
		unreachable
	as branch b
		b

.try-as-l0-leaf<a> a[]?(a seq a) noctx
	match a.root node
	as leaf xs
		xs,
	as branch _
		()

.get-l0-branch<a> branch<a, l1 a>(a seq a) unsafe noctx
	a.root.node as-branch

.try-get-l1<a> l1<a>?(a seq a) noctx
	match a.root node
	as leaf _
		()
	as branch b
		b.down,

.get-l1<a> l1 a(a seq a) unsafe noctx
	a.try-get-l1 force

.get-l1-branch<a> branch<a[], l2 a>(a seq a) unsafe noctx
	a.get-l0-branch.down.node as-branch

.get-l2<a> l2 a(a seq a) unsafe noctx
	a.get-l1-branch down

# Sequence containing the given elements.
new<a> seq a(...a a[]) noctx
	a to-seq

###
Convert an array to a sequence.
This is O(1).
###
to-seq<a> seq a(a a[]) noctx
	l l0 a = a.leaf,
	l,

seq-equal<a> bool(a seq a, b seq a) noctx equal<a>
	if la ?= a try-as-l0-leaf
		if lb ?= b try-as-l0-leaf
			la arr-equal lb
		else
			a.iter seq-equal-recur b.iter
	else
		a.size == b.size && a.iter seq-equal-recur b.iter
.seq-equal-recur<a> bool(a seq-iter a, b seq-iter a) noctx equal<a>
	if na ?= a next
		if nb ?= b next
			if na.value == nb.value
				na.rest seq-equal-recur nb.rest
	else
		b.next is-empty

seq-compare<a> comparison(a seq a, b seq a) noctx compare<a>
	a.iter seq-compare-recur b.iter
.seq-compare-recur<a> comparison(a seq-iter a, b seq-iter a) noctx compare<a>
	if na ?= a next
		if nb ?= b next
			cmp = na.value <=> nb.value
			if cmp == equal
				na.rest seq-compare-recur nb.rest
			else
				cmp
		else
			greater
	else
		b.next.is-empty ? equal : less

###
Convert a sequence to an array.
This is O(n).
This is O(1) if the seq came from to-seq of an array, meaning a round trip is free.
###
to-arr<a> a[](a seq a)
	a.try-as-l0-leaf ?? for x : a; x

###
`true` iff `a.size == 0`.
This is O(1).
###
is-empty<a> bool(a seq a) noctx
	match a.root node
	as leaf xs
		xs is-empty
	as branch _
		false

###
Number of elements in the sequence.
This is O(n).
###
size<a> nat64(a seq a) noctx
	match a.root node
	as leaf l
		l.size
	as branch b
		b.left.size + b.down.size + b.right.size
.size<a> nat64(a l1 a) noctx
	match a node
	as leaf l
		l.size-2d
	as branch b
		b.left.size-2d + b.down.size + b.right.size-2d
.size<a> nat64(a l2 a) noctx
	a.nodes.size-3d
.size-2d<a> nat64(a a[][]) noctx trusted
	cur mut = a begin-ptr
	end = a end-ptr
	res mut = 0
	until cur == end
		res := res + cur->size
		cur := cur + 1
	res

.size-3d<a> nat64(a a[][][]) noctx trusted
	cur mut = a begin-ptr
	end = a end-ptr
	res mut = 0
	until cur == end
		res := res + cur->size-2d
		cur := cur + 1
	res

###
Concatenate two sequences.
This is O(log n), where `n` is the size of the smaller sequence.
###
~~<a> seq a(a seq a, b seq a)
	# Concatenate the smaller sequence onto the bigger one.
	match a.depth <=> b.depth
	as less
		(a.root cat-left-node-l0 b.root),
	as equal
		if a.size < b.size
			(a.root cat-left-node-l0 b.root),
		else
			(a.root cat-right-node-l0 b.root),
	as greater
		(a.root cat-right-node-l0 b.root),

###
Prepend an element to a sequence.
This is O(log n), amortized O(1).
###
~<a> seq a(a a, b seq a)
	((a,)::a[] cat-left-array-l0 b.root),

###
Appendd an element to a sequence.
This is O(log n), amortized O(1).
###
~<a> seq a(a seq a, b a)
	(a.root cat-right-array-l0 (b,)),

# 'r' is bigger, add 'l' to the left
.cat-left-node-level<a, lower> node<a, lower>(
	l node<a, lower>,
	r node<a, lower>,
	cat-left-array-lower act lower(a[], lower),
	cat-left-node-lower act lower(lower, lower),
) trusted new<lower>
	match l
	as leaf xs
		xs cat-left-array-level r, cat-left-array-lower
	as branch bl
		match r
		as leaf _
			# 'r' should be bigger
			unreachable
		as branch br
			down1 = cat-left-array-lower[bl.right ~~ br.left, br.down]
			down2 = cat-left-node-lower[bl.down, down1]
			(bl.left, down2, br.right) branch

# 'l' is bigger, add 'r' to right
.cat-right-node-level<a, lower> node<a, lower>(
	l node<a, lower>,
	r node<a, lower>,
	cat-right-array-lower act lower(lower, a[]),
	cat-right-node-lower act lower(lower, lower),
) trusted new<lower>
	match r
	as leaf xs
		l cat-right-array-level xs, cat-right-array-lower
	as branch br
		match l
		as leaf _
			# 'l' should be bigger
			unreachable
		as branch bl
			down1 = cat-right-array-lower[bl.down, bl.right ~~ br.left]
			down2 = cat-right-node-lower[down1, br.down]
			(bl.left, down2, br.right) branch

# 'r' is bigger
.cat-left-array-level<a, lower> node<a, lower>(
	l a[],
	r node<a, lower>,
	cat-left-lower act lower(a[], lower),
) new<lower>
	match r
	as leaf xs
		if l.size-bytes + xs.size-bytes <= max-leaf-bytes
			l ~~ xs leaf
		else
			(l, (), xs) branch
	as branch br
		if l.size-bytes + br.left.size-bytes <= max-leaf-bytes
			(l ~~ br.left, br.down, br.right) branch
		else
			(l, cat-left-lower[br.left, br.down], br.right) branch

.cat-right-array-level<a, lower> node<a, lower>(
	l node<a, lower>,
	r a[],
	cat-right-lower act lower(lower, a[]),
) new<lower>
	match l
	as leaf xs
		if xs.size-bytes + r.size-bytes <= max-leaf-bytes
			xs ~~ r leaf
		else
			(xs, (), r) branch
	as branch br
		if br.right.size-bytes + r.size-bytes <= max-leaf-bytes
			(br.left, br.down, br.right ~~ r) branch
		else
			(br.left, cat-right-lower[br.down, br.right], r) branch

.cat-left-node-l0<a> l0 a(l l0 a, r l0 a)
	new: l.node cat-left-node-level r.node, ((xs, lower) => (xs,) cat-left-array-l1 lower), (x, y) =>
		x cat-left-node-l1 y

.cat-right-node-l0<a> l0 a(l l0 a, r l0 a)
	new: l.node cat-right-node-level r.node, ((lower, xs) => lower cat-right-array-l1 (xs,)), (x, y) =>
		x cat-right-node-l1 y

.cat-left-array-l0<a> l0 a(l a[], r l0 a)
	new: l cat-left-array-level r.node, (xs, lower) => (xs,) cat-left-array-l1 lower

.cat-right-array-l0<a> l0 a(l l0 a, r a[])
	new: l.node cat-right-array-level r, (lower, xs) => lower cat-right-array-l1 (xs,)

.cat-left-node-l1<a> l1 a(l l1 a, r l1 a)
	new: l.node cat-left-node-level r.node, ((xs, lower) => (xs,) cat-left-array-l2 lower), (x, y) =>
		x cat-left-node-l2 y

.cat-right-node-l1<a> l1 a(l l1 a, r l1 a)
	new: l.node cat-right-node-level r.node, ((lower, xs) => lower cat-right-array-l2 (xs,)), (x, y) =>
		x cat-right-node-l2 y

.cat-left-array-l1<a> l1 a(l a[][], r l1 a)
	new: l cat-left-array-level r.node, (xs, lower) => (xs,) cat-left-array-l2 lower

.cat-right-array-l1<a> l1 a(l l1 a, r a[][])
	new: l.node cat-right-array-level r, (lower, xs) => lower cat-right-array-l2 (xs,)

.cat-left-node-l2<a> l2 a(l l2 a, r l2 a)
	l.nodes ~~ r.nodes,

.cat-right-node-l2<a> l2 a(l l2 a, r l2 a)
	l.nodes ~~ r.nodes,

.cat-left-array-l2<a> l2 a(l a[][][], r l2 a)
	l ~~ r.nodes,

.cat-right-array-l2<a> l2 a(l l2 a, r a[][][])
	l.nodes ~~ r,

# Leaves are allowed to be arbitrarily long, this is just the limit when we would normally make a branch
.max-leaf-bytes nat64()
	64

# 'trusted' since we are just using it to guide branch sizes (which should have no observable effect)
.size-bytes<a> nat64(a a[]) trusted
	a.size * size-of@<a>

region iter and slice

# Immutable iterator over a sequence.
seq-iter<a> record by-val
	.seq seq a
	.cur arr-3d-iter a
	.pos position

.position enum
	l0-leaf
	l0-left
	l0-right
	l1-leaf
	l1-left
	l1-right
	l2-leaf

# New iterator at the beginning of the sequence.
iter<a> seq-iter<a>(a seq a) noctx
	match a.root node
	as leaf xs
		a, xs.iter.to-iter3d, l0-leaf
	as branch b
		a, b.left.iter.to-iter3d, l0-left

end-iter<a> seq-iter<a>(a seq a)
	match a.root node
	as leaf xs
		a, xs.end-iter.to-iter3d, l0-leaf
	as branch b
		a, b.right.end-iter.to-iter3d, l0-right

###
Returns the next element and next iterator.
Returns an empty option if the iterator was already at the end of the sequence.
###
next<a> value-and-rest<a, seq-iter a>?(a seq-iter a) trusted noctx
	if n ?= a.cur next
		(n.value, (a.seq, n.rest, a.pos)),
	elif pair ?= a.seq next-position a.pos
		(a.seq, pair.a, pair.b) next
.next-position<a> pair<arr-3d-iter a, position>?(a seq a, pos position) unsafe noctx
	match pos
	as l0-leaf
		()
	as l0-left
		a.l1-iter,
	as l0-right
		()
	as l1-leaf
		(a.get-l0-branch.right.iter.to-iter3d, l0-right),
	as l1-left
		a.l2-iter,
	as l1-right
		(a.get-l0-branch.right.iter.to-iter3d, l0-right),
	as l2-leaf
		(a.get-l1-branch.right.iter2d.to-iter3d, l1-right),

prev<a> value-and-rest<a, seq-iter a>?(a seq-iter a) trusted noctx
	if p ?= a.cur prev
		(p.value, (a.seq, p.rest, a.pos)),
	elif pair ?= a.seq prev-position a.pos
		(a.seq, pair.a, pair.b) prev
.prev-position<a> pair<arr-3d-iter a, position>?(a seq a, pos position) unsafe noctx
	match pos
	as l0-leaf
		()
	as l0-left
		()
	as l0-right
		a.l1-end-iter,
	as l1-leaf
		(a.get-l0-branch.left.end-iter.to-iter3d, l0-left),
	as l1-left
		(a.get-l0-branch.left.end-iter.to-iter3d, l0-left),
	as l1-right
		a.l2-end-iter,
	as l2-leaf
		(a.get-l1-branch.left.end-iter2d.to-iter3d, l1-left),

# Mutable iterator over a sequence.
mut-seq-iter<a> record mut
	.inner mut seq-iter a

# New mutable iterator at the beginning of the sequence.
mut-iter<a> mut-seq-iter a(a seq a)
	a.iter,

end-mut-iter<a> mut-seq-iter a(a seq a)
	a.end-iter,

# Copy to an immutable iterator.
iter<a> seq-iter a(a mut-seq-iter a)
	a.inner

copy<a> mut-seq-iter a(a mut-seq-iter a)
	a.inner,

###
Advances the iterator and returns the next element.
Returns an empty option if the iterator was already at the end of the sequence.
###
next<a> a?(a mut-seq-iter a)
	if pair ?= a.inner next
		a.inner := pair rest
		pair.value,

prev<a> a?(a mut-seq-iter a)
	if pair ?= a.inner prev
		a.inner := pair rest
		pair.value,

###
Returns the next element without advancing the iterator.
Returns an empty option if the iterator is at the end of the sequence.
###
peek<a> a?(a mut-seq-iter a)
	if pair ?= a.inner next
		pair.value,

###
Seq of every element to the left of the iterator.
This is O(log n).
###
slice-left<a> seq a(a seq-iter a) trusted
	match a pos
	as l0-leaf
		a.cur.as-1d.slice-left to-seq
	as l0-left
		a.cur.as-1d.slice-left to-seq
	as l0-right
		b = a.seq get-l0-branch
		(b.left branch-or-leaf-l0 b.down, a.cur.as-1d.slice-left),
	as l1-leaf
		a.seq slice-left-update-l1 _ =>
			a.cur.as-2d.slice-left.leaf,
	as l1-left
		a.seq slice-left-update-l1 l1 =>
			b = l1.node as-branch
			a.cur.as-2d.slice-left branch-or-leaf-l1 b.down, b.right
	as l1-right
		a.seq slice-left-update-l1 l1 =>
			b = l1.node as-branch
			b.left branch-or-leaf-l1 b.down, a.cur.as-2d.slice-left
	as l2-leaf
		a.seq slice-left-update-l2 _ =>
			a.cur.slice-left,

###
Seq of every element to the right of the iterator.
This is O(log n).
###
slice-right<a> seq a(a seq-iter a) trusted
	match a pos
	as l0-leaf
		a.cur.as-1d.slice-right to-seq
	as l0-left
		b = a.seq get-l0-branch
		(a.cur.as-1d.slice-right branch-or-leaf-l0 b.down, b.right),
	as l0-right
		a.cur.as-1d.slice-right to-seq
	as l1-leaf
		a.seq slice-right-update-l1 _ =>
			a.cur.as-2d.slice-right.leaf,
	as l1-left
		a.seq slice-right-update-l1 l1 =>
			b = l1.node as-branch
			a.cur.as-2d.slice-right branch-or-leaf-l1 b.down, b.right
	as l1-right
		a.seq slice-right-update-l1 l1 =>
			b = l1.node as-branch
			b.left branch-or-leaf-l1 b.down, a.cur.as-2d.slice-right
	as l2-leaf
		a.seq slice-right-update-l2 _ =>
			a.cur.slice-right,

.level<l, a> spec
	is-empty bool(level l)
	pop-left pair<a[], l>(level l)
	pop-right pair<l, a[]>(level l)

.branch-or-leaf-generic<a, lower> node<a, lower>(left a[], down lower, right a[]) trusted level<lower, a>
	if down is-empty
		if left is-empty
			right leaf
		elif right is-empty
			left leaf
		else
			left ~~ right leaf
	else
		forbid left.is-empty && right.is-empty
		if left is-empty
			pair = down pop-left
			if pair.b is-empty
				pair.a ~~ right leaf
			else
				(pair.a, pair.b, right) branch
		elif right is-empty
			pair = down pop-right
			if pair.a is-empty
				left ~~ pair.b leaf
			else
				(left, pair.a, pair.b) branch
		else
			(left, down, right) branch

.branch-or-leaf-l0<a> l0 a(left a[], down l1 a, right a[])
	(left branch-or-leaf-generic down, right),

.branch-or-leaf-l1<a> l1 a(left a[][], down l2 a, right a[][])
	(left branch-or-leaf-generic down, right),

.pop-left<a> pair<a[], l1 a>(a l1 a)
	match a node
	as leaf xs
		xs[0], (xs.tail.leaf,)
	as branch b
		popped = b.left[0]
		rest l1 a = if b.left.tail is-empty
			if b.down is-empty
				b.right.leaf,
			else
				pair = b.down pop-left
				(pair.a, pair.b, b.right).branch,
		else
			(b.left.tail, b.down, b.right).branch,
		popped, rest

.pop-right<a> pair<l1 a, a[]>(a l1 a)
	match a node
	as leaf xs
		(xs.rtail.leaf,), xs[xs.size - 1]
	as branch b
		popped = b.right[b.right.size - 1]
		rest l1 a = if b.right.rtail is-empty
			if b.down is-empty
				b.left.leaf,
			else
				pair = b.down pop-right
				(b.left, pair.a, pair.b).branch,
		else
			(b.left, b.down, b.right.rtail).branch,
		rest, popped

.pop-left<a> pair<a[][], l2 a>(a l2 a)
	a.nodes[0], (a.nodes.tail,)

.pop-right<a> pair<l2 a, a[][]>(a l2 a)
	(a.nodes.rtail,), a.nodes[a.nodes.size - 1]

.slice-left-update-l1<a> seq a(a seq a, f act l1 a(l1 a)) unsafe
	old-l0 = a get-l0-branch
	new-l1 = f[old-l0 down]
	(old-l0.left branch-or-leaf-l0 new-l1, ()),

.slice-right-update-l1<a> seq a(a seq a, f act l1 a(l1 a)) unsafe
	old-l0 = a get-l0-branch
	new-l1 = f[old-l0 down]
	(()::a[] branch-or-leaf-l0 new-l1, old-l0.right),

.slice-left-update-l2<a> seq a(a seq a, f act l2 a(l2 a)) unsafe
	a slice-left-update-l1 old-l1 =>
		b = old-l1.node as-branch
		new-l2 = f[b down]
		if new-l2 is-empty
			b.left.leaf,
		else
			pair = new-l2 pop-right
			(b.left, pair.a, pair.b).branch,

.slice-right-update-l2<a> seq a(a seq a, f act l2 a(l2 a)) unsafe
	a slice-right-update-l1 old-l1 =>
		b = old-l1.node as-branch
		new-l2 = f[b down]
		if new-l2 is-empty
			b.right.leaf,
		else
			pair = new-l2 pop-left
			(pair.a, pair.b, b.right).branch,

# Iterator through an a[][][]
.arr-3d-iter<a> record by-val
	cur-1d arr-iter a
	cur-2d arr-iter a[]
	cur-3d arr-iter a[][]
.new<a> arr-3d-iter a() noctx
	(), (), ()

.as-2d<a> arr-2d-iter a(a arr-3d-iter a) trusted
	assert a.cur-3d.prev.is-empty && a.cur-3d.next.is-empty
	a.cur-1d, a.cur-2d

.as-1d<a> arr-iter a(a arr-3d-iter a) trusted
	assert a.cur-2d.prev.is-empty && a.cur-2d.next.is-empty
	assert a.cur-3d.prev.is-empty && a.cur-3d.next.is-empty
	a cur-1d

.to-iter3d<a> arr-3d-iter a(a arr-iter a) noctx
	a, (), ()

.arr-2d-iter<a> record by-val
	cur-1d arr-iter a
	cur-2d arr-iter a[]
.new<a> arr-2d-iter a() noctx
	(), ()

.iter2d<a> arr-2d-iter a(a a[][]) noctx
	if n2 ?= a.iter next
		n2.value.iter, n2.rest

.end-iter2d<a> arr-2d-iter a(a a[][]) noctx
	if p2 ?= a.end-iter prev
		p2.value.end-iter, p2.rest

.to-iter3d<a> arr-3d-iter a(a arr-2d-iter a) noctx
	a.cur-1d, a.cur-2d, ()

.iter3d<a> arr-3d-iter a(a a[][][]) unsafe noctx
	if n3 ?= a.iter next
		n2 = n3.value.iter.next force
		n2.value.iter, n2.rest, n3.rest

.end-iter3d<a> arr-3d-iter a(a a[][][]) unsafe noctx
	if n3 ?= a.end-iter prev
		n2 = n3.value.end-iter.prev force
		n2.value.end-iter, n2.rest, n3.rest

.next<a> value-and-rest<a, arr-3d-iter a>?(a arr-3d-iter a) trusted noctx
	if n1 ?= a.cur-1d next
		(n1.value, (n1.rest, a.cur-2d, a.cur-3d)),
	elif n2 ?= a.cur-2d next
		n1 = n2.value.iter.next force
		(n1.value, (n1.rest, n2.rest, a.cur-3d)),
	elif n3 ?= a.cur-3d next
		n2 = n3.value.iter.next force
		n1 = n2.value.iter.next force
		(n1.value, (n1.rest, n2.rest, n3.rest)),

.prev<a> value-and-rest<a, arr-3d-iter a>?(a arr-3d-iter a) trusted noctx
	if p1 ?= a.cur-1d prev
		(p1.value, (p1.rest, a.cur-2d, a.cur-3d)),
	elif p2 ?= a.cur-2d prev
		p1 = p2.value.end-iter.prev force
		(p1.value, (p1.rest, p2.rest, a.cur-3d)),
	elif p3 ?= a.cur-3d prev
		p2 = p3.value.end-iter.prev force
		p1 = p2.value.end-iter.prev force
		(p1.value, (p1.rest, p2.rest, p3.rest)),

.slice-left<a> a[][](a arr-2d-iter a)
	a1 = a.cur-1d slice-left
	a2 = a.cur-2d.slice-left rtail
	a1.is-empty ? a2 : a2 ~ a1

.slice-left<a> a[][][](a arr-3d-iter a)
	a1 = a.cur-1d slice-left
	# rtail since 'slice-left' includes the array 'a1' is iterating
	a2 = a.cur-2d.slice-left rtail
	a3 = a.cur-3d.slice-left rtail
	b2 = a1.is-empty ? a2 : a2 ~ a1
	b2.is-empty ? a3 : a3 ~ b2

.slice-right<a> a[][](a arr-2d-iter a)
	a1 = a.cur-1d slice-right
	a2 = a.cur-2d slice-right
	a1.is-empty ? a2 : a1 ~ a2

.slice-right<a> a[][][](a arr-3d-iter a)
	a1 = a.cur-1d slice-right
	a2 = a.cur-2d slice-right
	a3 = a.cur-3d slice-right
	b2 = a1.is-empty ? a2 : a1 ~ a2
	b2.is-empty ? a3 : b2 ~ a3

.l1-iter<a> pair<arr-3d-iter a, position>(a seq a) unsafe noctx
	match a.get-l1 node
	as leaf xs
		if xs is-empty
			a.get-l0-branch.right.iter.to-iter3d, l0-right
		else
			xs.iter2d.to-iter3d, l1-leaf
	as branch b
		b.left.iter2d.to-iter3d, l1-left

.l1-end-iter<a> pair<arr-3d-iter a, position>(a seq a) unsafe noctx
	match a.get-l1 node
	as leaf xs
		if xs is-empty
			a.get-l0-branch.left.end-iter.to-iter3d, l0-left
		else
			xs.end-iter2d.to-iter3d, l1-leaf
	as branch b
		b.right.end-iter2d.to-iter3d, l1-right

.l2-iter<a> pair<arr-3d-iter a, position>(a seq a) unsafe noctx
	a.get-l2.nodes.iter3d, l2-leaf

.l2-end-iter<a> pair<arr-3d-iter a, position>(a seq a) unsafe noctx
	a.get-l2.nodes.end-iter3d, l2-leaf

region iteration

first<a> a?(a seq a)
	if i ?= a.iter next
		i.value,

last<a> a?(a seq a)
	if i ?= a.end-iter prev
		i.value,

for-loop<a> void(a seq a, f act void(a))
	() fold a, (_, x) => f[x]

fold<a, b> a(acc a, a seq b, f act a(a, b))
	acc fold-chunks a, (cur, chunk) =>
		cur fold chunk, f

some<a> bool(a seq a, f act bool(a))
	v void? = a find-and-get x =>
		if f[x]
			(),
	!v.is-empty

every<a> bool(a seq a, f act bool(a))
	!(a some x => !f[x])

find-and-get<out, in> out?(a seq in, f act out?(in))
	a find-and-get-chunk chunk =>
		chunk find-and-get f

filter<a> seq a(a seq a, f act bool(a))
	out arr-builder a = ()
	for x : a
		if f[x]
			out ~= x
	out.finish to-seq

drop-while<a> seq a(a seq a, f act bool(a))
	a.iter drop-while-recur f
.drop-while-recur<a> seq a(a seq-iter a, f act bool(a))
	if n ?= a next
		if f[n value]
			n.rest drop-while-recur f
		else
			a slice-right

drop-right-while<a> seq a(a seq a, f act bool(a))
	a.end-iter drop-right-while-recur f
.drop-right-while-recur<a> seq a(a seq-iter a, f act bool(a))
	if p ?= a prev
		if f[p value]
			p.rest drop-right-while-recur f
		else
			a slice-left

for-loop<out, in> seq out(a seq in, f act out(in))
	a for-loop f to-seq

for-loop<out, in> out[](a seq in, f act out(in)) trusted
	res fix-arr out = a.size uninitialized-fix-arr
	end = res.begin-ptr fold a, (out, x) =>
		*out := f[x]
		out + 1
	assert end == res.end-ptr
	res cast-immutable

flatten<a> seq a(a seq a[])
	# TODO:PERF
	a.to-arr.flatten to-seq

.fold-chunks<a, b> a(acc a, xs seq b, f act a(a, b[]))
	match xs.root node
	as leaf l
		f[acc, l]
	as branch b
		mid = f[acc, b left] fold-chunks-l1 b.down, f
		f[mid, b right]

.fold-chunks-l1<a, b> a(acc a, xs l1 b, f act a(a, b[]))
	match xs node
	as leaf l
		acc fold l, f
	as branch b
		acc fold b.left, f fold-chunks-l2 b.down, f fold b.right, f

.fold-chunks-l2<a, b> a(acc a, xs l2 b, f act a(a, b[]))
	acc fold xs.nodes, (cur, nodes) =>
		cur fold nodes, f

.find-and-get-chunk<out, in> out?(a seq in, f act out?(in[]))
	match a.root node
	as leaf l
		f[l]
	as branch b
		f[b.left] || b.down find-and-get-chunk-l1 f || f[b.right]

.find-and-get-chunk-l1<out, in> out?(a l1 in, f act out?(in[]))
	match a node
	as leaf l
		l find-and-get f
	as branch b
		b.left find-and-get f || b.down find-and-get-chunk-l2 f || b.right find-and-get f

.find-and-get-chunk-l2<out, in> out?(a l2 in, f act out?(in[]))
	a.nodes find-and-get xs =>
		xs find-and-get f

starts-with<a> bool(a seq a, b seq a) equal<a>
	!(a.iter iter-starts-with b.iter).is-empty

ends-with<a> bool(a seq a, b seq a) equal<a>
	!(a.end-iter iter-ends-with b.end-iter).is-empty

try-remove-start<a> seq<a>?(a seq a, b seq a) equal<a>
	if iter ?= a.iter iter-starts-with b.iter
		iter.slice-right,

try-remove-end<a> seq<a>?(a seq a, b seq a) equal<a>
	if iter ?= a.end-iter iter-ends-with b.end-iter
		iter.slice-left,

###
`true` iff `b` is a subsequence of `a`.

That means: The characters in `b` appear in `a`, in order, without interruptions.
###
contains-subseq<a> bool(a seq a, b seq a) equal<a>
	!(a iters-of-subseq b).is-empty

split-seq<a> record
	left seq a
	middle a
	right seq a

try-split-once-by-fn<a> split-seq<a>?(a seq a, f act bool(a)) equal<a>
	a.iter try-split-once-by-fn-recur f
.try-split-once-by-fn-recur<a> split-seq<a>?(a seq-iter a, f act bool(a))
	if n ?= a next
		if f[n value]
			(a.slice-left, n.value, n.rest.slice-right),
		else
			n.rest try-split-once-by-fn-recur f

###
Finds the first apperance of `b` as a subsequence of `a`,
and returns slices of `a` to the left and right of that.

Returns an empty option iff `b` is not a subsequence of `a`.
###
try-split-once-by-subseq<a> pair<seq a, seq a>?(a seq a, b seq a) equal<a>
	forbid b is-empty : "can't split by empty sequence"
	if pair ?= a iters-of-subseq b
		(pair.a.slice-left, pair.b.slice-right),

try-split-once-by-subseq-right<a> pair<seq a, seq a>?(a seq a, b seq a) equal<a>
	forbid b is-empty : "can't split by empty sequence"
	if pair ?= a iters-of-subseq-right b
		(pair.a.slice-left, pair.b.slice-right),

split-by-subseq<a> seq seq a(a seq a, b seq a) equal<a>
	forbid b is-empty : "can't split by empty sequence"
	out seq<a> mut[] = ()
	out split-by-subseq-recur a, b
	out.move-to-arr to-seq
.split-by-subseq-recur<a> void(out seq<a> mut[], a seq a, b seq a) equal<a>
	if pair ?= a try-split-once-by-subseq b
		out ~= pair.a
		out split-by-subseq-recur pair.b, b
	else
		unless a is-empty
			out ~= a

.iters-of-subseq<a> pair<seq-iter a, seq-iter a>?(a seq a, b seq a) equal<a>
	a.iter iters-of-subseq-recur b
.iters-of-subseq-recur<a> pair<seq-iter a, seq-iter a>?(a seq-iter a, b seq a) equal<a>
	if end-iter ?= a iter-starts-with b.iter
		(a, end-iter),
	elif n ?= a next
		n.rest iters-of-subseq-recur b

.iters-of-subseq-right<a> pair<seq-iter a, seq-iter a>?(a seq a, b seq a) equal<a>
	a.end-iter iters-of-subseq-right-recur b
.iters-of-subseq-right-recur<a> pair<seq-iter a, seq-iter a>?(a seq-iter a, b seq a) equal<a>
	if start-iter ?= a iter-ends-with b.end-iter
		(start-iter, a),
	elif p ?= a prev
		p.rest iters-of-subseq-right-recur b

.iter-starts-with<a> seq-iter<a>?(a seq-iter a, b seq-iter a) equal<a>
	if bn ?= b next
		if an ?= a next
			if an.value == bn.value
				an.rest iter-starts-with bn.rest
	else
		a,

.iter-ends-with<a> seq-iter<a>?(a seq-iter a, b seq-iter a) equal<a>
	if bp ?= b prev
		if ap ?= a prev
			if ap.value == bp.value
				ap.rest iter-ends-with bp.rest
	else
		a,

repeat<a> seq a(a seq a, n nat64)
	a.to-arr repeat n to-seq

reverse<a> seq a(a seq a)
	a.to-arr.reverse to-seq

.force<a> a(a a?) unsafe noctx
	if x ?= a
		x
	else
		unreachable
