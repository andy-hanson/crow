no-std
import
	../bool: !, &&, ==, bool, false, new, true
	../compare: <, <=, equal
	../exception: assert
	../fun-util: subscript
	../misc: new, void
	../number: ==, <=>, +, -, *, nat64
	../opt: !, ||, is-empty, new, opt
	../private/bootstrap: hard-assert, hard-forbid, hard-unreachable
	../ptr: ==, <=>, +, set-deref, size-of
	../str: ==, literal, str
	../str-conv: finish, interp, to-str, with-str, with-value
	../test-util: is
	../tuple: a, b, new, pair
	../writer: ~=, ~~=, backup, move-to-str, new, writer
	./arr: ~, ~~, arr, is-empty, new, size, subscript
	./arr-util: each, find-and-get, fold, rtail, tail
	./fix-arr: begin-ptr, cast-immutable, end-ptr, fix-arr, uninitialized-fix-arr
	./mut-arr: ~=, move-to-arr, mut-arr, new
	./private/arr-low-level: arr-from-begin-end, begin-ptr, end-ptr

###
Immutable sequence type.

This type is designed so concatenation (`~` and `~~`) will be efficient.
It also is efficient to split from an iterator.

It does not support efficient access by an index, so iterators should be used instead.
###
seq<a> record
	.root l0 a

.l0<a> record
	node node<a, l1 a>

.l1<a> record
	node node<a[], l2 a>

.l2<a> record
	nodes a[][][]

.node<a, lower> union
	leaf a[]
	branch branch<a, lower>

###
'left', 'down', and 'right' should all be non-empty.
(Else, this layer should be a leaf. See `branch-or-leaf`.)
###
.branch<a, lower> record
	left a[]
	down lower
	right a[]

.new<a, lower> node<a, lower>()
	() leaf

.new<a> l1 a()
	(),
.new<a> l2 a()
	(),

.is-empty<a> bool(a l1 a)
	match a node
	as leaf xs
		xs is-empty
	as branch _
		false

.is-empty<a> bool(a l2 a)
	a.nodes is-empty

.depth<a> nat64(a seq a)
	match a.root.node
	as leaf _
		0
	as branch b
		b.down depth-l1

.depth-l1<a> nat64(a l1 a)
	match a node
	as leaf _
		1
	as branch b
		b.down depth-l2

.depth-l2<a> nat64(_ l2 a)
	2

.as-branch<a, lower> branch<a, lower>(a node<a, lower>) trusted
	match a
	as leaf _
		hard-unreachable
	as branch b
		b

.get-l0-branch<a> branch<a, l1 a>(a seq a)
	a.root.node as-branch

.get-l1<a> l1 a(a seq a)
	a.get-l0-branch down

.get-l2<a> l2 a(a seq a)
	a.get-l1.node.as-branch down

# Sequence containing the given elements.
new<a> seq a(...a a[])
	a to-seq

###
Convert an array to a sequence.
This is O(1).
###
to-seq<a> seq a(a a[])
	l l0 a = a.leaf,
	l,

###
Convert a sequence to an array.
This is O(n).
###
to-arr<a> a[](a seq a)
	a map-to-arr x => x

###
`true` iff `a.size == 0`.
This is O(1).
###
is-empty<a> bool(a seq a)
	match a.root node
	as leaf xs
		xs is-empty
	as branch _
		false

###
Number of elements in the sequence.
This is O(n).
###
size<a> nat64(a seq a)
	0 fold-chunks a, (acc, xs) => acc + xs.size

###
Concatenate two sequences.
This is O(log n), where `n` is the size of the smaller sequence.
###
~~<a> seq a(a seq a, b seq a)
	# Concatenate the smaller sequence onto the bigger one.
	match a.depth <=> b.depth
	as less
		(a.root cat-left-node-l0 b.root),
	as equal
		if a.size < b.size
			(a.root cat-left-node-l0 b.root),
		else
			(a.root cat-right-node-l0 b.root),
	as greater
		(a.root cat-right-node-l0 b.root),

###
Prepend an element to a sequence.
This is O(log n), amortized O(1).
###
~<a> seq a(a a, b seq a)
	((a,)::a[] cat-left-array-l0 b.root),

###
Appendd an element to a sequence.
This is O(log n), amortized O(1).
###
~<a> seq a(a seq a, b a)
	(a.root cat-right-array-l0 (b,)),

# 'r' is bigger, add 'l' to the left
.cat-left-node-level<a, lower> node<a, lower>
	l node<a, lower>
	r node<a, lower>
	cat-left-array-lower act lower(a[], lower)
	cat-left-node-lower act lower(lower, lower)
spec
	trusted
	new<lower>
body
	match l
	as leaf xs
		xs cat-left-array-level r, cat-left-array-lower
	as branch bl
		match r
		as leaf _
			# 'r' should be bigger
			hard-unreachable
		as branch br
			down1 = cat-left-array-lower[bl.right ~~ br.left, br.down]
			down2 = cat-left-node-lower[bl.down, down1]
			(bl.left, down2, br.right) branch

# 'l' is bigger, add 'r' to right
.cat-right-node-level<a, lower> node<a, lower>
	l node<a, lower>
	r node<a, lower>
	cat-right-array-lower act lower(lower, a[])
	cat-right-node-lower act lower(lower, lower)
spec
	trusted
	new<lower>
body
	match r
	as leaf xs
		l cat-right-array-level xs, cat-right-array-lower
	as branch br
		match l
		as leaf _
			# 'l' should be bigger
			hard-unreachable
		as branch bl
			down1 = cat-right-array-lower[bl.down, bl.right ~~ br.left]
			down2 = cat-right-node-lower[down1, br.down]
			(bl.left, down2, br.right) branch

# 'r' is bigger
.cat-left-array-level<a, lower> node<a, lower>
	l a[]
	r node<a, lower>
	cat-left-lower act lower(a[], lower)
spec
	new<lower>
body
	match r
	as leaf xs
		if l.size-bytes + xs.size-bytes <= max-leaf-bytes
			l ~~ xs leaf
		else
			(l, (), xs) branch
	as branch br
		if l.size-bytes + br.left.size-bytes <= max-leaf-bytes
			(l ~~ br.left, br.down, br.right) branch
		else
			(l, cat-left-lower[br.left, br.down], br.right) branch

.cat-right-array-level<a, lower> node<a, lower>
	l node<a, lower>
	r a[]
	cat-right-lower act lower(lower, a[])
spec
	new<lower>
body
	match l
	as leaf xs
		if xs.size-bytes + r.size-bytes <= max-leaf-bytes
			xs ~~ r leaf
		else
			(xs, (), r) branch
	as branch br
		if br.right.size-bytes + r.size-bytes <= max-leaf-bytes
			(br.left, br.down, br.right ~~ r) branch
		else
			(br.left, cat-right-lower[br.down, br.right], r) branch

.cat-left-node-l0<a> l0 a(l l0 a, r l0 a)
	new: l.node cat-left-node-level r.node, ((xs, lower) => (xs,) cat-left-array-l1 lower), (x, y) =>
		x cat-left-node-l1 y

.cat-right-node-l0<a> l0 a(l l0 a, r l0 a)
	new: l.node cat-right-node-level r.node, ((lower, xs) => lower cat-right-array-l1 (xs,)), (x, y) =>
		x cat-right-node-l1 y

.cat-left-array-l0<a> l0 a(l a[], r l0 a)
	new: l cat-left-array-level r.node, (xs, lower) => (xs,) cat-left-array-l1 lower

.cat-right-array-l0<a> l0 a(l l0 a, r a[])
	new: l.node cat-right-array-level r, (lower, xs) => lower cat-right-array-l1 (xs,)

.cat-left-node-l1<a> l1 a(l l1 a, r l1 a)
	new: l.node cat-left-node-level r.node, ((xs, lower) => (xs,) cat-left-array-l2 lower), (x, y) =>
		x cat-left-node-l2 y

.cat-right-node-l1<a> l1 a(l l1 a, r l1 a)
	new: l.node cat-right-node-level r.node, ((lower, xs) => lower cat-right-array-l2 (xs,)), (x, y) =>
		x cat-right-node-l2 y

.cat-left-array-l1<a> l1 a(l a[][], r l1 a)
	new: l cat-left-array-level r.node, (xs, lower) => (xs,) cat-left-array-l2 lower

.cat-right-array-l1<a> l1 a(l l1 a, r a[][])
	new: l.node cat-right-array-level r, (lower, xs) => lower cat-right-array-l2 (xs,)

.cat-left-node-l2<a> l2 a(l l2 a, r l2 a)
	l.nodes ~~ r.nodes,

.cat-right-node-l2<a> l2 a(l l2 a, r l2 a)
	l.nodes ~~ r.nodes,

.cat-left-array-l2<a> l2 a(l a[][][], r l2 a)
	l ~~ r.nodes,

.cat-right-array-l2<a> l2 a(l l2 a, r a[][][])
	l.nodes ~~ r,

# Leaves are allowed to be arbitrarily long, this is just the limit when we would normally make a branch
.max-leaf-bytes nat64()
	64

# 'trusted' since we are just using it to guide branch sizes (which should have no observable effect)
.size-bytes<a> nat64(a a[]) trusted
	a.size * size-of@<a>

region iter and slice


# Immutable iterator over a sequence.
seq-iter<a> record
	seq seq a
	state seq-iter-state a

# New iterator at the beginning of the sequence.
iter<a> seq-iter<a>(a seq a)
	match a.root node
	as leaf xs
		a, xs.l0-right
	as branch b
		a, b.left.l0-left

# Next value and next iterator.
value-and-rest<a> record
	value a
	rest seq-iter<a>

###
Returns the next element and next iterator.
Returns an empty option if the iterator was already at the end of the sequence.
###
next<a> value-and-rest<a>?(a seq-iter a) trusted
	match a state
	as l0-left xs
		rest = if xs.tail is-empty
			a.seq l1-iter
		else
			a.seq, xs.tail.l0-left
		(xs[0], rest),
	as l0-right xs
		unless xs is-empty
			(xs[0], (a.seq, xs.tail.l0-right)),
	as l1-left iter
		rest = if t ?= iter tail
			a.seq, t.l1-left
		else
			a.seq.l2-iter
		(iter.cur, rest),
	as l1-right iter
		rest seq-iter a = if t ?= iter tail
			a.seq, t.l1-right
		else
			a.seq, a.seq.root.node.as-branch.right.l0-right
		(iter.cur, rest),
	as l2 iter
		rest seq-iter a = if t ?= iter tail
			a.seq, t.l2
		else
			a.seq, (a.seq.get-l1.node.as-branch.right,).l1-right
		(iter.cur, rest),

# Mutable iterator over a sequence.
mut-seq-iter<a> record mut
	.inner mut seq-iter a

# Copy to an immutable iterator.
iter<a> seq-iter a(a mut-seq-iter a)
	a.inner

# New mutable iterator at the beginning of the sequence.
mut-iter<a> mut-seq-iter a(a seq a)
	a.iter,

###
Advances the iterator and returns the next element.
Returns an empty option if the iterator was already at the end of the sequence.
###
next<a> a?(a mut-seq-iter a)
	if pair ?= a.inner next
		a.inner := pair rest
		pair.value,

###
Seq of every element to the left of the iterator.
This is O(log n).
###
slice-left<a> seq a(a seq-iter a)
	match a state
	as l0-left xs
		a.seq update-l0-branch b =>
			(b.left get-left-of-1d xs).leaf,
	as l0-right xs
		match a.seq.root node
		as leaf l
			l0 l0 a = (l get-left-of-1d xs).leaf,
			l0,
		as branch b
			(b.left branch-or-leaf-l0 b.down, (b.right get-left-of-1d xs)),
	as l1-left xs
		a.seq slice-left-update-l1 l1 =>
			b = l1.node as-branch
			left a[][] = b left
			(left get-left-of-2d xs) branch-or-leaf-l1 b.down, b.right
	as l1-right xs
		a.seq slice-left-update-l1 l1 =>
			match l1 node
			as leaf leaf
				(leaf get-left-of-2d xs).leaf,
			as branch b
				b.left branch-or-leaf-l1 b.down, (b.right get-left-of-2d xs)
	as l2 xs
		a.seq slice-left-update-l2 l2 =>
			(l2.nodes get-left-of-3d xs),

###
Seq of every element to the right of the iterator.
This is O(log n).
###
slice-right<a> seq a(a seq-iter a)
	match a state
	as l0-left xs
		a.seq update-l0-branch b =>
			xs branch-or-leaf-l0 b.down, b.right
	as l0-right xs
		l0 l0 a = xs.leaf,
		l0,
	as l1-left xs
		a.seq slice-right-update-l1 l1 =>
			b = l1.node as-branch
			xs.to-array branch-or-leaf-l1 b.down, b.right
	as l1-right xs
		a.seq slice-right-update-l1 l1 =>
			match l1 node
			as leaf _
				xs.to-array.leaf,
			as branch b
				b.left branch-or-leaf-l1 b.down, xs.to-array
	as l2 xs
		a.seq slice-right-update-l2 ignore =>
			xs.to-array,

.get-left-of-1d<a> a[](a a[], b a[]) trusted
	hard-assert: a.end-ptr == b.end-ptr
	hard-assert: a.begin-ptr <= b.begin-ptr
	a.begin-ptr arr-from-begin-end b.begin-ptr

.get-left-of-2d<a> a[][](a a[][], b iter2d a)
	left-1d = a get-left-of-1d b.rest
	last-part = left-1d[left-1d.size - 1] get-left-of-1d b.cur-array
	if last-part is-empty
		left-1d rtail
	else
		left-1d.rtail ~ last-part

.get-left-of-3d<a> a[][][](a a[][][], b iter3d a)
	left-2d = a get-left-of-1d b.rest
	last-part = left-2d[left-2d.size - 1] get-left-of-2d b.cur-iter
	if last-part is-empty
		left-2d rtail
	else
		left-2d.rtail ~ last-part

.level<l, a> spec
	is-empty bool(level l)
	pop-left pair<a[], l>(level l)
	pop-right pair<l, a[]>(level l)

.branch-or-leaf-generic<a, lower> node<a, lower>(left a[], down lower, right a[]) trusted level<lower, a>
	if down is-empty
		if left is-empty
			right leaf
		elif right is-empty
			left leaf
		else
			left ~~ right leaf
	else
		hard-forbid: left.is-empty && right.is-empty
		if left is-empty
			pair = down pop-left
			if pair.b is-empty
				pair.a ~~ right leaf
			else
				(pair.a, pair.b, right) branch
		elif right is-empty
			pair = down pop-right
			if pair.a is-empty
				left ~~ pair.b leaf
			else
				(left, pair.a, pair.b) branch
		else
			(left, down, right) branch

.branch-or-leaf-l0<a> l0 a(left a[], down l1 a, right a[])
	(left branch-or-leaf-generic down, right),

.branch-or-leaf-l1<a> l1 a(left a[][], down l2 a, right a[][])
	(left branch-or-leaf-generic down, right),

.pop-left<a> pair<a[], l1 a>(a l1 a)
	match a node
	as leaf xs
		xs[0], (xs.tail.leaf,)
	as branch b
		popped = b.left[0]
		rest l1 a = if b.left.tail is-empty
			if b.down is-empty
				b.right.leaf,
			else
				pair = b.down pop-left
				(pair.a, pair.b, b.right).branch,
		else
			(b.left.tail, b.down, b.right).branch,
		popped, rest

.pop-right<a> pair<l1 a, a[]>(a l1 a)
	match a node
	as leaf xs
		(xs.rtail.leaf,), xs[xs.size - 1]
	as branch b
		popped = b.right[b.right.size - 1]
		rest l1 a = if b.right.rtail is-empty
			if b.down is-empty
				b.left.leaf,
			else
				pair = b.down pop-right
				(b.left, pair.a, pair.b).branch,
		else
			(b.left, b.down, b.right.rtail).branch,
		rest, popped

.pop-left<a> pair<a[][], l2 a>(a l2 a)
	a.nodes[0], (a.nodes.tail,)

.pop-right<a> pair<l2 a, a[][]>(a l2 a)
	(a.nodes.rtail,), a.nodes[a.nodes.size - 1]

.update-l0<a> seq a(a seq a, f act l0 a(l0 a))
	f[a root],

.update-l0-branch<a> seq a(a seq a, f act l0 a(branch<a, l1 a>))
	a update-l0 l0 =>
		f[l0.node as-branch]

.slice-left-update-l1<a> seq a(a seq a, f act l1 a(l1 a))
	old-l0 = a get-l0-branch
	new-l1 = f[old-l0 down]
	(old-l0.left branch-or-leaf-l0 new-l1, ()),

.slice-right-update-l1<a> seq a(a seq a, f act l1 a(l1 a))
	old-l0 = a get-l0-branch
	new-l1 = f[old-l0 down]
	(()::a[] branch-or-leaf-l0 new-l1, old-l0.right),

.slice-left-update-l2<a> seq a(a seq a, f act l2 a(l2 a))
	a slice-left-update-l1 old-l1 =>
		b = old-l1.node as-branch
		new-l2 = f[b down]
		if new-l2 is-empty
			b.left.leaf,
		else
			pair = new-l2 pop-right
			(b.left, pair.a, pair.b).branch,

.slice-right-update-l2<a> seq a(a seq a, f act l2 a(l2 a))
	a slice-right-update-l1 old-l1 =>
		b = old-l1.node as-branch
		new-l2 = f[b down]
		if new-l2 is-empty
			b.right.leaf,
		else
			pair = new-l2 pop-left
			(pair.a, pair.b, b.right).branch,

.seq-iter-state<a> union
	l0-left a[]
	l0-right a[]
	l1-left iter2d a
	l1-right iter2d a
	l2 iter3d a

# Iterator through an a[][].
# This will always be non-empty.
.iter2d<a> record
	by-val
	cur-array a[]
	rest a[][]

.new<a> iter2d a(a a[][])
	a[0], a.tail

.to-array<a> a[][](a iter2d a)
	a.cur-array ~ a.rest

.cur<a> a(a iter2d a)
	a.cur-array[0]

.tail<a> iter2d<a>?(a iter2d a) unsafe
	hard-forbid: a.cur-array is-empty
	if a.cur-array.size == 1
		unless a.rest is-empty
			(a.rest[0], a.rest.tail),
	else
		(a.cur-array.tail, a.rest),

# Iterator through an a[][][]
.iter3d<a> record
	by-val
	cur-iter iter2d a
	rest a[][][]

.new<a> iter3d a(a a[][][])
	(a[0],), a.tail

.to-array<a> a[][][](a iter3d a)
	a.cur-iter.to-array ~ a.rest

.cur<a> a(a iter3d a)
	a.cur-iter.cur

.tail<a> iter3d<a>?(a iter3d a) unsafe
	if t ?= a.cur-iter tail
		(t, a.rest),
	else
		unless a.rest is-empty
			((a.rest[0],), a.rest.tail),

.l1-iter<a> seq-iter a(a seq a)
	a, match a.get-l1 node
	as leaf xs
		if xs is-empty
			a.root.node.as-branch.right l0-right
		else
			(xs,) l1-right
	as branch b
		(b.left,) l1-left

.l2-iter<a> seq-iter a(a seq a)
	a, (a.get-l2.nodes,).l2

region iteration

each<a> void(a seq a, f act void(a))
	() fold a, (ignore, x) => f[x]

fold<a, b> a(acc a, a seq b, f act a(a, b))
	acc fold-chunks a, (cur, chunk) =>
		cur fold chunk, f

some<a> bool(a seq a, f act bool(a))
	v void? = a find-and-get x =>
		if f[x]
			(),
	!v.is-empty

every<a> bool(a seq a, f act bool(a))
	!(a some x => !f[x])

find-and-get<out, in> out?(a seq in, f act out?(in))
	a find-and-get-chunk chunk =>
		chunk find-and-get f

filter<a> seq a(a seq a, f act bool(a))
	a flat-map x =>
		if f[x]
			x,

map<out, in> seq out(a seq in, f act out(in))
	a map-to-arr f to-seq

flat-map<out, in> seq out(a seq in, f act seq out(in))
	res out mut[] = ()
	a each in =>
		f[in] each out =>
			res ~= out
	res.move-to-arr to-seq

.map-to-arr<out, in> out[](a seq in, f act out(in)) trusted
	res fix-arr out = a.size uninitialized-fix-arr
	end = res.begin-ptr fold a, (out, x) =>
		*out := f[x]
		out + 1
	hard-assert: end == res.end-ptr
	res cast-immutable

.fold-chunks<a, b> a(acc a, xs seq b, f act a(a, b[]))
	match xs.root node
	as leaf l
		f[acc, l]
	as branch b
		mid = f[acc, b left] fold-chunks-l1 b.down, f
		f[mid, b right]

.fold-chunks-l1<a, b> a(acc a, xs l1 b, f act a(a, b[]))
	match xs node
	as leaf l
		acc fold l, f
	as branch b
		acc fold b.left, f fold-chunks-l2 b.down, f fold b.right, f

.fold-chunks-l2<a, b> a(acc a, xs l2 b, f act a(a, b[]))
	acc fold xs.nodes, (cur, nodes) =>
		cur fold nodes, f

.find-and-get-chunk<out, in> out?(a seq in, f act out?(in[]))
	match a.root node
	as leaf l
		f[l]
	as branch b
		f[b.left] || b.down find-and-get-chunk-l1 f || f[b.right]

.find-and-get-chunk-l1<out, in> out?(a l1 in, f act out?(in[]))
	match a node
	as leaf l
		l find-and-get f
	as branch b
		b.left find-and-get f || b.down find-and-get-chunk-l2 f || b.right find-and-get f

.find-and-get-chunk-l2<out, in> out?(a l2 in, f act out?(in[]))
	a.nodes find-and-get xs =>
		xs find-and-get f

region test

.dbg<a> str(a seq a) to-str<a>
	out writer = ()
	out dbg-l0 a.root
	out move-to-str

.dbg<a> str(a seq-iter a) trusted to-str<a>
	match a state
	as l0-left xs
		hard-forbid: xs is-empty
		"l0-left at {xs[0]}"
	as l0-right xs
		"l0-right at {xs.is-empty ? "end" : xs[0] to-str}"
	as l1-left iter
		hard-forbid: iter.cur-array is-empty
		"l1-left at {iter.cur-array[0]}"
	as l1-right iter
		hard-forbid: iter.cur-array is-empty
		"l1-right at {iter.cur-array[0]}"
	as l2 xs
		hard-forbid: xs.cur-iter.cur-array is-empty
		"l2 at {xs.cur-iter.cur-array[0]}"

.dbg-l0<a> void(out writer, a l0 a) to-str<a>
	out dbg-node a.node, (x => out dbg-arr x), (x => out dbg-l1 x)

.dbg-l1<a> void(out writer, a l1 a) to-str<a>
	out dbg-node a.node, (x => out dbg-arr2d x), (x => out dbg-l2 x)

.dbg-l2<a> void(out writer, a l2 a) to-str<a>
	out dbg-arr3d a.nodes

.dbg-node<a, lower> void(out writer, a node<a, lower>, dbg-a act void(a[]), dbg-lower act void(lower))
	match a
	as leaf l
		dbg-a[l]
	as branch b
		out ~= "("
		dbg-a[b left]
		out ~= " "
		dbg-lower[b down]
		out ~= " "
		dbg-a[b right]
		out ~= ")"

.dbg-arr<a> void(out writer, a a[]) to-str<a>
	out ~= "["
	unless a is-empty
		a each x =>
			out ~~= x to-str
			out ~= " "
		out backup
	out ~= "]"

.dbg-arr2d<a> void(out writer, a a[][]) to-str<a>
	out ~= "["
	unless a is-empty
		a each x =>
			out dbg-arr x
			out ~= " "
		out backup
	out ~= "]"

.dbg-arr3d<a> void(out writer, a a[][][]) to-str<a>
	out ~= "["
	unless a is-empty
		a each x =>
			out dbg-arr2d x
			out ~= " "
		out backup
	out ~= "]"

.check-structure<a> void(a l0 a) unsafe
	match a node
	as leaf _
		()
	as branch b
		hard-forbid: b.left.is-empty
		hard-forbid: b.right.is-empty
		b.down check-structure 

.check-structure<a> void(a l1 a) unsafe
	match a node
	as leaf _
		()
	as branch b
		b.left check-structure
		b.down check-structure
		b.right check-structure

.check-structure<a> void(xs a[][]) unsafe
	hard-forbid: xs.is-empty
	xs each ys =>
		hard-forbid: ys.is-empty

.check-structure<a> void(a l2 a) unsafe
	a.nodes each ys =>
		hard-forbid: ys.is-empty
		ys each zs =>
			hard-forbid: zs.is-empty

.verify<a> void(a seq a, expected str) trusted to-str<a>
	a.dbg is expected
	a.root check-structure

starts-with<a> bool(a seq a, b seq a) equal<a>
	!(a.iter iter-starts-with b).is-empty

###
`true` iff `b` is a subsequence of `a`.

That means: The characters in `b` appear in `a`, in order, without interruptions.
###
has-subseq<a> bool(a seq a, b seq a) equal<a>
	!(a iters-of-subseq b).is-empty

###
Finds the first apperance of `b` as a subsequence of `a`,
and returns slices of `a` to the left and right of that.

Returns an empty option iff `b` is not a subsequence of `a`.
###
split-on-subseq<a> pair<seq a, seq a>?(a seq a, b seq a) equal<a>
	if pair ?= a iters-of-subseq b
		(pair.a.slice-left, pair.b.slice-right),

.iters-of-subseq<a> pair<seq-iter a, seq-iter a>?(a seq a, b seq a) equal<a>
	a.iter iters-of-subseq-recur b

.iters-of-subseq-recur<a> pair<seq-iter a, seq-iter a>?(a seq-iter a, b seq a) equal<a>
	if end-iter ?= a iter-starts-with b
		(a, end-iter),
	elif n ?= a next
		n.rest iters-of-subseq-recur b

.iter-starts-with<a> seq-iter<a>?(a seq-iter a, b seq a) equal<a>
	iter mut-seq-iter a = a,
	success = b every x =>
		if y ?= iter next
			x == y
	if success
		iter.iter,

test
	a seq nat64 = ()
	b = 1 ~ a
	b verify "[1]"

test
	a seq nat64 = 1, 2, 3, 4, 5, 6, 7, 8
	a verify "[1 2 3 4 5 6 7 8]"
	b = 1 ~ a
	b verify "([1] [] [1 2 3 4 5 6 7 8])"
	c seq nat64 = (8, 7, 6, 5, 4, 3, 2) ~~ b
	c verify "([8 7 6 5 4 3 2 1] [] [1 2 3 4 5 6 7 8])"
	d = 9 ~ c
	d verify "([9] [[8 7 6 5 4 3 2 1]] [1 2 3 4 5 6 7 8])"
	e = d ~~ (1, 2, 3, 4, 5)
	e verify "([9] [[8 7 6 5 4 3 2 1] [1 2 3 4 5 6 7 8]] [1 2 3 4 5])"

test
	a seq nat64 = 1, 2, 3, 4, 5
	a verify "[1 2 3 4 5]"
	b = a ~~ (9, 8, 7, 6)
	b verify "([1 2 3 4 5] [] [9 8 7 6])"
	c = b ~~ b
	s = "[9 8 7 6 1 2 3 4 5]"
	c verify "([1 2 3 4 5] [{s}] [9 8 7 6])"
	d = c ~~ c
	d verify "([1 2 3 4 5] [{s} {s} {s}] [9 8 7 6])"
	e = d ~~ d
	e verify "([1 2 3 4 5] ([{s} {s} {s} {s}] [] [{s} {s} {s}]) [9 8 7 6])"

# use a big type to force smaller leaves for easier testing
.big-nat record
	by-val
	a nat64
	b nat64
	c nat64

.== bool(a big-nat, b big-nat)
	a.a == b.a && a.b == b.b && a.c == b.c

.big big-nat(a nat64)
	a, a, a

.to-str str(a big-nat)
	a.a to-str

.verify<a> void(a seq-iter a, expected str) to-str<a>
	a.dbg is expected

test
	assert: size-of@<big-nat> == 24
	a seq big-nat = 5.big, 6.big
	b seq big-nat = 4.big ~ a
	b verify "([4] [] [5 6])"
	
	iter = b iter
	iter verify "l0-left at 4"
	n0 = iter.next!
	n0.value is 4.big
	iter1 = n0 rest
	iter1 verify "l0-right at 5"
	n1 = iter1.next!
	n1.value is 5.big
	iter2 = n1 rest
	iter2 verify "l0-right at 6"
	n2 = iter2.next!
	n2.value is 6.big
	iter3 = n2 rest
	iter3.next.is-empty is true

	b-split = (b split-on-subseq (5.big,))!
	b-split.a verify "[4]"
	b-split.b verify "[6]"

	c seq big-nat = b ~ 7.big
	c verify "([4] [[5 6]] [7])"

	c-iters = (c iters-of-subseq (5.big,))!
	c-iters.a verify "l1-right at 5"
	c-iters.b verify "l1-right at 6"

	c-split = (c split-on-subseq (5.big,))!
	c-split.a verify "[4]"
	c-split.b verify "[6 7]"

	d seq big-nat = c ~ 8.big ~ 9.big ~ 10.big ~ 11.big
	d verify "([4] [[5 6] [7 8] [9 10]] [11])"

	d-split = (d split-on-subseq (6.big, 7.big))!
	d-split.a verify "[4 5]"
	d-split.b verify "([8] [[9 10]] [11])"

	e seq big-nat = 0.big ~ (1.big ~ (2.big ~ (3.big ~ d)))
	e verify "([0] ([[1 2]] [] [[3 4] [5 6] [7 8] [9 10]]) [11])"
	f seq big-nat = e ~ 12.big ~ 13.big
	f verify "([0] ([[1 2]] [[[3 4] [5 6] [7 8] [9 10]]] [[11 12]]) [13])"

	f-split = (f split-on-subseq (4.big, 5.big))!
	f-split.a verify "([0] [[1 2]] [3])"
	f-split.b verify "([6] ([[7 8] [9 10]] [] [[11 12]]) [13])"
