no-std
import
	../bool: !, &&, bool, false, new, true
	../cell: *, cell, new, set-deref
	../compare: ==, <, <=, compare, comparison, equal, greater, less, min
	../fun-util: subscript
	../misc: new, void
	../number: +, -, *, /, %, ==, <=>, nat8, nat64
	../opt: ??, ||, is-empty, new, opt
	../private/exception-low-level: unreachable
	../private/range-low-level: .., range
	../ptr: ==, +, *, set-deref, size-of
	../tuple: a, b, new, pair
	./array:
		~, ~~, array, array-equal, array-iter, end-iter, iter, find-and-get, fold, for-loop,
		index-of, is-empty, new, next, prev, rtail, size, slice-left, slice-right, subscript, tail
	./mut-array: begin-ptr, cast-immutable, end-ptr, mut-array, uninitialized-mut-array
	./iter: new, rest, value, value-and-rest
	./private/array-builder: ~=, array-builder, finish, new
	./private/array-low-level: array-cast, begin-ptr, end-ptr

###
Immutable list type.

This type is designed so concatenation (`~` and `~~`) will be efficient.
It also is efficient to split from an iterator.

It does not support efficient access by an index, so iterators should be used instead.
###
list<a> record by-val
	.root l0 a

get-root<a> l0 a(a a[]) no-doc
	a.root

# TODO: no-doc
l0<a> record by-val
	node node<a, l1 a>

# TODO: no-doc
l1<a> record by-val
	node node<array a, l2 a>

# TODO: no-doc
l2<a> record by-val
	nodes array array array a

# TODO: no-doc
node<a, lower> union
	leaf array a
	branch branch<a, lower>

###
TODO: no-doc
'left', 'down', and 'right' should all be non-empty.
(Else, this layer should be a leaf. See `branch-or-leaf`.)
###
branch<a, lower> record
	left array a
	down lower
	right array a

.new<a, lower> node<a, lower>()
	() leaf

.new<a> l1 a()
	(),
.new<a> l2 a()
	(),

.is-empty<a> bool(a l1 a)
	match a node
	as leaf xs
		xs is-empty
	as branch _
		false

.is-empty<a> bool(a l2 a)
	a.nodes is-empty

.depth<a> nat64(a a[])
	match a.root.node
	as leaf _
		0
	as branch b
		b.down depth-l1

.depth-l1<a> nat64(a l1 a)
	match a node
	as leaf _
		1
	as branch b
		b.down depth-l2

.depth-l2<a> nat64(_ l2 a)
	2

.as-branch<a, lower> branch<a, lower>(a node<a, lower>) unsafe noctx
	match a
	as leaf _
		unreachable
	as branch b
		b

.try-as-l0-leaf<a> array<a>?(a a[]) noctx
	match a.root node
	as leaf xs
		xs,
	as branch _
		()

.get-l0-branch<a> branch<a, l1 a>(a a[]) unsafe noctx
	a.root.node as-branch

.try-get-l1<a> l1<a>?(a a[]) noctx
	match a.root node
	as leaf _
		()
	as branch b
		b.down,

.get-l1<a> l1 a(a a[]) unsafe noctx
	a.try-get-l1 force

.get-l1-branch<a> branch<array a, l2 a>(a a[]) unsafe noctx
	a.get-l0-branch.down.node as-branch

.get-l2<a> l2 a(a a[]) unsafe noctx
	a.get-l1-branch down

# List containing the given elements.
new<a> a[](...a array a) noctx
	a to-list

###
Convert an array to a list.
This is O(1).
###
to-list<a> a[](a array a) noctx
	l l0 a = a.leaf,
	l,

== bool(a nat8[], b nat8[]) no-doc noctx
	a list-equal b
== bool(a nat64[], b nat64[]) no-doc noctx
	a list-equal b
<=> comparison(a nat8[], b nat8[]) no-doc noctx
	a list-compare b
<=> comparison(a nat64[], b nat64[]) no-doc noctx
	a list-compare b

list-cast<out, in> out[](a in[]) no-doc unsafe
	assert size-of@<out> == size-of@<in>
	# TODO:PERF
	a.to-array.array-cast to-list

list-equal<a> bool(a a[], b a[]) noctx equal<a>
	if la ?= a try-as-l0-leaf
		if lb ?= b try-as-l0-leaf
			la array-equal lb
		else
			a.iter list-equal-recur b.iter
	else
		a.size == b.size && a.iter list-equal-recur b.iter
.list-equal-recur<a> bool(a list-iter a, b list-iter a) noctx equal<a>
	if na ?= a next
		if nb ?= b next
			if na.value == nb.value
				na.rest list-equal-recur nb.rest
	else
		b.next is-empty

list-compare<a> comparison(a a[], b a[]) noctx compare<a>
	a.iter list-compare-recur b.iter
.list-compare-recur<a> comparison(a list-iter a, b list-iter a) noctx compare<a>
	if na ?= a next
		if nb ?= b next
			cmp = na.value <=> nb.value
			if cmp == equal
				na.rest list-compare-recur nb.rest
			else
				cmp
		else
			greater
	else
		b.next.is-empty ? equal : less

###
Convert a list to an array.
This is O(n).
This is O(1) if the list came from to-list of an array, meaning a round trip is free.
###
to-array<a> array a(a a[])
	a.try-as-l0-leaf ?? for x : a; x

###
`true` iff `a.size == 0`.
This is O(1).
###
is-empty<a> bool(a a[]) noctx
	match a.root node
	as leaf xs
		xs is-empty
	as branch _
		false

###
Number of elements in the list.
This is O(n).
###
size<a> nat64(a a[]) noctx
	match a.root node
	as leaf l
		l.size
	as branch b
		b.left.size + b.down.size + b.right.size
.size<a> nat64(a l1 a) noctx
	match a node
	as leaf l
		l.size-2d
	as branch b
		b.left.size-2d + b.down.size + b.right.size-2d
.size<a> nat64(a l2 a) noctx
	a.nodes.size-3d
.size-2d<a> nat64(a array array a) noctx trusted
	cur mut = a begin-ptr
	end = a end-ptr
	res mut = 0
	until cur == end
		res := res + cur->size
		cur := cur + 1
	res

.size-3d<a> nat64(a array array array a) noctx trusted
	cur mut = a begin-ptr
	end = a end-ptr
	res mut = 0
	until cur == end
		res := res + cur->size-2d
		cur := cur + 1
	res

###
Concatenate two lists.
This is O(log n), where `n` is the size of the smaller list.
###
~~<a> a[](a a[], b a[])
	# Concatenate the smaller list onto the bigger one.
	match a.depth <=> b.depth
	as less
		(a.root cat-left-node-l0 b.root),
	as equal
		if a.size < b.size
			(a.root cat-left-node-l0 b.root),
		else
			(a.root cat-right-node-l0 b.root),
	as greater
		(a.root cat-right-node-l0 b.root),

###
Prepend an element to a list.
This is O(log n), amortized O(1).
###
~<a> a[](a a, b a[])
	((a,)::array<a> cat-left-array-l0 b.root),

###
Appendd an element to a list.
This is O(log n), amortized O(1).
###
~<a> a[](a a[], b a)
	(a.root cat-right-array-l0 (b,)),

# 'r' is bigger, add 'l' to the left
.cat-left-node-level<a, lower> node<a, lower>(
	l node<a, lower>,
	r node<a, lower>,
	cat-left-array-lower act lower(array a, lower),
	cat-left-node-lower act lower(lower, lower),
) trusted new<lower>
	match l
	as leaf xs
		xs cat-left-array-level r, cat-left-array-lower
	as branch bl
		match r
		as leaf _
			# 'r' should be bigger
			unreachable
		as branch br
			down1 = cat-left-array-lower[bl.right ~~ br.left, br.down]
			down2 = cat-left-node-lower[bl.down, down1]
			(bl.left, down2, br.right) branch

# 'l' is bigger, add 'r' to right
.cat-right-node-level<a, lower> node<a, lower>(
	l node<a, lower>,
	r node<a, lower>,
	cat-right-array-lower act lower(lower, array a),
	cat-right-node-lower act lower(lower, lower),
) trusted new<lower>
	match r
	as leaf xs
		l cat-right-array-level xs, cat-right-array-lower
	as branch br
		match l
		as leaf _
			# 'l' should be bigger
			unreachable
		as branch bl
			down1 = cat-right-array-lower[bl.down, bl.right ~~ br.left]
			down2 = cat-right-node-lower[down1, br.down]
			(bl.left, down2, br.right) branch

# 'r' is bigger
.cat-left-array-level<a, lower> node<a, lower>(
	l array a,
	r node<a, lower>,
	cat-left-lower act lower(array a, lower),
) new<lower>
	match r
	as leaf xs
		if l.size-bytes + xs.size-bytes <= max-leaf-bytes
			l ~~ xs leaf
		else
			(l, (), xs) branch
	as branch br
		if l.size-bytes + br.left.size-bytes <= max-leaf-bytes
			(l ~~ br.left, br.down, br.right) branch
		else
			(l, cat-left-lower[br.left, br.down], br.right) branch

.cat-right-array-level<a, lower> node<a, lower>(
	l node<a, lower>,
	r array a,
	cat-right-lower act lower(lower, array a),
) new<lower>
	match l
	as leaf xs
		if xs.size-bytes + r.size-bytes <= max-leaf-bytes
			xs ~~ r leaf
		else
			(xs, (), r) branch
	as branch br
		if br.right.size-bytes + r.size-bytes <= max-leaf-bytes
			(br.left, br.down, br.right ~~ r) branch
		else
			(br.left, cat-right-lower[br.down, br.right], r) branch

.cat-left-node-l0<a> l0 a(l l0 a, r l0 a)
	node = l.node cat-left-node-level r.node, ((xs, lower) => (xs,) cat-left-array-l1 lower), (x, y) =>
		x cat-left-node-l1 y
	node,

.cat-right-node-l0<a> l0 a(l l0 a, r l0 a)
	node = l.node cat-right-node-level r.node, ((lower, xs) => lower cat-right-array-l1 (xs,)), (x, y) =>
		x cat-right-node-l1 y
	node,

.cat-left-array-l0<a> l0 a(l array a, r l0 a)
	(l cat-left-array-level r.node, (xs, lower) => (xs,) cat-left-array-l1 lower),

.cat-right-array-l0<a> l0 a(l l0 a, r array a)
	(l.node cat-right-array-level r, (lower, xs) => lower cat-right-array-l1 (xs,)),

.cat-left-node-l1<a> l1 a(l l1 a, r l1 a)
	node = l.node cat-left-node-level r.node, ((xs, lower) => (xs,) cat-left-array-l2 lower), (x, y) =>
		x cat-left-node-l2 y
	node,

.cat-right-node-l1<a> l1 a(l l1 a, r l1 a)
	node = l.node cat-right-node-level r.node, ((lower, xs) => lower cat-right-array-l2 (xs,)), (x, y) =>
		x cat-right-node-l2 y
	node,

.cat-left-array-l1<a> l1 a(l array array a, r l1 a)
	(l cat-left-array-level r.node, (xs, lower) => (xs,) cat-left-array-l2 lower),

.cat-right-array-l1<a> l1 a(l l1 a, r array array a)
	(l.node cat-right-array-level r, (lower, xs) => lower cat-right-array-l2 (xs,)),

.cat-left-node-l2<a> l2 a(l l2 a, r l2 a)
	l.nodes ~~ r.nodes,

.cat-right-node-l2<a> l2 a(l l2 a, r l2 a)
	l.nodes ~~ r.nodes,

.cat-left-array-l2<a> l2 a(l array array array a, r l2 a)
	l ~~ r.nodes,

.cat-right-array-l2<a> l2 a(l l2 a, r array array array a)
	l.nodes ~~ r,

# Leaves are allowed to be arbitrarily long, this is just the limit when we would normally make a branch
.max-leaf-bytes nat64()
	64

# 'trusted' since we are just using it to guide branch sizes (which should have no observable effect)
.size-bytes<a> nat64(a array a) trusted
	a.size * size-of@<a>

region iter and slice

# Immutable iterator over a list.
list-iter<a> record by-val
	.list a[]
	.cur array-3d-iter a
	.pos position

.position enum
	l0-leaf
	l0-left
	l0-right
	l1-leaf
	l1-left
	l1-right
	l2-leaf

# New iterator at the beginning of the list.
iter<a> list-iter<a>(a a[]) noctx
	match a.root node
	as leaf xs
		a, xs.iter.to-iter3d, l0-leaf
	as branch b
		a, b.left.iter.to-iter3d, l0-left

end-iter<a> list-iter<a>(a a[])
	match a.root node
	as leaf xs
		a, xs.end-iter.to-iter3d, l0-leaf
	as branch b
		a, b.right.end-iter.to-iter3d, l0-right

###
Returns the next element and next iterator.
Returns an empty option if the iterator was already at the end of the list.
###
next<a> value-and-rest<a, list-iter a>?(a list-iter a) trusted noctx
	if n ?= a.cur next
		(n.value, (a.list, n.rest, a.pos)),
	elif pair ?= a.list next-position a.pos
		(a.list, pair.a, pair.b) next
.next-position<a> (array-3d-iter a, position)?(a a[], pos position) unsafe noctx
	match pos
	as l0-leaf
		()
	as l0-left
		a.l1-iter,
	as l0-right
		()
	as l1-leaf
		(a.get-l0-branch.right.iter.to-iter3d, l0-right),
	as l1-left
		a.l2-iter,
	as l1-right
		(a.get-l0-branch.right.iter.to-iter3d, l0-right),
	as l2-leaf
		(a.get-l1-branch.right.iter2d.to-iter3d, l1-right),

prev<a> value-and-rest<a, list-iter a>?(a list-iter a) trusted noctx
	if p ?= a.cur prev
		(p.value, (a.list, p.rest, a.pos)),
	elif pair ?= a.list prev-position a.pos
		(a.list, pair.a, pair.b) prev
.prev-position<a> (array-3d-iter a, position)?(a a[], pos position) unsafe noctx
	match pos
	as l0-leaf
		()
	as l0-left
		()
	as l0-right
		a.l1-end-iter,
	as l1-leaf
		(a.get-l0-branch.left.end-iter.to-iter3d, l0-left),
	as l1-left
		(a.get-l0-branch.left.end-iter.to-iter3d, l0-left),
	as l1-right
		a.l2-end-iter,
	as l2-leaf
		(a.get-l1-branch.left.end-iter2d.to-iter3d, l1-left),

# Mutable iterator over a list.
mut-list-iter<a> record mut
	.inner mut list-iter a

# New mutable iterator at the beginning of the list.
mut-iter<a> mut-list-iter a(a a[])
	a.iter,

end-mut-iter<a> mut-list-iter a(a a[])
	a.end-iter,

# Copy to an immutable iterator.
iter<a> list-iter a(a mut-list-iter a)
	a.inner

copy<a> mut-list-iter a(a mut-list-iter a)
	a.inner,

###
Advances the iterator and returns the next element.
Returns an empty option if the iterator was already at the end of the list.
###
next<a> a?(a mut-list-iter a)
	if pair ?= a.inner next
		a.inner := pair rest
		pair.value,

prev<a> a?(a mut-list-iter a)
	if pair ?= a.inner prev
		a.inner := pair rest
		pair.value,

###
Returns the next element without advancing the iterator.
Returns an empty option if the iterator is at the end of the list.
###
peek<a> a?(a mut-list-iter a)
	if pair ?= a.inner next
		pair.value,

groups-of<a> a[][](a a[], group-size nat64)
	forbid group-size == 0 : "group-size can't be 0"
	div = a.size / group-size
	out-size = div * group-size == a.size ? div : div + 1
	for group-index : 0 .. out-size
		start = group-index * group-size
		a[start .. (start + group-size min a.size)]

###
List of every element to the left of the iterator.
This is O(log n).
###
slice-left<a> a[](a list-iter a) trusted
	match a pos
	as l0-leaf
		a.cur.as-1d.slice-left to-list
	as l0-left
		a.cur.as-1d.slice-left to-list
	as l0-right
		b = a.list get-l0-branch
		(b.left branch-or-leaf-l0 b.down, a.cur.as-1d.slice-left),
	as l1-leaf
		a.list slice-left-update-l1 _ =>
			a.cur.as-2d.slice-left.leaf,
	as l1-left
		a.list slice-left-update-l1 l1 =>
			b = l1.node as-branch
			a.cur.as-2d.slice-left branch-or-leaf-l1 b.down, b.right
	as l1-right
		a.list slice-left-update-l1 l1 =>
			b = l1.node as-branch
			b.left branch-or-leaf-l1 b.down, a.cur.as-2d.slice-left
	as l2-leaf
		a.list slice-left-update-l2 _ =>
			a.cur.slice-left,

###
List of every element to the right of the iterator.
This is O(log n).
###
slice-right<a> a[](a list-iter a) trusted
	match a pos
	as l0-leaf
		a.cur.as-1d.slice-right to-list
	as l0-left
		b = a.list get-l0-branch
		(a.cur.as-1d.slice-right branch-or-leaf-l0 b.down, b.right),
	as l0-right
		a.cur.as-1d.slice-right to-list
	as l1-leaf
		a.list slice-right-update-l1 _ =>
			a.cur.as-2d.slice-right.leaf,
	as l1-left
		a.list slice-right-update-l1 l1 =>
			b = l1.node as-branch
			a.cur.as-2d.slice-right branch-or-leaf-l1 b.down, b.right
	as l1-right
		a.list slice-right-update-l1 l1 =>
			b = l1.node as-branch
			b.left branch-or-leaf-l1 b.down, a.cur.as-2d.slice-right
	as l2-leaf
		a.list slice-right-update-l2 _ =>
			a.cur.slice-right,

.level<l, a> spec
	is-empty bool(level l)
	pop-left (array a, l)(level l)
	pop-right (l, array a)(level l)

.branch-or-leaf-generic<a, lower> node<a, lower>(left array a, down lower, right array a) trusted level<lower, a>
	if down is-empty
		if left is-empty
			right leaf
		elif right is-empty
			left leaf
		else
			left ~~ right leaf
	else
		forbid left.is-empty && right.is-empty
		if left is-empty
			pair = down pop-left
			if pair.b is-empty
				pair.a ~~ right leaf
			else
				(pair.a, pair.b, right) branch
		elif right is-empty
			pair = down pop-right
			if pair.a is-empty
				left ~~ pair.b leaf
			else
				(left, pair.a, pair.b) branch
		else
			(left, down, right) branch

.branch-or-leaf-l0<a> l0 a(left array a, down l1 a, right array a)
	(left branch-or-leaf-generic down, right),

.branch-or-leaf-l1<a> l1 a(left array array a, down l2 a, right array array a)
	(left branch-or-leaf-generic down, right),

.pop-left<a> (array a, l1 a)(a l1 a)
	match a node
	as leaf xs
		xs[0], (xs.tail.leaf,)
	as branch b
		popped = b.left[0]
		rest l1 a = if b.left.tail is-empty
			if b.down is-empty
				b.right.leaf,
			else
				pair = b.down pop-left
				(pair.a, pair.b, b.right).branch,
		else
			(b.left.tail, b.down, b.right).branch,
		popped, rest

.pop-right<a> (l1 a, array a)(a l1 a)
	match a node
	as leaf xs
		(xs.rtail.leaf,), xs[xs.size - 1]
	as branch b
		popped = b.right[b.right.size - 1]
		rest l1 a = if b.right.rtail is-empty
			if b.down is-empty
				b.left.leaf,
			else
				pair = b.down pop-right
				(b.left, pair.a, pair.b).branch,
		else
			(b.left, b.down, b.right.rtail).branch,
		rest, popped

.pop-left<a> (array array a, l2 a)(a l2 a)
	a.nodes[0], (a.nodes.tail,)

.pop-right<a> (l2 a, array array a)(a l2 a)
	(a.nodes.rtail,), a.nodes[a.nodes.size - 1]

.slice-left-update-l1<a> a[](a a[], f act l1 a(l1 a)) unsafe
	old-l0 = a get-l0-branch
	new-l1 = f[old-l0 down]
	(old-l0.left branch-or-leaf-l0 new-l1, ()),

.slice-right-update-l1<a> a[](a a[], f act l1 a(l1 a)) unsafe
	old-l0 = a get-l0-branch
	new-l1 = f[old-l0 down]
	(()::array<a> branch-or-leaf-l0 new-l1, old-l0.right),

.slice-left-update-l2<a> a[](a a[], f act l2 a(l2 a)) unsafe
	a slice-left-update-l1 old-l1 =>
		b = old-l1.node as-branch
		new-l2 = f[b down]
		if new-l2 is-empty
			b.left.leaf,
		else
			pair = new-l2 pop-right
			(b.left, pair.a, pair.b).branch,

.slice-right-update-l2<a> a[](a a[], f act l2 a(l2 a)) unsafe
	a slice-right-update-l1 old-l1 =>
		b = old-l1.node as-branch
		new-l2 = f[b down]
		if new-l2 is-empty
			b.right.leaf,
		else
			pair = new-l2 pop-left
			(pair.a, pair.b, b.right).branch,

# Iterator through an array array array a
.array-3d-iter<a> record by-val
	cur-1d array-iter a
	cur-2d array-iter array a
	cur-3d array-iter array array a
.new<a> array-3d-iter a() noctx
	(), (), ()

.as-2d<a> array-2d-iter a(a array-3d-iter a) trusted
	assert a.cur-3d.prev.is-empty && a.cur-3d.next.is-empty
	a.cur-1d, a.cur-2d

.as-1d<a> array-iter a(a array-3d-iter a) trusted
	assert a.cur-2d.prev.is-empty && a.cur-2d.next.is-empty
	assert a.cur-3d.prev.is-empty && a.cur-3d.next.is-empty
	a cur-1d

.to-iter3d<a> array-3d-iter a(a array-iter a) noctx
	a, (), ()

.array-2d-iter<a> record by-val
	cur-1d array-iter a
	cur-2d array-iter array a
.new<a> array-2d-iter a() noctx
	(), ()

.iter2d<a> array-2d-iter a(a array array a) noctx
	if n2 ?= a.iter next
		n2.value.iter, n2.rest

.end-iter2d<a> array-2d-iter a(a array array a) noctx
	if p2 ?= a.end-iter prev
		p2.value.end-iter, p2.rest

.to-iter3d<a> array-3d-iter a(a array-2d-iter a) noctx
	a.cur-1d, a.cur-2d, ()

.iter3d<a> array-3d-iter a(a array array array a) unsafe noctx
	if n3 ?= a.iter next
		n2 = n3.value.iter.next force
		n2.value.iter, n2.rest, n3.rest

.end-iter3d<a> array-3d-iter a(a array array array a) unsafe noctx
	if n3 ?= a.end-iter prev
		n2 = n3.value.end-iter.prev force
		n2.value.end-iter, n2.rest, n3.rest

.next<a> value-and-rest<a, array-3d-iter a>?(a array-3d-iter a) trusted noctx
	if n1 ?= a.cur-1d next
		(n1.value, (n1.rest, a.cur-2d, a.cur-3d)),
	elif n2 ?= a.cur-2d next
		n1 = n2.value.iter.next force
		(n1.value, (n1.rest, n2.rest, a.cur-3d)),
	elif n3 ?= a.cur-3d next
		n2 = n3.value.iter.next force
		n1 = n2.value.iter.next force
		(n1.value, (n1.rest, n2.rest, n3.rest)),

.prev<a> value-and-rest<a, array-3d-iter a>?(a array-3d-iter a) trusted noctx
	if p1 ?= a.cur-1d prev
		(p1.value, (p1.rest, a.cur-2d, a.cur-3d)),
	elif p2 ?= a.cur-2d prev
		p1 = p2.value.end-iter.prev force
		(p1.value, (p1.rest, p2.rest, a.cur-3d)),
	elif p3 ?= a.cur-3d prev
		p2 = p3.value.end-iter.prev force
		p1 = p2.value.end-iter.prev force
		(p1.value, (p1.rest, p2.rest, p3.rest)),

.slice-left<a> array array a(a array-2d-iter a)
	a1 = a.cur-1d slice-left
	a2 = a.cur-2d.slice-left rtail
	a1.is-empty ? a2 : a2 ~ a1

.slice-left<a> array array array a(a array-3d-iter a)
	a1 = a.cur-1d slice-left
	# rtail since 'slice-left' includes the array 'a1' is iterating
	a2 = a.cur-2d.slice-left rtail
	a3 = a.cur-3d.slice-left rtail
	b2 = a1.is-empty ? a2 : a2 ~ a1
	b2.is-empty ? a3 : a3 ~ b2

.slice-right<a> array array a(a array-2d-iter a)
	a1 = a.cur-1d slice-right
	a2 = a.cur-2d slice-right
	a1.is-empty ? a2 : a1 ~ a2

.slice-right<a> array array array a(a array-3d-iter a)
	a1 = a.cur-1d slice-right
	a2 = a.cur-2d slice-right
	a3 = a.cur-3d slice-right
	b2 = a1.is-empty ? a2 : a1 ~ a2
	b2.is-empty ? a3 : b2 ~ a3

.l1-iter<a> (array-3d-iter a, position)(a a[]) unsafe noctx
	match a.get-l1 node
	as leaf xs
		if xs is-empty
			a.get-l0-branch.right.iter.to-iter3d, l0-right
		else
			xs.iter2d.to-iter3d, l1-leaf
	as branch b
		b.left.iter2d.to-iter3d, l1-left

.l1-end-iter<a> (array-3d-iter a, position)(a a[]) unsafe noctx
	match a.get-l1 node
	as leaf xs
		if xs is-empty
			a.get-l0-branch.left.end-iter.to-iter3d, l0-left
		else
			xs.end-iter2d.to-iter3d, l1-leaf
	as branch b
		b.right.end-iter2d.to-iter3d, l1-right

.l2-iter<a> (array-3d-iter a, position)(a a[]) unsafe noctx
	a.get-l2.nodes.iter3d, l2-leaf

.l2-end-iter<a> (array-3d-iter a, position)(a a[]) unsafe noctx
	a.get-l2.nodes.end-iter3d, l2-leaf

region iteration

first<a> a?(a a[])
	if i ?= a.iter next
		i.value,

tail<a> a[](a a[])
	if i ?= a.iter next
		i.rest slice-right

last<a> a?(a a[])
	if i ?= a.end-iter prev
		i.value,

rtail<a> a[](a a[])
	if i ?= a.end-iter prev
		i.rest slice-left

for-loop<a> void(a a[], f act void(a))
	() fold a, (_, x) => f[x]

fold<a, b> a(acc a, a b[], f act a(a, b))
	acc fold-chunks a, (cur, chunk) =>
		cur fold chunk, f

in<a> bool(value a, a a[]) equal<a>
	a some x =>
		x == value

some<a> bool(a a[], f act bool(a))
	v void? = a find-and-get x =>
		if f[x]
			(),
	!v.is-empty

every<a> bool(a a[], f act bool(a))
	!(a some x => !f[x])

find-and-get<out, in> out?(a in[], f act out?(in))
	a find-and-get-chunk chunk =>
		chunk find-and-get f

filter<a> a[](a a[], f act bool(a))
	out array-builder a = ()
	for x : a
		if f[x]
			out ~= x
	out.finish to-list

drop-while<a> a[](a a[], f act bool(a))
	a.iter drop-while-recur f
.drop-while-recur<a> a[](a list-iter a, f act bool(a))
	if n ?= a next
		if f[n value]
			n.rest drop-while-recur f
		else
			a slice-right

drop-right-while<a> a[](a a[], f act bool(a))
	a.end-iter drop-right-while-recur f
.drop-right-while-recur<a> a[](a list-iter a, f act bool(a))
	if p ?= a prev
		if f[p value]
			p.rest drop-right-while-recur f
		else
			a slice-left

for-loop<out, in> out[](a in[], f act out(in))
	a for-loop f to-list

for-loop<out, in> array out(a in[], f act out(in)) trusted
	res mut-array out = a.size uninitialized-mut-array
	end = res.begin-ptr fold a, (out, x) =>
		*out := f[x]
		out + 1
	assert end == res.end-ptr
	res.cast-immutable

flatten<a> a[](a a[][])
	() fold a, (acc, x) => acc ~~ x

join<a> a[](joiner a[], parts a[][])
	first cell bool = true,
	() fold parts, (acc, x) =>
		if *first
			*first := false
			x
		else
			acc ~~ joiner ~~ x

.fold-chunks<a, b> a(acc a, xs b[], f act a(a, array b))
	match xs.root node
	as leaf l
		f[acc, l]
	as branch b
		mid = f[acc, b left] fold-chunks-l1 b.down, f
		f[mid, b right]

.fold-chunks-l1<a, b> a(acc a, xs l1 b, f act a(a, array b))
	match xs node
	as leaf l
		acc fold l, f
	as branch b
		acc fold b.left, f fold-chunks-l2 b.down, f fold b.right, f

.fold-chunks-l2<a, b> a(acc a, xs l2 b, f act a(a, array b))
	acc fold xs.nodes, (cur, nodes) =>
		cur fold nodes, f

.find-and-get-chunk<out, in> out?(a in[], f act out?(array in))
	match a.root node
	as leaf l
		f[l]
	as branch b
		f[b.left] || b.down find-and-get-chunk-l1 f || f[b.right]

.find-and-get-chunk-l1<out, in> out?(a l1 in, f act out?(array in))
	match a node
	as leaf l
		l find-and-get f
	as branch b
		b.left find-and-get f || b.down find-and-get-chunk-l2 f || b.right find-and-get f

.find-and-get-chunk-l2<out, in> out?(a l2 in, f act out?(array in))
	a.nodes find-and-get xs =>
		xs find-and-get f

subscript<a> a(a a[], index nat64)
	# TODO:PERF
	a.to-array[index]

subscript<a> a[](a a[], indices range nat64)
	# TODO:PERF
	a.to-array[indices] to-list

index-of<a> nat64?(a a[], value a) equal<a>
	# TODO:PERF
	a.to-array index-of value

starts-with<a> bool(a a[], b a[]) equal<a>
	!(a.iter iter-starts-with b.iter).is-empty

ends-with<a> bool(a a[], b a[]) equal<a>
	!(a.end-iter iter-ends-with b.end-iter).is-empty

try-remove-start<a> a[]?(a a[], b a[]) equal<a>
	if iter ?= a.iter iter-starts-with b.iter
		iter.slice-right,

try-remove-end<a> a[]?(a a[], b a[]) equal<a>
	if iter ?= a.end-iter iter-ends-with b.end-iter
		iter.slice-left,

###
`true` iff `b` is a sublist of `a`.

That means: The characters in `b` appear in `a`, in order, without interruptions.
###
contains-sublist<a> bool(a a[], b a[]) equal<a>
	!(a iters-of-sublist b).is-empty

# Removes elements from the left while `f` returns true.
strip-left-while<a> a[](a a[], f act bool(a))
	a.iter strip-left-while-recur f
.strip-left-while-recur<a> a[](a list-iter a, f act bool(a))
	if n ?= a next
		if f[n value]
			n.rest strip-left-while-recur f
		else
			a slice-right
strip-right-while<a> a[](a a[], f act bool(a))
	a.end-iter strip-right-while-recur f
.strip-right-while-recur<a> a[](a list-iter a, f act bool(a))
	if n ?= a prev
		if f[n value]
			n.rest strip-right-while-recur f
		else
			a slice-left

split-list<a> record
	left a[]
	middle a
	right a[]

try-split-once-by-fn<a> split-list<a>?(a a[], f act bool(a)) equal<a>
	a.iter try-split-once-by-fn-recur f
.try-split-once-by-fn-recur<a> split-list<a>?(a list-iter a, f act bool(a))
	if n ?= a next
		if f[n value]
			(a.slice-left, n.value, n.rest.slice-right),
		else
			n.rest try-split-once-by-fn-recur f

###
Finds the first apperance of `b` as a sublist of `a`,
and returns slices of `a` to the left and right of that.

Returns an empty option iff `b` is not a sublist of `a`.
###
try-split-once-by-sublist<a> (a[], a[])?(a a[], b a[]) equal<a>
	forbid b is-empty : "can't split by empty list"
	if pair ?= a iters-of-sublist b
		(pair.a.slice-left, pair.b.slice-right),

try-split-once-by-sublist-right<a> (a[], a[])?(a a[], b a[]) equal<a>
	forbid b is-empty : "can't split by empty list"
	if pair ?= a iters-of-sublist-right b
		(pair.a.slice-left, pair.b.slice-right),

split-by-sublist<a> a[][](a a[], b a[]) equal<a>
	if pair ?= a try-split-once-by-sublist b
		pair.a ~ (pair.b split-by-sublist b)
	else
		a,

.iters-of-sublist<a> (list-iter a, list-iter a)?(a a[], b a[]) equal<a>
	a.iter iters-of-sublist-recur b
.iters-of-sublist-recur<a> (list-iter a, list-iter a)?(a list-iter a, b a[]) equal<a>
	if end-iter ?= a iter-starts-with b.iter
		(a, end-iter),
	elif n ?= a next
		n.rest iters-of-sublist-recur b

.iters-of-sublist-right<a> (list-iter a, list-iter a)?(a a[], b a[]) equal<a>
	a.end-iter iters-of-sublist-right-recur b
.iters-of-sublist-right-recur<a> (list-iter a, list-iter a)?(a list-iter a, b a[]) equal<a>
	if start-iter ?= a iter-ends-with b.end-iter
		(start-iter, a),
	elif p ?= a prev
		p.rest iters-of-sublist-right-recur b

.iter-starts-with<a> list-iter<a>?(a list-iter a, b list-iter a) equal<a>
	if bn ?= b next
		if an ?= a next
			if an.value == bn.value
				an.rest iter-starts-with bn.rest
	else
		a,

.iter-ends-with<a> list-iter<a>?(a list-iter a, b list-iter a) equal<a>
	if bp ?= b prev
		if ap ?= a prev
			if ap.value == bp.value
				ap.rest iter-ends-with bp.rest
	else
		a,

# Concatenate `n` copies of `a`.
repeat<a> a[](a a[], n nat64)
	for i : 0 .. a.size * n
		a[i % a.size]

reverse<a> a[](a a[])
	for i : 0 .. a.size
		a[a.size - 1 - i]

.force<a> a(a a?) unsafe noctx
	if x ?= a
		x
	else
		unreachable

.for-loop<out> out[](a range nat64, f act out(nat64))
	a for-loop f to-list
