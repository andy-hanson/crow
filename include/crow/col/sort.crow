no-std
import
	../bool: !
	../compare: ==, !=, <, <=, >, compare, comparison, equal, less
	../exception: assert, forbid
	../fun-util: subscript
	../misc: void
	../number: ==, <=>, +, -, /, nat64
	../ptr: ==, +, -, *, mut-ptr, set-deref
	../range: ..
	../str: ==, <=>, chars, str
	../test-util: is
	./arr: ==, arr, new, subscript
	./fix-arr:
		arr, begin-ptr, cast-immutable, end-ptr, is-empty, fix-arr, new, size, set-subscript,
		subscript, to-fix-arr
	./mut-arr: mut-arr, temp-as-fix-arr

###
Returns a new array containing the same elements as `a`, but in sorted order.
That means `res[i] <= res[i + 1]` for each element in the result.
###
sort<a> a[](a a[]) compare<a>
	a sort (x, y) => x <=> y
sort<a> a[](a a[], comparer act comparison(a, a)) trusted
	res = a to-fix-arr
	res sort! comparer
	res cast-immutable
sort-by<a, b> a[](a a[], f act b(a)) compare<b>
	a sort (x, y) => f[x] <=> f[y]

# TODO: try https://github.com/BonzaiThePenguin/WikiSort

###
Sort and remove duplicates.
That means `res[i] < res[i + 1]` for each element in the result.
`[2, 1, 2] sort-unique` is `[1, 2]`.
###
sort-unique<a> a[](a a[]) compare<a> trusted
	a.to-fix-arr.sort-unique! cast-immutable

test
	()::nat64[].sort is ()
	(3, 1, 2)::nat64[].sort is (1, 2, 3)

	# Test that it's a stable sort
	arr fix-arr str = "2a", "2b", "1a", "1b"
	arr sort! (x, y) => x.chars[0] <=> y.chars[0]
	arr.arr is ("1a", "1b", "2a", "2b")

# Sort a mut-arr in place.
sort<a> void(a a mut[]) compare<a> trusted
	a.temp-as-fix-arr sort!
sort<a> void(a a mut[], comparer act comparison(a, a)) trusted
	a.temp-as-fix-arr sort! comparer
sort-by!<a, b> void(a a mut[], f act b(a)) compare<b> trusted
	a.temp-as-fix-arr sort-by! f

# Sort a fix-arr in place.
sort!<a> void(a fix-arr a) compare<a>
	a sort! (x, y) => x <=> y
sort!<a> void(a fix-arr a, comparer act comparison(a, a)) trusted
	if !a.is-empty
		a.begin-ptr insertion-sort-recur! a.begin-ptr + 1, a.end-ptr, comparer
sort-by!<a, b> void(a fix-arr a, f act b(a)) compare<b>
	a sort! (x, y) => f[x] <=> f[y]

.insertion-sort-recur!<a> void(begin a mut*, cur a mut*, end a mut*, comparer act comparison(a, a)) unsafe
	if cur != end
		begin insert! cur, *cur, comparer
		begin insertion-sort-recur! cur + 1, end, comparer

.insert!<a> void(begin a mut*, cur a mut*, value a, comparer act comparison(a, a)) unsafe
	forbid: begin == cur
	prev = cur - 1
	if comparer[value, *prev] == less
		*cur := *prev
		if begin == prev
			*prev := value
		else
			begin insert! prev, value, comparer
	else
		*cur := value

# Sort a mut-arr in place, remove unique elements, and return the (now shorter) fix-arr.
sort-unique!<a> fix-arr a(a fix-arr a) compare<a>
	a sort-unique! (x, y) => x <=> y
sort-unique!<a> fix-arr a(a fix-arr a, comparer act comparison(a, a)) trusted
	if a is-empty
		a
	else
		a sort! comparer
		end = *a.begin-ptr unique-recur! a.begin-ptr + 1, a.begin-ptr + 1, a.end-ptr, comparer
		a[0 .. end - a.begin-ptr]
sort-unique-by!<a, b> fix-arr a(a fix-arr a, f act b(a)) compare<b>
	a sort-unique! (x, y) => f[x] <=> f[y]
.unique-recur!<a> a mut*
	prev a
	read a mut*
	write a mut*
	end a mut*
	comparer act comparison(a, a)
spec
	unsafe
body
	if read == end
		write
	else
		here = *read
		if comparer[here, prev] == equal
			prev unique-recur! read + 1, write, end, comparer
		else
			*write := here
			here unique-recur! read + 1, write + 1, end, comparer

.swap<a> void(a fix-arr a, x nat64, y nat64)
	old-x = a[x]
	a[x] := a[y]
	a[y] := old-x

sorted-by-first<a, b> record
	a a[]
	b b[]

# Sort `a`, and apply the same permutation to `b`.
sort-by-first<a, b> sorted-by-first<a, b>(a a[], b b[]) compare<a> trusted
	mut-a = a to-fix-arr
	mut-b = b to-fix-arr
	mut-a sort-by-first! mut-b
	mut-a.cast-immutable, mut-b.cast-immutable

# Sort `a` in place, and apply the same permutation to `b` in place.
sort-by-first!<a, b> void(a a mut[], b b mut[]) compare<a> trusted
	a.temp-as-fix-arr sort-by-first! b.temp-as-fix-arr

# Sort `a` in place, and apply the same permutation to `b` in place.
sort-by-first!<a, b> void(a fix-arr a, b fix-arr b) compare<a>
	assert: a.size == b.size
	if a.size > 1
		a swap 0, a.size / 2
		pivot = a[0]
		new-pivot-index = (a partition-by-first! b, pivot, 1, a.size - 1) - 1
		a swap 0, new-pivot-index
		b swap 0, new-pivot-index
		a[0 .. new-pivot-index] sort-by-first! b[0 .. new-pivot-index]
		a[new-pivot-index + 1 .. a.size] sort-by-first! b[new-pivot-index + 1 .. b.size]

.partition-by-first!<a, b> nat64(a fix-arr a, b fix-arr b, pivot a, l nat64, r nat64) compare<a>
	assert: l <= a.size
	assert: r < a.size
	if l <= r
		if a[l] < pivot
			a partition-by-first! b, pivot, (l + 1), r
		else
			a swap l, r
			b swap l, r
			a partition-by-first! b, pivot, l, r - 1
	else
		l
