no-std
import
	../bool: ||
	../compare: !=, <, <=, >, compare
	../fun-util: subscript
	../json: json
	../misc: new, void
	../number: ==, <=>, +, -, /, nat64
	../option: !
	../range: .., for-loop, reverse
	../string: ==, <=>, end-iter, iter, literal, next, prev, slice-left, slice-right, string
	../test-util: is
	./array: ==, new
	./mut-array:
		cast-immutable, for-loop, is-empty, mut-array, new, size, set-subscript, subscript,
		to-array, to-mut-array
	./iter: rest
	./list: ==, list, new, to-array, to-list
	./mut-list: mut-list, set-reverse, temp-as-mut-array

###
Sorts the elements of `a` from least to greatest.

The result satisfies `res[i] <= res[i + 1]`.
###
sort[t] t[](a t[]) t compare
	a sort x => x
###
Same as `sort`, but use `get-key` to get the comparable part of each element.
###
sort[t, k] t[](a t[], get-key fun k(t)) trusted, k compare
	res = a.to-array to-mut-array
	res set-sort get-key
	res.cast-immutable to-list

###
Sort and remove duplicates.
That means `res[i] < res[i + 1]` for each element in the result.
`(2, 1, 2) sort-unique` is `1, 2`.
###
sort-unique[t] t[](a t[]) trusted, t compare
	a.to-array.to-mut-array.set-sort-unique.cast-immutable to-list

test
	()::nat64[].sort is ()
	(3, 1, 2)::nat64[].sort is (1, 2, 3)

	# Test that it's a stable sort
	arr string mut-array = "2a", "2b", "1a", "1b"
	arr.sort := x => x.first-char
	arr.to-array is ("1a", "1b", "2a", "2b")
	arr.sort := x => x.last-char
	arr.to-array is ("1a", "2a", "1b", "2b")

.first-char string(a string)
	a.iter.next!.rest slice-left
.last-char string(a string)
	# TODO: this should not be so complicated
	a.end-iter.prev!.rest slice-right

# Sort the elements of `a` from least to greatest.
set-sort[t] void(a t mut[]) trusted, t compare
	a set-sort x => x
# Like `set-sort`, but use `get-key` to get the comparable part of each element.
set-sort[t, k] void(a t mut[], get-key fun k(t)) trusted, k compare
	a.temp-as-mut-array set-sort get-key
set-sort-reverse[t] void(a t mut[]) t compare
	a set-sort-reverse x => x
set-sort-reverse[t, k] void(a t mut[], get-key fun k(t)) k compare
	a set-sort get-key
	a set-reverse

set-sort[t] void(a t mut-array) t compare
	a set-sort x => x
set-sort[t, k] void(a t mut-array, get-key fun k(t)) k compare
	# TODO: PERF Try https://github.com/BonzaiThePenguin/WikiSort
	# Given that a subarray is sorted, add one more element in sorted order
	unless a is-empty
		for i : 1 .. a.size + 1
			a[0 .. i] move-last-sorted get-key
.move-last-sorted[t, k] void(a t mut-array, get-key fun k(t)) k compare
	for i : 1 .. a.size reverse
		if get-key[a[i - 1]] > get-key[a[i]]
			a swap i, i - 1

###
Sort `a` in place and remove unique elements.
Returns is a slice of the original `a`, which will be shorter if non-unique elements were removed.
###
.set-sort-unique[t] t mut-array(a t mut-array) t compare
	a set-sort
	out-i mut = 0
	for x, i : a
		if i == a.size - 1 || x != a[i + 1]
			a[out-i] := x
			out-i := out-i + 1
	a[0 .. out-i]

.swap[t] void(a t mut-array, x nat64, y nat64)
	old-x = a[x]
	a[x] := a[y]
	a[y] := old-x

sorted-by-first[t, u] record
	a t[]
	b u[]

###
Sort `a`, and move elements of `b` in the same permutation as `a`.

This is useful if `a` and `b` are parallel arrays, meaning `a[i]` and `b[i]` belong together.

Every pair `a[i]` and `b[i]`, will move to `res.a[j]` and `res.b[j]` for some `j`.
###
sort-by-first[t, u] (t, u) sorted-by-first(a t[], b u[]) trusted, t compare
	mut-a = a.to-array to-mut-array
	mut-b = b.to-array to-mut-array
	mut-a set-sort-by-first mut-b
	mut-a.cast-immutable.to-list, mut-b.cast-immutable.to-list

# Sort `a` in place, and move elements of `b` in the same permutation as `a`.
set-sort-by-first[t, u] void(a t mut[], b u mut[]) trusted, t compare
	a.temp-as-mut-array set-sort-by-first b.temp-as-mut-array

# Sort `a` in place, and move elements of `b` in the same permutation as `a`.
set-sort-by-first[t, u] void(a t mut-array, b u mut-array) t compare
	assert a.size == b.size
	if a.size > 1
		a swap 0, a.size / 2
		pivot = a[0]
		new-pivot-index = (a set-partition-by-first b, pivot, 1, a.size - 1) - 1
		a swap 0, new-pivot-index
		b swap 0, new-pivot-index
		a[0 .. new-pivot-index] set-sort-by-first b[0 .. new-pivot-index]
		a[new-pivot-index + 1 .. a.size] set-sort-by-first b[new-pivot-index + 1 .. b.size]

.set-partition-by-first[t, u] nat64(a t mut-array, b u mut-array, pivot t, l nat64, r nat64) t compare
	assert l <= a.size
	assert r < a.size
	if l <= r
		if a[l] < pivot
			a set-partition-by-first b, pivot, (l + 1), r
		else
			a swap l, r
			b swap l, r
			a set-partition-by-first b, pivot, l, r - 1
	else
		l
