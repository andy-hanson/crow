no-std
import
	./bool: !, bool
	./cell: *, cell, new, set-deref
	./col/array-util: for-loop
	./col/list: list, to-list
	./col/private/array-low-level: array-from-begin-end
	./fun-util: subscript
	./misc: new, void
	./number: ==, +, -, nat64
	./opt: is-empty, new, opt
	./private/alloc: alloc-uninitialized
	./ptr: ==, +, as-const, mut-ptr, set-deref
export
	./private/range-low-level: .., low, high, range, size

to-list nat64[](a range nat64)
	for x : a
		x

region iteration

is-empty bool(a range nat64) noctx
	a.low == a.high

# Calls `f` for each value in the range, from `a.low` to `a.high - 1`.
for-loop void(a range nat64, f act void(nat64))
	cur mut = a low
	high = a high
	until cur == high
		f[cur]
		cur := cur + 1

range-reverse<a> record
	low a
	high a

is-empty bool(a range-reverse nat64) noctx
	a.low == a.high

reverse<a> range-reverse a(a range a)
	a.low, a.high

# Calls `f` for each value in the range, from `a.high - 1` to `a.low`.
for-loop void(a range-reverse nat64, f act void(nat64))
	unless a is-empty
		low = a low
		cur mut = a.high - 1
		loop
			f[cur]
			if cur == low
				break
			else
				cur := cur - 1
				continue

for-loop<out> out[](a range-reverse nat64, f act out(nat64)) trusted
	size = a.high - a.low
	out out mut* = size alloc-uninitialized
	cur cell out mut* = out,
	for x : a
		*(*cur) := f[x]
		*cur := *cur + 1
	end = out + size
	assert *cur == end
	out.as-const array-from-begin-end end.as-const to-list

for-loop<out> out[](a range nat64, f act out(nat64)) trusted
	a for-loop f to-list

# `true` iff `f` is `true` for some value in the range.
exists bool(a range nat64, f act bool(nat64))
	!(a find f is-empty)

# Returns the first value in the range for which `f` returns true.
find nat64?(a range nat64, f act bool(nat64))
	cur mut = a low
	high = a high
	loop
		if cur == high
			break
		elif f[cur]
			break cur,
		else
			cur := cur + 1
			continue
