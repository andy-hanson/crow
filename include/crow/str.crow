###
More string functions are in `crow/str-conv` and `crow/str-util`.
Also, `crow/reader` is useful for parsing strings, and `crow-writer` is useful for generating strings.
###

no-std
import
	./bool: bool
	./compare: comparison
	./col/arr: ~, ~~, arr, arr-compare, arr-equal, is-empty, size
	./col/private/arr-low-level: arr-from-begin-end
	./private/bootstrap: new
	./private/number-low-level: ==, <=>, nat64
	./private/c-str-util: find-c-str-end
export
	./private/bootstrap: char, chars, c-str, str, to-char, to-nat8

###
Treat an array of characters as a string.
This is O(1).
###
str str(a char[]) noctx
	a,

literal str(a c-str) noctx trusted
	a arr-from-begin-end a.find-c-str-end str

# Same as `""`.
new str() noctx
	""

###
Concatenate two strings.
This is O(n).

If you need to concatenate many strings, consider using the `crow/writer` module.
###
~~ str(a str, b str)
	a.chars ~~ b.chars,

~ str(a char, b str)
	a ~ b.chars,

~ str(a str, b char)
	a.chars ~ b,

# Same as `a == ""`.
is-empty bool(a str) noctx
	a.chars is-empty

###
Number of bytes in the UTF-8 representation of `a`.
This is O(1).
###
size-bytes nat64(a str) noctx
	a.chars size

== bool(a str, b str) trusted noctx
	a.chars arr-equal b.chars
== bool(a char, b char) noctx
	a.to-nat8 == b.to-nat8

<=> comparison(a str, b str) trusted noctx
	a.chars arr-compare b.chars
<=> comparison(a char, b char) noctx
	a.to-nat8 <=> b.to-nat8

# TODO: this should be generic on all arrs
== bool(a char[], b char[]) no-doc noctx
	a arr-equal b
== bool(a str[], b str[]) no-doc noctx
	a arr-equal b
