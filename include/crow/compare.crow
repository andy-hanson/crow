###
Functions for comparison.

If you want a type to be comparable, just define `==` and `<=>`.
Use the signatures defined in the `compare` spec.

Other functions like `!=` are defined here, derived from those.
###

no-std
import
	./private/bool-low-level: bool, false, not, true

###
Result of comparison.

If `a <=> b` is `equal`, then any function on `a` should return ths same result as a on `b`.
###
!comparison enum
	less
	equal
	greater

!equal[t] spec
	== bool(a t, b t)

###
When defined for mutable values, this should compare their content without regard to mutablility;
so it may consider values equal that may not be equal in the future.
###
!compare[t] spec t equal
	# This should return `equal` iff `==` would return `true`.
	<=> comparison(a t, b t)

# True iff `!(a == b)`.
!!=[t] bool(a t, b t) noctx, t equal
	!(a == b)

# True iff `(a <=> b) == less`.
!<[t] bool(a t, b t) noctx, t compare
	match a <=> b
	as less
		true
	as equal
		false
	as greater
		false

# True iff `(a <=> b) != greater`.
!<=[t] bool(a t, b t) noctx, t compare
	!(b < a)

# True iff `(a <=> b) == greater`.
!>[t] bool(a t, b t) noctx, t compare
	b < a

# True iff `(a <=> b) != less`.
!>=[t] bool(a t, b t) noctx, t compare
	!(a < b)

###
Returns the lesser argument.

Returns `b` if they are equal.
###
!min[t] t(a t, b t) noctx, t compare
	a < b ? a : b

###
Returns the greater argument.

Returns `b` if they are equal.
###
!max[t] t(a t, b t) noctx, t compare
	a > b ? a : b

# Wraps a value and reverses comparison (so less becomes greater and vice versa)
!compare-reverse[t] record by-val
	.inner t
!compare-reverse[t] t compare-reverse(a t) noctx
	a,
!==[t] bool(a t compare-reverse, b t compare-reverse) t equal, noctx
	a.inner == b.inner
!<=>[t] comparison(a t compare-reverse, b t compare-reverse) t compare, noctx
	match a.inner <=> b.inner
	as less
		greater
	as equal
		equal
	as greater
		less
