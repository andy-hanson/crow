no-std
import
	./bool: bool, false, new, true
	./compare: compare, comparison, equal, greater, less
	./number: nat64, new
	./private/bootstrap: none, some
export
	./private/bootstrap: option

# Empty option.
+new[t] t?() bare
	none

# Option containing `a`.
+new[t] t?(a t) bare
	a some

+==[t] bool(a t?, b t?) bare, t equal
	if va ?= a
		if vb ?= b
			va == vb
	else
		b is-empty

+<=>[t] comparison(a t?, b t?) bare, t compare
	if va ?= a
		if vb ?= b
			va <=> vb
		else
			greater
	elif _ ?= b
		less
	else
		equal

# True iff `a` is an empty option.
+is-empty[t] bool(a t?) bare
	if _ ?= a
		false
	else
		true

# 1 if `a` has a value, else 0.
+size[t] nat64(a t?) bare
	unless a is-empty
		1

###
Lazily-evaluated.
If `a` is non-empty, returns it and does not evaluate `b`.
Else, returns `b`.
###
+||[t] t?(a t?, b t?) builtin, bare

###
Lazily-evaluated.
If `a` is non-empty, returns its value and does not evaluate `b`.
Else, returns `b`.
###
+??[t] t(a t?, default t) builtin, bare

###
Called like 'a!'
If `a` is non-empty, returns its value; else throws.
###
+force[t] t(a t?) bare
	a ?? throw "tried to force empty option"
