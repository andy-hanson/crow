no-std
import
	../bool: !, &&, bool
	../col/mut-array: fill, mut-array, in, set-subscript, unmanaged-uninitialized-mut-array
	../compare: <, <=
	../io/private/time-low-level: timestamp
	../misc: new, void
	../number: ==, <=>, max-nat64, nat64
	../option: is-empty, new, option
	../pointer: by-val, ref-cast, zeroed
	./bootstrap: hard-unreachable, first, last, new, next, set-next, time
export
	./bootstrap: action, exclusion, task, task-list, task-node, task-node-with-time

# WARN: `task-queue` is not thread-safe; acquire `tasks-lock` on `global-ctx` first.

task-queue record mut by-ref
	# sorted by time
	# TODO: use a heap
	# First node is an ignored sentinel.
	.timed-sentinel-val .mut task-node-with-time by-val
	.non-timed-sentinel-val .mut task-node by-val
	.non-timed-last .mut task-node
	# This is allocated with max-threads capacity on init, so never needs further allocation
	.currently-running-exclusions exclusion mut-array

.nil-exclusion exclusion() noctx
	max-nat64

.timed-sentinel task-node-with-time(a task-queue) noctx
	trusted &a.timed-sentinel-val

.non-timed-sentinel task-node(a task-queue) noctx
	trusted &a.non-timed-sentinel-val

is-empty bool(a task-queue) noctx
	a.timed-sentinel.next.is-empty && a.non-timed-sentinel.next.is-empty

uninit task-queue by-val(max-threads nat64) noctx, unsafe
	timed-sentinel task-node-with-time by-val = (0, () => hard-unreachable), (), 0
	non-timed-sentinel task-node by-val = (0, () => hard-unreachable), ()
	timed-sentinel, non-timed-sentinel, zeroed, max-threads.unmanaged-uninitialized-mut-array

init void(a task-queue) noctx, unsafe
	a.non-timed-last := a non-timed-sentinel
	a.currently-running-exclusions fill nil-exclusion

# Expose construction of nodes, because it's better to do this outside of a lock
new task-node(task task)
	task, ()

pop-task-result union mut
	task task
	no-task no-task

no-task record by-val
	# True if there any tasks exist (whether timed or not).
	any-tasks bool
	# If any timed tasks exists, this is the time of the first one.
	first-task-time timestamp?

# Caller should call 'return-task' after running the task
pop-task pop-task-result(a task-queue, cur-time timestamp, thread-id nat64) noctx, unsafe
	a move-timed-tasks cur-time
	exclusions = a currently-running-exclusions
	task = a try-pop-task exclusions
	if t ?= task
		exclusions[thread-id] := t exclusion
		t task
	else
		first-task-time timestamp? = if head ?= a.timed-sentinel next
			head.time,
		(!a.is-empty, first-task-time) no-task

# Move timed tasks to the non-timed queue if they are ready
.move-timed-tasks void(a task-queue, cur-time timestamp) noctx
	if head ?= a.timed-sentinel.next
		if head.time <= cur-time
			a.timed-sentinel.next := head next
			head.next := ()
			a add-task head.as-task-node
			a move-timed-tasks cur-time

.as-task-node task-node(a task-node-with-time) noctx
	trusted a ref-cast

.try-pop-task task?(a task-queue, exclusions exclusion mut-array) noctx, unsafe
	prev mut = a non-timed-sentinel
	loop
		if cur ?= prev next
			task task = cur task
			if task.exclusion in exclusions
				prev := cur
				continue
			else
				prev.next := cur next
				if prev.next is-empty
					a.non-timed-last := prev
				break task,
		else
			break

return-task void(a task-queue, _ task, thread-index nat64) noctx, unsafe
	a.currently-running-exclusions[thread-index] := nil-exclusion

add-timed-task void(a task-queue, task task-node-with-time) noctx, unsafe
	# TODO: use a heap
	prev mut = a timed-sentinel
	loop
		if cur ?= prev next
			if task.time < cur.time
				prev.next := task,
				task.next := cur,
				break
			else
				prev := cur
				continue
		else
			prev.next := task,
			break

add-task void(a task-queue, task task-node) noctx
	a.non-timed-last.next := task,
	a.non-timed-last := task

add-tasks void(a task-queue, tasks task-list) noctx
	a.non-timed-last.next := tasks.first,
	a.non-timed-last := tasks last
