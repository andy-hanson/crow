no-std
import
	../bool: !, &&, bool
	../col/mut-arr:
		in, mut-arr, mut-arr-by-val-with-capacity-from-unmanaged-memory,
		noctx-must-remove-unordered, push-capacity-must-be-sufficient
	../compare: <, <=
	../io/private/time-low-level: timestamp
	../misc: new, void
	../opt: is-empty, new, opt
	../ptr: by-val, ref-cast, ref-of-val, zeroed
	./bootstrap: hard-unreachable, first, last, new, next, set-next, time
	./number-low-level: ==, <=>, nat64
export
	./bootstrap: action, exclusion, task, task-list, task-node, task-node-with-time

# WARN: `task-queue` is not thread-safe; acquire `tasks-lock` on `global-ctx` first.

task-queue record mut
	# sorted by time
	# TODO: use a heap
	# First node is an ignored sentinel.
	.timed-sentinel-val by-val<task-node-with-time>
	.non-timed-sentinel-val by-val<task-node>
	.non-timed-last .mut task-node
	# This is allocated with max-threads capacity on init, so never needs further allocation
	.currently-running-exclusions by-val<exclusion mut[]>

.timed-sentinel task-node-with-time(a task-queue) noctx trusted
	a.timed-sentinel-val ref-of-val

.non-timed-sentinel task-node(a task-queue) noctx trusted
	a.non-timed-sentinel-val ref-of-val

is-empty bool(a task-queue) noctx
	a.timed-sentinel.next.is-empty && a.non-timed-sentinel.next.is-empty

uninit by-val task-queue(max-threads nat64) noctx unsafe
	timed-sentinel by-val task-node-with-time = (0, () => hard-unreachable), (), 0
	non-timed-sentinel by-val task-node = (0, () => hard-unreachable), ()
	timed-sentinel, non-timed-sentinel, zeroed, max-threads.mut-arr-by-val-with-capacity-from-unmanaged-memory

init void(a task-queue) noctx unsafe
	a.non-timed-last := a non-timed-sentinel

# Expose construction of nodes, because it's better to do this outside of a lock
new task-node(task task)
	task, ()

pop-task-result union mut
	task task
	no-task no-task

no-task record
	by-val
	# True if there any tasks exist (whether timed or not).
	any-tasks bool
	# If any timed tasks exists, this is the time of the first one.
	first-task-time timestamp?

# Caller should call 'return-task' after running the task
pop-task pop-task-result(a task-queue, cur-time timestamp) noctx unsafe
	a move-timed-tasks cur-time
	exclusions = a.currently-running-exclusions ref-of-val
	task = a try-pop-task exclusions
	if t ?= task
		exclusions push-capacity-must-be-sufficient t.exclusion
		t task
	else
		first-task-time timestamp? = if head ?= a.timed-sentinel next
			head.time,
		(!a.is-empty, first-task-time) no-task

# Move timed tasks to the non-timed queue if they are ready
.move-timed-tasks void(a task-queue, cur-time timestamp) noctx
	if head ?= a.timed-sentinel.next
		if head.time <= cur-time
			a.timed-sentinel.next := head next
			head.next := ()
			a add-task head.as-task-node
			a move-timed-tasks cur-time

.as-task-node task-node(a task-node-with-time) noctx trusted
	a ref-cast

.try-pop-task task?(a task-queue, exclusions exclusion mut[]) noctx unsafe
	a try-pop-task-recur a.non-timed-sentinel, exclusions

.try-pop-task-recur task?(a task-queue, prev task-node, exclusions exclusion mut[]) noctx unsafe
	if cur ?= prev next
		task task = cur task
		if task.exclusion in exclusions
			a try-pop-task-recur cur, exclusions
		else
			prev.next := cur next
			if prev.next is-empty
				a.non-timed-last := prev
			task,

return-task void(a task-queue, task task) noctx unsafe
	a.currently-running-exclusions.ref-of-val noctx-must-remove-unordered task.exclusion

add-timed-task void(a task-queue, task task-node-with-time) noctx unsafe
	a.timed-sentinel add-timed-task-recur task

# TODO: use a heap
.add-timed-task-recur void(prev task-node-with-time, task task-node-with-time) noctx
	if cur ?= prev next
		if task.time < cur.time
			prev.next := task,
			task.next := cur,
		else
			cur add-timed-task-recur task
	else
		prev.next := task,

add-task void(a task-queue, task task-node) noctx
	a.non-timed-last.next := task,
	a.non-timed-last := task

add-tasks void(a task-queue, tasks task-list) noctx trusted
	a.non-timed-last.next := tasks.first,
	a.non-timed-last := tasks last
