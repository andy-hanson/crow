no-std
import
	../bool: &&, bool, not
	../col/collection: fill, set-subscript
	../col/mut-array: +, begin, begin-pointer, mut-array, in, next, set-next, size, subscript
	../io/private/time-low-level: timestamp
	../misc: new, void
	../number: ==, <=>, -, max-value, nat64
	../option: force, option
	../pointer: *, as-const, const-pointer, mut-pointer
	../range: ..
	./alloc: gc, unmanaged-alloc-elements, unmanaged-free-elements
	./bare-priority-queue:
		add-gc-roots, bare-priority-queue, dequeue-if-less-or-equal, destroy, enqueue, is-empty,
		new, peek-key
	./bare-queue: add-gc-roots, bare-queue, dequeue, destroy, enqueue, is-empty, new, size
	./bootstrap: first, new, next, task-list
export
	./bootstrap: action, exclusion, task

# WARN: `task-queue` is not thread-safe; acquire `tasks-lock` on `global-ctx` first.

task-queue record mut by-val
	-non-timed mut task bare-queue
	-timed mut (nat64, task) bare-priority-queue
	# This is allocated with max-threads capacity on init, so never needs further allocation
	# This is unmanaged-allocated. (TODO: We probably shouldn't use 'mut-array' for non-GC data)
	-currently-running-exclusions exclusion mut-array

-nil-exclusion exclusion() noctx
	max-value

is-empty bool(a task-queue*) noctx, unsafe
	a.non-timed.is-empty && a.timed.is-empty

new task-queue(max-threads nat64) noctx, unsafe
	exclusions exclusion mut-array = max-threads.unmanaged-alloc-elements[0 .. max-threads]
	exclusions fill nil-exclusion
	(), (), exclusions

destroy void(a task-queue mut*) noctx, unsafe
	a.non-timed destroy
	a.timed destroy
	a->currently-running-exclusions destroy

-destroy[t] void(a t mut-array) noctx, unsafe
	a.begin-pointer unmanaged-free-elements a.size

add-gc-roots void(a task-queue*, gc gc mut*) noctx, unsafe
	a.non-timed add-gc-roots gc
	a.timed add-gc-roots gc

pop-task-result union mut
	task task
	no-task no-task

no-task record by-val
	# True if there any tasks exist (whether timed or not).
	any-tasks bool
	# If any timed tasks exists, this is the time of the first one.
	first-task-time timestamp?

# Caller should call 'return-task' after running the task
pop-task pop-task-result(a task-queue mut*, cur-time timestamp, thread-id nat64) noctx, unsafe
	a move-timed-tasks cur-time
	exclusions = a->currently-running-exclusions
	remaining mut = a.non-timed.as-const size
	loop
		if remaining == 0
			break (!a.as-const.is-empty, a.as-const.timed.peek-key) no-task
		else
			t = a.non-timed.dequeue!
			if t.exclusion in exclusions
				a.non-timed enqueue t
				remaining -:= 1
				continue
			else
				exclusions[thread-id] := t exclusion
				break t task

# Move timed tasks to the non-timed queue if they are ready
-move-timed-tasks void(a task-queue mut*, cur-time timestamp) noctx, unsafe
	loop
		if t ?= a.timed dequeue-if-less-or-equal cur-time
			a.non-timed enqueue t
			continue
		else
			break

return-task void(a task-queue mut*, _ task, thread-index nat64) noctx, unsafe
	a->currently-running-exclusions[thread-index] := nil-exclusion

enqueue-timed-task void(a task-queue mut*, time nat64, task task) noctx, unsafe
	a.timed enqueue (time, task)

enqueue-task void(a task-queue mut*, task task) noctx, unsafe
	a.non-timed enqueue task

enqueue-tasks void(a task-queue mut*, tasks task-list) noctx, unsafe
	cur mut = tasks first
	loop
		a.non-timed enqueue cur.task
		if next ?= cur next
			cur := next
			continue
		else
			break
