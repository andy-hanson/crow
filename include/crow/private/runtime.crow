no-std
import
	../col/dict: dict, empty-dict
	../exception: exception, to-string
	../fun-util: subscript
	../io/print: err, print, print-no-newline
	../io/private/time-low-level: get-monotime-nsec, timestamp
	../log: default-log-handler, set-log-handler, log-handler
	../misc: void
	../number: ==, nat64
	../option: new, option
	../pointer: *, by-val, mut-pointer, set-deref
	../string: literal, string
	../version: is-wasm
	./alloc:
		gc, init, needs-gc, return-gc-ctx, run-garbage-collection, set-gc-ctx-for-thread, uninit
	./bool-low-level: !, &&, ||, bool, false, true
	./bootstrap: hard-assert, new, symbol
	./task-queue:
		action, add-task, add-tasks, add-timed-task, any-tasks, exclusion, first-task-time, init,
		is-empty, pop-task, return-task, task, task-list, task-node, task-node-with-time,
		task-queue, uninit
	./thread-utils:
		acquire, broadcast, condition, decrement, destroy-condition, get-and-increment,
		get-sequence, increment-and-get, init, lock, release, thread-safe-counter, uninit, wait-on

get-global-ctx global-ctx() unsafe
	*global-ctx-var

# TODO: this should be a global instead
.global-ctx-var global-ctx mut*() thread-local

# This fun is required by the compiler.
cur-exclusion exclusion() unsafe
	*cur-exclusion-var

.cur-exclusion-var exclusion mut*() thread-local

global-ctx record mut by-ref
	global-lock mut by-val lock
	may-be-work-to-do mut by-val condition
	# Set to true the first time the default exception handler is invoked.
	# Can never be unset.
	any-unhandled-exceptions mut bool

	gc mut by-val gc
	gc-root mut by-val gc-root
	# All below must not be GC allocated

	symbols-lock mut by-val lock
	# protects 'gc-root.tasks'
	.tasks-lock mut by-val lock
	.n-threads nat64
	.n-waiting-threads mut by-val thread-safe-counter
	.next-exclusion mut by-val thread-safe-counter
	.is-shut-down mut bool

get-global-lock lock() unsafe
	&get-global-ctx.global-lock

.thread-id-var nat64 mut*() thread-local

# This is not 'noctx' since a non-crow thread won't have an ID
cur-thread-id nat64() unsafe
	*thread-id-var

uninit by-val global-ctx(n-threads nat64) noctx unsafe summon
	q by-val task-queue = n-threads uninit
	gc-root by-val gc-root = q, empty-dict, (exn => exn default-exception-handler), log =>
		log default-log-handler
	uninit, uninit, false, uninit, gc-root, uninit, uninit, n-threads, uninit, uninit, false

init void(a global-ctx) noctx unsafe
	(&a.global-lock)::lock init
	(&a.may-be-work-to-do)::condition init
	(&a.gc)::gc init a.n-threads
	(&a.symbols-lock)::lock init
	(&a.tasks-lock)::lock init
	(&a.gc-root)::gc-root init
	(&a.n-waiting-threads)::thread-safe-counter init
	(&a.next-exclusion)::thread-safe-counter init

free void(a global-ctx) noctx unsafe
	&a.may-be-work-to-do destroy-condition

gc-root record mut by-ref
	# protected by 'tasks-lock' on the global ctx
	tasks mut by-val task-queue
	symbols-table mut symbol[string]
	# If there's an uncaught exception (e.g. in 'call-ref-and-drop'), we'll call this.
	# Default is to print it and set `gctx.any-unhandled-exceptions`
	exception-handler mut fun void(exception)
	# TODO: this should be a `global`. But need to atomically set.
	default-log-handler mut log-handler

.init void(a gc-root) noctx unsafe
	(&a.tasks)::task-queue init

symbols-table symbol[string](a global-ctx) trusted noctx
	(&a.gc-root)::gc-root symbols-table
set-symbols-table void(a global-ctx, value symbol[string]) trusted noctx
	(&a.gc-root)::gc-root.symbols-table := value

.tasks task-queue(a global-ctx) noctx unsafe
	&(&a.gc-root).tasks

exception-handler fun void(exception)(a global-ctx) trusted
	(&a.gc-root)::gc-root exception-handler

new-exclusion exclusion(v global-ctx) noctx trusted
	&v.next-exclusion get-and-increment

default-exception-handler void(e exception) summon unsafe
	err print-no-newline "uncaught exception: "
	err print e.to-string
	get-global-ctx.any-unhandled-exceptions := true

# TODO: move to exception.crow ?
set-exception-handler void(exception-handler fun void(exception)) summon trusted
	(&get-global-ctx.gc-root).exception-handler := exception-handler

add-task void(a global-ctx, exclusion exclusion, action act void()) unsafe
	a add-task ((exclusion, action), ())

add-task void(a global-ctx, task task-node) noctx unsafe
	&a.tasks-lock acquire
	a.tasks add-task task
	&a.tasks-lock release
	&a.may-be-work-to-do broadcast

add-tasks void(a global-ctx, task-list task-list) noctx unsafe
	&a.tasks-lock acquire
	a.tasks add-tasks task-list
	&a.tasks-lock release
	&a.may-be-work-to-do broadcast

add-timed-task void(a global-ctx, time timestamp, exclusion exclusion, action act void()) unsafe
	node task-node-with-time = (exclusion, action), (), time
	&a.tasks-lock acquire
	a.tasks add-timed-task node
	&a.tasks-lock release
	&a.may-be-work-to-do broadcast

thread-function void(thread-id nat64, gctx global-ctx) noctx unsafe summon
	*thread-id-var := thread-id
	loop
		# Get a task to do; or sleep.
		last-checked = &gctx.may-be-work-to-do get-sequence
		match gctx choose-task
		as task t
			gctx do-task t
			continue
		as gc
			&gctx.may-be-work-to-do broadcast
			&gctx.gc run-garbage-collection gctx.gc-root
			continue
		as wait-for-task wait-until-time
			&gctx.may-be-work-to-do wait-on wait-until-time, last-checked
			&gctx.n-waiting-threads decrement
			continue
		as shut-down
			break gctx thread-shut-down

.do-task void(gctx global-ctx, task task) noctx unsafe summon
	gctx before-task task.exclusion
	task.action invoke-action
	&gctx.tasks-lock acquire
	gctx.tasks return-task task, *thread-id-var
	&gctx.tasks-lock release
	after-task

.invoke-action void(action act void()) force-ctx
	action[]

.thread-shut-down void(gctx global-ctx) noctx unsafe summon
	&gctx.may-be-work-to-do broadcast
	&gctx.tasks-lock acquire
	gctx.tasks.is-empty hard-assert
	&gctx.tasks-lock release

before-task void(gctx global-ctx, exclusion exclusion) noctx unsafe
	*global-ctx-var := gctx
	*cur-exclusion-var := exclusion
	&gctx.gc set-gc-ctx-for-thread
	(&gctx.gc-root).default-log-handler set-log-handler

after-task void() noctx unsafe
	return-gc-ctx

.choose-task-result union mut
	task task
	gc
	# No task to do now, but wait on 'may-be-work-to-do'.
	# Timestamp is time of the first first timed task, if any.
	wait-for-task timestamp?
	# No task to do now or ever, so shut down
	shut-down

.choose-task choose-task-result(gctx global-ctx) noctx unsafe summon
	cur-time = if is-wasm
		0
	else
		get-monotime-nsec
	&gctx.tasks-lock acquire

	res = if &gctx.gc needs-gc
		gc
	else
		match gctx.tasks pop-task cur-time, *thread-id-var
		as task t
			t task
		as no-task n
			n-waiting = &gctx.n-waiting-threads increment-and-get
			if (n-waiting == gctx.n-threads && !n.any-tasks) || gctx.is-shut-down
				# Can't possibly be any more tasks: No timed tasks, no threads doing work to add tasks.
				gctx.is-shut-down := true
				shut-down
			else
				n.first-task-time wait-for-task

	&gctx.tasks-lock release
	res
