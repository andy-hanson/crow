no-std
import
	../bool: &&, ||, bool, false, true
	../col/array: array
	../col/collection: .., -, end, subscript
	../col/map: empty-map, map
	../col/mut-array: -, +, begin, begin-pointer, end, end-pointer, mut-array, size, slice, uninitialized-mut-array
	../fun-util: subscript
	../io/private/time-low-level: get-monotime-nsec, timestamp
	../log: default-log-handler, set-log-handler, log-handler
	../misc: new, void
	../number: ==, is-multiple-of, nat64
	../option: force, is-empty, new, option
	../pointer: ==, *, any-mut-pointer, as-const, as-fun-pointer, mut-pointer, null, reference-equal, to
	../string: string
	../version: is-wasm
	./alloc:
		gc, gc-add-root, gc-begin, gc-complete, gc-end, init, needs-gc, mutator-begin, mutator-end,
		uninit
	./bootstrap:
		cur-exclusion, cur-fiber, fiber, fiber-suspension, hard-assert, initial-function, is-running, new,
		set-cur-exclusion, set-cur-fiber, set-initial-function, set-is-running, suspension, symbol
	./task-queue:
		add-gc-roots, destroy, enqueue-fiber, enqueue-fibers, enqueue-timed-fiber, exclusion,
		init, pop-task, release-exclusion, slow-is-empty, task-queue, uninit
	./thread-utils:
		acquire, broadcast, condition, decrement, destroy-condition, get-and-increment,
		get-sequence, increment-and-get, init, lock, release, thread-safe-counter, uninit, wait-on

get-global-ctx global-ctx mut*() unsafe
	global-ctx-var

# TODO: this should be a global instead
-global-ctx-var thread-local(global-ctx mut*)

cur-exclusion exclusion() unsafe
	cur-fiber! cur-exclusion

# Only set right before yielding and unset right after
-cur-yield-request thread-local(yield-request?)

global-ctx record by-val, mut
	global-lock mut lock
	may-be-work-to-do mut condition
	# Set to true the first time the default exception handler is invoked.
	# Can never be unset.
	any-unhandled-exceptions mut bool

	gc mut gc

	# protected by 'tasks-lock'
	tasks mut task-queue
	symbols-table mut symbol[string] # TODO: just move to where it's used? --------------------------------------------------
	# TODO: this should be a `global`. But need to atomically set.
	default-log-handler mut log-handler

	# All below must not be GC allocated

	symbols-lock mut lock
	# protects 'tasks'
	-tasks-lock mut lock
	-n-threads nat64
	-n-waiting-threads mut thread-safe-counter
	-next-exclusion mut thread-safe-counter
	-is-shut-down mut bool

get-global-lock lock mut*() unsafe
	get-global-ctx.global-lock

-thread-id-var thread-local(nat64)

# This is not 'bare' since a non-crow thread won't have an ID
+cur-thread-id nat64() unsafe
	thread-id-var

uninit global-ctx(n-threads nat64) bare, summon, unsafe
	global-lock: uninit
	may-be-work-to-do: uninit
	any-unhandled-exceptions: false
	gc: uninit
	tasks: uninit
	symbols-table: empty-map
	default-log-handler: log => log default-log-handler # TODO: think about this one too .............................
	symbols-lock: uninit
	tasks-lock: uninit
	n-threads: n-threads
	n-waiting-threads: uninit
	next-exclusion: uninit
	is-shut-down: false

init void(a global-ctx mut*) bare, unsafe
	a.global-lock init
	a.may-be-work-to-do init
	a.gc init a->n-threads
	a.tasks init
	a.symbols-lock init
	a.tasks-lock init
	a.n-waiting-threads init
	a.next-exclusion init

destroy void(a global-ctx mut*) bare, unsafe
	a.tasks destroy
	a.may-be-work-to-do destroy-condition

# stack-top must be 16-byte aligned
# TODO: move to where they're used ---------------------------------------------------------------------------------------
-new-fiber-suspension fiber-suspension(stack-top nat64 mut*, func void function(x any-mut-pointer), arg any-mut-pointer) builtin, bare
-switch-fiber-suspension void(from fiber-suspension mut*, to fiber-suspension mut*) builtin, bare

# Regular fibers return to this for the task loop.
# TODO: This could be by-value. But we currently don't support pointer to thread-local. ------------------------------------
-thread-base-fiber-suspension thread-local(fiber-suspension mut*)

-is-valid-stack bool(a nat64 mut-array) bare, unsafe
	a.begin-pointer.to is-multiple-of 16 && a.size is-multiple-of 2

# Caller is responsible for catching all exceptions in 'action'
add-new-fiber void(a global-ctx mut*, action void mut()) unsafe
	a enqueue-fiber (a create-new-fiber action)
-create-new-fiber fiber(a global-ctx mut*, action void mut()) unsafe
	# TODO: A small stack like this may fail for real programs. I should get around to implementing stack overflow checking.
	stack1 nat64 mut-array = 0x10000 uninitialized-mut-array
	# TODO: getter way to align it -----------------------------------------------------------------------------------------------
	stack = if stack1 is-valid-stack
		stack1
	else
		stack1[1 .. end - 1]
	stack.is-valid-stack hard-assert

	# TODO: We need to make sure the func is visible to the GC immediately! ---------------------------------------------------
	# TODO: This means we need to pin the memory....
	initial-function: action,
	is-running: false
	suspension: stack.end-pointer new-fiber-suspension &fiber-func, null
	cur-exclusion: a.next-exclusion.get-and-increment
	cur-jmp-buf: null
	stack: stack
	gc-root: null

-fiber-func void(arg any-mut-pointer) unsafe
	arg == null hard-assert
	fiber = cur-fiber!
	func = fiber.initial-function!
	fiber.initial-function := ()
	func[]
	done yield-this-fiber

enqueue-fiber void(a global-ctx mut*, fiber fiber) bare, unsafe
	forbid fiber is-running
	a.tasks-lock acquire
	a.tasks enqueue-fiber fiber
	a.tasks-lock release
	a.may-be-work-to-do broadcast

enqueue-fibers void(a global-ctx mut*, fibers fiber array) bare, unsafe # TODO: is this still needed? Could just run 'enqueue-fiber' in a loop?
	a.tasks-lock acquire
	a.tasks enqueue-fibers fibers
	a.tasks-lock release
	a.may-be-work-to-do broadcast

delay-cur-fiber-until-time void(target-nsec nat64) summon, trusted
	target-nsec.delay-until-time yield-this-fiber

-enqueue-timed-fiber void(a global-ctx mut*, time timestamp, fiber fiber) bare, unsafe
	a.tasks-lock acquire
	a.tasks enqueue-timed-fiber time, fiber
	a.tasks-lock release
	a.may-be-work-to-do broadcast

# TODO: this is ugly 0--------------------------------------------------------------------------------------------------------------
dummy record extern, mut
	a nat64
	b nat64
	x mut nat64

thread-function void(thread-id nat64, gctx global-ctx mut*) bare, summon, unsafe
	# This will be initialized properly the first time we switch away
	
	# It needs to set stack[-2]
	dummy mut dummy = 0, 0, 0
	dummy-ptr dummy mut* = &dummy
	my-suspension mut = dummy-ptr.x new-fiber-suspension null.as-fun-pointer, null
	thread-base-fiber-suspension := &my-suspension
	thread-id-var := thread-id
	loop
		# Get a task to do; or sleep.
		last-checked = gctx.may-be-work-to-do get-sequence
		match gctx decide-what-to-do
		as fiber x
			gctx run-fiber x
			continue
		as gc
			gctx.may-be-work-to-do broadcast
			gctx do-gc
			continue
		as wait-for-task wait-until-time
			gctx.may-be-work-to-do wait-on wait-until-time, last-checked
			gctx.n-waiting-threads decrement
			continue
		as shut-down
			break gctx thread-shut-down

~change-this-fibers-exclusion void(new-exclusion exclusion) unsafe
	# TOOD: PERF: If the exclusion is availalbe immediately, no need to add to queue -----------------------------------------
	new-exclusion.change-exclusion yield-this-fiber

~yield-request union mut
	# Add this fiber back to the queue of runnable fibers.
	add-to-queue
	# Since 'future' has many types, we need a pointer to the function for adding a fiber to the future
	await-future (any-mut-pointer, bool function(future any-mut-pointer, fiber fiber))
	# Change this fiber's exclusion to a new one, then enqueue it again.
	change-exclusion exclusion
	# Like 'add-to-queue', but adds to the timed queue
	delay-until-time timestamp
	done

# The caller should do something to ensure the fiber will eventually be resumed.
~yield-this-fiber void(request yield-request) unsafe
	assert cur-yield-request is-empty
	cur-yield-request := request,
	fiber = cur-fiber!
	fiber.is-running := false
	&fiber.suspension switch-fiber-suspension thread-base-fiber-suspension

# Runs the fiber until its next yield
-run-fiber void(gctx global-ctx mut*, fiber fiber) bare, summon, unsafe
	gctx before-task
	assert cur-fiber is-empty
	cur-fiber := fiber,

	thread-base-fiber-suspension switch-fiber-suspension &fiber.suspension

	# It yields to get back here.
	assert cur-fiber! reference-equal fiber
	cur-fiber := ()
	forbid fiber is-running

	gctx.tasks-lock acquire
	gctx.tasks release-exclusion fiber.cur-exclusion
	gctx.tasks-lock release

	match cur-yield-request!
	as add-to-queue
		gctx enqueue-fiber fiber
	as await-future future, add-awaiting-fiber
		unless add-awaiting-fiber[future, fiber]
			# Future is already complete, so just enqueue the fiber
			gctx enqueue-fiber fiber
	as change-exclusion new-exclusion
		fiber.cur-exclusion := new-exclusion
		gctx enqueue-fiber fiber
	as delay-until-time timestamp
		gctx enqueue-timed-fiber timestamp, fiber
	as done
		()

	cur-yield-request := ()

	after-task

-do-gc void(gctx global-ctx mut*) bare, unsafe
	gc = gctx gc
	if gc gc-begin
		gctx.as-const.tasks add-gc-roots gc
		gc gc-add-root gctx->symbols-table
		gc gc-complete
	gc gc-end

-thread-shut-down void(gctx global-ctx mut*) bare, summon, unsafe
	gctx.may-be-work-to-do broadcast
	gctx.tasks-lock acquire
	gctx.as-const.tasks.slow-is-empty hard-assert
	gctx.tasks-lock release

~before-task void(gctx global-ctx mut*) bare, unsafe
	global-ctx-var := gctx
	gctx.gc mutator-begin
	gctx->default-log-handler set-log-handler # TODO: Ideally this would persist across fiber yields.......................

after-task void() bare, unsafe
	mutator-end

-what-to-do union mut
	fiber fiber
	gc
	# No task to do now, but wait on 'may-be-work-to-do'.
	# Timestamp is time of the first first timed task, if any.
	wait-for-task timestamp?
	# No task to do now or ever, so shut down
	shut-down

-decide-what-to-do what-to-do(gctx global-ctx mut*) bare, summon, unsafe
	cur-time nat64 = if is-wasm
		0
	else
		get-monotime-nsec
	gctx.tasks-lock acquire

	res = if gctx.gc->needs-gc
		gc
	else
		match gctx.tasks pop-task cur-time
		as popped x
			x fiber
		as no-immediate first-task-time
			n-waiting = gctx.n-waiting-threads increment-and-get
			if (n-waiting == gctx->n-threads && first-task-time.is-empty) || gctx->is-shut-down
				# Can't possibly be any more tasks:
				# No timed tasks, no threads doing work to add tasks.
				gctx->is-shut-down := true
				shut-down
			else
				first-task-time wait-for-task

	gctx.tasks-lock release
	res
