no-std
import
	../bool: &&, ||, bool, false, true
	../col/array: array
	../col/collection: .., -, end, subscript
	../col/map: empty-map, map
	../col/mut-array:
		-, +, begin, begin-pointer, end, end-pointer, mut-array, new, size, slice, zeroed-mut-array
	../fun-util: subscript
	../io/private/time-low-level: get-monotime-nsec, timestamp
	../log: default-log-handler, get-log-handler
	../misc: new, shared, void
	../number: ==, is-multiple-of, nat64
	../option: force, is-empty, new, option
	../pointer: ==, *, any-mut-pointer, as-const, mut-pointer, null, reference-equal, to
	../string: string
	../version: is-wasm
	./alloc:
		gc, gc-root, gc-add-root, gc-begin, gc-complete, gc-end, init, needs-gc, mutator-begin,
		mutator-end, uninit
	./bootstrap:
		cur-exclusion, cur-fiber, fiber, hard-assert, hard-forbid, initial-function, is-running,
		new, set-cur-exclusion, set-cur-fiber, set-initial-function, set-is-running, stack-pointer,
		symbol
	./fiber-queue:
		add-gc-roots, destroy, enqueue-fiber, enqueue-fibers, enqueue-timed-fiber, exclusion,
		fiber-queue, init, pop-task, release-exclusion, slow-is-empty, uninit
	./thread-utils:
		acquire, broadcast, condition, decrement, destroy-condition, get-and-increment,
		get-sequence, increment-and-get, init, lock, release, thread-safe-counter, uninit, wait-on

-global-ctx-var global(global-ctx mut*)
~get-global-ctx global-ctx mut*() unsafe
	global-ctx-var
~set-global-ctx void(value global-ctx mut*) bare, unsafe
	global-ctx-var := value

cur-exclusion exclusion() unsafe
	cur-fiber! cur-exclusion

# Only set right before yielding and unset right after
-cur-yield-request thread-local(yield-request?)

global-ctx record by-val, mut
	global-lock mut lock
	may-be-work-to-do mut condition
	# Set to true the first time the default exception handler is invoked.
	# Can never be unset.
	any-unhandled-exceptions mut bool

	gc mut gc

	# protected by 'fiber-queue-lock'
	fiber-queue mut fiber-queue
	symbols-table mut symbol[string]

	# All below must not be GC allocated

	symbols-lock mut lock
	# protects 'tasks'
	-fiber-queue-lock mut lock
	-n-threads nat64
	-n-waiting-threads mut thread-safe-counter
	-next-exclusion mut thread-safe-counter
	-is-shut-down mut bool

get-global-lock lock mut*() unsafe
	get-global-ctx.global-lock

-thread-id-var thread-local(nat64)

# This is not 'bare' since a non-crow thread won't have an ID
+cur-thread-id nat64() unsafe
	thread-id-var

uninit global-ctx(n-threads nat64) bare, summon, unsafe
	global-lock: uninit
	may-be-work-to-do: uninit
	any-unhandled-exceptions: false
	gc: uninit
	fiber-queue: uninit
	symbols-table: empty-map
	symbols-lock: uninit
	fiber-queue-lock: uninit
	n-threads: n-threads
	n-waiting-threads: uninit
	next-exclusion: uninit
	is-shut-down: false

init void(a global-ctx mut*) bare, unsafe
	a.global-lock init
	a.may-be-work-to-do init
	a.gc init a->n-threads
	a.fiber-queue init
	a.symbols-lock init
	a.fiber-queue-lock init
	a.n-waiting-threads init
	a.next-exclusion init

destroy void(a global-ctx mut*) bare, unsafe
	a.fiber-queue destroy
	a.may-be-work-to-do destroy-condition

###
`stack-low` and `stack-high` must be 16-byte aligned. This will grow down, meaning it starts at the greatest value.
Initializes the stack, then returns the new stack pointer.
###
-init-stack stack-pointer(stack-low stack-pointer, stack-high stack-pointer, func void function()) builtin, bare
###
Takes a pointer to the current stack pointer and updates it.
Then resumes from the stack pointer at 'to'.
###
-switch-fiber void(from stack-pointer mut*, to stack-pointer) builtin, bare

# Stack pointer for the runtime. Regular fibers return to this when they yield.
# TODO: This could be by-value. But we currently don't support pointer to thread-local.
-thread-base-stack-pointer thread-local(stack-pointer mut*)

-is-valid-stack bool(a nat64 mut-array) bare, unsafe
	a.begin-pointer.to is-multiple-of 16 && a.size is-multiple-of 2

# Normally only a fiber can create another fiber. To initialize the first one, set a dummy fiber. Remember to unset when done.
~set-dummy-fiber void() summon, unsafe
	fiber fiber = do
		initial-function: ()
		log-handler: log => log default-log-handler
		stack: ()
		gc-root: null
		is-running: false
		# This will be written to the first time we call 'switch-fiber'.
		stack-pointer: null
		cur-exclusion: 0
		cur-jmp-buf: null
	cur-fiber := fiber,

# Caller is responsible for catching all exceptions in 'action'
add-new-fiber void(a global-ctx mut*, action void mut()) unsafe
	a enqueue-fiber (a create-new-fiber action)
-create-new-fiber fiber(a global-ctx mut*, action void mut()) unsafe
	# TODO: A small stack like this may fail for real programs. I should get around to implementing stack overflow checking.
	stack1 nat64 mut-array = 0x10000 zeroed-mut-array
	# TODO: getter way to align it -----------------------------------------------------------------------------------------------
	stack = if stack1 is-valid-stack
		stack1
	else
		stack1[1 .. end - 1]
	stack.is-valid-stack hard-assert

	# TODO: We need to make sure the func is visible to the GC immediately! ---------------------------------------------------
	# TODO: This means we need to pin the memory....
	initial-function: action,
	# Inherits this fiber's log handler
	log-handler: get-log-handler
	stack: stack
	gc-root: null
	is-running: false
	stack-pointer: stack.begin-pointer init-stack stack.end-pointer, &fiber-func
	cur-exclusion: a.next-exclusion.get-and-increment
	cur-jmp-buf: null

-fiber-func void() unsafe
	gc-root == null hard-assert
	fiber = cur-fiber!
	func = fiber.initial-function!
	fiber.initial-function := ()
	func[]
	done yield-this-fiber

enqueue-fiber void(a global-ctx mut*, fiber fiber) bare, unsafe
	forbid fiber is-running
	a.fiber-queue-lock acquire
	a.fiber-queue enqueue-fiber fiber
	a.fiber-queue-lock release
	a.may-be-work-to-do broadcast

enqueue-fibers void(a global-ctx mut*, fibers fiber array) bare, unsafe # TODO: is this still needed? Could just run 'enqueue-fiber' in a loop?
	a.fiber-queue-lock acquire
	a.fiber-queue enqueue-fibers fibers
	a.fiber-queue-lock release
	a.may-be-work-to-do broadcast

delay-cur-fiber-until-time void(target-nsec nat64) summon, trusted
	target-nsec.delay-until-time yield-this-fiber

-enqueue-timed-fiber void(a global-ctx mut*, time timestamp, fiber fiber) bare, unsafe
	a.fiber-queue-lock acquire
	a.fiber-queue enqueue-timed-fiber time, fiber
	a.fiber-queue-lock release
	a.may-be-work-to-do broadcast

thread-function void(thread-id nat64, gctx global-ctx mut*) bare, summon, unsafe
	# This will be initialized properly the first time we switch away
	stack-pointer-value mut stack-pointer = null
	thread-base-stack-pointer := &stack-pointer-value
	thread-id-var := thread-id
	loop
		# Get a task to do; or sleep.
		last-checked = gctx.may-be-work-to-do get-sequence
		match gctx decide-what-to-do
		as fiber x
			gctx run-fiber x
			continue
		as gc
			gctx.may-be-work-to-do broadcast
			gctx do-gc
			continue
		as wait-for-task wait-until-time
			gctx.may-be-work-to-do wait-on wait-until-time, last-checked
			gctx.n-waiting-threads decrement
			continue
		as shut-down
			break gctx thread-shut-down

-change-this-fibers-exclusion void(new-exclusion exclusion) unsafe
	# TOOD: PERF: If the exclusion is availalbe immediately, no need to add to queue -----------------------------------------
	new-exclusion.change-exclusion yield-this-fiber

~yield-request union mut
	# Add this fiber back to the queue of runnable fibers.
	add-to-queue
	# Since 'future' has many types, we need a pointer to the function for adding a fiber to the future
	await-future (any-mut-pointer, bool function(future any-mut-pointer, fiber fiber))
	# Change this fiber's exclusion to a new one, then enqueue it again.
	change-exclusion exclusion
	# Like 'add-to-queue', but adds to the timed queue
	delay-until-time timestamp
	done

# The caller should do something to ensure the fiber will eventually be resumed.
~yield-this-fiber void(request yield-request) unsafe
	assert cur-yield-request is-empty
	cur-yield-request := request,
	fiber = cur-fiber!
	fiber.is-running := false
	&fiber.stack-pointer switch-fiber *thread-base-stack-pointer

# Runs the fiber until its next yield
~run-fiber void(gctx global-ctx mut*, fiber fiber) bare, summon, unsafe
	gctx before-task
	cur-fiber.is-empty hard-assert
	cur-fiber := fiber,

	thread-base-stack-pointer switch-fiber fiber.stack-pointer

	# It yields to get back here.
	cur-fiber! reference-equal fiber hard-assert
	cur-fiber := ()
	fiber.is-running hard-forbid

	gctx.fiber-queue-lock acquire
	gctx.fiber-queue release-exclusion fiber.cur-exclusion
	gctx.fiber-queue-lock release

	match cur-yield-request!
	as add-to-queue
		gctx enqueue-fiber fiber
	as await-future future, add-awaiting-fiber
		unless add-awaiting-fiber[future, fiber]
			# Future is already complete, so just enqueue the fiber
			gctx enqueue-fiber fiber
	as change-exclusion new-exclusion
		fiber.cur-exclusion := new-exclusion
		gctx enqueue-fiber fiber
	as delay-until-time timestamp
		gctx enqueue-timed-fiber timestamp, fiber
	as done
		()

	cur-yield-request := ()

	after-task

-do-gc void(gctx global-ctx mut*) bare, unsafe
	gc = gctx gc
	if gc gc-begin
		gctx.as-const.fiber-queue add-gc-roots gc
		gc gc-add-root gctx->symbols-table
		gc gc-complete
	gc gc-end

-thread-shut-down void(gctx global-ctx mut*) bare, summon, unsafe
	gctx.may-be-work-to-do broadcast
	gctx.fiber-queue-lock acquire
	gctx.as-const.fiber-queue.slow-is-empty hard-assert
	gctx.fiber-queue-lock release

~before-task void(gctx global-ctx mut*) bare, unsafe
	gctx.gc mutator-begin

after-task void() bare, unsafe
	mutator-end

-what-to-do union mut
	fiber fiber
	gc
	# No task to do now, but wait on 'may-be-work-to-do'.
	# Timestamp is time of the first first timed task, if any.
	wait-for-task timestamp?
	# No task to do now or ever, so shut down
	shut-down

-decide-what-to-do what-to-do(gctx global-ctx mut*) bare, summon, unsafe
	cur-time nat64 = if is-wasm
		0
	else
		get-monotime-nsec
	gctx.fiber-queue-lock acquire

	res = if gctx.gc->needs-gc
		gc
	else
		match gctx.fiber-queue pop-task cur-time
		as popped x
			x fiber
		as no-immediate first-task-time
			n-waiting = gctx.n-waiting-threads increment-and-get
			if (n-waiting == gctx->n-threads && first-task-time.is-empty) || gctx->is-shut-down
				# Can't possibly be any more tasks:
				# No timed tasks, no threads doing work to add tasks.
				gctx->is-shut-down := true
				shut-down
			else
				first-task-time wait-for-task

	gctx.fiber-queue-lock release
	res

# This is called by the compiler for 'shared () => ...' lambdas.
~shared-of-mut-lambda[r, p] r shared(param p)(a r mut(param p)) r shared, p shared
	trusted
		exclusion = cur-exclusion
		wrapper (r, p) force-lambda-shared = a,
		param =>
			# TODO:PERF -- if new-exclusion is the same as cur-exclusion, do nothing -------------------------------------------------------
			# Remember the old exclusion of this fiber. Then change it to the new exclusion and yield.
			# When it resumes, run 'f[]', then set the exclusion back and yield again.
			prev-exclusion = cur-exclusion
			exclusion change-this-fibers-exclusion
			finally prev-exclusion change-this-fibers-exclusion
			wrapper.fn[param]
-force-lambda-shared[r, p] record(fn r mut(param p)) force-shared
