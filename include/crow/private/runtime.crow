no-std
import
	../col/dict: dict, empty-dict
	../exception: exception, to-str
	../io/print: print-err, print-err-no-newline
	../io/private/time-low-level: get-monotime-nsec, timestamp
	../misc: void
	../number: ==, nat64
	../opt: new, opt
	../ptr: as-any-mut-ptr, as-ref, by-val
	../str: literal, str
	../version: is-wasm
	./alloc:
		gc, gc-ctx, get-gc-ctx, init, needs-gc, return-gc-ctx, run-garbage-collection, uninit
	./bool-low-level: !, &&, ||, bool, false, true
	./bootstrap:
		call-with-ctx, ctx, gc-ctx-ptr, gctx-ptr, get-ctx, hard-assert, log-ctx-ptr,
		new, sym, thread-id, thread-local-stuff
	./log-low-level: default-log-handler, log-ctx, log-handler, set-handler
	./perf-low-level: perf-ctx
	./task-queue:
		action, add-task, add-tasks, add-timed-task, any-tasks, exclusion, first-task-time, init,
		is-empty, pop-task, return-task, task, task-list, task-node, task-node-with-time,
		task-queue, uninit
	./thread-utils:
		acquire, broadcast, condition, decrement, destroy-condition, get-and-increment,
		get-sequence, increment-and-get, init, lock, release, thread-safe-counter, uninit, wait-on

get-global-ctx global-ctx() unsafe
	get-ctx.gctx-ptr as-ref

# This fun is required by the compiler.
cur-exclusion exclusion() unsafe
	get-ctx exclusion

global-ctx record mut by-ref
	print-lock mut by-val lock
	may-be-work-to-do mut by-val condition
	# Set to true the first time the default exception handler is invoked.
	# Can never be unset.
	any-unhandled-exceptions mut bool

	gc mut by-val gc
	gc-root mut by-val gc-root
	# All below must not be GC allocated

	syms-lock mut by-val lock
	# protects 'gc-root.tasks'
	.tasks-lock mut by-val lock
	.n-threads nat64
	.n-waiting-threads mut by-val thread-safe-counter
	.next-exclusion mut by-val thread-safe-counter
	.is-shut-down mut bool

cur-thread-id nat64() unsafe
	get-ctx.thread-local-stuff thread-id

uninit by-val global-ctx(n-threads nat64) noctx unsafe summon
	q by-val task-queue = n-threads uninit
	gc-root by-val gc-root = q, empty-dict, (exn => exn default-exception-handler), log =>
		log default-log-handler
	uninit, uninit, false, uninit, gc-root, uninit, uninit, n-threads, uninit, uninit, false

init void(a global-ctx) noctx unsafe
	(&a.print-lock)::lock init
	(&a.may-be-work-to-do)::condition init
	(&a.gc)::gc init a.n-threads
	(&a.syms-lock)::lock init
	(&a.tasks-lock)::lock init
	(&a.gc-root)::gc-root init
	(&a.n-waiting-threads)::thread-safe-counter init
	(&a.next-exclusion)::thread-safe-counter init

free void(a global-ctx) noctx unsafe
	&a.may-be-work-to-do destroy-condition

gc-root record mut by-ref
	# protected by 'tasks-lock' on the global ctx
	tasks mut by-val task-queue
	syms-table mut sym[str]
	# If there's an uncaught exception (e.g. in 'call-ref-and-drop'), we'll call this.
	# Default is to print it and set `gctx.any-unhandled-exceptions`
	exception-handler mut fun void(exception)
	log-handler mut log-handler

.init void(a gc-root) noctx unsafe
	(&a.tasks)::task-queue init

syms-table sym[str](a global-ctx) trusted noctx
	(&a.gc-root)::gc-root syms-table
set-syms-table void(a global-ctx, value sym[str]) trusted noctx
	(&a.gc-root)::gc-root.syms-table := value

.tasks task-queue(a global-ctx) noctx unsafe
	&(&a.gc-root).tasks

exception-handler fun void(exception)(a global-ctx) trusted
	(&a.gc-root)::gc-root exception-handler

new-exclusion exclusion(v global-ctx) noctx trusted
	&v.next-exclusion get-and-increment

default-exception-handler void(e exception) summon unsafe
	print-err-no-newline: "uncaught exception: "
	print-err: e to-str
	get-global-ctx.any-unhandled-exceptions := true

# TODO: move to exception.crow ?
set-exception-handler void(exception-handler fun void(exception)) summon trusted
	(&get-global-ctx.gc-root).exception-handler := exception-handler

add-task void(a global-ctx, exclusion exclusion, action act void()) unsafe
	a add-task ((exclusion, action), ())

add-task void(a global-ctx, task task-node) noctx unsafe
	&a.tasks-lock acquire
	a.tasks add-task task
	&a.tasks-lock release
	&a.may-be-work-to-do broadcast

add-tasks void(a global-ctx, task-list task-list) noctx unsafe
	&a.tasks-lock acquire
	a.tasks add-tasks task-list
	&a.tasks-lock release
	&a.may-be-work-to-do broadcast

add-timed-task void(a global-ctx, time timestamp, exclusion exclusion, action act void()) unsafe
	node task-node-with-time = (exclusion, action), (), time
	&a.tasks-lock acquire
	a.tasks add-timed-task node
	&a.tasks-lock release
	&a.may-be-work-to-do broadcast

thread-function void(thread-id nat64, gctx global-ctx) noctx unsafe summon
	log-ctx mut = log-ctx
	perf-ctx mut = perf-ctx
	print-lock lock = &gctx.print-lock
	log-ctx-ptr = (&log-ctx)::log-ctx as-any-mut-ptr
	perf-ptr = (&perf-ctx)::perf-ctx as-any-mut-ptr
	tls by-val thread-local-stuff = thread-id, print-lock, log-ctx-ptr, perf-ptr
	gctx thread-function-recur &tls

.thread-function-recur void(gctx global-ctx, tls thread-local-stuff) noctx unsafe summon
	# Get a task to do; or sleep.
	last-checked = &gctx.may-be-work-to-do get-sequence
	match gctx choose-task tls.thread-id
	as task t
		gctx do-task tls, t
		gctx thread-function-recur tls
	as gc
		&gctx.may-be-work-to-do broadcast
		&gctx.gc run-garbage-collection gctx.gc-root
		gctx thread-function-recur tls
	as wait-for-task wait-until-time
		&gctx.may-be-work-to-do wait-on wait-until-time, last-checked
		&gctx.n-waiting-threads decrement
		gctx thread-function-recur tls
	as shut-down
		gctx thread-shut-down

.do-task void(gctx global-ctx, tls thread-local-stuff, task task) noctx unsafe summon
	ctx = gctx new-ctx tls, task.exclusion
	task.action call-with-ctx &ctx
	&gctx.tasks-lock acquire
	gctx.tasks return-task task, tls.thread-id
	&gctx.tasks-lock release
	&ctx return-ctx

.thread-shut-down void(gctx global-ctx) noctx unsafe summon
	&gctx.may-be-work-to-do broadcast
	&gctx.tasks-lock acquire
	hard-assert: gctx.tasks is-empty
	&gctx.tasks-lock release

new-ctx by-val ctx(gctx global-ctx, tls thread-local-stuff, exclusion exclusion) noctx unsafe
	gc gc = &gctx.gc
	gc-ctx gc-ctx = gc get-gc-ctx
	tls.log-ctx-ptr.as-ref.handler := &gctx.gc-root log-handler
	gctx.as-any-mut-ptr, exclusion, gc-ctx.as-any-mut-ptr, tls

.return-ctx void(c ctx) noctx unsafe
	c.gc-ctx-ptr.as-ref return-gc-ctx

.choose-task-result union mut
	task task
	gc
	# No task to do now, but wait on 'may-be-work-to-do'.
	# Timestamp is time of the first first timed task, if any.
	wait-for-task timestamp?
	# No task to do now or ever, so shut down
	shut-down

.choose-task choose-task-result(gctx global-ctx, thread-id nat64) noctx unsafe summon
	cur-time = if is-wasm
		0
	else
		get-monotime-nsec
	&gctx.tasks-lock acquire

	res = if &gctx.gc needs-gc
		gc
	else
		match gctx.tasks pop-task cur-time, thread-id
		as task t
			t task
		as no-task n
			n-waiting = &gctx.n-waiting-threads increment-and-get
			if (n-waiting == gctx.n-threads && !n.any-tasks) || gctx.is-shut-down
				# Can't possibly be any more tasks: No timed tasks, no threads doing work to add tasks.
				gctx.is-shut-down := true
				shut-down
			else
				n.first-task-time wait-for-task

	&gctx.tasks-lock release
	res
