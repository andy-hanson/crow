no-std
import
	stdlib: free, malloc
	string: memcpy, memset
	../bits: ~, &
	../bool: !, bool, false, to-nat64, true
	../compare: !=, <, <=, >
	../misc: new
	../option: new, option
	../pointer:
		==, <=>, +, -, *, any-const-pointer, any-mut-pointer, as-any-const-pointer, as-any-mut-pointer, as-const,
		as-mut, as-ref, by-val, const-pointer, mut-pointer, null, pointer-cast, set-deref, size-of, to-nat64
	./bootstrap: hard-assert, hard-unreachable, lock, nat64, todo, void
	./number-low-level: ==, <=>, nat8, unsafe-div, wrap-add, wrap-mul, wrap-sub
	./thread-utils: acquire, barrier, init, release, wait-barrier, uninit

mem-copy<a> void(dest a mut*, src a*, size nat64) unsafe noctx
	_ = dest.as-any-mut-pointer memcpy src.as-any-const-pointer, (size wrap-mul size-of@<a>)
	()

set-zero-range<a> void(begin a mut*, size nat64) noctx unsafe
	# TODO: wrap-mul is unsafe
	_ = begin.as-any-mut-pointer memset 0, (size wrap-mul size-of@<a>)
	()

mark-ctx record mut by-ref
	memory-size-words nat64
	marks bool mut*
	memory-start nat64 mut*

# Returns true if the range is GC-allocated memory and was not already marked
mark bool(ctx mark-ctx, pointer-any any-const-pointer, size-bytes nat64) noctx unsafe summon
	size-words = size-bytes words-of-bytes
	pointer nat64* = pointer-any pointer-cast
	index = pointer - ctx.memory-start.as-const
	if index < ctx.memory-size-words
		pointer-any.is-word-aligned hard-assert
		(index wrap-add size-words) <= ctx.memory-size-words hard-assert
		mark-start = ctx.marks + index
		mark-end = mark-start + size-words
		mark-start mark-range mark-end
	else
		(index wrap-add size-words) > ctx.memory-size-words hard-assert
		false

.is-word-aligned bool(a any-const-pointer) noctx unsafe
	a.as-mut is-word-aligned
.is-word-aligned bool(a any-mut-pointer) noctx unsafe
	a.to-nat64 & 7 == 0

words-of-bytes nat64(size-bytes nat64) noctx trusted
	size-bytes.round-up-to-multiple-of-8 unsafe-div 8

round-up-to-multiple-of-8 nat64(n nat64) noctx
	(n wrap-add 7) & ~7

mark-range bool(start bool mut*, end bool mut*) noctx unsafe
	cur mut = start
	marked-anything mut = false
	until cur == end
		if !*cur
			*cur := true
			marked-anything := true
		cur := cur + 1
	marked-anything

mark-visit<a> void(mark-ctx mark-ctx, value a) noctx unsafe builtin

gc record mut by-ref
	.lk mut by-val lock
	.barrier mut by-val barrier
	.gc-count mut nat64
	.context-head mut gc-ctx?
	needs-gc .mut bool
	.size-words mut nat64
	# 'mark-cur' and 'data-cur' run in parallel
	# mark-end must be `mark-begin + size-words` and similar for data-end
	.mark-begin bool mut*
	.mark-cur mut bool mut*
	.mark-end mut bool mut*
	# We allocate data in increments of nat64
	.data-begin nat64 mut*
	.data-cur mut nat64 mut*
	.data-end mut nat64 mut*

gc-stats record by-val
	gc-count nat64
	cur-word nat64
	total-words nat64
	words-used nat64

words-free nat64(a gc-stats) noctx
	a.total-words wrap-sub a.words-used

# Super unsafe
# WARN: Unfortunately this doesn't prevent the original allocation in new-gc, just forbids us to use it
set-hard-limit void(gc gc, size-words nat64) noctx unsafe
	gc validate-gc
	size-words <= gc.size-words hard-assert
	cur-index = gc.mark-cur - gc.mark-begin
	cur-index < size-words hard-assert
	gc.size-words := size-words
	gc.mark-end := gc.mark-begin + size-words
	gc.data-end := gc.data-begin + size-words
	gc validate-gc

# WARN: this locks up the GC for a long time
get-stats gc-stats(gc gc) noctx unsafe
	gc validate-gc
	&gc.lk acquire
	gc-count = gc gc-count
	cur-word = gc.mark-cur - gc.mark-begin
	used-words-remaining = 0 words-used-in-range gc.mark-cur, gc.mark-end
	total-words = gc.mark-end - gc.mark-begin
	&gc.lk release
	gc-count, cur-word, total-words, (cur-word wrap-add used-words-remaining)

words-used-in-range nat64(acc nat64, cur bool mut*, end bool mut*) noctx unsafe
	if cur == end
		acc
	else
		acc wrap-add cur->to-nat64 words-used-in-range cur + 1, end

uninit by-val gc() noctx unsafe
	# TODO: handle malloc failure
	# 3 * 2**24 words = 3 * 2**27 bytes = 3 * 2**8 MB = 1.5 GB
	# If changing this, be sure `globalBuffer` in `wasm.d` is big enough
	size-words = 0x3000000
	# 8 GB
	#size-words = 0x40000000
	size-of@<bool> == size-of@<nat8> hard-assert
	mark bool mut* = size-words.malloc pointer-cast@<bool, nat8>
	mark-end = mark + size-words
	bytes nat64 mut* = (size-words wrap-mul size-of@<nat64>).malloc pointer-cast@<nat64, nat8>
	bytes.as-any-mut-pointer.is-word-aligned hard-assert
	bytes-end = bytes + size-words

	_ = mark.as-any-mut-pointer memset 0, size-words

	res mut by-val gc = uninit, uninit, 0, (), false, size-words, mark, mark, mark-end, bytes, bytes, bytes-end
	&res validate-gc
	res

init void(a gc, n-threads nat64) noctx unsafe
	(&a.lk)::lock init
	(&a.barrier)::barrier init n-threads

# WARN: This should be called by all threads.
run-garbage-collection<a> void(gc gc, gc-root a) noctx unsafe
	gc.needs-gc hard-assert
	if &gc.barrier wait-barrier
		gc.gc-count := gc.gc-count wrap-add 1
		_ = gc.mark-begin.as-any-mut-pointer memset 0, gc.size-words
		mark-ctx by-val mark-ctx = gc.size-words, gc.mark-begin, gc.data-begin
		&mark-ctx mark-visit gc-root
		prev-mark-cur = gc.mark-cur
		gc.mark-cur := gc.mark-begin
		gc.data-cur := gc.data-begin
		if false
			# Expensive safety check
			gc.mark-begin clear-free-mem prev-mark-cur, gc.data-begin
		gc validate-gc
		gc.needs-gc := false
	_ = &gc.barrier wait-barrier
	()

.clear-free-mem void(mark-pointer bool mut*, mark-end bool mut*, data-pointer nat64 mut*) noctx unsafe
	unless mark-pointer == mark-end
		unless *mark-pointer
			*data-pointer := 0xfadefadefadefade
		mark-pointer + 1 clear-free-mem mark-end, data-pointer

###
GC info specific to a ctx.
Currently they all share the common GC and must take a lock every time they allocate.
###
gc-ctx record mut by-ref
	gc mut gc
	next-ctx mut gc-ctx?

force-needs-gc void(gc gc) unsafe
	gc.needs-gc := true

.acquire-gc-ctx gc-ctx(gc gc) noctx unsafe
	&gc.lk acquire
	res = if c ?= gc.context-head
		gc.context-head := c next-ctx
		c.next-ctx := ()
		c
	else
		# NOTE: malloc'd memory is not traced for garbage col.
		# This is fine as 'gc' is kept alive anyway.
		# TODO: `size-of@<by-val<gc-ctx>>.malloc` should be legal
		c gc-ctx = (size-of@<by-val<gc-ctx>> malloc) as-ref
		c.gc := gc
		c.next-ctx := ()
		c
	&gc.lk release
	res

return-gc-ctx void() noctx unsafe
	gc-ctx = try-get-cur-gc-ctx force
	*cur-gc-ctx := ()
	gc = gc-ctx gc
	&gc.lk acquire
	gc-ctx.next-ctx := gc context-head
	gc.context-head := gc-ctx,
	&gc.lk release

.cur-gc-ctx gc-ctx? mut*() thread-local

get-gc-ctx gc-ctx() unsafe
	try-get-cur-gc-ctx force

.force<a> a(a a?) noctx unsafe
	if res ?= a
		res
	else
		hard-unreachable

try-get-cur-gc-ctx gc-ctx?() noctx unsafe
	*cur-gc-ctx

set-gc-ctx-for-thread void(a gc) noctx unsafe
	*cur-gc-ctx := a.acquire-gc-ctx,

get-gc gc() unsafe
	get-gc-ctx gc

validate-gc void(gc gc) noctx unsafe
	gc.mark-begin.as-any-mut-pointer.is-word-aligned hard-assert
	gc.data-begin.as-any-mut-pointer.is-word-aligned hard-assert
	gc.data-cur.as-any-mut-pointer.is-word-aligned hard-assert
	gc.mark-begin <= gc.mark-cur hard-assert
	gc.mark-cur <= gc.mark-end hard-assert
	gc.data-begin <= gc.data-cur hard-assert
	gc.data-cur <= gc.data-end hard-assert
	mark-idx = gc.mark-cur - gc.mark-begin
	data-idx = gc.data-cur - gc.data-begin
	gc.mark-end - gc.mark-begin == gc.size-words hard-assert
	gc.data-end - gc.data-begin == gc.size-words hard-assert
	mark-idx == data-idx hard-assert

.try-gc-alloc any-mut-pointer?(gc gc-ctx, size-bytes nat64) noctx trusted
	&gc.gc.lk acquire
	res = gc.gc try-gc-alloc-recur size-bytes
	gc.gc maybe-set-needs-gc
	&gc.gc.lk release
	res

.maybe-set-needs-gc void(gc gc) noctx unsafe
	cur-word = gc.mark-cur - gc.mark-begin
	if cur-word > (gc.size-words unsafe-div 2)
		gc.needs-gc := true

.try-gc-alloc-recur any-mut-pointer?(gc gc, size-bytes nat64) noctx unsafe
	# TODO: support larger allocations than 256MB
	size-bytes < 0x10000000 hard-assert
	# gc validate-gc
	size-words = size-bytes words-of-bytes
	cur = gc data-cur
	next = cur + size-words
	if next < gc.data-end
		if non-free ?= gc.mark-cur first-non-free gc.mark-cur + size-words
			gc.data-cur := gc.data-cur + (non-free - gc.mark-cur) + 1
			gc.mark-cur := non-free + 1
			gc try-gc-alloc-recur size-bytes
		else
			gc.mark-cur := gc.mark-cur + size-words
			gc.data-cur := next
			cur.pointer-cast,

.first-non-free bool mut*?(mark bool mut*, end bool mut*) noctx unsafe
	if mark == end
		()
	elif *mark
		mark,
	else
		mark + 1 first-non-free end

gc-alloc any-mut-pointer(gc gc-ctx, size nat64) noctx trusted
	if res ?= gc try-gc-alloc size
		res
	else
		# TODO: throw an exception on OOM
		todo

alloc any-mut-pointer(size-bytes nat64) unsafe
	get-gc-ctx gc-alloc size-bytes

alloc-uninitialized<a> a mut*() unsafe
	1 alloc-uninitialized

alloc-uninitialized<a> a mut*(count nat64) unsafe
	get-gc-ctx alloc-uninitialized count

alloc-uninitialized<a> a mut*(gc gc-ctx, count nat64) noctx unsafe
	gc gc-alloc (count wrap-mul size-of@<a>) pointer-cast

alloc-uninitialized<a> a mut*(gc gc-ctx) noctx unsafe
	gc alloc-uninitialized 1

try-alloc-uninitialized<a> a mut*?(size nat64) unsafe
	get-gc-ctx try-alloc-uninitialized size

try-alloc-uninitialized<a> a mut*?(gc gc-ctx, size nat64) noctx unsafe
	if res ?= gc try-gc-alloc (size wrap-mul size-of@<a>)
		res.pointer-cast,

try-alloc-uninitialized<a> a mut*?() unsafe
	1 try-alloc-uninitialized

try-alloc-uninitialized<a> a mut*?(gc gc-ctx) noctx unsafe
	gc try-alloc-uninitialized 1

unmanaged-alloc-uninitialized<a> a mut*() noctx unsafe
	1 unmanaged-alloc-elements

unmanaged-alloc-bytes any-mut-pointer(size nat64) noctx unsafe
	res = size malloc
	res != null hard-assert
	res

unmanaged-alloc-zeroed-elements<a> a mut*(size-elements nat64) noctx unsafe
	res a mut* = size-elements unmanaged-alloc-elements
	res set-zero-range size-elements
	res

unmanaged-alloc-elements<a> a mut*(size-elements nat64) noctx unsafe
	# TODO: wrap-mul is unsafe!
	(size-elements wrap-mul size-of@<a>).unmanaged-alloc-bytes pointer-cast

unmanaged-free-elements<a> void(begin a mut*, _ nat64) noctx unsafe
	begin.as-any-mut-pointer free

unmanaged-free<a> void(p a mut*) noctx unsafe
	p.as-any-mut-pointer free

copy-data-from<a> void(to a mut*, from a*, len nat64) noctx unsafe
	_ = to.as-any-mut-pointer memcpy from.as-any-const-pointer, (len wrap-mul size-of@<a>)
	()
