no-std
import
	win32:
		CONTEXT, CONTEXT_FULL, GetCurrentProcess, GetCurrentThread, HANDLE,
		IMAGE_FILE_MACHINE_AMD64, new, RtlCaptureContext
	windows/DbgHelp:
		AddrPC, FileName, IMAGEHLP_LINE64, IMAGEHLP_SYMBOL64, LineNumber, Name, new, Offset,
		STACKFRAME64, StackWalk64, SymCleanup, SymGetLineFromAddr64, SymGetSymFromAddr64,
		SymFunctionTableAccess64, SymInitialize, SYMOPT_LOAD_LINES, SymSetOptions
	../bool: ||, true
	../bytes-types: new
	../cell: as-mut-ptr, cell, new
	../col/private/arr-low-level: arr-from-begin-end, new
	../compare: <=
	../misc: new, void
	../private/number-low-level: ==, <=>, nat8, nat32, nat64, unsafe-to-nat32, wrap-add, wrap-sub
	../ptr:
		==, +, *, as-any-const-ptr, as-const, by-val, mut-ptr, null, ptr-cast, ptr-to, ref-of-val,
		set-deref, size-of
	../version: is-interpreted, is-windows
	./alloc: copy-data-from, gc-ctx, try-alloc-uninitialized
	./bootstrap: char8, c-str, hard-assert, none, opt, some
	./c-str-util: c-str-size-incl-nul
	./libunwind:
		new, unw_context_t, unw_cursor_t, unw_getcontext, unw_get_proc_name, unw_init_local,
		unw_step, unw_word_t
export
	./bootstrap: backtrace, backtrace-entry, column-number, entries, file-path, function-name, line-number, new

.new backtrace() noctx
	(),

# Taking 'gc' explicitly to avoid accidental uses
get-backtrace backtrace(gc gc-ctx, skip nat64) noctx unsafe
	max-entries = 8
	opt-entries backtrace-entry mut*? = gc try-alloc-uninitialized max-entries
	if entries ?= opt-entries
		if is-interpreted
			end = entries interpreter-backtrace max-entries, skip
			gc copy-strings entries, end
			(entries.as-const arr-from-begin-end end.as-const),
		elif is-windows
			gc get-native-backtrace-windows entries, max-entries, (skip wrap-add 2)
		else
			gc get-native-backtrace-libunwind entries, max-entries, (skip wrap-add 1)

###
Implemented by interpreter only.
Returns the pointer to after the last entry written.
Result c-str are temporary, must copy!
###
.interpreter-backtrace backtrace-entry mut*(
	out backtrace-entry mut*,
	max-entries nat64,
	skip nat64,
) noctx unsafe builtin

.copy-strings void(gc gc-ctx, begin backtrace-entry mut*, end backtrace-entry mut*) noctx unsafe
	cur mut = begin
	until cur == end
		*cur := gc copy-c-strs *cur
		cur := cur + 1

.copy-c-strs backtrace-entry(gc gc-ctx, a backtrace-entry) noctx unsafe
	(gc copy-c-str-or-empty a.function-name), (gc copy-c-str-or-empty a.file-path), a.line-number, a.column-number

.get-native-backtrace-windows backtrace(
	gc gc-ctx,
	entries backtrace-entry mut*,
	max-entries nat64,
	skip nat64,
) noctx unsafe
	if vars ?= gc try-alloc-windows-backtrace-vars
		gc get-windows-backtrace-with-vars entries, max-entries, (skip wrap-add 1), vars

.get-windows-backtrace-with-vars backtrace(
	gc gc-ctx,
	entries backtrace-entry mut*,
	max-entries nat64,
	skip nat64,
	vars windows-backtrace-vars,
) noctx unsafe
	process = GetCurrentProcess
	thread = GetCurrentThread

	ok0 = process SymInitialize null, true
	hard-assert: ok0

	# For some reason this has to be on the stack. Failed when in 'windows-backtrace-vars'
	context CONTEXT = CONTEXT_FULL,
	context.ptr-to RtlCaptureContext
	frame STACKFRAME64 = context.ptr-to,

	_ = SYMOPT_LOAD_LINES SymSetOptions
	max-end = entries + max-entries
	end = gc windows-walk-backtrace entries, max-end, skip, process, thread, context.ptr-to, frame.ptr-to, vars
	ok1 = process SymCleanup
	hard-assert: ok1
	(entries.as-const arr-from-begin-end end.as-const),

.windows-backtrace-vars record by-val mut
	offset nat64 mut*
	displacement nat32 mut*
	symbol IMAGEHLP_SYMBOL64 mut*
	line IMAGEHLP_LINE64 mut*

.try-alloc-windows-backtrace-vars windows-backtrace-vars?(gc gc-ctx) noctx unsafe
	if offset ?= gc.try-alloc-uninitialized :: nat64 mut*?
		if displacement ?= gc.try-alloc-uninitialized :: nat32 mut*?
			symbol-max-name-length = 255
			symbol-size = size-of@<IMAGEHLP_SYMBOL64> wrap-add symbol-max-name-length wrap-add 1
			if symbol-buffer ?= (gc try-alloc-uninitialized symbol-size) :: nat8 mut*?
				symbol IMAGEHLP_SYMBOL64 mut* = symbol-buffer ptr-cast
				*symbol := symbol-max-name-length.unsafe-to-nat32,
				if line ?= gc.try-alloc-uninitialized :: IMAGEHLP_LINE64 mut*?
					*line := ()
					(offset, displacement, symbol, line) some

.new<a> a?() noctx
	none

.windows-walk-backtrace backtrace-entry mut*(
	gc gc-ctx
	out backtrace-entry mut*,
	out-end backtrace-entry mut*,
	skip nat64,
	process HANDLE,
	thread HANDLE,
	context CONTEXT mut*,
	frame STACKFRAME64 mut*,
	vars windows-backtrace-vars,
) noctx unsafe
	ctx = context as-any-const-ptr
	if out == out-end
		out
	elif IMAGE_FILE_MACHINE_AMD64 StackWalk64 process, thread, frame, ctx, null, &SymFunctionTableAccess64, null, null
		if skip == 0
			name c-str = if process SymGetSymFromAddr64 frame->AddrPC.Offset, vars.offset, vars.symbol
				gc copy-c-str-or-empty vars.symbol->Name.ptr-to
			else
				""
			*out := if process SymGetLineFromAddr64 frame->AddrPC.Offset, vars.displacement, vars.line
				name, (gc copy-c-str-or-empty vars.line->FileName), vars.line->LineNumber, 0
			else
				name, "", 0, 0
			gc windows-walk-backtrace out + 1, out-end, 0, process, thread, context, frame, vars
		else
			gc windows-walk-backtrace out, out-end, (skip wrap-sub 1), process, thread, context, frame, vars
	else
		out

.copy-c-str-or-empty c-str(gc gc-ctx, a c-str) noctx unsafe
	size = a c-str-size-incl-nul
	if out ?= (gc try-alloc-uninitialized size) :: char8 mut*?
		out copy-data-from a, size
		out as-const
	else
		""

.get-native-backtrace-libunwind backtrace
	gc gc-ctx
	entries backtrace-entry mut*
	max-entries nat64
	skip nat64
spec
	noctx
	unsafe
body
	cursor-val by-val unw_cursor_t = (),
	cursor = cursor-val ref-of-val
	context-val by-val unw_context_t = (),
	context = context-val ref-of-val
	err0 = context unw_getcontext
	hard-assert: err0 == 0
	err1 = cursor unw_init_local context
	hard-assert: err1 == 0
	# omit 'get-native-backtrace' in addition to other skipped
	cursor unwind-skip (skip wrap-add 1)
	end = gc unwind-recur entries, entries + max-entries, cursor
	(entries.as-const arr-from-begin-end end.as-const),

.unwind-skip void(cursor unw_cursor_t, skip nat64) noctx unsafe
	unless skip == 0
		_ = cursor unw_step
		cursor unwind-skip (skip wrap-sub 1)

# Returns one past the last entry written to
.unwind-recur backtrace-entry mut*(
	gc gc-ctx,
	out-cur backtrace-entry mut*,
	out-end backtrace-entry mut*,
	cursor unw_cursor_t,
) noctx unsafe
	if out-cur == out-end || cursor.unw_step <= 0
		out-cur
	else
		offset by-val cell unw_word_t = 0,
		buf-size = 256
		buf-try char8 mut*? = gc try-alloc-uninitialized buf-size
		if buf ?= buf-try
			err = cursor unw_get_proc_name buf, buf-size, offset.ref-of-val.as-mut-ptr
			*out-cur := if err == 0
				# TODO: get filename and line number too
				buf.as-const, "", 0, 0
			else
				"", "", 0, 0
			gc unwind-recur out-cur + 1, out-end, cursor
		else
			*out-cur := "<<out of memory for backtrace>>", "", 0, 0
			out-cur + 1
