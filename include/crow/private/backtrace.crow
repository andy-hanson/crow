no-std
import
	sys/execinfo: backtrace
	../compare: <, <=, >
	../misc: name, named-val, val
	../ptr: +, ==, <=>, any-ptr, ptr, set-subscript, subscript
	./alloc: copy-data-from!, try-alloc-uninitialized
	./bootstrap: arr, as, begin-ptr, hard-assert, nat64, opt, size, some, sym, void
	./number-low-level:
		==, <=>, to-int64, unsafe-div, unsafe-to-int64, unsafe-to-int32, unsafe-to-nat64, wrap-add,
		wrap-sub
export
	./bootstrap: all-funs, backtrace, return-stack

get-backtrace backtrace() unsafe
	# Being careful to avoid calling functions that may throw here
	if arrs ?= try-alloc-backtrace-arrs
		n-code-ptrs = (arrs.code-ptrs backtrace code-ptrs-size.unsafe-to-int64.unsafe-to-int32).to-int64.unsafe-to-nat64
		hard-assert: n-code-ptrs <= code-ptrs-size
		arrs.funs copy-data-from! all-funs.begin-ptr, all-funs.size
		arrs.funs sort! all-funs.size
		end-code-names = arrs.code-names + n-code-ptrs
		arrs.code-names fill-code-names! end-code-names, arrs.code-ptrs, arrs.funs
		backtrace: n-code-ptrs arr<sym> arrs.code-names
	else
		backtrace: as<sym[]>: []

.fill-code-names! void
	code-names ptr sym
	end-code-names ptr sym
	code-ptrs ptr any-ptr
	funs ptr named-val any-ptr
spec
	unsafe
body
	if code-names < end-code-names
		code-names[] := code-ptrs[] get-fun-name funs, all-funs.size
		code-names + 1 fill-code-names! end-code-names, code-ptrs + 1, funs

.code-ptrs-size nat64()
	8

.backtrace-arrs record mut
	code-ptrs ptr any-ptr
	code-names ptr sym
	funs ptr named-val any-ptr

.try-alloc-backtrace-arrs opt backtrace-arrs() unsafe
	size = 8
	if code-ptrs ?= size try-alloc-uninitialized<any-ptr>
		if code-names ?= size try-alloc-uninitialized<sym>
			if funs ?= all-funs.size try-alloc-uninitialized<named-val any-ptr>
				some: backtrace-arrs: code-ptrs, code-names, funs

.get-fun-name sym(code-ptr any-ptr, funs ptr named-val any-ptr, size nat64) unsafe noctx
	# TODO: this will fail to give a name for the last function
	if size < 2
		'<<UNKNOWN>>'
	elif code-ptr < funs[1].val
		funs[].name
	else
		code-ptr get-fun-name: funs + 1, size wrap-sub 1

# TODO: use the one from sort.crow
.sort! void(a ptr named-val any-ptr, size nat64) noctx unsafe
	if size > 1
		a swap!: 0, size unsafe-div 2
		after-pivot = a partition! a[].val, 1, (size wrap-sub 1)
		new-pivot-index = after-pivot wrap-sub 1
		a swap! 0, new-pivot-index
		a sort! new-pivot-index
		a + after-pivot sort!: size wrap-sub after-pivot

.partition! nat64(a ptr named-val any-ptr, pivot any-ptr, l nat64, r nat64) noctx unsafe
	if l <= r
		if a[l].val < pivot
			a partition! pivot, (l wrap-add 1), r
		else
			a swap! l, r
			a partition! pivot, l, (r wrap-sub 1)
	else
		l

.swap! void(a ptr ?a, lo nat64, hi nat64) noctx unsafe
	temp = a[lo]
	a[lo] := a[hi]
	a[hi] := temp
