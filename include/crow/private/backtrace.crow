no-std
import
	win32:
		CONTEXT, CONTEXT_FULL, GetCurrentProcess, GetCurrentThread, HANDLE,
		IMAGE_FILE_MACHINE_AMD64, new, RtlCaptureContext
	windows/DbgHelp:
		AddrPC, FileName, IMAGEHLP_LINE64, IMAGEHLP_SYMBOL64, LineNumber, Name, new, Offset,
		STACKFRAME64, StackWalk64, SymCleanup, SymGetLineFromAddr64, SymGetSymFromAddr64,
		SymFunctionTableAccess64, SymInitialize, SYMOPT_LOAD_LINES, SymSetOptions
	../bool: ||, true
	../bytes-types: new
	../cell: as-mut-ptr, cell, new
	../col/private/arr-low-level: arr-from-begin-end, new
	../compare: <=
	../misc: new, void
	../private/number-low-level: ==, <=>, nat8, nat32, nat64, unsafe-to-nat32, wrap-add, wrap-sub
	../ptr:
		==, +, *, as-any-const-ptr, as-const, by-val, mut-ptr, null, ptr-cast, ptr-to, ref-of-val,
		set-deref, size-of
	../version: is-interpreted, is-windows
	./alloc: copy-data-from, try-alloc-uninitialized
	./bootstrap: char8, c-str, hard-assert, none, opt, some
	./c-str-util: c-str-size-incl-nul
	./libunwind:
		new, unw_context_t, unw_cursor_t, unw_getcontext, unw_get_proc_name, unw_init_local,
		unw_step, unw_word_t
export
	./bootstrap: backtrace, backtrace-entry, column-number, entries, file-path, function-name, line-number, new

.new backtrace()
	(),

get-backtrace backtrace(skip nat64) unsafe
	max-entries = 8
	opt-entries backtrace-entry mut*? = max-entries try-alloc-uninitialized
	if entries ?= opt-entries
		if is-interpreted
			end = entries interpreter-backtrace max-entries, skip
			entries copy-strings end
			(entries.as-const arr-from-begin-end end.as-const),
		elif is-windows
			entries get-native-backtrace-windows max-entries, (skip wrap-add 2)
		else
			entries get-native-backtrace-libunwind max-entries, (skip wrap-add 1)

###
Implemented by interpreter only.
Returns the pointer to after the last entry written.
Result c-str are temporary, must copy!
###
.interpreter-backtrace backtrace-entry mut*
	out backtrace-entry mut*
	max-entries nat64
	skip nat64
spec
	noctx
	unsafe
	builtin

.copy-strings void(begin backtrace-entry mut*, end backtrace-entry mut*) unsafe
	cur mut = begin
	until cur == end
		*cur := cur->copy-c-strs
		cur := cur + 1

.copy-c-strs backtrace-entry(a backtrace-entry) unsafe
	a.function-name.copy-c-str-or-empty, a.file-path.copy-c-str-or-empty, a.line-number, a.column-number

.get-native-backtrace-windows backtrace
	entries backtrace-entry mut*
	max-entries nat64
	skip nat64
spec
	unsafe
body
	if vars ?= try-alloc-windows-backtrace-vars
		entries get-windows-backtrace-with-vars max-entries, (skip wrap-add 1), vars

.get-windows-backtrace-with-vars backtrace
	entries backtrace-entry mut*
	max-entries nat64
	skip nat64
	vars windows-backtrace-vars
spec
	unsafe
body
	process = GetCurrentProcess
	thread = GetCurrentThread

	ok0 = process SymInitialize null, true
	hard-assert: ok0

	# For some reason this has to be on the stack. Failed when in 'windows-backtrace-vars'
	context CONTEXT = CONTEXT_FULL,
	context.ptr-to RtlCaptureContext
	frame STACKFRAME64 = context.ptr-to,

	_ = SYMOPT_LOAD_LINES SymSetOptions
	max-end = entries + max-entries
	end = entries windows-walk-backtrace max-end, skip, process, thread, context.ptr-to, frame.ptr-to, vars
	ok1 = process SymCleanup
	hard-assert: ok1
	(entries.as-const arr-from-begin-end end.as-const),

.windows-backtrace-vars record by-val mut
	offset nat64 mut*
	displacement nat32 mut*
	symbol IMAGEHLP_SYMBOL64 mut*
	line IMAGEHLP_LINE64 mut*

.try-alloc-windows-backtrace-vars windows-backtrace-vars?() unsafe
	if offset ?= try-alloc-uninitialized :: nat64 mut*?
		if displacement ?= try-alloc-uninitialized :: nat32 mut*?
			symbol-max-name-length = 255
			symbol-size = size-of@<IMAGEHLP_SYMBOL64> wrap-add symbol-max-name-length wrap-add 1
			if symbol-buffer ?= symbol-size.try-alloc-uninitialized :: nat8 mut*?
				symbol IMAGEHLP_SYMBOL64 mut* = symbol-buffer ptr-cast
				*symbol := symbol-max-name-length.unsafe-to-nat32,
				if line ?= try-alloc-uninitialized :: IMAGEHLP_LINE64 mut*?
					*line := ()
					(offset, displacement, symbol, line) some

.new<a> a?() noctx
	none

.windows-walk-backtrace backtrace-entry mut*
	out backtrace-entry mut*
	out-end backtrace-entry mut*
	skip nat64
	process HANDLE
	thread HANDLE
	context CONTEXT mut*
	frame STACKFRAME64 mut*
	vars windows-backtrace-vars
spec
	unsafe
body
	ctx = context as-any-const-ptr
	if out == out-end
		out
	elif IMAGE_FILE_MACHINE_AMD64 StackWalk64 process, thread, frame, ctx, null, &SymFunctionTableAccess64, null, null
		if skip == 0
			name c-str = if process SymGetSymFromAddr64 frame->AddrPC.Offset, vars.offset, vars.symbol
				vars.symbol->Name.ptr-to copy-c-str-or-empty
			else
				""
			*out := if process SymGetLineFromAddr64 frame->AddrPC.Offset, vars.displacement, vars.line
				name, vars.line->FileName.copy-c-str-or-empty, vars.line->LineNumber, 0
			else
				name, "", 0, 0
			out + 1 windows-walk-backtrace out-end, 0, process, thread, context, frame, vars
		else
			out windows-walk-backtrace out-end, (skip wrap-sub 1), process, thread, context, frame, vars
	else
		out

.copy-c-str-or-empty c-str(a c-str) unsafe
	size = a c-str-size-incl-nul
	if out ?= size.try-alloc-uninitialized :: char8 mut*?
		out copy-data-from a, size
		out as-const
	else
		""

.get-native-backtrace-libunwind backtrace(entries backtrace-entry mut*, max-entries nat64, skip nat64) unsafe
	cursor-val by-val unw_cursor_t = (),
	cursor = cursor-val ref-of-val
	context-val by-val unw_context_t = (),
	context = context-val ref-of-val
	err0 = context unw_getcontext
	hard-assert: err0 == 0
	err1 = cursor unw_init_local context
	hard-assert: err1 == 0
	# omit 'get-native-backtrace' in addition to other skipped
	cursor unwind-skip (skip wrap-add 1)
	end = entries unwind-recur entries + max-entries, cursor
	(entries.as-const arr-from-begin-end end.as-const),

.unwind-skip void(cursor unw_cursor_t, skip nat64) unsafe
	unless skip == 0
		_ = cursor unw_step
		cursor unwind-skip (skip wrap-sub 1)

# Returns one past the last entry written to
.unwind-recur backtrace-entry mut*
	out-cur backtrace-entry mut*
	out-end backtrace-entry mut*
	cursor unw_cursor_t
spec
	unsafe
body
	if out-cur == out-end || cursor.unw_step <= 0
		out-cur
	else
		offset by-val cell unw_word_t = 0,
		buf-size = 256
		buf-try char8 mut*? = buf-size try-alloc-uninitialized
		if buf ?= buf-try
			err = cursor unw_get_proc_name buf, buf-size, offset.ref-of-val.as-mut-ptr
			*out-cur := if err == 0
				# TODO: get filename and line number too
				buf.as-const, "", 0, 0
			else
				"", "", 0, 0
			out-cur + 1 unwind-recur out-end, cursor
		else
			*out-cur := "<<out of memory for backtrace>>", "", 0, 0
			out-cur + 1
