no-std
import
	../bool: bool, false, true
	../col/mut-list: move-to
	../misc: new, void
	../pointer: mut-pointer
	../result: error, ok, result
	./bootstrap:
		awaited-by, empty, exception-and-backtrace, fiber, future, future-state, hard-unreachable, is-running, lk, new, rejected, resolved, set-state, state, todo
	./exception-low-level: rethrow
	./runtime: enqueue-fiber, enqueue-fibers, get-global-ctx
	./thread-utils: acquire, init, lock, release, uninit

# If the future is already complete, returns 'false'
~add-awaiting-fiber[t] bool(a t future, fiber fiber) bare, unsafe
	forbid fiber is-running
	&a.lk acquire
	res bool = match a state
	as empty
		a.state := fiber awaited-by
		true
	as awaited-by _
		todo
		#a.state := (x, fiber) awaited-by-multiple
		#true
	as awaited-by-multiple _
		todo
	as resolved _
		false
	as rejected _
		false
	&a.lk release
	res

~unresolved[t] t future() unsafe
	res t future = uninit, empty
	res.lock init
	res

-lock[t] lock mut*(a t future) bare, unsafe
	&a.lk

~resolve[t] void(a t future, value t) unsafe
	a resolve-or-reject value.resolved

~reject[t] void(a t future, error exception-and-backtrace) unsafe
	a resolve-or-reject error.rejected

~is-completed[t] bool(a t future)
	match a state
	as empty
		false
	as awaited-by _
		false
	as awaited-by-multiple _
		false
	as resolved _
		true
	as rejected _
		true

-resolve-or-reject[t] void(a t future, new-state t future-state) unsafe
	a.lock acquire
	old-state = a state
	a.state := new-state
	a.lock release
	match old-state
	as empty
		()
	as awaited-by fiber
		get-global-ctx enqueue-fiber fiber
	as awaited-by-multiple fibers
		get-global-ctx enqueue-fibers fibers.move-to
	as resolved _
		hard-unreachable
	as rejected _
		hard-unreachable

~must-get-result[t] t(a t future) bare, unsafe
	match a.get-result
	as ok x
		x
	as error x
		x rethrow

# Assuming the future is resolved, get the result.
~get-result[t] (t, exception-and-backtrace) result(a t future) bare, unsafe
	a.lock acquire
	res (t, exception-and-backtrace) result = match a state
	as empty
		hard-unreachable
	as awaited-by _
		hard-unreachable
	as awaited-by-multiple _
		hard-unreachable
	as resolved x
		x ok
	as rejected x
		x error
	a.lock release
	res
