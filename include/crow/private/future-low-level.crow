no-std
import
	../bool: bool, false, true
	../misc: new, void
	../option: ??, new
	../pointer: mut-pointer
	../result: error, ok, result
	./bootstrap:
		awaiting-future, awaited-by, empty, exception-and-backtrace, fiber, future, future-state,
		hard-unreachable, lk, new, queued, rejected, resolved, set-state, state
	./exception-low-level: rethrow
	./runtime: enqueue-fiber, get-global-ctx
	./thread-utils: acquire, init, lock, release, uninit

# If the future is already complete, returns 'false'
~try-add-awaiting-fiber[t] bool(a t future, fiber fiber) bare, unsafe, native extern
	&a.lk acquire
	res bool = match a state
	as empty
		a.state := fiber awaited-by
		fiber.state := () awaiting-future
		true
	as awaited-by x
		fiber.state := (x,) awaiting-future
		a.state := fiber awaited-by
		true
	as resolved _
		false
	as rejected _
		false
	&a.lk release
	res

~unresolved[t] t future() unsafe, native extern
	res t future = uninit, empty
	res.lock init
	res

-lock[t] lock mut*(a t future) bare, unsafe, native extern
	&a.lk

~resolve[t] void(a t future, value t) unsafe, native extern
	a resolve-or-reject value.resolved

~reject[t] void(a t future, error exception-and-backtrace) unsafe, native extern
	a resolve-or-reject error.rejected

~is-completed[t] bool(a t future)
	match a state
	as empty
		false
	as awaited-by _
		false
	as resolved _
		true
	as rejected _
		true

-resolve-or-reject[t] void(a t future, new-state t future-state) bare, unsafe, native extern
	a.lock acquire
	old-state = a state
	a.state := new-state
	a.lock release
	match old-state
	as empty
		()
	as awaited-by fiber
		cur mut = fiber
		loop
			opt-next = cur.state.awaiting-future ?? hard-unreachable
			cur.state := queued
			get-global-ctx enqueue-fiber cur
			if next ?= opt-next
				cur := next
				continue
			else
				break
	as resolved _
		hard-unreachable
	as rejected _
		hard-unreachable

~must-get-result[t] t(a t future) bare, unsafe, native extern
	match a.get-result
	as ok x
		x
	as error x
		x rethrow

# Assuming the future is resolved, get the result.
~get-result[t] (t, exception-and-backtrace) result(a t future) bare, unsafe, native extern
	a.lock acquire
	res (t, exception-and-backtrace) result = match a state
	as empty
		hard-unreachable
	as awaited-by _
		hard-unreachable
	as resolved x
		x ok
	as rejected x
		x error
	a.lock release
	res
