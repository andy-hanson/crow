no-std
import
	../bool: bool, false, true
	../misc: new, void
	../option: is-empty, new
	../pointer: mut-pointer
	../result: error, ok, result
	./bootstrap:
		awaited-by, empty, exception-and-backtrace, fiber, future, future-state, hard-assert,
		hard-forbid, hard-unreachable, is-running, lk, next-awaiting, new, rejected, resolved,
		set-next-awaiting, set-state, state
	./exception-low-level: rethrow
	./runtime: enqueue-fiber, get-global-ctx
	./thread-utils: acquire, init, lock, release, uninit

# If the future is already complete, returns 'false'
~try-add-awaiting-fiber[t] bool(a t future, fiber fiber) bare, unsafe
	fiber.is-running hard-forbid
	fiber.next-awaiting.is-empty hard-assert
	&a.lk acquire
	res bool = match a state
	as empty
		a.state := fiber awaited-by
		true
	as awaited-by x
		fiber.next-awaiting := x,
		a.state := fiber awaited-by
		true
	as resolved _
		false
	as rejected _
		false
	&a.lk release
	res

~unresolved[t] t future() unsafe
	res t future = uninit, empty
	res.lock init
	res

-lock[t] lock mut*(a t future) bare, unsafe
	&a.lk

~resolve[t] void(a t future, value t) unsafe
	a resolve-or-reject value.resolved

~reject[t] void(a t future, error exception-and-backtrace) unsafe
	a resolve-or-reject error.rejected

~is-completed[t] bool(a t future)
	match a state
	as empty
		false
	as awaited-by _
		false
	as resolved _
		true
	as rejected _
		true

-resolve-or-reject[t] void(a t future, new-state t future-state) unsafe
	a.lock acquire
	old-state = a state
	a.state := new-state
	a.lock release
	match old-state
	as empty
		()
	as awaited-by fiber
		cur mut = fiber
		loop
			get-global-ctx enqueue-fiber cur
			if next ?= cur next-awaiting
				cur.next-awaiting := ()
				cur := next
				continue
			else
				break
	as resolved _
		hard-unreachable
	as rejected _
		hard-unreachable

~must-get-result[t] t(a t future) bare, unsafe
	match a.get-result
	as ok x
		x
	as error x
		x rethrow

# Assuming the future is resolved, get the result.
~get-result[t] (t, exception-and-backtrace) result(a t future) bare, unsafe
	a.lock acquire
	res (t, exception-and-backtrace) result = match a state
	as empty
		hard-unreachable
	as awaited-by _
		hard-unreachable
	as resolved x
		x ok
	as rejected x
		x error
	a.lock release
	res
