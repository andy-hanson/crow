no-std
import
	../col/array: array
	../col/list: for-loop, list, tail, to-list
	../col/private/array-low-level: subscript
	../fun-util: fun-ptr1, subscript
	../fut: delay, fut, handle-exceptions, then-void
	../misc: new, void
	../number: ==, <=>, +, -, int32, nat64, to-int32, to-int64, to-nat64
	../ptr:
		+, any-mut-ptr, as-any-mut-ptr, as-const, as-ref, by-val, const-ptr, mut-ptr, null,
		set-deref, set-subscript, subscript
	../range: ..
	../str: c-str, str
	../str-util: to-str
	./alloc: unmanaged-alloc-elements, unmanaged-free
	./bootstrap: call-with-ctx
	./fut-low-level: get-result
	./runtime:
		after-task, any-unhandled-exceptions, before-task, free, get-global-ctx, global-ctx, init,
		thread-function, uninit
	./sym-low-level: init-symbol-table
	./thread-utils: count-processors, create-one-thread, join-one-thread, thread-handle

.main-ptr alias
	fun-ptr1<fut nat64, str[]>

# Treated specially by the compiler
rt-main int32(argc int32, argv c-str*, main-ptr main-ptr) trusted noctx summon
	do-init-constants
	n-threads = count-processors
	gctx-by-val mut by-val global-ctx = n-threads uninit
	gctx global-ctx = &gctx-by-val
	gctx init
	main-fut = gctx add-main-task argc, argv, main-ptr
	n-threads run-threads gctx
	res = gctx exit-code-from-main-fut main-fut
	gctx free
	res

.exit-code-from-main-fut int32(gctx global-ctx, main-fut fut nat64) unsafe noctx
	match main-fut get-result
	as ok v
		# TODO: handle nat64 too big for int32
		if gctx any-unhandled-exceptions
			1
		else
			v.to-int64 to-int32
	as err _
		# 'handle-exceptions' should have logged the error
		1

# TODO:KILL (using this to narrow down scope of error)
.do-init-constants void() unsafe noctx summon
	init-constants

init-constants void() unsafe noctx summon builtin

.add-main-task fut nat64(
	gctx global-ctx,
	argc int32,
	argv c-str*,
	main-ptr main-ptr,
) trusted noctx
	# Create a ctx manually so we can call functions that need it when creating the task
	gctx before-task 0
	add act fut nat64(array c-str, main-ptr) = (all-args, main-ptr-2) =>
		all-args add-first-task main-ptr-2
	all-args = argv[0 .. argc.to-int64.to-nat64]
	res = add call-with-ctx all-args, main-ptr
	after-task
	res

.thread-args record mut by-ref
	thread-id nat64
	gctx global-ctx

# TODO: if mut-bag-node is in unmanaged memory, don't need ctx for this
# We want main-fut to be available immediately, not after having run some user code.
# So we create main-fut now, and forward the result of 'main' to that.
.add-first-task fut nat64(all-args array c-str, main-ptr fun-ptr1<fut nat64, str[]>) unsafe
	# 'then' is useful here -- it handles any errors in 'main' and gets us main-fut immediately.
	# TODO: 'then' overload for fut<void> taking lambda with 0 params
	res = delay then-void () =>
		get-global-ctx init-symbol-table
		# First argument is the path to this executable; omit from crow main
		main-ptr[for arg : all-args.to-list.tail; arg to-str]
	res handle-exceptions
	res

# Each thread will get the thread ID, and the common arguments.
.run-threads void(n-threads nat64, gctx global-ctx) noctx unsafe summon
	threads thread-handle mut* = n-threads unmanaged-alloc-elements
	thread-args by-val<thread-args> mut* = n-threads unmanaged-alloc-elements

	actual-n-threads = n-threads - 1

	0 start-threads-recur actual-n-threads, threads, thread-args, gctx
	actual-n-threads thread-function gctx
	0 join-threads-recur actual-n-threads, threads.as-const

	threads unmanaged-free
	thread-args unmanaged-free

.start-threads-recur void(
	i nat64,
	n-threads nat64,
	threads thread-handle mut*,
	thread-args-begin by-val<thread-args> mut*,
	gctx global-ctx,
) noctx unsafe summon
	unless i == n-threads
		thread-arg-ptr = thread-args-begin + i
		*thread-arg-ptr := i, gctx
		threads[i] := thread-arg-ptr.as-any-mut-ptr create-one-thread &thread-fun
		i + 1 start-threads-recur n-threads, threads, thread-args-begin, gctx

.thread-fun any-mut-ptr(args-ptr any-mut-ptr) noctx unsafe summon
	args thread-args = args-ptr as-ref
	args.thread-id thread-function args.gctx
	null

.join-threads-recur void(i nat64, n-threads nat64, threads thread-handle*) noctx unsafe summon
	unless i == n-threads
		threads[i] join-one-thread
		i + 1 join-threads-recur n-threads, threads
