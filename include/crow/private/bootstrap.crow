no-std

region basic types

void builtin

void void() noctx builtin

as<a> a(value a) noctx builtin

###
A type is data if it is:
* A primitive
* A record or union of pure types
###
data<a> builtin-spec

# A type is sendable if it does not have any thread-unsafe mutable state.
send<a> builtin-spec

## TODO: extern<a> builtin-spec for extern ptr types

region opt.crow

opt<a> union
	none
	some a

region result.crow

# Union that represents a value that may have failed.
result<ok, err> union
	ok ok
	err err

region ptr.crow

by-val<a> builtin

###
A raw pointer. GC will not trace these.
WARN: If a is a reference type, mut-ptr<a> is a pointer to a pointer to a
###
mut-ptr<a> builtin mut
const-ptr<a> builtin

any-const-ptr alias
	nat8*
any-mut-ptr alias
	nat8 mut*

region arr

###
Array of values.

For a mutable version, see the `mut-arr` module.

This is implemented as a pointer and a length, also known as a "fat pointer".
This means this is also the type for a slice of an array, and slicing is O(1).

A slice does not keep the whole array alive, only the elements it can reach;
elements not reachable by any slice will be garbage collected.
###
arr<a> record
	by-val
	size nat64
	begin-ptr a*

region str

# Single character in a string.
# This could be any UTF-8 code point.
char builtin
# String type.
str record
	by-val
	chars char[]
###
C-style string. Always const.
This should be a valid pointer whose content ends in a "\0", though this is not enforced.
Thus, all operations on `c-str` are unsafe.
###
c-str alias
	char*

to-char char(a nat8) noctx builtin
to-nat8 nat8(c char) noctx builtin

region bool.crow

bool builtin
false bool() noctx builtin
true bool() noctx builtin

region sym.crow

sym record
	by-val
	to-c-str c-str

region bootstrap arithmetic

# The compiler needs special access to these types to support number literals

nat8 builtin
nat16 builtin
nat32 builtin
nat64 builtin
int8 builtin
int16 builtin
int32 builtin
int64 builtin
float32 builtin
float64 builtin

region hard assertions

abort void() noctx unsafe extern

###
Zeroed data isn't safe as it would contain null pointers.
It's GC-safe though, since the GC treats a null pointer same as any external pointer.
###
zeroed<a> a() noctx unsafe builtin

hard-unreachable<a> a() unsafe noctx
	abort
	zeroed

todo<a> a() trusted noctx
	## TODO: soft-fail, remove 'trusted noctx' above
	abort
	zeroed

hard-assert void(condition bool) noctx unsafe
	if condition
		void
	else
		abort

hard-forbid void(condition bool) noctx unsafe
	if condition
		abort

region bootstrap runtime

# Since this fun is not marked 'noctx', it simply returns the ctx that already exists.
get-ctx ctx() unsafe builtin

# The ctx only exists temporarily, so can use 'any-const-ptr' without worrying about GC
ctx record mut
	by-ref
	gctx-ptr any-mut-ptr
	island-id island-id
	exclusion exclusion
	gc-ctx-ptr any-mut-ptr
	thread-local-stuff thread-local-stuff

thread-local-stuff record mut
	by-ref
	thread-id nat64
	print-lock lock
	exception-ctx-ptr any-mut-ptr
	log-ctx-ptr any-mut-ptr
	perf-ctx-ptr any-mut-ptr

island-id alias
	nat64

exclusion alias
	nat64

island-and-exclusion record
	by-val
	island island-id
	exclusion exclusion

region fun

# Low-level function pointer type. Must point to `noctx` code.
fun-ptr0<r> builtin
fun-ptr1<r, p0> builtin
fun-ptr2<r, p0, p1> builtin
fun-ptr3<r, p0, p1, p2> builtin
fun-ptr4<r, p0, p1, p2, p3> builtin
fun-ptr5<r, p0, p1, p2, p3, p4> builtin
fun-ptr6<r, p0, p1, p2, p3, p4, p5> builtin

###
Don't reference directly, instead use syntax `fun r(p0, p1)`
Contrasted with `act`, a fun can't close over mutable data, so is thread-safe.
It can still close over `send` data and perform I/O, so it's not a completely pure function.
###
fun0<r> builtin sendable
fun1<r, p0> builtin sendable
fun2<r, p0, p1> builtin sendable
fun3<r, p0, p1, p2> builtin sendable
fun4<r, p0, p1, p2, p3> builtin sendable

###
Don't reference directly, instead use syntax `act r(p0, p1)`
Can close over anything. Can only be run by the exclusion context that created it.
###
fun-act0<r> builtin mut
fun-act1<r, p0> builtin mut
fun-act2<r, p0, p1> builtin mut
fun-act3<r, p0, p1, p2> builtin mut
fun-act4<r, p0, p1, p2, p3> builtin mut

###
Don't reference directly, instead use syntax `act r(p0, p1)`
This wraps an `act` combined with the island/exclusion it came from, and becomes sendable
since the `act` can't be called directly. Instead, it adds a task to the island.
###
fun-ref0<r> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut r()
fun-ref1<r, p0> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut r(p0)
fun-ref2<r, p0, p1> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut r(p0, p1)
fun-ref3<r, p0, p1, p2> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut r(p0, p1, p2)
fun-ref4<r, p0, p1, p2, p3> record force-sendable
	by-val
	island-and-exclusion island-and-exclusion
	fun act fut r(p0, p1, p2, p3)

# Calls the function and returns its return value.
subscript<r, p0, p1> r(a fun-ptr0 r) noctx builtin
subscript<r, p0> r(a fun-ptr1<r, p0>, p0 p0) noctx builtin
subscript<r, p0, p1> r(a fun-ptr2<r, p0, p1>, p0 p0, p1 p1) noctx builtin
subscript<r, p0, p1, p2> r(a fun-ptr3<r, p0, p1, p2>, p0 p0, p1 p1, p2 p2) noctx builtin
subscript<r, p0, p1, p2, p3> r(a fun-ptr4<r, p0, p1, p2, p3>, p0 p0, p1 p1, p2 p2, p3 p3) noctx builtin
subscript<r, p0, p1, p2, p3, p4> r(a fun-ptr5<r, p0, p1, p2, p3, p4>, p0 p0, p1 p1, p2 p2, p3 p3, p4 p4) noctx builtin
subscript<r, p0, p1, p2, p3, p4, p5> r
	a fun-ptr6<r, p0, p1, p2, p3, p4, p5>
	p0 p0
	p1 p1
	p2 p2
	p3 p3
	p4 p4
	p5 p5
spec
	noctx
	builtin

# Calls the function and returns its return value.
subscript<r> r(a fun r()) trusted
	a call-with-ctx get-ctx
subscript<r, p0> r(a fun r(p0), p0 p0) trusted
	a call-with-ctx get-ctx, p0
subscript<r, p0, p1> r(a fun r(p0, p1), p0 p0, p1 p1) trusted
	a call-with-ctx get-ctx, p0, p1
subscript<r, p0, p1, p2> r(a fun r(p0, p1, p2), p0 p0, p1 p1, p2 p2) trusted
	a call-with-ctx get-ctx, p0, p1, p2
subscript<r, p0, p1, p2, p3> r(a fun r(p0, p1, p2, p3), p0 p0, p1 p1, p2 p2, p3 p3) trusted
	a call-with-ctx get-ctx, p0, p1, p2, p3

# Calls the function and returns its return value.
subscript<r> r(a act r()) trusted
	a call-with-ctx get-ctx
subscript<r, p0> r(a act r(p0), p0 p0) trusted
	a call-with-ctx get-ctx, p0
subscript<r, p0, p1> r(a act r(p0, p1), p0 p0, p1 p1) trusted
	a call-with-ctx get-ctx, p0, p1
subscript<r, p0, p1, p2> r(a act r(p0, p1, p2), p0 p0, p1 p1, p2 p2) trusted
	a call-with-ctx get-ctx, p0, p1, p2
subscript<r, p0, p1, p2, p3> r(a act r(p0, p1, p2, p3), p0 p0, p1 p1, p2 p2, p3 p3) trusted
	a call-with-ctx get-ctx, p0, p1, p2, p3

call-with-ctx<r> r(f fun r(), c ctx) noctx builtin
call-with-ctx<r> r(f act r(), c ctx) noctx builtin
call-with-ctx<r, p0> r(f fun r(p0), c ctx, p0 p0) noctx builtin
call-with-ctx<r, p0> r(f act r(p0), c ctx, p0 p0) noctx builtin
call-with-ctx<r, p0, p1> r(f fun r(p0, p1), c ctx, p0 p0, p1 p1) noctx builtin
call-with-ctx<r, p0, p1> r(f act r(p0, p1), c ctx, p0 p0, p1 p1) noctx builtin
call-with-ctx<r, p0, p1, p2> r(f fun r(p0, p1, p2), c ctx, p0 p0, p1 p1, p2 p2) noctx builtin
call-with-ctx<r, p0, p1, p2> r(f act r(p0, p1, p2), c ctx, p0 p0, p1 p1, p2 p2) noctx builtin
call-with-ctx<r, p0, p1, p2, p3> r(f fun r(p0, p1, p2, p3), c ctx, p0 p0, p1 p1, p2 p2, p3 p3) noctx builtin
call-with-ctx<r, p0, p1, p2, p3> r(f act r(p0, p1, p2, p3), c ctx, p0 p0, p1 p1, p2 p2, p3 p3) noctx builtin

region fut

backtrace record
	by-val
	return-stack sym[]

exception record
	by-val
	message str
	## TODO: accessing backtrace should be unsafe
	backtrace backtrace

fut<a> record force-sendable
	lk by-val lock
	state mut fut-state a

fut-state<a> union mut
	fut-state-no-callbacks
	fut-state-callbacks fut-state-callbacks<a>
	fut-state-resolved a
	fut-state-exception exception

fut-state-callbacks<a> record mut
	by-ref
	# WARN: the cb will be called with whatever ctx resolves the fut, not the ctx that created it
	cb act void(result<a, exception>)
	next fut-state-callbacks<a>?

region lock

atomic-bool record force-sendable
	value mut bool

# TODO: use pthread lock
lock record sendable
	by-ref
	is-locked by-val atomic-bool

region reflect

named-val<a> record
	by-val
	name sym
	val a

# all symbols that exist in the compiled code, in arbitrary order
static-syms sym[]() noctx builtin

# all named functions in arbitrary order
all-funs named-val<any-const-ptr>[]() noctx unsafe builtin
