no-std

region basic types

###
Empty type, for use by functions with nothing in particular to return.
###
void builtin extern

new-void void() noctx builtin

###
Specifies that a type must be immutable data.

This includes most types in crow that are not `mut`.
This does not include `future` or `ref`, though these types work with `is-sendable`.

To put it another way, a type works with `is-data` if it is:
* A primitive like `nat`, an `enum`, or `flags`.
* A record with no `mut` fields, whose fields are all `is-data`.
* A union whose member types are all `is-data`.
* Immutable collections like `x[]`, where the type arguments are all `is-data`.
* A constant pointer like `nat*`.
###
is-data<a> builtin-spec

###
Specifies that a type must be safe to share between tasks that may run in parallel.

Anything that satisfies `is-data` satisfies `is-sendable`.
In addition, `future` and `ref` types are sendable if their type arguments are.
(`nat mut[]^` is not sendable.)

In the future, parallel-safe collections may be included here.
###
is-sendable<a> builtin-spec

region option.crow

###
Optional type. Read the tutorial to learn more.

You never need to `match` on this union; use the `if x ?= y` syntax instead. 
###
option<a> union
	none
	some a

region result.crow

###
A `result` is either a success (`ok`) or failure (`err`) value.

This provides a more explicit alternative to throwing an exception.
Prefer this over throwing an exception if failure is likely.
###
result<ok, err> union
	ok ok
	err err

region pointer.crow

###
Avoid using this; this may change in a future version.
Forces a type to be passed by-value instead of by-reference.

You'll usually need to get `&x` in order to pass the value to functions.

This even works on mutable types; passing a mutable record by-value does a shallow copy.
###
by-val<a> builtin extern

###
A raw pointer. Equivalent to `const a*` in C.

The garbage collector does not trace raw pointers.

If `a` is a reference type, `a*` is a pointer to a pointer.

This is a read-only reference, is the pointee is not immutable;
it could be modified if there are other references to it.
###
const-pointer<a> builtin extern

###
This is like `const-pointer` but supports writing to the contents.
###
mut-pointer<a> builtin mut extern

any-const-pointer alias
	nat8*
any-mut-pointer alias
	nat8 mut*

region arr

###
Array of values.

For a mutable version, see the `mut-list` module.

This is implemented as a pointer and a length, also known as a "fat pointer".
This means this is also the type for a slice of an array, and slicing is O(1).

A slice does not keep the whole array alive, only the elements it can reach;
elements not reachable by any slice will be garbage collected.
###
array<a> record by-val
	size nat64
	begin-pointer a*

region string

# Single character in a string.
# This could be any UTF-8 code point.
char8 builtin extern
###
C-style string. Always const.
This should be a valid pointer whose content ends in a "\0", though this is not enforced.
Thus, all operations on `c-string` are unsafe.
###
c-string alias
	char8*

to-char8 char8(a nat8) noctx builtin
to-nat8 nat8(c char8) noctx builtin

region bool.crow

###
Boolean type: either `false` or `true`.

Unlike in other programming languages, this isn't a numeric type.
###
bool builtin extern

###
False boolean value.
This can also be written as `()`.
###
false bool() noctx builtin

# True boolean value.
true bool() noctx builtin

region symbol.crow

symbol record by-val
	.symbol-to-c-string c-string

new-symbol symbol(a c-string) noctx unsafe
	a,

to-c-string c-string(a symbol) no-doc noctx unsafe
	a symbol-to-c-string

region bootstrap arithmetic

# The compiler needs special access to these types to support number literals

###
8-bit natural number.
An unsigned integer in the range 0 through 255.
###
nat8 builtin extern
###
16-bit natural number.
An unsigned integer in the range 0 through 65_535.
###
nat16 builtin extern
###
32-bit natural number.
An unsigned integer in the range 0 through 4_294_967_295 (4 billion).
###
nat32 builtin extern
###
64-bit natural number.
An unsigned integer in the range 0 through 18_446_744_073_709_551_615 (18 quintillion).
###
nat64 builtin extern
###
8-bit signed integer.
In the range -128 through 127.
###
int8 builtin extern
###
16-bit signed integer.
In the range -32_768 through 32_767.
###
int16 builtin extern
###
32-bit signed integer.
In the range -2_147_483_648 through 2_147_483_647 (-2 billion through 2 billion).
###
int32 builtin extern
###
64-bit signed integer,
In the range 9_223_372_036_854_775_808 through 9_223_372_036_854_775_807 (-9 quintillion through 9 quintillion).
###
int64 builtin extern
# 32-bit IEEE floating point number.
float32 builtin extern
# 64-bit IEEE floating point number.
float64 builtin extern

region hard assertions

abort void() extern<c>

###
Zeroed data isn't safe as it would contain null pointers.
It's GC-safe though, since the GC treats a null pointer same as any external pointer.
###
zeroed<a> a() noctx unsafe builtin

###
For a number: 0.
For a record: 'safe-value' for each field.
For a union: 'safe-value' of the first union member.
For an enum: The first member.
For flags: 0.
###
safe-value<a> a() builtin

todo<a> a() trusted noctx
	## TODO: soft-fail, remove 'trusted noctx' above
	abort
	zeroed

# Used in low-level code that should always abort on failure instead of throwing an exception
hard-unreachable<a> a() unsafe noctx
	abort
	zeroed

# Used in low-level code that should always abort on failure instead of throwing an exception
hard-assert void(condition bool) noctx unsafe
	if condition
		new-void
	else
		abort

# Used in low-level code that should always abort on failure instead of throwing an exception
hard-forbid void(condition bool) noctx unsafe
	if condition
		abort
	else
		new-void

region bootstrap runtime

task record mut by-val
	exclusion exclusion
	action act void()

###
NOTE: This mutable value is often *shared*.
If on a future, the lock on the future should be held while working with this.
WARN: Keep in sync with 'task-node-with-time', which casts to this.
###
task-node record mut by-ref
	task task
	next mut task-node?

task-list record mut
	first mut task-node
	last mut task-node

# WARN: Keep in sync with 'task-node'.
task-node-with-time record mut by-ref
	task task
	next mut task-node-with-time?
	time nat64

exclusion alias
	nat64

region fun

###
Low-level function pointer type. Must point to `noctx` code.
These aren't used much in crow code.

Create a function pointer by writing `&foo` where `foo` is the name of a function in scope.
###
fun-pointer0<r> builtin extern
fun-pointer1<r, p0> builtin extern
fun-pointer2<r, p0, p1> builtin extern
fun-pointer3<r, p0, p1, p2> builtin extern
fun-pointer4<r, p0, p1, p2, p3> builtin extern
fun-pointer5<r, p0, p1, p2, p3, p4> builtin extern
fun-pointer6<r, p0, p1, p2, p3, p4, p5> builtin extern
fun-pointer7<r, p0, p1, p2, p3, p4, p5, p6> builtin extern
fun-pointer8<r, p0, p1, p2, p3, p4, p5, p6, p7> builtin extern
fun-pointer9<r, p0, p1, p2, p3, p4, p5, p6, p7, p8> builtin extern

###
Non-mutating function type.
This is usually written as `fun nat(string)` instead of `fun1<nat, string>`.

Contrasted with `act`, a `fun` can't close over mutable data.
It can still close over `sendable` data and perform I/O, so it's not a completely pure function.
###
fun0<r> builtin sendable
fun1<r, p0> builtin sendable
fun2<r, p0, p1> builtin sendable
fun3<r, p0, p1, p2> builtin sendable
fun4<r, p0, p1, p2, p3> builtin sendable
fun5<r, p0, p1, p2, p3, p4> builtin sendable
fun6<r, p0, p1, p2, p3, p4, p5> builtin sendable
fun7<r, p0, p1, p2, p3, p4, p5, p6> builtin sendable
fun8<r, p0, p1, p2, p3, p4, p5, p6, p7> builtin sendable
fun9<r, p0, p1, p2, p3, p4, p5, p6, p7, p8> builtin sendable

###
This is usually written as `act nat(string, bool)` instead of `fun-act2<nat, string, bool>`.

An `act` can have anything in its closure, including mutable data, so it's considered mutable.
###
fun-act0<r> builtin mut
fun-act1<r, p0> builtin mut
fun-act2<r, p0, p1> builtin mut
fun-act3<r, p0, p1, p2> builtin mut
fun-act4<r, p0, p1, p2, p3> builtin mut
fun-act5<r, p0, p1, p2, p3, p4> builtin mut
fun-act6<r, p0, p1, p2, p3, p4, p5> builtin mut
fun-act7<r, p0, p1, p2, p3, p4, p5, p6> builtin mut
fun-act8<r, p0, p1, p2, p3, p4, p5, p6, p7> builtin mut
fun-act9<r, p0, p1, p2, p3, p4, p5, p6, p7, p8> builtin mut

###
This is usually written as `ref nat(string)` instead of `fun-ref1<nat, string>`.

This wraps an `act` combined with the exclusion it came from.
This is sendable since the `act` isn't be called directly;
instead a task is added that will call the `act` when its exclusion is available.
###
fun-ref0<r> record force-sendable by-val
	exclusion exclusion
	action act r^()
fun-ref1<r, p0> record force-sendable by-val
	exclusion exclusion
	action act r^(p0)
fun-ref2<r, p0, p1> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1)
fun-ref3<r, p0, p1, p2> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1, p2)
fun-ref4<r, p0, p1, p2, p3> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1, p2, p3)
fun-ref5<r, p0, p1, p2, p3, p4> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1, p2, p3, p4)
fun-ref6<r, p0, p1, p2, p3, p4, p5> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1, p2, p3, p4, p5)
fun-ref7<r, p0, p1, p2, p3, p4, p5, p6> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1, p2, p3, p4, p5, p6)
fun-ref8<r, p0, p1, p2, p3, p4, p5, p6, p7> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1, p2, p3, p4, p5, p6, p7)
fun-ref9<r, p0, p1, p2, p3, p4, p5, p6, p7, p8> record force-sendable by-val
	exclusion exclusion
	action act r^(p0, p1, p2, p3, p4, p5, p6, p7, p8)

region future

backtrace record by-val
	entries array backtrace-entry

# 'extern' because interpreter also declares this type
backtrace-entry record extern
	# These point into either GC or permanent memory. May be empty strings, never null.
	function-name c-string
	file-path c-string
	# 1-indexed. 0 if unknown.
	line-number nat32
	# 1-indexed. 0 if unknown.
	column-number nat32

###
Type of a thrown exception.

There is no exception subtyping in crow, so all exceptions have this type.
###
exception record by-val
	# Message passed to `throw`.
	message c-string
	# TODO: accessing backtrace should be unsafe
	###
	Backtrace when the exception was created.
	Catching and rethrowing the exception doesn't affect this.
	###
	backtrace backtrace

###
Future type.

Ignore the fields, they should be private.
###
future<a> record force-sendable by-ref
	# It's important to make future by-ref since its lock is by-val 
	lk by-val lock
	state mut future-state a

future-state<a> union mut
	# The future hasn't been resolved or forwarded, and no tasks have been added.
	empty
	# The future has one task waiting for it to be resolved.
	one-task task-node
	# The future has multiple tasks attached.
	tasks task-list
	# All operations should be directed to another future.
	forwarded a^
	# The future was resolved successfully.
	resolved a
	# The future resolved with an exception.
	rejected exception

region lock

lock record sendable by-ref
	n0 nat64
	n1 nat64
	n2 nat64
	n3 nat64
	n4 nat64

region reflect

# General-purpose type that stores a name and value.
named-val<a> record by-val
	name symbol
	val a

# All symbols that exist in the compiled code, in arbitrary order
static-symbols array symbol() noctx builtin
