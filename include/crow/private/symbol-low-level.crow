no-std
import
	../bool: bool
	../col/array: iterate, size
	../col/collection: for-loop
	../col/dict: ~=, build, get-or-add
	../compare: comparison
	../misc: void
	../number: +
	../pointer: ==, +, as-const, mut-pointer, set-deref
	../string: ==, <=>, char8, c-string, hash-mix, iterate, literal, size, string
	../tuple: a, b, new
	./alloc: unmanaged-alloc-elements
	./bootstrap: new-symbol, static-symbols
	./runtime: get-global-ctx, global-ctx, set-symbols-table, symbols-lock, symbols-table
	./thread-utils: with-lock
export
	# TODO: don't export to
	../private/bootstrap: symbol, to

+== bool(a symbol, b symbol) noctx
	# (this is pointer equality)
	trusted a.to::c-string == b.to

# Same as `a.to::string <=> b.to::string`.
+<=> comparison(a symbol, b symbol)
	a.to::string <=> b.to

+to string(a symbol) noctx
	trusted a.to literal

init-symbol-table void(a global-ctx)
	a.symbols-table := for x : static-symbols
		x.to, x

###
Interns a string.
This is O(log n), where 'n' is the number of unique symbols that exist.
###
+to symbol(a string)
	gctx = trusted get-global-ctx
	trusted &gctx.symbols-lock with-lock () =>
		match gctx.symbols-table get-or-add a, () => a.to-malloced-c-string new-symbol
		as got x
			x
		as added pair
			gctx.symbols-table := pair a
			pair b

-to-malloced-c-string c-string(a string) unsafe
	res char8 mut* = a.size + 1 unmanaged-alloc-elements
	cur mut = res
	for x : a
		*cur := x
		cur +:= 1
	assert cur == res + a.size
	*cur := "\0"
	res as-const
