no-std
import
	system/setjmp: jmp_buf, __jmp_buf_tag, longjmp, new, setjmp, _setjmp
	../fun-util: subscript
	../misc: new, void
	../number: ==, nat64
	../pointer: pointer-cast, zeroed
	../result: error, ok, result
	../version: is-interpreted, is-windows
	./alloc: gc-root, set-gc-root, try-get-cur-gc-ctx
	./backtrace: get-backtrace
	./bootstrap: abort, array, cur-fiber, cur-jmp-buf, hard-unreachable, new, set-cur-jmp-buf, string
export
	./bootstrap: backtrace, error, exception, exception-and-backtrace

+test-failure variant-member(exception, string)

# Just use a thread-local for these, since they will be handled immediately before the fiber suspends
-cur-thrown thread-local(exception)
-cur-backtrace thread-local(backtrace)

cur-jmp-buf jmp_buf() unsafe
	guard fiber ?= cur-fiber : hard-unreachable
	fiber.cur-jmp-buf pointer-cast
set-cur-jmp-buf void(value jmp_buf) unsafe
	guard fiber ?= cur-fiber : hard-unreachable
	fiber.cur-jmp-buf := value.pointer-cast

# Used by the compiler when implementing 'try-catch' and 'finally'
rethrow-current-exception void() bare, unsafe
	if fiber ?= cur-fiber
		fiber.cur-jmp-buf.pointer-cast longjmp 1
	else
		# Throwing outside of a fiber aborts
		abort

+catch-all[t] (t, exception-and-backtrace) result(tried t mut())
	trusted
		old-gc-root = gc-root
		old-jmp-buf = cur-jmp-buf
		store mut __jmp_buf_tag = ()
		setjmp-result = if is-interpreted
			&store setjmp
		elif is-windows
			&store _setjmp
		else
			&store setjmp
		if setjmp-result == 0
			# Get here after setting the jump
			cur-jmp-buf := &store
			# If it throws, we'll go to the above branch.
			res = tried[]
			cur-jmp-buf := old-jmp-buf
			res ok
		else
			cur-jmp-buf := old-jmp-buf
			gc-root := old-gc-root
			thrown = cur-thrown
			cur-thrown := zeroed
			backtrace = cur-backtrace
			cur-backtrace := zeroed
			(thrown, backtrace) error

###
Fail unconditionally.
This function is used to mark part of an `if` or `match` that should not be possible.
###
+unreachable[t] t() bare
	throw "Should be unreachable" error

# This is called by the compiler on 'throw'
throw-impl void(a exception) bare
	a throw-with-skip 2

throw-with-skip void(a exception, skip nat64) bare
	backtrace = trusted if ctx ?= try-get-cur-gc-ctx
		ctx get-backtrace skip
	else
		(),
	(a, backtrace) rethrow

-new[t] t array(...a t array) bare
	a

###
Throw an existing exception object.

This is useful for rethrowing an exception that was already caught.
Throwing an exception does not modify its backtrace.
###
+rethrow[t] t(e exception-and-backtrace) bare
	trusted
		cur-thrown := e exception
		cur-backtrace := e backtrace
		rethrow-current-exception
		# unreachable
		zeroed
