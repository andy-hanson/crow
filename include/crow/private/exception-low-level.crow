no-std
import
	setjmp: jmp_buf, __jmp_buf_tag, longjmp, new, setjmp, _setjmp
	../fun-util: subscript
	../misc: new, void
	../number: ==, int32, nat64
	../pointer: ==, null, zeroed
	../version: is-interpreted, is-windows
	./alloc: try-get-cur-gc-ctx
	./backtrace: get-backtrace
	./bootstrap: abort, array, c-string, err, hard-assert, new, ok, result
export
	./bootstrap: exception, message

-cur-jmp-buf thread-local(jmp_buf)
-cur-thrown thread-local(exception)

###
Fail unconditionally.
This function is used to mark part of an `if` or `match` that should not be possible.
###
+unreachable[t] t() noctx
	throw "should be unreachable"

# WARN: Need to set to null at end of catch
#set-exception-ctx void(a exception-ctx?)

###
Run `try` and return what it returns, or return the result of `catcher` if `try` threw an exception.
(An exception thrown by `catcher` will not be caught.)
###
+catch[t] t(try act t(), catcher act t(exception))
	trusted
		old-jmp-buf = cur-jmp-buf
		store mut __jmp_buf_tag = ()
		setjmp-result = if is-interpreted
			&store setjmp
		elif is-windows
			&store _setjmp
		else
			&store setjmp
		if setjmp-result == 0
			# Get here after setting the jump
			cur-jmp-buf := &store
			# If it throws, we'll go to the above branch.
			res = try[]
			cur-jmp-buf := old-jmp-buf
			res
		else
			# Get here after throwing from inside `try[]`
			setjmp-result == number-to-throw hard-assert
			thrown = cur-thrown
			cur-thrown := zeroed
			cur-jmp-buf := old-jmp-buf
			catcher[thrown]

###
Run `try` and return `ok` containing its return value,
or `err` containing an exception if it threw one.
###
+catch[t] (t, exception) result(try act t())
	(() => try[] ok) catch e => e err

# This is called by the compiler on 'throw'
throw-impl void(message c-string) noctx
	message throw-with-skip 2

throw-with-skip void(message c-string, skip nat64) noctx
	backtrace = trusted if ctx ?= try-get-cur-gc-ctx
		ctx get-backtrace skip
	else
		(),
	(message, backtrace) rethrow

-new[t] t array(...a t array) noctx
	a

###
Throw an existing exception object.

This is useful for rethrowing an exception that was already caught.
Throwing an exception does not modify its backtrace.
###
+rethrow[t] t(e exception) noctx
	trusted
		jmp-buf = cur-jmp-buf
		if jmp-buf == null
			abort
		else
			cur-thrown := e 
			jmp-buf longjmp number-to-throw
		# unreachable
		zeroed

-number-to-throw int32() noctx, unsafe
	7
