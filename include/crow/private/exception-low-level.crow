no-std
import
	setjmp: jmp_buf, __jmp_buf_tag, longjmp, new, setjmp, _setjmp
	../col/private/arr-low-level: new
	../fun-util: subscript
	../misc: void
	../number: ==, int32, nat64
	../ptr: *, ==, mut-ptr, null, ptr-to, set-deref, zeroed
	../version: is-interpreted, is-windows
	./alloc: gc-ctx, get-gc-ctx
	./backtrace: get-backtrace
	./bootstrap: abort, c-str, err, hard-assert, new, opt, ok, result, some
export
	./bootstrap: exception, message

.cur-gc-ctx gc-ctx? mut*() thread-local
.cur-jmp-buf jmp_buf mut*() thread-local
.cur-thrown exception mut*() thread-local

###
Fail unconditionally.
This function is used to mark part of an `if` or `match` that should not be possible.
###
unreachable<a> a() noctx
	throw "should be unreachable"

# WARN: Need to set to null at end of catch
#set-exception-ctx void(a exception-ctx?)

###
Run `try` and return what it returns, or return the result of `catcher` if `try` threw an exception.
(An exception thrown by `catcher` will not be caught.)
###
catch<a> a(try act a(), catcher act a(exception)) trusted
	old-jmp-buf = *cur-jmp-buf
	old-gc-ctx = *cur-gc-ctx
	store __jmp_buf_tag = ()
	setjmp-result = if is-interpreted
		store.ptr-to setjmp
	elif is-windows
		store.ptr-to _setjmp
	else
		store.ptr-to setjmp
	if setjmp-result == 0
		# Get here after setting the jump
		*cur-jmp-buf := store ptr-to
		*cur-gc-ctx := get-gc-ctx some
		# If it throws, we'll go to the above branch.
		res = try[]
		*cur-jmp-buf := old-jmp-buf
		*cur-gc-ctx := old-gc-ctx
		res
	else
		# Get here after throwing from inside `try[]`
		hard-assert: setjmp-result == number-to-throw
		thrown = *cur-thrown
		*cur-thrown := zeroed
		*cur-jmp-buf := old-jmp-buf
		*cur-gc-ctx := old-gc-ctx
		catcher[thrown]

# THis is called by the compiler on 'throw'
throw-impl void(message c-str) noctx trusted
	message throw-with-skip 2

throw-with-skip void(message c-str, skip nat64) noctx trusted
	backtrace = if ctx ?= *cur-gc-ctx
		ctx get-backtrace skip
	else
		(),
	(message, backtrace) rethrow

###
Throw an existing exception object.

This is useful for rethrowing an exception that was already caught.
Throwing an exception does not modify its backtrace.
###
rethrow<a> a(e exception) noctx trusted
	jmp-buf = *cur-jmp-buf
	if jmp-buf == null
		abort
	else
		*cur-thrown := e 
		jmp-buf longjmp number-to-throw
	# unreachable
	zeroed

.number-to-throw int32() unsafe noctx
	7

###
Run `try` and return `ok` containing its return value,
or `err` containing an exception if it threw one.
###
catch<a> result<a, exception>(try act a())
	(() => try[] ok) catch e => e err
