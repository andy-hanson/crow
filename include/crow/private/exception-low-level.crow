no-std
import
	../bool: bool
	../fun-util: subscript
	../misc: new, void
	../number: nat64
	../pointer: mut-pointer, pointer-cast, zeroed
	../result: error, ok, result
	./alloc: gc-root, set-gc-root, try-get-cur-gc-ctx
	./backtrace: get-backtrace
	./bootstrap:
		abort, array, cur-fiber, cur-jmp-buf, hard-unreachable, new, set-cur-jmp-buf, string
export
	./bootstrap: backtrace, exception, exception-and-backtrace

# 'setup-catch' is like 'setjmp' and 'jump-to-catch' is like 'longjmp'.
# ('setjmp' and 'longjmp' don't work with fibers on Windows.)
# This is visible for use by the compiler, which uses it in 'try' expressions.
~setup-catch bool(env jmp_buf) bare, builtin
~jump-to-catch void(env jmp_buf) bare, builtin
# TODO: RENAME THESE -----------------------------------------------------------------------------------------------------------
# TODO: Only needs 64 bytes on Linux. (Also only needs 16-byte alignment on Windows.) And much less in interpreter. Maybe make this a builtin with varying size. -------------------
~__jmp_buf_tag extern(240, 16)
~jmp_buf alias
	__jmp_buf_tag mut*

# Thrown when an exception is not specified in an 'assert' or 'forbid'.
+error variant-member(exception, string)

+test-failure variant-member(exception, string)

# Just use a thread-local for these, since they will be handled immediately
# (not giving the fiber a chance to yield)
-cur-thrown thread-local(exception)
-cur-backtrace thread-local(backtrace)

cur-jmp-buf jmp_buf() unsafe
	guard fiber ?= cur-fiber : hard-unreachable
	fiber.cur-jmp-buf pointer-cast
set-cur-jmp-buf void(value jmp_buf) unsafe
	guard fiber ?= cur-fiber : hard-unreachable
	fiber.cur-jmp-buf := value.pointer-cast

# Used by the compiler when implementing 'try-catch' and 'finally'
rethrow-current-exception void() bare, unsafe
	if fiber ?= cur-fiber
		fiber.cur-jmp-buf.pointer-cast jump-to-catch
	else
		# Throwing outside of a fiber aborts
		abort

+catch-all[t] (t, exception-and-backtrace) result(tried t mut())
	trusted
		old-gc-root = gc-root
		old-jmp-buf = cur-jmp-buf
		store mut __jmp_buf_tag = ()
		if &store setup-catch
			# Get here if something is thrown
			cur-jmp-buf := old-jmp-buf
			gc-root := old-gc-root
			thrown = cur-thrown
			cur-thrown := zeroed
			backtrace = cur-backtrace
			cur-backtrace := zeroed
			(thrown, backtrace) error
		else
			# Get here after initial call to 'setup-catch'
			cur-jmp-buf := &store
			# If it throws, we'll go to the above branch.
			res = tried[]
			cur-jmp-buf := old-jmp-buf
			res ok

###
Fail unconditionally.
This function is used to mark part of an `if` or `match` that should not be possible.
###
+unreachable[t] t() bare
	throw "Should be unreachable" error

# This is called by the compiler on 'throw'
throw-impl void(a exception) bare
	a throw-with-skip 2

throw-with-skip void(a exception, skip nat64) bare
	backtrace = trusted if ctx ?= try-get-cur-gc-ctx
		ctx get-backtrace skip
	else
		(),
	(a, backtrace) rethrow

-new[t] t array(...a t array) bare
	a

###
Throw an existing exception object.

This is useful for rethrowing an exception that was already caught.
Throwing an exception does not modify its backtrace.
###
+rethrow[t] t(e exception-and-backtrace) bare
	trusted
		cur-thrown := e exception
		cur-backtrace := e backtrace
		rethrow-current-exception
		# unreachable
		zeroed
