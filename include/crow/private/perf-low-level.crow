no-std
import
	../col/array: array, size
	../col/array-util: zip-each
	../col/mut-array:
		copy-from, fill, mut-array, free-unmanaged-mut-array, index-of, set-subscript,
		subscript, temp-as-array, unmanaged-uninitialized-mut-array
	../fun-util: subscript
	../misc: void
	../number: +, nat64
	../opt: opt
	../ptr: *, mut-ptr, set-deref
	./sym-low-level: ==, sym

###
Enables performance measurement.
Only names in `names` will be measured; others will be ignored.

If measurement was already enabled, this sets all measurements to 0 (and may change measured names)
###
perf-enable-low-level void(measure-names array sym) summon trusted
	*measure-names-var free-unmanaged-mut-array
	*measure-values-var free-unmanaged-mut-array
	*measure-names-var := measure-names.size unmanaged-uninitialized-mut-array
	*measure-names-var copy-from measure-names
	*measure-values-var := measure-names.size unmanaged-uninitialized-mut-array
	*measure-values-var fill (0, 0)

.measure-names-var mut-array<sym> mut*() thread-local
.measure-values-var mut-array<perf-measure-value> mut*() thread-local

get-measure-index nat64?(measure-name sym) noctx unsafe
	*measure-names-var index-of measure-name

add-measure-value-at-index void(index nat64, nsec nat64) noctx unsafe
	values = *measure-values-var
	cur = values[index]
	values[index] := cur.count + 1, cur.total-nsec + nsec

perf-measure-value record by-val
	count nat64
	total-nsec nat64

each-measure void(f act void(sym, perf-measure-value)) unsafe
	measure-names-var->temp-as-array zip-each measure-values-var->temp-as-array, (name, value) =>
		f[name, value]
