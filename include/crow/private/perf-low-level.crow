no-std
import
	../col/array: array, size
	../col/mut-array:
		copy-from, fill, mut-array, free-unmanaged-mut-array, index-of, set-subscript, size,
		subscript, unmanaged-uninitialized-mut-array
	../fun-util: subscript
	../misc: void
	../number: ==, <=>, +, nat64
	../opt: opt
	../ptr: *, mut-ptr, set-deref
	../range: .., for-loop
	./symbol-low-level: ==, symbol

###
Enables performance measurement.
Only names in `names` will be measured; others will be ignored.

If measurement was already enabled, this sets all measurements to 0 (and may change measured names)
###
perf-enable-low-level void(measure-names array symbol) summon trusted
	*measure-names-var free-unmanaged-mut-array
	*measure-values-var free-unmanaged-mut-array
	*measure-names-var := measure-names.size unmanaged-uninitialized-mut-array
	*measure-names-var copy-from measure-names
	*measure-values-var := measure-names.size unmanaged-uninitialized-mut-array
	*measure-values-var fill (0, 0)

.measure-names-var mut-array<symbol> mut*() thread-local
.measure-values-var mut-array<perf-measure-value> mut*() thread-local

get-measure-index nat64?(measure-name symbol) noctx unsafe
	*measure-names-var index-of measure-name

add-measure-value-at-index void(index nat64, nsec nat64) noctx unsafe
	values = *measure-values-var
	cur = values[index]
	values[index] := cur.count + 1, cur.total-nsec + nsec

perf-measure-value record by-val
	count nat64
	total-nsec nat64

each-measure void(f act void(symbol, perf-measure-value)) unsafe
	measure-names = *measure-names-var
	measure-values = *measure-values-var
	for i : 0 .. measure-names.size
		f[measure-names[i], measure-values[i]]
