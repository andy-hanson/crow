no-std
import
	errno: EAGAIN, EINVAL, ESRCH, ETIMEDOUT
	pthread:
		pthread_barrier_destroy, pthread_barrier_init, PTHREAD_BARRIER_SERIAL_THREAD,
		pthread_barrier_t, pthread_barrier_wait, pthread_condattr_destroy, pthread_condattr_init,
		pthread_condattr_setclock, pthread_condattr_t, pthread_cond_broadcast,
		pthread_cond_destroy, pthread_cond_init, pthread_cond_t, pthread_cond_timedwait,
		pthread_cond_wait, pthread_create, pthread_join, pthread_mutexattr_destroy,
		pthread_mutexattr_init, pthread_mutexattr_t, pthread_mutex_destroy, pthread_mutex_init,
		pthread_mutex_lock, pthread_mutex_t, pthread_mutex_unlock, pthread_t
	sys/sysinfo: get_nprocs
	time: CLOCK_MONOTONIC, nanosleep
	win32:
		_beginthreadex, CloseHandle, CONDITION_VARIABLE, CRITICAL_SECTION, DeleteCriticalSection,
		DeleteSynchronizationBarrier, dwNumberOfProcessors, EnterCriticalSection,
		EnterSynchronizationBarrier, ERROR_TIMEOUT, GetLastError, GetSystemInfo, HANDLE, INFINITE,
		InitializeConditionVariable, InitializeCriticalSection, InitializeSynchronizationBarrier,
		LeaveCriticalSection, new, Sleep, SleepConditionVariableCS, SYNCHRONIZATION_BARRIER,
		SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY, SYSTEM_INFO, WaitForSingleObject, WAIT_OBJECT_0,
		WakeAllConditionVariable
	../bool: bool, false, true
	../compare: !=, <, <=
	../extra-types: err-t
	../fun-util: fun-ptr1, subscript
	../io/private/time-low-level: get-monotime-nsec, nsec-to-msec, timestamp, to-timespec
	../misc: new, void
	../number: ==, <=>, nat32, nat64, to-int64, to-nat64
	./number-low-level: unsafe-to-int64, unsafe-to-nat32, wrap-add, wrap-sub
	../ptr:
		==, any-mut-ptr, as-any-mut-ptr, as-ref, by-val, null, ptr-cast, size-of, to-nat64, zeroed
	../version: is-single-threaded, is-windows
	./bootstrap: hard-assert, hard-forbid, hard-unreachable, opt, todo
export
	./bootstrap: lock

count-processors nat64() unsafe noctx summon
	if is-single-threaded
		1
	elif is-windows
		res mut SYSTEM_INFO = ()
		&res GetSystemInfo
		res.dwNumberOfProcessors to-nat64
	else
		get_nprocs.to-int64 to-nat64

uninit by-val lock() noctx unsafe
	zeroed

.as-critical-section CRITICAL_SECTION(a lock) noctx unsafe
	hard-assert: size-of@<by-val CRITICAL_SECTION> <= size-of@<by-val lock>
	a.as-any-mut-ptr as-ref

.as-mutex pthread_mutex_t(a lock) noctx unsafe
	hard-assert: size-of@<by-val pthread_mutex_t> <= size-of@<by-val lock>
	a.as-any-mut-ptr as-ref

init void(a lock) noctx unsafe
	if is-single-threaded
		()
	elif is-windows
		a.as-critical-section InitializeCriticalSection
	else
		attr by-val pthread_mutexattr_t = zeroed
		hard-assert-posix-error: a.as-mutex pthread_mutex_init &attr

acquire void(a lock) noctx unsafe
	if is-single-threaded
		()
	elif is-windows
		a.as-critical-section EnterCriticalSection
	else
		hard-assert-posix-error: a.as-mutex pthread_mutex_lock

release void(a lock) noctx unsafe
	if is-single-threaded
		()
	elif is-windows
		a.as-critical-section LeaveCriticalSection
	else
		hard-assert-posix-error: a.as-mutex pthread_mutex_unlock

with-lock<a> a(a lock, f act a()) trusted
	a acquire
	res = f[]
	a release
	res

condition record mut by-ref
	# TODO: use union to save space instead of storing posix/windows side-by-side
	.posix-mutex-attr by-val pthread_mutexattr_t
	.posix-mutex by-val pthread_mutex_t
	.posix-cond-attr by-val pthread_condattr_t
	.posix-cond by-val pthread_cond_t

	.windows-condition by-val CONDITION_VARIABLE
	.windows-critical-section by-val CRITICAL_SECTION

	###
	Incremented each time the condition fires.
	Used to avoid waiting on a condition that has already changed.
	WARN: this is mutable state, but should acquire the mutex first.
	###
	.sequence .mut sequence-id

uninit by-val condition() noctx unsafe
	# The only thing that actually has to be 0 is 'sequence'
	zeroed

# Remember to 'destroy-condition'!
init void(a condition) noctx unsafe
	if is-single-threaded
		()
	elif is-windows
		&a.windows-condition InitializeConditionVariable
		&a.windows-critical-section InitializeCriticalSection
	else
		hard-assert-posix-error: &a.posix-mutex-attr pthread_mutexattr_init
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_init &a.posix-mutex-attr
		hard-assert-posix-error: &a.posix-cond-attr pthread_condattr_init
		hard-assert-posix-error: &a.posix-cond-attr pthread_condattr_setclock CLOCK_MONOTONIC
		hard-assert-posix-error: &a.posix-cond pthread_cond_init &a.posix-cond-attr

destroy-condition void(a condition) noctx unsafe
	if is-single-threaded
		()
	elif is-windows
		&a.windows-critical-section DeleteCriticalSection
	else
		hard-assert-posix-error: &a.posix-mutex-attr pthread_mutexattr_destroy
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_destroy
		hard-assert-posix-error: &a.posix-cond-attr pthread_condattr_destroy
		hard-assert-posix-error: &a.posix-cond pthread_cond_destroy
	
.hard-assert-posix-error void(err err-t) noctx unsafe
	hard-assert: err == 0

broadcast void(a condition) noctx trusted
	if is-single-threaded
		()
	elif is-windows
		&a.windows-critical-section EnterCriticalSection
		a.sequence := a.sequence wrap-add 1
		&a.windows-condition WakeAllConditionVariable
		&a.windows-critical-section LeaveCriticalSection
	else
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_lock
		a.sequence := a.sequence wrap-add 1
		hard-assert-posix-error: &a.posix-cond pthread_cond_broadcast
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_unlock

sequence-id alias
	nat64

get-sequence sequence-id(a condition) noctx unsafe
	if is-single-threaded
		0
	elif is-windows
		&a.windows-critical-section EnterCriticalSection
		res = a sequence
		&a.windows-critical-section LeaveCriticalSection
		res
	else
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_lock
		res = a sequence
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_unlock
		res

###
WARN: May wake up early. Use only to be avoid consuming CPU.
`until-time`, if set, should be from `get-monotime-nsec`.
'last-sequence' is to ensure that we don't wait at all if the condition has already triggered.
###
wait-on void(a condition, until-time timestamp?, last-sequence sequence-id) noctx unsafe summon
	if is-single-threaded
		if t ?= until-time
			now = get-monotime-nsec
			if now < t
				nsec = t wrap-sub now
				if is-windows
					# TODO: should be clamp-to-nat32
					nsec.nsec-to-msec.unsafe-to-nat32 Sleep
				else
					ts = nsec to-timespec
					_ = &ts nanosleep null
					()
		else
			hard-unreachable
	elif is-windows
		&a.windows-critical-section EnterCriticalSection
		if a.sequence == last-sequence
			wait = if t ?= until-time
				now = get-monotime-nsec
				if now < t
					(t wrap-sub now).nsec-to-msec unsafe-to-nat32
				else
					0
			else
				INFINITE
			ok = &a.windows-condition SleepConditionVariableCS &a.windows-critical-section, wait
			unless ok
				if GetLastError != ERROR_TIMEOUT
					todo
		&a.windows-critical-section LeaveCriticalSection
	else
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_lock
		if a.sequence == last-sequence
			hard-assert-posix-error: if t ?= until-time
				abstime = t to-timespec
				err = &a.posix-cond pthread_cond_timedwait &a.posix-mutex, &abstime
				if err == ETIMEDOUT
					0
				else
					err
			else
				&a.posix-cond pthread_cond_wait &a.posix-mutex
		hard-assert-posix-error: &a.posix-mutex pthread_mutex_unlock

barrier record mut by-ref
	# TODO: use union to save space instead of storing posix/windows side-by-side
	.posix by-val pthread_barrier_t
	.windows mut SYNCHRONIZATION_BARRIER

uninit by-val barrier() noctx unsafe
	zeroed

init void(a barrier, n-threads nat64) noctx unsafe
	if is-single-threaded
		hard-assert: n-threads == 1
	elif is-windows
		hard-assert: &a.windows InitializeSynchronizationBarrier n-threads.unsafe-to-int64, 0
	else
		hard-assert-posix-error: &a.posix pthread_barrier_init null, n-threads.unsafe-to-nat32

free void(a barrier) noctx unsafe
	if is-single-threaded
		()
	elif is-windows
		hard-assert: &a.windows DeleteSynchronizationBarrier
	else
		hard-assert-posix-error: &a.posix pthread_barrier_destroy

# Returns true for one of the threads.
wait-barrier bool(a barrier) noctx unsafe
	if is-single-threaded
		true
	elif is-windows
		&a.windows EnterSynchronizationBarrier SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY
	else
		res = &a.posix pthread_barrier_wait
		if res == PTHREAD_BARRIER_SERIAL_THREAD
			true
		else
			res hard-assert-posix-error
			false

# TODO: use atomic operations for this
thread-safe-counter record mut by-ref
	lk mut by-val lock
	value mut nat64

uninit by-val thread-safe-counter() noctx unsafe
	uninit, 0

init void(a thread-safe-counter) noctx unsafe
	(&a.lk)::lock init

increment-and-get nat64(a thread-safe-counter) noctx unsafe
	a.get-and-increment wrap-add 1

# Returns the old value
get-and-increment nat64(a thread-safe-counter) noctx unsafe
	&a.lk acquire
	old = a value
	a.value := old wrap-add 1
	&a.lk release
	old

decrement void(a thread-safe-counter) noctx unsafe
	_ = a get-and-decrement
	()

# Returns the old value
get-and-decrement nat64(t thread-safe-counter) noctx unsafe
	&t.lk acquire
	old = t value
	hard-forbid: old == 0
	t.value := old wrap-sub 1
	&t.lk release
	old

thread-handle record mut by-val
	.storage any-mut-ptr
.as-windows-handle HANDLE(a thread-handle) noctx unsafe
	a.storage
.as-pthread pthread_t(a thread-handle) noctx unsafe
	a.storage to-nat64

create-one-thread thread-handle(
	thread-arg any-mut-ptr,
	thread-fun fun-ptr1<any-mut-ptr, any-mut-ptr>,
) noctx unsafe summon
	if is-single-threaded
		hard-unreachable
	elif is-windows
		thread-id mut nat32 = 0
		res = null _beginthreadex 0, thread-fun, thread-arg, 0, &thread-id
		res,
	else
		res mut thread-handle = null,
		err = (&res).ptr-cast@<pthread_t, thread-handle> pthread_create null, thread-fun, thread-arg
		unless err == 0
			if err == EAGAIN
				# TODO: warn and make do with the threads it does let us create (so long as there's at least one)
				todo
			else
				# Fatal error
				todo
		res

join-one-thread void(a thread-handle) noctx unsafe summon
	if is-single-threaded
		hard-unreachable
	elif is-windows
		res = a.as-windows-handle WaitForSingleObject INFINITE
		if res != WAIT_OBJECT_0
			todo
		ok = a.as-windows-handle CloseHandle
		hard-assert: ok
	else
		thread-return mut any-mut-ptr = null
		err = a.as-pthread pthread_join &thread-return
		unless err == 0
			if err == EINVAL
				todo
			elif err == ESRCH
				todo
			else
				todo
		assert thread-return == null
