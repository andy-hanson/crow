no-std
import
	errno: EAGAIN, EINVAL, ESRCH, ETIMEDOUT
	pthread:
		pthread_barrier_destroy, pthread_barrier_init, PTHREAD_BARRIER_SERIAL_THREAD,
		pthread_barrier_t, pthread_barrier_wait, pthread_condattr_destroy, pthread_condattr_init,
		pthread_condattr_setclock, pthread_condattr_t, pthread_cond_broadcast,
		pthread_cond_destroy, pthread_cond_init, pthread_cond_t, pthread_cond_timedwait,
		pthread_cond_wait, pthread_create, pthread_join, pthread_mutexattr_destroy,
		pthread_mutexattr_init, pthread_mutexattr_t, pthread_mutex_destroy, pthread_mutex_init,
		pthread_mutex_lock, pthread_mutex_t, pthread_mutex_unlock, pthread_t
	sys/sysinfo: get_nprocs
	time: CLOCK_MONOTONIC, nanosleep
	win32:
		_beginthreadex, CloseHandle, CONDITION_VARIABLE, CRITICAL_SECTION, DeleteCriticalSection,
		DeleteSynchronizationBarrier, dwNumberOfProcessors, EnterCriticalSection,
		EnterSynchronizationBarrier, ERROR_TIMEOUT, GetLastError, GetSystemInfo, HANDLE, INFINITE,
		InitializeConditionVariable, InitializeCriticalSection, InitializeSynchronizationBarrier,
		LeaveCriticalSection, new, Sleep, SleepConditionVariableCS, SYNCHRONIZATION_BARRIER,
		SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY, SYSTEM_INFO, WaitForSingleObject, WAIT_OBJECT_0,
		WakeAllConditionVariable
	../bool: bool, false, true
	../compare: !=, <, <=
	../c-types: err-t
	../fun-util: subscript
	../io/private/time-low-level: get-monotime-nsec, nsec-to-msec, timestamp, to-timespec
	../misc: new, void
	../number: ==, <=>, nat32, nat64, to-int64, to-nat64
	./number-low-level: unsafe-to-int64, unsafe-to-nat32, wrap-add, wrap-sub
	../pointer:
		==, any-mut-pointer, as-any-mut-pointer, by-val, mut-pointer, null, pointer-cast, size-of,
		to-nat64, zeroed
	../version: is-single-threaded, is-windows
	./bootstrap: hard-assert, hard-forbid, hard-unreachable, option, todo
export
	./bootstrap: lock

count-processors nat64() noctx, summon, unsafe
	if is-single-threaded
		1
	elif is-windows
		res mut SYSTEM_INFO = ()
		&res GetSystemInfo
		res.dwNumberOfProcessors to-nat64
	else
		get_nprocs.to-int64 to-nat64

uninit lock by-val() noctx, unsafe
	zeroed

-as-critical-section CRITICAL_SECTION mut*(a lock) noctx, unsafe
	size-of@(CRITICAL_SECTION by-val) <= size-of@(lock by-val) hard-assert
	a.as-any-mut-pointer pointer-cast

-as-mutex pthread_mutex_t mut*(a lock) noctx, unsafe
	size-of@pthread_mutex_t <= size-of@(lock by-val) hard-assert
	a.as-any-mut-pointer pointer-cast

init void(a lock) noctx, unsafe
	if is-single-threaded
		()
	elif is-windows
		a.as-critical-section InitializeCriticalSection
	else
		attr pthread_mutexattr_t = zeroed
		a.as-mutex pthread_mutex_init &attr hard-assert-posix-error

acquire void(a lock) noctx, unsafe
	if is-single-threaded
		()
	elif is-windows
		a.as-critical-section EnterCriticalSection
	else
		a.as-mutex.pthread_mutex_lock hard-assert-posix-error

release void(a lock) noctx, unsafe
	if is-single-threaded
		()
	elif is-windows
		a.as-critical-section LeaveCriticalSection
	else
		a.as-mutex.pthread_mutex_unlock hard-assert-posix-error

with-lock[t] t(a lock, f act t())
	trusted
		a acquire
		res = f[]
		a release
		res

condition record mut by-ref
	# TODO: use union to save space instead of storing posix/windows side-by-side
	-posix-mutex-attr mut pthread_mutexattr_t
	-posix-mutex mut pthread_mutex_t
	-posix-cond-attr mut pthread_condattr_t
	-posix-cond mut pthread_cond_t

	-windows-condition mut CONDITION_VARIABLE
	-windows-critical-section mut CRITICAL_SECTION

	###
	Incremented each time the condition fires.
	Used to avoid waiting on a condition that has already changed.
	WARN: this is mutable state, but should acquire the mutex first.
	###
	-sequence .mut sequence-id

uninit condition by-val() noctx, unsafe
	# The only thing that actually has to be 0 is 'sequence'
	zeroed

# Remember to 'destroy-condition'!
init void(a condition) noctx, unsafe
	if is-single-threaded
		()
	elif is-windows
		&a.windows-condition InitializeConditionVariable
		&a.windows-critical-section InitializeCriticalSection
	else
		(&a.posix-mutex-attr).pthread_mutexattr_init hard-assert-posix-error
		&a.posix-mutex pthread_mutex_init &a.posix-mutex-attr hard-assert-posix-error
		(&a.posix-cond-attr).pthread_condattr_init hard-assert-posix-error
		&a.posix-cond-attr pthread_condattr_setclock CLOCK_MONOTONIC hard-assert-posix-error
		&a.posix-cond pthread_cond_init &a.posix-cond-attr hard-assert-posix-error

destroy-condition void(a condition) noctx, unsafe
	if is-single-threaded
		()
	elif is-windows
		&a.windows-critical-section DeleteCriticalSection
	else
		(&a.posix-mutex-attr).pthread_mutexattr_destroy hard-assert-posix-error
		(&a.posix-mutex).pthread_mutex_destroy hard-assert-posix-error
		(&a.posix-cond-attr).pthread_condattr_destroy hard-assert-posix-error
		(&a.posix-cond).pthread_cond_destroy hard-assert-posix-error
	
-hard-assert-posix-error void(err err-t) noctx, unsafe
	err == 0 hard-assert

broadcast void(a condition) noctx
	trusted if is-single-threaded
		()
	elif is-windows
		&a.windows-critical-section EnterCriticalSection
		a.sequence := a.sequence wrap-add 1
		&a.windows-condition WakeAllConditionVariable
		&a.windows-critical-section LeaveCriticalSection
	else
		(&a.posix-mutex).pthread_mutex_lock hard-assert-posix-error
		a.sequence := a.sequence wrap-add 1
		(&a.posix-cond).pthread_cond_broadcast hard-assert-posix-error
		(&a.posix-mutex).pthread_mutex_unlock hard-assert-posix-error

sequence-id alias
	nat64

get-sequence sequence-id(a condition) noctx, unsafe
	if is-single-threaded
		0
	elif is-windows
		&a.windows-critical-section EnterCriticalSection
		res = a sequence
		&a.windows-critical-section LeaveCriticalSection
		res
	else
		(&a.posix-mutex).pthread_mutex_lock hard-assert-posix-error
		res = a sequence
		(&a.posix-mutex).pthread_mutex_unlock hard-assert-posix-error
		res

###
WARN: May wake up early. Use only to be avoid consuming CPU.
`until-time`, if set, should be from `get-monotime-nsec`.
'last-sequence' is to ensure that we don't wait at all if the condition has already triggered.
###
wait-on void(a condition, until-time timestamp?, last-sequence sequence-id) noctx, summon, unsafe
	if is-single-threaded
		if t ?= until-time
			now = get-monotime-nsec
			if now < t
				nsec = t wrap-sub now
				if is-windows
					# TODO: should be clamp-to-nat32
					nsec.nsec-to-msec.unsafe-to-nat32 Sleep
				else
					ts = nsec to-timespec
					_ = &ts nanosleep null
					()
		else
			hard-unreachable
	elif is-windows
		&a.windows-critical-section EnterCriticalSection
		if a.sequence == last-sequence
			wait = if t ?= until-time
				now = get-monotime-nsec
				if now < t
					(t wrap-sub now).nsec-to-msec unsafe-to-nat32
				else
					0
			else
				INFINITE
			ok = &a.windows-condition SleepConditionVariableCS &a.windows-critical-section, wait
			unless ok
				if GetLastError != ERROR_TIMEOUT
					todo
		&a.windows-critical-section LeaveCriticalSection
	else
		(&a.posix-mutex).pthread_mutex_lock hard-assert-posix-error
		if a.sequence == last-sequence
			if t ?= until-time
				abstime = t to-timespec
				err = &a.posix-cond pthread_cond_timedwait &a.posix-mutex, &abstime
				if err != ETIMEDOUT
					err hard-assert-posix-error
			else
				&a.posix-cond pthread_cond_wait &a.posix-mutex hard-assert-posix-error
		(&a.posix-mutex).pthread_mutex_unlock hard-assert-posix-error

barrier record mut by-ref
	# TODO: use union to save space instead of storing posix/windows side-by-side
	-posix mut pthread_barrier_t
	-windows mut SYNCHRONIZATION_BARRIER

uninit barrier by-val() noctx, unsafe
	zeroed

init void(a barrier, n-threads nat64) noctx, unsafe
	if is-single-threaded
		n-threads == 1 hard-assert
	elif is-windows
		&a.windows InitializeSynchronizationBarrier n-threads.unsafe-to-int64, 0 hard-assert
	else
		&a.posix pthread_barrier_init null, n-threads.unsafe-to-nat32 hard-assert-posix-error

free void(a barrier) noctx, unsafe
	if is-single-threaded
		()
	elif is-windows
		(&a.windows).DeleteSynchronizationBarrier hard-assert
	else
		(&a.posix).pthread_barrier_destroy hard-assert-posix-error

# Returns true for one of the threads.
wait-barrier bool(a barrier) noctx, unsafe
	if is-single-threaded
		true
	elif is-windows
		&a.windows EnterSynchronizationBarrier SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY
	else
		res = &a.posix pthread_barrier_wait
		if res == PTHREAD_BARRIER_SERIAL_THREAD
			true
		else
			res hard-assert-posix-error
			false

# TODO: use atomic operations for this
thread-safe-counter record mut by-ref
	lk mut lock by-val
	value mut nat64

uninit thread-safe-counter by-val() noctx, unsafe
	uninit, 0

init void(a thread-safe-counter) noctx, unsafe
	(&a.lk)::lock init

increment-and-get nat64(a thread-safe-counter) noctx, unsafe
	a.get-and-increment wrap-add 1

# Returns the old value
get-and-increment nat64(a thread-safe-counter) noctx, unsafe
	&a.lk acquire
	old = a value
	a.value := old wrap-add 1
	&a.lk release
	old

decrement void(a thread-safe-counter) noctx, unsafe
	_ = a get-and-decrement
	()

# Returns the old value
get-and-decrement nat64(t thread-safe-counter) noctx, unsafe
	&t.lk acquire
	old = t value
	old == 0 hard-forbid
	t.value := old wrap-sub 1
	&t.lk release
	old

thread-handle record mut by-val
	-storage any-mut-pointer
-as-windows-handle HANDLE(a thread-handle) noctx, unsafe
	a.storage
-as-pthread pthread_t(a thread-handle) noctx, unsafe
	a.storage to-nat64

create-one-thread thread-handle(
	thread-arg any-mut-pointer,
	thread-fun fun* any-mut-pointer(any-mut-pointer),
) noctx, summon, unsafe
	if is-single-threaded
		hard-unreachable
	elif is-windows
		thread-id mut nat32 = 0
		res = null _beginthreadex 0, thread-fun, thread-arg, 0, &thread-id
		res,
	else
		res mut thread-handle = null,
		err = (&res)::thread-handle mut*.pointer-cast pthread_create null, thread-fun, thread-arg
		unless err == 0
			if err == EAGAIN
				# TODO: warn and make do with the threads it does let us create (so long as there's at least one)
				todo
			else
				# Fatal error
				todo
		res

join-one-thread void(a thread-handle) noctx, summon, unsafe
	if is-single-threaded
		hard-unreachable
	elif is-windows
		res = a.as-windows-handle WaitForSingleObject INFINITE
		if res != WAIT_OBJECT_0
			todo
		ok = a.as-windows-handle CloseHandle
		ok hard-assert
	else
		thread-return mut any-mut-pointer = null
		err = a.as-pthread pthread_join &thread-return
		unless err == 0
			if err == EINVAL
				todo
			elif err == ESRCH
				todo
			else
				todo
		assert thread-return == null
