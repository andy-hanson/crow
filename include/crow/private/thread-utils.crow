no-std
import
	errno: EAGAIN, EINVAL, ESRCH, ETIMEDOUT
	pthread:
		pthread_condattr_destroy, pthread_condattr_init, pthread_condattr_setclock,
		pthread_condattr_t, pthread_cond_broadcast, pthread_cond_destroy, pthread_cond_init,
		pthread_cond_t, pthread_cond_timedwait, pthread_cond_wait, pthread_create, pthread_join,
		pthread_mutexattr_destroy, pthread_mutexattr_init, pthread_mutexattr_t,
		pthread_mutex_destroy, pthread_mutex_init, pthread_mutex_lock, pthread_mutex_t,
		pthread_mutex_unlock, pthread_t
	time: CLOCK_MONOTONIC
	win32:
		_beginthreadex, CloseHandle, CONDITION_VARIABLE, CRITICAL_SECTION, DeleteCriticalSection,
		EnterCriticalSection, ERROR_TIMEOUT, GetLastError, HANDLE, INFINITE,
		InitializeConditionVariable, InitializeCriticalSection, LeaveCriticalSection,
		SleepConditionVariableCS, WaitForSingleObject, WAIT_OBJECT_0, WakeAllConditionVariable
	../cell: *, as-mut-ptr, cell, new, set-deref
	../compare: !=, <, <=
	../extra-types: err-t
	../fun-util: fun-ptr1, subscript
	../io/private/time-low-level: get-monotime-nsec, nsec-to-msec, timestamp, to-timespec
	../misc: new, void
	../ptr:
		==, any-mut-ptr, as-any-mut-ptr, as-ref, by-val, null, ptr-cast, ptr-to,
		ref-of-val, size-of, to-nat64, zeroed
	../version: is-windows
	./bootstrap: hard-assert, hard-forbid, nat64, opt, todo
	./number-low-level: ==, <=>, nat32, unsafe-to-nat32, wrap-add, wrap-sub
export
	./bootstrap: lock

uninit by-val lock() noctx unsafe
	zeroed

.as-critical-section CRITICAL_SECTION(a lock) noctx unsafe
	hard-assert: size-of@<by-val CRITICAL_SECTION> <= size-of@<by-val lock>
	a.as-any-mut-ptr as-ref

.as-mutex pthread_mutex_t(a lock) noctx unsafe
	hard-assert: size-of@<by-val pthread_mutex_t> <= size-of@<by-val lock>
	a.as-any-mut-ptr as-ref

init void(a lock) noctx unsafe
	if is-windows
		a.as-critical-section InitializeCriticalSection
	else
		attr by-val pthread_mutexattr_t = zeroed
		hard-assert-posix-error: a.as-mutex pthread_mutex_init attr.ref-of-val

acquire void(a lock) noctx unsafe
	if is-windows
		a.as-critical-section EnterCriticalSection
	else
		hard-assert-posix-error: a.as-mutex pthread_mutex_lock

release void(a lock) noctx unsafe
	if is-windows
		a.as-critical-section LeaveCriticalSection
	else
		hard-assert-posix-error: a.as-mutex pthread_mutex_unlock

with-lock<a> a(a lock, f act a()) trusted
	a acquire
	res = f[]
	a release
	res

condition record mut
	by-ref
	# TODO: use union to safe space instead of storing posix/windows side-by-side
	.posix-mutex-attr by-val pthread_mutexattr_t
	.posix-mutex by-val pthread_mutex_t
	.posix-cond-attr by-val pthread_condattr_t
	.posix-cond by-val pthread_cond_t

	.windows-condition by-val CONDITION_VARIABLE
	.windows-critical-section by-val CRITICAL_SECTION

	###
	Incremented each time the condition fires.
	Used to avoid waiting on a condition that has already changed.
	WARN: this is mutable state, but should acquire the mutex first.
	###
	.sequence .mut sequence-id

uninit by-val condition() noctx unsafe
	# The only thing that actually has to be 0 is 'sequence'
	zeroed

# Remember to 'destroy-condition'!
init void(a condition) noctx unsafe
	if is-windows
		a.windows-condition.ref-of-val InitializeConditionVariable
		a.windows-critical-section.ref-of-val InitializeCriticalSection
	else
		hard-assert-posix-error: a.posix-mutex-attr.ref-of-val pthread_mutexattr_init
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_init a.posix-mutex-attr.ref-of-val
		hard-assert-posix-error: a.posix-cond-attr.ref-of-val pthread_condattr_init
		hard-assert-posix-error: a.posix-cond-attr.ref-of-val pthread_condattr_setclock CLOCK_MONOTONIC
		hard-assert-posix-error: a.posix-cond.ref-of-val pthread_cond_init a.posix-cond-attr.ref-of-val

destroy-condition void(a condition) noctx unsafe
	if is-windows
		a.windows-critical-section.ref-of-val DeleteCriticalSection
	else
		hard-assert-posix-error: a.posix-mutex-attr.ref-of-val pthread_mutexattr_destroy
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_destroy
		hard-assert-posix-error: a.posix-cond-attr.ref-of-val pthread_condattr_destroy
		hard-assert-posix-error: a.posix-cond.ref-of-val pthread_cond_destroy
	
.hard-assert-posix-error void(err err-t) noctx unsafe
	hard-assert: err == 0

broadcast void(a condition) noctx trusted
	if is-windows
		a.windows-critical-section.ref-of-val EnterCriticalSection
		a.sequence := a.sequence wrap-add 1
		a.windows-condition.ref-of-val WakeAllConditionVariable
		a.windows-critical-section.ref-of-val LeaveCriticalSection
	else
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_lock
		a.sequence := a.sequence wrap-add 1
		hard-assert-posix-error: a.posix-cond.ref-of-val pthread_cond_broadcast
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_unlock

sequence-id alias
	nat64

get-sequence sequence-id(a condition) noctx unsafe
	if is-windows
		a.windows-critical-section.ref-of-val EnterCriticalSection
		res = a sequence
		a.windows-critical-section.ref-of-val LeaveCriticalSection
		res
	else
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_lock
		res = a sequence
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_unlock
		res

###
WARN: May wake up early. Use only to be avoid consuming CPU.
`until-time`, if set, should be from `get-monotime-nsec`.
'last-sequence' is to ensure that we don't wait at all if the condition has already triggered.
###
wait-on void(a condition, until-time timestamp?, last-sequence sequence-id) noctx unsafe summon
	if is-windows
		a.windows-critical-section.ref-of-val EnterCriticalSection
		if a.sequence == last-sequence
			wait = if t ?= until-time
				now = get-monotime-nsec
				if now < t
					(t wrap-sub now).nsec-to-msec unsafe-to-nat32
				else
					0
			else
				INFINITE
			ok = a.windows-condition.ref-of-val SleepConditionVariableCS a.windows-critical-section.ref-of-val, wait
			unless ok
				if GetLastError != ERROR_TIMEOUT
					todo
		a.windows-critical-section.ref-of-val LeaveCriticalSection
	else
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_lock
		if a.sequence == last-sequence
			hard-assert-posix-error: if t ?= until-time
				abstime = t to-timespec
				err = a.posix-cond.ref-of-val pthread_cond_timedwait a.posix-mutex.ref-of-val, abstime.ptr-to
				if err == ETIMEDOUT
					0
				else
					err
			else
				a.posix-cond.ref-of-val pthread_cond_wait a.posix-mutex.ref-of-val
		hard-assert-posix-error: a.posix-mutex.ref-of-val pthread_mutex_unlock

# TODO: use atomic operations for this
thread-safe-counter record mut
	lk by-val lock
	value mut nat64

uninit by-val thread-safe-counter() noctx unsafe
	uninit, 0

init void(a thread-safe-counter) noctx unsafe
	a.lk.ref-of-val init

# Returns the old value
get-and-increment nat64(t thread-safe-counter) noctx unsafe
	t.lk.ref-of-val acquire
	old = t value
	t.value := old wrap-add 1
	t.lk.ref-of-val release
	old

# Returns the old value
get-and-decrement nat64(t thread-safe-counter) noctx unsafe
	t.lk.ref-of-val acquire
	old = t value
	hard-forbid: old == 0
	t.value := old wrap-sub 1
	t.lk.ref-of-val release
	old

thread-handle record mut
	by-val
	.storage any-mut-ptr
.as-windows-handle HANDLE(a thread-handle) noctx unsafe
	a.storage
.as-pthread pthread_t(a thread-handle) noctx unsafe
	a.storage to-nat64

create-one-thread void
	out cell thread-handle
	thread-arg any-mut-ptr
	thread-fun fun-ptr1<any-mut-ptr, any-mut-ptr>
spec
	noctx
	unsafe
	summon
body
	if is-windows
		thread-id by-val cell nat32 = 0,
		res = null _beginthreadex 0, thread-fun, thread-arg, 0, thread-id.ref-of-val.as-mut-ptr
		*out := res,
	else
		err = out.as-mut-ptr.ptr-cast pthread_create null, thread-fun, thread-arg
		unless err == 0
			if err == EAGAIN
				# TODO: warn and make do with the threads it does let us create (so long as there's at least one)
				todo
			else
				# Fatal error
				todo

join-one-thread void(a thread-handle) noctx unsafe summon
	if is-windows
		res = a.as-windows-handle WaitForSingleObject INFINITE
		if res != WAIT_OBJECT_0
			todo
		ok = a.as-windows-handle CloseHandle
		hard-assert: ok
	else
		thread-return by-val cell any-mut-ptr = null,
		err = a.as-pthread pthread_join thread-return.ref-of-val.as-mut-ptr
		unless err == 0
			if err == EINVAL
				todo
			elif err == ESRCH
				todo
			else
				todo
		hard-assert: *thread-return.ref-of-val == null
