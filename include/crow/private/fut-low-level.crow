no-std
import
	../fun: subscript
	../opt: none, some, value
	../ptr: ref-of-val
	../result: err, ok, result
	./bootstrap:
		cb, exception, fut, fut-state-callbacks, fut-state-no-callbacks, fut-state-resolved,
		hard-unreachable, lk, next, set-state, state, void
	./thread-utils: lock-by-val, with-lock

unresolved<a> fut a() unsafe
	lock-by-val fut fut-state-no-callbacks

resolve!<a> void(f fut a, value a) unsafe
	f resolve-or-reject! value.ok

reject!<a> void(f fut a, e exception) unsafe
	f resolve-or-reject! e.err

resolve-or-reject!<a> void(f fut a, result result<a, exception>) unsafe
	old-state = f.lk.ref-of-val with-lock () =>
		old = f.state
		f.state := match result
		as ok o
			fut-state-resolved: o.value
		as err e
			# TODO: should work without this variable
			ex = e value
			ex
		old

	match old-state
	as fut-state-no-callbacks
		void
	as fut-state-callbacks cbs
		cbs call-callbacks! result
	as fut-state-resolved
		hard-unreachable
	as exception
		hard-unreachable

.call-callbacks!<a> void(cbs fut-state-callbacks a, value result<a, exception>)
	cbs.cb[value]
	if next ?= cbs next
		next call-callbacks! value

# TODO: PRIVATE
# WARN: Calls the callback immediately if possible
callback!<a> void(f fut a, cb act void(result<a, exception>)) unsafe
	f.lk.ref-of-val with-lock () =>
		match f state
		as fut-state-no-callbacks
			f.state := cb fut-state-callbacks none
		as fut-state-callbacks cbs
			f.state := cb fut-state-callbacks cbs.some
		as fut-state-resolved r
			cb[r.value ok]
		as exception e
			cb[e err]
