###
Functions dealing with pointers and low-level memory issues.
###

no-std
import
	./bool: bool
	./compare: comparison, less, equal, greater
	./misc: void
	./number: /, nat64
	./private/number-low-level: wrap-sub
export
	./private/bootstrap: any-const-pointer, any-mut-pointer, by-val, const-pointer, mut-pointer, zeroed

# Treats a mutable pointer as constant.
+as-const[t] t*(a t mut*) builtin, noctx, unsafe
###
Treats a constant pointer as mutable.
Do not actually write to it.
###
+as-mut[t] t mut*(a t*) builtin, noctx, unsafe

# Null pointer.
+null[t] t*() noctx, unsafe
	null.as-const
+null[t] t mut*() builtin, noctx, unsafe
+null[r, p] fun* r(p)() noctx, unsafe
	null as-fun-pointer

# Same as `null`.
+new[t] t*() noctx, unsafe
	null
+new[t] t mut*() noctx, unsafe
	null

# `*a` reads the value pointed to by `a`.
+*[t] t(a t*) builtin, noctx, unsafe
+*[t] t(a t mut*) builtin, noctx, unsafe

# `*a := value` writes `value` to the place pointed to be `a`.
+set-deref[t] void(a t mut*, value t) builtin, noctx, unsafe

# `a[n]` is the same as `*(a + n)`.
+subscript[t] t(a t*, n nat64) noctx, unsafe
	*(a + n)
+subscript[t] t(a t mut*, n nat64) noctx, unsafe
	*(a + n)

# `a[n] := value` is the same as `*(a + n) := value`.
+set-subscript[t] void(a t mut*, n nat64, value t) noctx, unsafe
	*(a + n) := value

###
`true` iff the two pointers are identical.
(That means: `false` if they point to equal values but are different pointers.)
###
+==[t] bool(a t*, b t*) builtin, noctx, unsafe
+==[t] bool(a t mut*, b t mut*) builtin, noctx, unsafe

###
Advance the pointer past `offset` values of type `a`.

Like in C, the address increases by `offset * size-of@t`.
###
+ +[t] t*(a t*, offset nat64) builtin, noctx, unsafe
+ +[t] t mut*(a t mut*, offset nat64) builtin, noctx, unsafe

# Back up the pointer by `offset` values of type `a`.
+-[t] t*(a t*, offset nat64) builtin, noctx, unsafe
+-[t] t mut*(a t mut*, offset nat64) builtin, noctx, unsafe

###
Get the difference between two pointers, measured in strides of `a`.

This is undefined behavior if `a < b` or if `size-of@t == 0`.
###
+-[t] nat64(a t*, b t*) noctx, unsafe
	a.as-mut - b.as-mut
+-[t] nat64(a t mut*, b t mut*) noctx, unsafe
	(a.to wrap-sub b.to) / size-of@t

-is-less[t] bool(a t*, b t*) builtin, noctx, unsafe
-is-less[t] bool(a t mut*, b t mut*) builtin, noctx, unsafe
# Same as `a.to::nat64 <=> b.to::nat64`.
+<=>[t] comparison(a t*, b t*) noctx, unsafe
	if a is-less b
		less
	elif a == b
		equal
	else
		greater
+<=>[t] comparison(a t mut*, b t mut*) noctx, unsafe
	if a is-less b
		less
	elif a == b
		equal
	else
		greater

###
Number of bytes taken up by a type.
You'll need to manually supply a type argument, as in `size-of@nat`.

If `a` is a reference type, this is just the size of a pointer.
Similarly, this is the same for all array types,
regardless of the number of size of the array elements.
###
+size-of[t] nat64() builtin, noctx, unsafe

###
Change the type of the pointee. This is like a pointer cast `(out*) a` in C.

At a low level, this is just an identity function; it just changes the type.
###
+pointer-cast[out, in] out*(a in*) noctx, unsafe
	a.as-mut.pointer-cast as-const
+pointer-cast[out, in] out mut*(a in mut*) builtin, noctx, unsafe

# TODO:KILL
ref-cast[out, in] out(a in) noctx, unsafe
	a.as-any-mut-pointer as-ref

# Raw address of a pointer.
+to[t] nat64(a t*) builtin, noctx, unsafe
+to[t] nat64(a t mut*) builtin, noctx, unsafe
# Get a pointer from a raw address.
+to-const-pointer[t] t*(a nat64) noctx, unsafe
	a.to-mut-pointer as-const
+to-mut-pointer[t] t mut*(a nat64) builtin, noctx, unsafe

# Swap the value pointed to be 'a' with the value pointed to by 'b'.
+swap[t] void(a t mut*, b t mut*) noctx, unsafe
	temp = *a
	*a := *b
	*b := temp

region Conversion between pointers and pointer-like types

# TODO: this function only works for by-ref types -- currently that is not checked by the type checker
# Convert a reference to `any-pointer`.
as-any-const-pointer[t] any-const-pointer(reference t) noctx, unsafe
	reference.as-any-mut-pointer.as-const
# TODO: this could just use pointer-cast? Doesn't need to be builtin?
as-any-mut-pointer[t] any-mut-pointer(reference t) builtin, noctx, unsafe

# TODO:KILL
-as-ref[t] t(a any-mut-pointer) builtin, noctx, unsafe

+as-fun-pointer[r, p] fun* r(p)(a any-const-pointer) builtin, noctx, unsafe

###
True if two references have the same pointer.
Contrast with `a == b` which can also e true for different pointers with equal contents.
###
reference-equal[t] bool(a t, b t) builtin, noctx, unsafe
