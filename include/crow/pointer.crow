###
Functions dealing with pointers and low-level memory issues.
###

no-std
import
	./bool: bool
	./compare: comparison, less, equal, greater
	./misc: void
	./number: /, nat64
	./private/number-low-level: wrap-sub
export
	./private/bootstrap: any-const-pointer, any-mut-pointer, by-val, const-pointer, mut-pointer, zeroed

# Treats a mutable pointer as constant.
as-const[t] t*(a t mut*) builtin, noctx
###
Treats a constant pointer as mutable.
Do not actually write to it.
###
as-mut[t] t mut*(a t*) builtin, noctx, unsafe

# Null pointer.
null[t] t*() noctx, unsafe
	null.as-const
null[t] t mut*() builtin, noctx, unsafe
null[r] fun* r()() noctx, unsafe
	null as-fun-pointer
null[r, p0] fun* r(p0)() noctx, unsafe
	null as-fun-pointer
null[r, p0, p1] fun* r(p0, p1)() noctx, unsafe
	null as-fun-pointer
null[r, p0, p1, p2] fun* r(p0, p1, p2)() noctx, unsafe
	null as-fun-pointer
null[r, p0, p1, p2, p3] fun* r(p0, p1, p2, p3)() noctx, unsafe
	null as-fun-pointer
null[r, p0, p1, p2, p3, p4] fun* r(p0, p1, p2, p3, p4)() noctx, unsafe
	null as-fun-pointer

# Same as `null`.
new[t] t*() noctx, unsafe
	null
new[t] t mut*() noctx, unsafe
	null

# `*a` reads the value pointed to by `a`.
*[t] t(a t*) builtin, noctx, unsafe
*[t] t(a t mut*) builtin, noctx, unsafe

# `*a := value` writes `value` to the place pointed to be `a`.
set-deref[t] void(a t mut*, value t) builtin, noctx, unsafe

# `a[n]` is the same as `*(a + n)`.
subscript[t] t(a t*, n nat64) noctx, unsafe
	*(a + n)
subscript[t] t(a t mut*, n nat64) noctx, unsafe
	*(a + n)

# `a[n] := value` is the same as `*(a + n) := value`.
set-subscript[t] void(a t mut*, n nat64, value t) noctx, unsafe
	*(a + n) := value

###
`true` iff the two pointers are identical.
(That means: `false` if they point to equal values but are different pointers.)
###
==[t] bool(a t*, b t*) builtin, noctx, unsafe
==[t] bool(a t mut*, b t mut*) builtin, noctx, unsafe

###
Advance the pointer past `offset` values of type `a`.

Like in C, the address increases by `offset * size-of@t`.
###
+[t] t*(a t*, offset nat64) builtin, noctx, unsafe
+[t] t mut*(a t mut*, offset nat64) builtin, noctx, unsafe

# Back up the pointer by `offset` values of type `a`.
-[t] t*(a t*, offset nat64) builtin, noctx, unsafe
-[t] t mut*(a t mut*, offset nat64) builtin, noctx, unsafe

###
Get the difference between two pointers, measured in strides of `a`.

This is undefined behavior if `a < b` or if `size-of@t == 0`.
###
-[t] nat64(a t*, b t*) noctx, unsafe
	a.as-mut - b.as-mut
-[t] nat64(a t mut*, b t mut*) noctx, unsafe
	(a.to-nat64 wrap-sub b.to-nat64) / size-of@t

.is-less[t] bool(a t*, b t*) builtin, noctx, unsafe
.is-less[t] bool(a t mut*, b t mut*) builtin, noctx, unsafe
# Same as `a.to-nat64 <=> b.to-nat64`.
<=>[t] comparison(a t*, b t*) noctx, unsafe
	if a is-less b
		less
	elif a == b
		equal
	else
		greater
<=>[t] comparison(a t mut*, b t mut*) noctx, unsafe
	if a is-less b
		less
	elif a == b
		equal
	else
		greater

###
Number of bytes taken up by a type.
You'll need to manually supply a type argument, as in `size-of@nat`.

If `a` is a reference type, this is just the size of a pointer.
Similarly, this is the same for all array types,
regardless of the number of size of the array elements.
###
size-of[t] nat64() builtin, noctx, unsafe

###
Change the type of the pointee. This is like a pointer cast `(out*) a` in C.

At a low level, this is just an identity function; it just changes the type.
###
pointer-cast[out, in] out*(a in*) noctx, unsafe
	a.as-mut.pointer-cast as-const
pointer-cast[out, in] out mut*(a in mut*) builtin, noctx, unsafe

ref-cast[out, in] out(a in) noctx, no-doc, unsafe
	a.as-any-mut-pointer as-ref

# Raw address of a pointer.
to-nat64[t] nat64(a t*) builtin, noctx, unsafe
to-nat64[t] nat64(a t mut*) builtin, noctx, unsafe
# Get a pointer from a raw address.
to-const-pointer[t] t*(a nat64) noctx, unsafe
	a.to-mut-pointer as-const
to-mut-pointer[t] t mut*(a nat64) builtin, noctx, unsafe

# Swap the value pointed to be 'a' with the value pointed to by 'b'.
swap[t] void(a t mut*, b t mut*) noctx, unsafe
	temp = *a
	*a := *b
	*b := temp

# Maximum pointer value.
max-pointer[t] t*() noctx, unsafe
	max-pointer as-const
max-pointer[t] t mut*() noctx, unsafe
	null + 0xffffffffffffffff

region Conversion between pointers and pointer-like types

# TODO: this function only works for by-ref types -- currently that is not checked by the type checker
# Convert a reference to `any-pointer`.
as-any-const-pointer[t] any-const-pointer(reference t) noctx, no-doc, unsafe
	reference.as-any-mut-pointer.as-const
# TODO: this could just use pointer-cast? Doesn't need to be builtin?
as-any-mut-pointer[t] any-mut-pointer(reference t) builtin, noctx, no-doc, unsafe
# TODO: this function only works for by-ref types -- currently that is not checked by the type checker
as-ref[t] t(a any-const-pointer) noctx, no-doc, unsafe
	a.as-mut as-ref
###
Convert a pointer to a reference of the chosen type.
UB if a value of that type was not stored at the pointer.
###
as-ref[t] t(a any-mut-pointer) builtin, noctx, no-doc, unsafe

as-fun-pointer[r] fun* r()(a any-const-pointer) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0] fun* r(p0)(a any-const-pointer) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1] fun* r(p0, p1)(a any-const-pointer) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1, p2] fun* r(p0, p1, p2)(a any-const-pointer) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1, p2, p3] fun* r(p0, p1, p2, p3)(a any-const-pointer) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1, p2, p3, p4] fun* r(p0, p1, p2, p3, p4)(
	a any-const-pointer,
) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1, p2, p3, p4, p5] fun* r(p0, p1, p2, p3, p4, p5)(
	a any-const-pointer,
) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1, p2, p3, p4, p5, p6] fun* r(p0, p1, p2, p3, p4, p5, p6)(
	a any-const-pointer,
) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1, p2, p3, p4, p5, p6, p7] fun* r(p0, p1, p2, p3, p4, p5, p6, p7)(
	a any-const-pointer,
) noctx, unsafe
	a as-ref
as-fun-pointer[r, p0, p1, p2, p3, p4, p5, p6, p7, p8] fun* r(p0, p1, p2, p3, p4, p5, p6, p7, p8)(
	a any-const-pointer,
) noctx, unsafe
	a as-ref

###
True if two references have the same pointer.
Contrast with `a == b` which can also e true for different pointers with equal contents.
###
ref-eq[t] bool(a t, b t) noctx, no-doc, unsafe
	a.as-any-const-pointer == b.as-any-const-pointer
