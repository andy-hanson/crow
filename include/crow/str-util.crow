no-std
import
	./bool: !, &&, ||, bool
	./col/arr: arr, arr-cast, arr-from-begin-end, begin-ptr, is-empty
	./col/arr-util:
		contains-subseq, each, ends-with, first, last, map, reverse, rtail, split-by-subseq,
		starts-with, tail, try-remove-end, try-remove-start, try-split-once
	./col/mut-arr: ~=, move-to-arr, mut-arr, new
	./compare: !=, <=
	./number: ==, <=>, +, -, nat8
	./opt: !, new, opt
	./ptr: +, *
	./str: ==, ~, char, chars, c-str, new, str, to-char, to-nat8
	./tuple: a, b, new, pair
	./private/bootstrap: hard-unreachable

# Treats bytes as a string.
as-str str(bytes nat8[]) unsafe noctx
	bytes.arr-cast str

bytes nat8[](a str) trusted noctx
	a.chars arr-cast

# Converts a str to a c-str by appending "\0".
to-c-str c-str(a str)
	(a ~ "\0").chars begin-ptr

# Treats a c-str as a str by walking to the end.
to-str str(a c-str) unsafe noctx
	a arr-from-begin-end a.find-cstr-end str

###
Walk a c-str and return a pointer to the first occurrence of `c`.
If that is not found, return `none`.
###
find-char-in-cstr c-str?(a c-str, c char) unsafe noctx
	if *a == c
		a,
	elif *a != "\0"
		a + 1 find-char-in-cstr c

# Pointer to the end of a c-str.
find-cstr-end c-str(a c-str) unsafe noctx
	if v ?= a find-char-in-cstr "\0"
		v
	else
		hard-unreachable

# Strips whitespace from both ends.
strip str(a str)
	a.lstrip rstrip

# Strips whitespace from the front.
lstrip str(a str)
	if c ?= a.chars first
		if c is-whitespace
			a.chars.tail.str lstrip
		else
			a
	else
		a

rstrip str(a str)
	if c ?= a.chars last
		if c is-whitespace
			a.chars.rtail.str rstrip
		else
			a
	else
		a

.is-whitespace bool(a char)
	a == " " || a == "\n" || a == "\t"

has-substr bool(a str, b str)
	a.chars contains-subseq b.chars

starts-with bool(a str, b str)
	a.chars starts-with b.chars

ends-with bool(a str, b str)
	a.chars ends-with b.chars

try-remove-start str?(a str, b str)
	if res ?= a.chars try-remove-start b.chars
		res.str,

try-remove-end str?(a str, b str)
	if res ?= a.chars try-remove-end b.chars
		res.str,

try-split-once pair<str, str>?(a str, b char)
	if res ?= a.chars try-split-once b
		(res.a.str, res.b.str),

split-by str[](a str, b str)
	a.chars split-by-subseq b.chars map chars => chars str

join str(a str[], b str)
	if !a.is-empty
		res char mut[] = ()
		a.rtail each x =>
			res ~= x chars
			res ~= b chars
		res ~= a.last!.chars
		res.move-to-arr str

lower-case str(a str)
	a.chars map (it => it lower-case-char) str

.lower-case-char char(a char)
	a-nat = a to-nat8
	# TODO: support '<=' for chars
	if "A".to-nat8 <= a-nat && a-nat <= "Z".to-nat8
		to-char: "a".to-nat8 + a-nat - "A".to-nat8
	else
		a

reverse str(a str)
	a.chars.reverse str
