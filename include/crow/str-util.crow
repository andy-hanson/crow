no-std
import
	.bool: &&, ||, bool
	.col.arr: arr, arr-cast, arr-from-begin-end, begin-ptr
	.col.arr-util:
		contains-subseq?, ends-with?, first, flatten, last, map, reverse, rtail, split-by-subseq,
		starts-with?, tail, try-remove-end, try-remove-start, try-split-once
	.compare: <=
	.number: ==, <=>, +, -, nat8
	.opt: none, opt, some
	.ptr: +, subscript
	.str: ==, ~, char, chars, c-str, str, to-char, to-nat8
	.tuple: a, b, pair
	.private.bootstrap: hard-unreachable

# Treats bytes as a string.
as-str str(bytes arr nat8) unsafe noctx
	bytes.arr-cast str

bytes arr nat8(a str) trusted noctx
	a.chars arr-cast

# Converts a str to a c-str by appending "\0".
to-c-str c-str(a str)
	(a ~ "\0").chars begin-ptr

# Treats a c-str as a str by walking to the end.
to-str str(a c-str) unsafe noctx
	a arr-from-begin-end a.find-cstr-end str

###
Walk a c-str and return a pointer to the first occurrence of `c`.
If that is not found, return `none`.
###
find-char-in-cstr opt c-str(a c-str, c char) unsafe noctx
	if a[] == c
		a some
	elif a[] == "\0"
		# Did not find the char
		none
	else
		a + 1 find-char-in-cstr c

# Pointer to the end of a c-str.
find-cstr-end c-str(a c-str) unsafe noctx
	if v ?= a find-char-in-cstr "\0"
		v
	else
		hard-unreachable

# Strips whitespace from both ends.
strip str(a str)
	a.lstrip rstrip

# Strips whitespace from the front.
lstrip str(a str)
	if c ?= a.chars first
		if c whitespace?
			a.chars.tail.str lstrip
		else
			a
	else
		a

rstrip str(a str)
	if c ?= a.chars last
		if c whitespace?
			a.chars.rtail.str rstrip
		else
			a
	else
		a

.whitespace? bool(a char)
	a == " " || a == "\n" || a == "\t"

has-substr? bool(a str, b str)
	a.chars contains-subseq? b.chars

starts-with? bool(a str, b str)
	a.chars starts-with? b.chars

ends-with? bool(a str, b str)
	a.chars ends-with? b.chars

try-remove-start opt str(a str, b str)
	if res ?= a.chars try-remove-start b.chars
		res.str some

try-remove-end opt str(a str, b str)
	if res ?= a.chars try-remove-end b.chars
		res.str some

try-split-once opt pair<str, str>(a str, b char)
	if res ?= a.chars try-split-once b
		res.a.str pair res.b.str some

split-by arr str(a str, b str)
	a.chars split-by-subseq b.chars map chars => chars str

join str(a arr str, b str)
	a map (it => it chars) flatten b.chars str

lower-case str(a str)
	a.chars map (it => it lower-case-char) str

.lower-case-char char(a char)
	a-nat = a to-nat8
	# TODO: support '<=' for chars
	if "A".to-nat8 <= a-nat && a-nat <= "Z".to-nat8
		to-char: "a".to-nat8 + a-nat - "A".to-nat8
	else
		a

reverse str(a str)
	a.chars.reverse str
