no-std
import
	./bool: ||, bool
	./col/arr: arr, is-empty
	./col/private/arr-low-level: arr-cast, begin-ptr
	./col/arr-util: each, last, rtail
	./col/iter: new, rest, value, value-and-rest
	./col/mut-arr: ~~=, move-to-arr, mut-arr, new
	./col/seq:
		contains-subseq, copy, drop-right-while, drop-while, each, ends-with, iter, left, map,
		map-to-arr, middle, mut-iter, mut-seq-iter, next, peek, reverse, right, seq-iter,
		slice-left, slice-right, split-by-subseq, starts-with, try-remove-end, try-remove-start,
		try-split-once-by-fn, try-split-once-by-subseq
	./compare: <
	./misc: void
	./number: ==, <=>, nat8
	./opt: !, new, opt
	./str: ==, ~, ~~, as-seq, char, chars, c-str, literal, new, str, str-from-seq, to-char, to-nat8
	./tuple: a, b, new, pair
	./private/number-low-level: wrap-add, wrap-sub

region iterator

str-iter record
	by-val
	.inner seq-iter char

iter str-iter(a str)
	a.as-seq.iter,

next value-and-rest<char, str-iter>?(a str-iter)
	if res ?= a.inner next
		rest str-iter = res.rest,
		(res.value, rest),

slice-left str(a str-iter)
	a.inner.slice-left str-from-seq

slice-right str(a str-iter)
	a.inner.slice-right str-from-seq

mut-str-iter record mut
	.inner mut-seq-iter char

mut-iter mut-str-iter(a str)
	a.as-seq.mut-iter,

copy mut-str-iter(a mut-str-iter)
	a.inner.copy,

peek char?(a mut-str-iter)
	a.inner peek

next char?(a mut-str-iter)
	a.inner next

region iteration

each-char8 void(a str, f act void(char))
	a.as-seq each f

region split

###
`true` iff `b` is a subtring of `a`.

That means: The characters in `b` appear in `a`, in order, without interruptions.
###
contains-substr bool(a str, b str)
	a.as-seq contains-subseq b.as-seq

# `true` iff the first characters of `a` are `b`.
starts-with bool(a str, b str)
	a.as-seq starts-with b.as-seq

# `true` iff the last characters of `a` are `b`.
ends-with bool(a str, b str)
	a.as-seq ends-with b.as-seq

###
If `a` starts with `b`, returns the rest.
Else, returns an empty option.
###
try-remove-start str?(a str, b str)
	if res ?= a.as-seq try-remove-start b.as-seq
		res.str-from-seq,

###
If `a` ends with `b, returns the rest.
Else, returns an empty option.
###
try-remove-end str?(a str, b str)
	if res ?= a.as-seq try-remove-end b.as-seq
		res.str-from-seq,

###
If `b` is a substring of `a`, removes it and return the parts of `a` before and after it.
###
try-split-once pair<str, str>?(a str, b str)
	if res ?= a.as-seq try-split-once-by-subseq b.as-seq
		(res.a.str-from-seq, res.b.str-from-seq),

###
Removes every occurrence of the substring `b` in `a` and return the remaining parts as an array.
The result may include empty strings.
###
split-by str[](a str, b str)
	a.as-seq split-by-subseq b.as-seq map-to-arr x => x str-from-seq

lines str[](a str)
	a split-by "\n"

split-str record
	by-val
	left str
	middle char
	right str

###
Find the first character where `f` returns `true`, and return the parts of `a` before and after it.
Returns an empty option if `f` does not returns `true` for any character in `a`.
###
try-split-once-by-fn split-str?(a str, f act bool(char))
	if res ?= a.as-seq try-split-once-by-fn f
		(res.left.str-from-seq, res.middle, res.right.str-from-seq),

# Finds the first whitespace character in `a` and returns the parts before and after it.
try-split-once-by-whitespace pair<str, str>?(a str)
	if x ?= a try-split-once-by-fn x => x is-whitespace
		(x.left, x.right),

###
Returns a string containing each element of `a`, with `b` as a separator.
This is `a[0] ~ b ~ a[1] ~ b ~ ... ~ a[a.size - 1]`.
###
join str(a str[], b str)
	unless a is-empty
		res char mut[] = ()
		a.rtail each x =>
			res ~~= x chars
			res ~~= b chars
		res ~~= a.last! chars
		res.move-to-arr str

# Lower cases every character in `a`.
lower-case str(a str)
	a.as-seq map (it => it lower-case-char) str-from-seq

.lower-case-char char(a char) noctx
	diff = a.to-nat8 wrap-sub "A".to-nat8
	if diff < 26
		"a".to-nat8 wrap-add diff to-char
	else
		a

# Capitalizes every character in `a`.
upper-case str(a str)
	a.as-seq map (it => it upper-case-char) str-from-seq

.upper-case-char char(a char) noctx
	diff = a.to-nat8 wrap-sub "a".to-nat8
	if diff < 26
		"A".to-nat8 wrap-add diff to-char
	else
		a

# String with characters in reverse order.
reverse str(a str)
	a.as-seq.reverse str-from-seq

# Replaces every instance of the substring `find` with `replace-with`.
replace str(a str, find str, replace-with str)
	# TODO:PERF
	if pair ?= a try-split-once find
		pair.a ~~ replace-with ~~ (pair.b replace find, replace-with)
	else
		a

region strip

# Strips whitespace from both ends.
strip str(a str)
	a.strip-left strip-right

# Strips whitespace from the front.
strip-left str(a str)
	a.as-seq drop-while (x => x is-whitespace) str-from-seq

# Strips whitespace from the end.
strip-right str(a str)
	a.as-seq drop-right-while (x => x is-whitespace) str-from-seq

.is-whitespace bool(a char)
	a == " " || a == "\n" || a == "\t"

region Conversion

###
Treats bytes as a string.
This is O(1).
###
as-str str(bytes nat8[]) unsafe noctx
	bytes.arr-cast str

###
Gets the raw UTF-8 bytes that represent a string.
This is O(n).
###
bytes nat8[](a str) trusted
	a.chars arr-cast

###
Converts a str to a c-str by appending "\0".
This is O(n).

WARN: The resulting string is allocated from GC memory but isn't traced by the garbage collector,
so it may be freed after the current task.
###
to-c-str c-str(a str) unsafe
	(a ~ "\0").chars begin-ptr

###
Treats a c-str as a str by walking to the end.
This does not copy the memory.

Unsafe because:
* `a` must end in a `"\0"` character somewhere.
* The resulting string should not be used longer than `a` lives.
###
to-str str(a c-str) unsafe noctx
	a literal
