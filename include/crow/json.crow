no-std
import
	./bool: ==, bool, false, new, true
	./col/array: array
	./col/dict: dict, dict-equal, for-loop, new, subscript, to-dict
	./col/list: for-loop, list, list-equal, new, to-list
	./parse:
		==, /, ~~, bool, exact, float, grammar, lazy, map, parse, parse-error, quoted-string,
		separated-by, spaces, with-block
	./misc: void
	./number: ==, float64, int64, nat64, to-float64
	./option: new, option
	./result: ok, result, result-equals
	./string: ==, <=>, ~~, hash-mix, join, literal, quote, string, to-string
	./test-util: is
	./tuple: new, pair

###
JSON data.

This can be the result of parsing or the input to `to-string`.
###
json union
	json-bool bool
	json-number float64
	json-string string
	json-list json[]
	json-object json[string]

new json(...pairs array (string, json))
	pairs.to-list.to-dict json-object

json<a> spec
	json json(a a)

json json(a bool)
	a.json-bool
json json(a nat64)
	a.to-float64 json
json json(a int64)
	a.to-float64 json
json json(a float64)
	a json-number
json json(a string)
	a json-string
json<a> json(a a[]) json<a>
	(for x : a; x json) json-list

###
True iff the two values are deeply equal.

This is equivalent to `a.to-string == b.to-string`.
###
== bool(a json, b json)
	match a
	as json-bool ba
		if bb ?= b as-bool
			ba == bb
	as json-number fa
		if fb ?= b as-number
			fa == fb
	as json-string sa
		if sb ?= b as-string
			sa == sb
	as json-list aa
		if ab ?= b as-list
			aa list-equal ab
	as json-object oa
		if ob ?= b as-object
			oa dict-equal ob

# TODO: option equality should be generic
== bool(a json?, b json?) no-doc
	if va ?= a
		if vb ?= b
			va == vb

# If `a` is a boolean, returns that, else returns an empty option.
as-bool bool?(a json) noctx
	match a
	as json-bool b
		b,
	as json-number _
		()
	as json-string _
		()
	as json-list _
		()
	as json-object _
		()
# If `a` is a number, returns that, else returns an empty option.
as-number float64?(a json) noctx
	match a
	as json-bool _
		()
	as json-number n
		n,
	as json-string _
		()
	as json-list _
		()
	as json-object _
		()
###
If `a` is a string, returns that, else returns an empty option.

This does not render as JSON; `to-string` does that.
###
as-string string?(a json) noctx
	match a
	as json-bool _
		()
	as json-number _
		()
	as json-string s
		s,
	as json-list _
		()
	as json-object _
		()
# If `a` is a list, returns that, else returns an empty option.
as-list json[]?(a json) noctx
	match a
	as json-bool _
		()
	as json-number _
		()
	as json-string _
		()
	as json-list x
		x,
	as json-object _
		()
# If `a` is an object, returns that, else returns an empty option.
as-object json[string]?(a json) noctx
	match a
	as json-bool _
		()
	as json-number _
		()
	as json-string _
		()
	as json-list _
		()
	as json-object o
		o,

###
If `a` is an `object` containing the key `key`, returns the associated value.
Else, returns an empty option.
###
subscript json?(a json, key string)
	if o ?= a.as-object
		o[key]

json grammar json()
	with : lazy
		(json-object map x => x.json-object) / (json-list map x => x.json-list) / json-primitive
.json-object grammar json[string]()
	pair grammar<(string, json)> = quoted-string ~~ spaces ~~ ":" ~~ spaces ~~ json
	pairs grammar<(string, json)[]> = pair separated-by ","
	pairs2 grammar<json[string]> = pairs map x => x.to-dict
	"\{" ~~ spaces ~~ pairs2 ~~ spaces ~~ "}"
.json-list grammar json[]()
	"[" ~~ spaces ~~ (json separated-by "," ~~ spaces) ~~ spaces ~~ "]"
.json-primitive grammar json()
	literal = (bool map x => x json) / ("null" exact ())
	(quoted-string map x => x json) / (float map x => x json-number) / literal

# Renders a json value to JSON.
to-string string(a json)
	match a
	as json-bool b
		"{b}"
	as json-number f
		"{f}"
	as json-string s
		s quote
	as json-list xs
		parts = "," join for x : xs; "{x}"
		"[{parts}]"
	as json-object o
		parts = "," join for k, v : o
			"{k quote}:{v}"
		"\{{parts}}"

.verify void(a json, s string)
	json parse s is@<result<json, parse-error>> a.ok
	a.to-string is s

.== bool(a result<json, parse-error>, b result<json, parse-error>)
	a result-equals b

test
	true.json-bool verify "true"
	false.json-bool verify "false"
	-3.0.json-number verify "-3"
	1.5.json-number verify "1.5"
	-1.5.json-number verify "-1.5"
	"j".json-string verify "\"j\""
	"a\nb".json-string verify "\"a\\nb\""
	"a\\nb".json-string verify "\"a\\\\nb\""

	().json-list verify "[]"
	(1.0.json-number,).json-list verify "[1]"
	(1.0.json-number, true.json-bool).json-list verify "[1,true]"

	().json-object verify "\{}"
	(("a", 1.0.json-number),).json-object verify "\{\"a\":1}"
	(("a", 1.0.json-number), ("x\ny", true.json-bool)).json-object verify "\{\"a\":1,\"x\\ny\":true}"
