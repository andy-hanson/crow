no-std
import
	./bool: ==, bool, false, new, true
	./col/array: array, iterate, size
	./col/collection: for-loop, join
	./col/dict: ==, ~=, build, dict, iterate, size, subscript, to-dict
	./col/experimental/index-set: iterate, index-set, size
	./hash: hasher
	./col/list: ==, ~=, build, iterate, list, new, size, to-list
	./parse:
		/, ~~, bool, exact, float, grammar, lazy, map, quoted-string, separated-by, spaces,
		with-block
	./private/symbol-low-level: ==, <=>, string-to-symbol, symbol, to-string
	./misc: void
	./number:
		==, float32, float64, int8, int16, int32, int64, nat8, nat16, nat32, nat64, to-float64,
		to-int64, to-nat64
	./option: new, option
	./result: result
	./string: ==, ~~, hash-mix, literal, new, quote, string, to-string
	./tuple: a, b, new, tuple2

#TODO: get from 'symbol'
-hash-mix void(hasher hasher, a symbol)
	hasher hash-mix a.to-string

###
JSON data.

This can be the result of parsing or the input to `to-string`.
###
+json union
	json-null
	json-bool bool
	json-number float64
	json-string string
	json-list json[]
	json-object json[symbol]

+null json()
	json-null

+new json(...pairs (symbol, json) array)
	pairs.to-list.to-dict json-object

+json[t] spec
	json json(a t)

# Identity function to satisfy the 'json' spec
+json json(a json)
	a
+json json(a bool)
	a.json-bool
+json json(a nat8)
	a.to-nat64 json
+json json(a nat16)
	a.to-nat64 json
+json json(a nat32)
	a.to-nat64 json
+json json(a nat64)
	a.to-float64 json
+json json(a int8)
	a.to-int64 json
+json json(a int16)
	a.to-int64 json
+json json(a int32)
	a.to-int64 json
+json json(a int64)
	a.to-float64 json
+json json(a float32)
	a.to-float64 json
+json json(a float64)
	a json-number
+json json(a string)
	a json-string
+json[t] json(a t array) t json
	(for x : a; x json) json-list
+json[t] json(a t[]) t json
	(for x : a; x json) json-list
+json[t] json(a t[symbol]) t json
	(for k, v : a; k, v.json) json-object
json json(a index-set)
	(for x : a; x json) json-list
+json[t] json(a t?) t json
	if x ?= a
		(x.json,) json-list
	else
		()
+json[t, u] json(a (t, u)) t json, u json
	(a.a json, a.b json) json-list
+json[t, u] json(a (t, u) result) t json, u json
	match a
	as ok v
		("ok", v json),
	as err e
		("err", e json),

+== bool(a json, b json)
	match a
	as json-null
		b is-null
	as json-bool ba
		if bb ?= b as-bool
			ba == bb
	as json-number fa
		if fb ?= b as-number
			fa == fb
	as json-string sa
		if sb ?= b as-string
			sa == sb
	as json-list aa
		if ab ?= b as-list
			aa == ab
	as json-object oa
		if ob ?= b as-object
			oa == ob

+is-null bool(a json) noctx
	match a
	as json-null
		true
	as json-bool _
		false
	as json-number _
		false
	as json-string _
		false
	as json-list _
		false
	as json-object _
		false

# If `a` is a boolean, returns that, else returns an empty option.
+as-bool bool?(a json) noctx
	match a
	as json-null
		()
	as json-bool b
		b,
	as json-number _
		()
	as json-string _
		()
	as json-list _
		()
	as json-object _
		()
# If `a` is a number, returns that, else returns an empty option.
+as-number float64?(a json) noctx
	match a
	as json-null
		()
	as json-bool _
		()
	as json-number n
		n,
	as json-string _
		()
	as json-list _
		()
	as json-object _
		()
###
If `a` is a string, returns that, else returns an empty option.

This does not render as JSON; `to-string` does that.
###
+as-string string?(a json) noctx
	match a
	as json-null
		()
	as json-bool _
		()
	as json-number _
		()
	as json-string s
		s,
	as json-list _
		()
	as json-object _
		()
# If `a` is a list, returns that, else returns an empty option.
+as-list json[]?(a json) noctx
	match a
	as json-null
		()
	as json-bool _
		()
	as json-number _
		()
	as json-string _
		()
	as json-list x
		x,
	as json-object _
		()
# If `a` is an object, returns that, else returns an empty option.
+as-object json[symbol]?(a json) noctx
	match a
	as json-null
		()
	as json-bool _
		()
	as json-number _
		()
	as json-string _
		()
	as json-list _
		()
	as json-object o
		o,

###
If `a` is an `object` containing the key `key`, returns the associated value.
Else, returns an empty option.
###
+subscript json?(a json, key symbol)
	if o ?= a as-object
		o[key]

+json json grammar()
	with : lazy
		(json-object map x => x.json-object) / (json-list map x => x.json-list) / json-primitive
-json-object json[symbol] grammar()
	pair (symbol, json) grammar = (quoted-string map s => s string-to-symbol) ~~ spaces ~~ ":" ~~ spaces ~~ json
	pairs (symbol, json)[] grammar = pair separated-by "," ~~ spaces
	pairs2 json[symbol] grammar = pairs map x => x to-dict
	"\{" ~~ spaces ~~ pairs2 ~~ spaces ~~ "}"
-json-list json[] grammar()
	"[" ~~ spaces ~~ (json separated-by "," ~~ spaces) ~~ spaces ~~ "]"
-json-primitive json grammar()
	literal = (bool map x => x json) / ("null" exact null)
	(quoted-string map x => x json) / (float map x => x json-number) / literal

# Renders a json value to JSON.
+to-string string(a json)
	match a
	as json-null
		"null"
	as json-bool b
		"{b}"
	as json-number f
		"{f}"
	as json-string s
		s quote
	as json-list xs
		parts = "," join for x : xs; "{x}"
		"[{parts}]"
	as json-object o
		parts = "," join for k, v : o
			"{k.to-string quote}:{v}"
		"\{{parts}}"
