no-std
import
	./bool: &&, bool, false, not, true
	./col/collection: build, exists, for-break, for-loop, is-at-end, join, with-block
	./col/list: ~, ~=, build, iterate, list, new, size
	./col/set: in, new, set
	./compare: !=, <=
	./fun-util: subscript
	./misc: loop-break, new, void
	./number: ==, <=>, +, -, *, **, float64, int64, nat64, to-float64, to-int64, to-nat64
	./option: is-empty, new, option
	./result: err, ok, result
	./string:
		==, <=>, ~~, ~=, as-string, begin, build, char8, char8s, hash-mix, is-empty, literal, new,
		next, string, string-iterator, to-nat8, to-c-string, to-string
	./tuple: a, b, new, tuple2

###
Opaque grammar type parsing an 'a' value.
Use the functions in this module to build a grammar.
###
+grammar[t] record mut
	# TODO: should be a 'fun'
	-fn act (string-iterator, t inner-parse-result)(string-iterator)

###
Match a string against a grammar.
THe whole string must match the grammar.
If the string has leading or trailing spaces you must use a grammar that includes those.
###
+parse[t] (t, parse-error) result(a t grammar, text string)
	result = a.fn[text begin]
	iter = result a
	match result b
	as ok v
		if iter is-at-end
			v ok
		else
			(text, iter, "string continues past end of parse") err
	as err e
		(text, iter, e.expected) err

# Return a parse result or throw on error.
+force[t] t(a (t, parse-error) result)
	match a
	as ok v
		v
	as err e
		throw "{e}"

+parse-error record
	# The argument passed to 'parse'.
	input string
	###
	Position where the parse error happened.
	This will be 'input.end-iterator' if the error was end of input.
	###
	iter string-iterator
	# Description of what was expected.
	expected string
+== bool(a parse-error, b parse-error)
	a.input == b.input && a.iter == b.iter && a.expected == b.expected

-inner-parse-result[t] union
	ok t
	err inner-parse-error

-then[out, in] out inner-parse-result(a in inner-parse-result, f act out(in))
	match a
	as ok v
		f[v] ok
	as err e
		e err
-then[out, in] (string-iterator, out inner-parse-result)(a (string-iterator, in inner-parse-result), f act out(in))
	a.a, a.b then f

-inner-parse-error record
	expected string

+to-string string(a parse-error)
	# TODO: show where it is
	peek = if pair ?= a.iter next
		"'{pair.a}'"
	else
		"EOF"
	"expected {a expected}, got {peek}"

# This is like 'grammar' but produces no result.
+grammar-skip record mut
	inner void grammar

# Grammar matching empty strings
+new grammar-skip()
	"" exact

-make-grammar record
-make-grammar make-grammar()
	()
-with-block[t] t grammar(_ make-grammar, f act (string-iterator, t inner-parse-result)(string-iterator))
	f,

region basic building blocks

# Use to discard the result of any grammar.
+skip[t] grammar-skip(a t grammar)
	(a map _ => ()),

+and-return[t] t grammar(a grammar-skip, value t)
	a.inner map _ => value

+text-delimited string grammar(begin string, end string)
	begin ~~ end.text-not-containing ~~ end

text-not-containing string grammar(ending string)
	(ending,) text-not-containing-any

text-not-containing-any string grammar(possible-endings string[])
	with start : make-grammar
		iter mut = start
		res string = with out : build
			loop
				if possible-endings exists x => !(iter try-take-exact x).is-empty
					break 
				elif pair ?= iter next
					out ~= pair a
					iter := pair b
					continue
				else
					break
		if res is-empty
			desc = ", " join for x : possible-endings; "'{x}'"
			iter, ("expected text ending in one of {desc}",).err
		else
			iter, res.ok

# Grammar for a single character matching the predicate.
-char-matching-predicate char8 grammar(description string, predicate fun bool(char8))
	with start : make-grammar
		if pair ?= start next
			if predicate[pair a]
				pair.b, pair.a.ok
			else
				pair.b, (description,) err
		else
			start, (description,) err

-try-take-exact string-iterator?(iter string-iterator, expect string)
	cur mut = iter
	for expected : expect char8s
		if pair ?= cur next
			if pair.a != expected
				break
			else
				cur := pair b
				()
		else
			break
	else
		cur,

###
Expects to parse 'a' followed by 'b'.
By default this does not allow spaces in between. For that, use `a ~~ spaces ~~ b`.
###
+~~[t, u] (t, u) grammar(a t grammar, b u grammar)
	with start : make-grammar
		pair0 = a.fn[start]
		match pair0 b
		as ok x
			pair1 = b.fn[pair0 a]
			pair1.a, match pair1 b
			as ok y
				(x, y) ok
			as err e
				e err
		as err e
			pair0.a, e.err
+~~[t] t grammar(a t grammar, b grammar-skip)
	with start : make-grammar
		pair0 = a.fn[start]
		match pair0 b
		as ok x
			pair1 = b.inner.fn[pair0 a]
			pair1.a, match pair1 b
			as ok _
				x ok
			as err e
				e err
		as err e
			pair0.a, e.err
+~~[t] t grammar(a grammar-skip, b t grammar)
	with start : make-grammar
		pair0 = a.inner.fn[start]
		match pair0 b
		as ok _
			pair1 = b.fn[pair0 a]
			pair1.a, match pair1 b
			as ok x
				x ok
			as err e
				e err
		as err e
			pair0.a, e.err
+~~ grammar-skip(a grammar-skip, b grammar-skip)
	a.inner ~~ b,
# Skips an exact string, then parses 'b'
+~~[t] t grammar(a string, b t grammar)
	a.exact ~~ b
# Parses 'a', then skips an exact string
+~~[t] t grammar(a t grammar, b string)
	a ~~ b.exact
+~~ grammar-skip(a string, b grammar-skip)
	a.exact ~~ b
+~~ grammar-skip(a grammar-skip, b string)
	a ~~ b.exact

# Tries to parse with 'a', and if that fails, tries to parse with 'b' instead.
+/[t] t grammar(a t grammar, b t grammar)
	with start : make-grammar
		pair = a.fn[start]
		match pair b
		as ok v
			pair.a, v.ok
		as err _
			b.fn[start]

# TODO: use 'fun' not 'act'
# Uses a function to transform the result if parsing is successful.
+map[out, in] out grammar(a in grammar, f act out(in))
	with start : make-grammar
		a.fn[start] then f
+map[out, in0, in1] out grammar(a (in0, in1) grammar, f act out(in0, in1))
	a map pair => f[pair.a, pair.b]

# Allows parsing to fail, returning an empty option if it does.
+optional[t] t? grammar(a t grammar)
	with start : make-grammar
		pair = a.fn[start]
		pair.a, match pair b
		as ok v
			(v,) ok
		as err _
			() ok
# Optionally skips an exact string.
+optional grammar-skip(a string)
	a.exact.inner.optional skip

# Parses the same grammar as many times as possible (including 0 times).
+many[t] t[] grammar(a t grammar)
	with start : make-grammar
		iter mut = start
		res t[] = with out : build
			loop
				pair = a.fn[iter]
				match pair b
				as ok v
					iter := pair a
					out ~= v
					continue
				as err _
					break
		iter, res.ok

+many grammar-skip(a grammar-skip)
	inner void[] grammar = a.inner many
	(inner map _ => ()),

# Parses 'a' at least once, then as many times as possible.
+one-or-more[t] t[] grammar(a t grammar)
	a ~~ a.many map x =>
		x.a ~ x.b

+one-or-more grammar-skip(a grammar-skip)
	inner void[] grammar = a.inner one-or-more
	(inner map _ => ()),

###
Parses 'a' as many times as possible, with 'separator' in between.

This does not allow a trailing separator;
it is a parse error to have a separator not followed by another 'a'.
###
+separated-by[t] t[] grammar(a t grammar, separator string)
	a separated-by separator.exact
+separated-by[t] t[] grammar(a t grammar, separator grammar-skip)
	with start : make-grammar
		iter mut = start
		pair0 = a.fn[iter]
		match pair0 b
		as ok first
			iter := pair0 a
			error mut inner-parse-error? = ()
			res t[] = with out : build
				out ~= first
				loop
					pair1 = separator.inner.fn[iter]
					match pair1 b
					as ok _
						iter := pair1 a
						pair2 = a.fn[iter]
						iter := pair2 a
						match pair2 b
						as ok v
							out ~= v
							continue
						as err e
							error := e,
							break
					as err _
						break
			iter, if e ?= error
				e err
			else
				res ok
		as err _
			start, () ok

# Use this to allow recursive grammars.
+lazy record
+lazy lazy()
	()
+with-block[t] t grammar(_ lazy, f fun t grammar())
	with start : make-grammar
		# TODO: actually be lazy (cache it)
		grammar = f[]
		grammar.fn[start]

region basic elements

# Matches 'a' exactly.
+exact grammar-skip(a string)
	res void grammar = with start : make-grammar
		if next ?= start try-take-exact a
			next, ().ok
		else
			start, ("expected '{a}'",).err
	res,

# Equivalent to `a.exact map _ => value`
+exact[t] t grammar(a string, value t)
	a.exact.inner map _ => value

# Matches any amount of whitespace (including none) and discards it.
+spaces grammar-skip()
	("" char-matching-predicate (x => x.is-space)).many skip

-is-space bool(a char8)
	a in space-chars
-space-chars char8 set()
	" ", "\r", "\n", "\t"

# A double-quoted string as in JSON, including escape sequences.
+quoted-string string grammar()
	with start : make-grammar
		if after-quote ?= start try-take "\""
			after-quote take-quoted-string-rest
		else
			start, ("quoted string",).err
-take-quoted-string-rest (string-iterator, string inner-parse-result)(start string-iterator)
	iter mut = start
	error mut bool = false
	res string = with out : build
		loop
			if pair ?= iter next
				iter := pair b
				if pair.a == "\""
					break
				elif pair.a == "\\"
					if pair2 ?= iter next
						iter := pair2 b
						if esc ?= pair2.a escape
							out ~= esc
							continue
						else
							error := true
							break
					else
						break
				else
					out ~= pair.a
					continue
			else
				error := true
				break
	iter, if error
		("quoted string",) err
	else
		res ok
-escape char8?(a char8)
	if a == "n"
		"\n",
	elif a == "r"
		"\r",
	elif a == "t"
		"\t",
	elif a == "\""
		"\"",
	elif a == "\\"
		"\\",
	elif a == "0"
		"\0",

# TODO: support letters from more languages
# Matches and returns a sequence of letters.
+word string grammar()
	letter.one-or-more map (x => x as-string)

-letter char8 grammar()
	"letter" char-matching-predicate x => x is-letter

-is-letter bool(a char8)
	# TODO: support other alphabets
	"a".to-nat8 <= a.to-nat8 && a.to-nat8 <= "z".to-nat8

# Parse a boolean as 'true' or 'false'
+bool bool grammar()
	("true" exact true) / ("false" exact false)

###
Parses a natural number in decimal format.
This allows leading 0s which have no effect.
###
+nat nat64 grammar()
	with start : make-grammar
		if x ?= start take-nat-and-count-digits
			x.end, x.value.ok
		else
			start, ("natural number",).err

###
Parses a signed integer in decimal format.
This allows e.g. "1", "+23", "-45".
###
+int int64 grammar()
	("+".optional ~~ (nat map x => x to-int64)) / ("+" ~~ (nat map x => -x.to-int64))

-nat-and-count-digits record
	-end string-iterator
	-value nat64
	-count-digits nat64
-take-nat-and-count-digits nat-and-count-digits?(start string-iterator)
	acc mut = 0
	count-digits mut = 0
	iter mut = start
	loop
		if pair ?= iter next-digit
			iter := pair b
			acc := acc * 10 + pair.a
			count-digits := count-digits + 1
			continue
		else
			break
	unless count-digits == 0
		(iter, acc, count-digits),
-next-digit (nat64, string-iterator)?(a string-iterator)
	if pair ?= a next
		if digit ?= pair.a char-to-nat64
			(digit, pair.b),

-char-to-nat64 nat64?(c char8)
	if "0".to-nat8 <= c.to-nat8 && c.to-nat8 <= "9".to-nat8
		(c.to-nat8 - "0".to-nat8).to-nat64,

###
Parse a decimal number.
This allows e.g. "+1.23".
###
+float float64 grammar()
	with start : make-grammar
		iter mut = start
		sign float64 = if n ?= iter try-take "-"
			iter := n
			-1
		else
			if n ?= iter try-take "+"
				iter := n
			1
		if whole-nat ?= iter take-nat-and-count-digits
			iter := whole-nat end
			whole-part = whole-nat.value to-float64
			if after-dot ?= iter try-take "."
				if nd ?= after-dot take-nat-and-count-digits
					# TODO: more accurate methods exist
					nd.end, sign * (whole-part + nd.value.to-float64 * 0.1 ** nd.count-digits) ok
				else
					iter, sign * whole-part ok
			else
				iter, sign * whole-part ok
		else
			start, ("float",) err

-try-take string-iterator?(a string-iterator, c char8)
	if pair ?= a next
		if pair.a == c
			pair.b,
