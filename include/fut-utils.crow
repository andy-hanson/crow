import
	.bootstrap:
		as, err, exception, exclusion, fun, fut, fut-callback-node, fut-state-callbacks,
		fut-state-resolved, hard-unreachable, head, island, island-and-exclusion, lk, ok,
		result, send, set-state, state, value, void
	.collection.arr: arr, size
	.compare: ==
	.cell: cell, set-subscript, subscript
	.collection.arr-util: each-with-index, first-some, map
	.exceptions: catch
	.fun: subscript
	.fut-low-level: reject!, resolve!, resolve-or-reject!, unresolved
	.number: -, nat
	.opt: none, opt, some
	.ptr: ref-of-val
	.runtime: add-task, exception-handler, get-cur-island, get-island, new-exclusion
	.thread-utils: lock, lock-by-val, with-lock
# Used to make code run after the next step. Equivalent to `sleep 0`.
delay fut void()
	void resolved

resolved fut ?t(value ?t)
	fut: lock-by-val, fut-state-resolved: value

rejected fut ?t(err exception)
	fut: lock-by-val, err

join fut ?out(a fut ?in0, b fut ?in1, f ref ?out(?in0, ?in1)) trusted send<?out> send<?in0> send<?in1>
	res = unresolved<?out>
	lock = lock
	remaining = cell<nat>: 2
	decr-remaining = as<act void()>: \
		lock with-lock \
			remaining[] := remaining[] - 1
			if remaining[] == 0
				res finish-join! a, b, f
	a callback! \ignore
		decr-remaining[]
	b callback! \ignore
		decr-remaining[]
	res

.finish-join! void(res fut ?out, a fut ?in0, b fut ?in1, f ref ?out(?in0, ?in1)) unsafe send<?out> send<?in0> send<?in1>
	match a state
	as fut-state-callbacks
		hard-unreachable<void>
	as fut-state-resolved resolved-a
		match b state
		as fut-state-callbacks
			hard-unreachable<void>
		as fut-state-resolved resolved-b
			f[resolved-a value, resolved-b value] forward-to! res
		as exception e
			res reject! e
	as exception e
		res reject! e

# TODO: send<arr ?a> should be unnecessary
join fut arr ?a(a arr fut ?a) trusted send<?a> send<arr ?a> summon
	res = unresolved<arr ?a>
	lock = lock
	remaining = cell<nat>: a.size
	a each-with-index \in, index
		in callback! \value
			lock with-lock \
				remaining[] := remaining[] - 1
				if remaining[] == 0
					res finish-join! a
	res

# TODO: send<arr ?a> should be unnecessary
.finish-join! void(res fut arr ?a, a arr fut ?a) unsafe send<?a> send<arr ?a> summon
	exception = a first-some \x
		match x state
		as fut-state-callbacks
			hard-unreachable<opt exception>
		as fut-state-resolved
			none
		as exception e
			e some
	match exception
	as none
		res resolve!: a map {it must-be-resolved}
	as some s
		res reject! s.value

.must-be-resolved ?a(a fut ?a) unsafe
	match a state
	as fut-state-callbacks
		hard-unreachable
	as fut-state-resolved r
		r value
	as exception
		hard-unreachable

# TODO: PRIVATE
# WARN: Calls the callback immediately if possible
callback! void(f fut ?t, cb act void(result<?t, exception>)) unsafe
	f.lk.ref-of-val with-lock \
		match f state
		as fut-state-callbacks cbs
			# create a new callback
			f.state := fut-state-callbacks<?t>: some: fut-callback-node<?t>: cb, cbs.head
		as fut-state-resolved r
			cb[r.value ok]
		as exception e
			cb[e err]

.forward-to! void(from fut ?t, to fut ?t) unsafe
	from callback! {to resolve-or-reject! it}

fut-catch fut result<?t, exception>(a fut ?t) trusted
	res = unresolved<result<?t, exception>>
	a callback! {res resolve! it}
	res

then fut ?out(f fut ?in, cb ref ?out(?in)) trusted send<?out> send<?in>
	res = unresolved<?out>
	f callback! \result
		match result
		as ok o
			cb[o.value] forward-to! res
		as err e
			res reject! e.value
	res

then-void fut ?out(a fut void, cb ref ?out()) send<?out>
	a then \ignore
		cb[]

# TODO: rename to just 'then'
# This requires that we be able to handle two expected types at once,
# and choose just one based on the arity of a lambda.
then2 fut ?out(f fut void, cb ref ?out()) send<?out>
	f then<?out, void> \ignore
		cb[]

# Runs `f` in parallel.
launch fut ?t(f fun fut ?t()) trusted
	res = unresolved<?t>
	island = get-cur-island
	island add-task island.new-exclusion, \
		f[] forward-to! res
	res

subscript fut ?r(f ref ?r()) trusted send<?r>
	res = unresolved<?r>
	f.island-and-exclusion.island.get-island add-task f.island-and-exclusion.exclusion, \
		{f.fun[] forward-to! res} catch {res reject! it}
	res

call-ref-void void(f ref void()) trusted
	f[] handle-exceptions

subscript fut ?r(f ref ?r(?p0), p0 ?p0) trusted send<?r> send<?p0>
	island = f.island-and-exclusion.island get-island
	res = unresolved<?r>
	island add-task f.island-and-exclusion.exclusion, \
		{f.fun[p0] forward-to! res} catch {res reject! it}
	res

call-ref-void void(f ref void(?p0), p0 ?p0) trusted send<?p0>
	f[p0] handle-exceptions

subscript fut ?r(f ref ?r(?p0, ?p1), p0 ?p0, p1 ?p1) trusted send<?r> send<?p0> send<?p1>
	island = f.island-and-exclusion.island get-island
	res = unresolved<?r>
	island add-task f.island-and-exclusion.exclusion, \
		{f.fun[p0, p1] forward-to! res} catch {res reject! it}
	res

call-ref-void void(f ref void(?p0, ?p1), p0 ?p0, p1 ?p1) send<?p0> send<?p1>
	f[p0, p1] handle-exceptions

handle-exceptions void(a fut ?t) trusted
	a callback! \result
		match result
		as ok
			void
		as err e
			get-cur-island.exception-handler[e.value]
