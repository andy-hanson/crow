import
	col.arr-util: try-remove-start
	io.io: check-errno, connect-to-uri, exit-code, print, uri
	openssl
		ERR_clear_error, OPENSSL_init_ssl, ssl, SSL_connect, ssl-ctx, SSL_CTX_new,
		SSL_load_error_strings, SSL_new, SSL_set_fd, TLS_client_method
	posix: fd-t, sigignore, sigpipe

main fut exit-code(args arr str) summon
	print: "Hello ya world!"
	test-uri
	0 resolved

test-uri void() summon
	my-uri = "https://www.duckduckgo.com:80/some-thing"
	if uri ?= my-uri parse-uri
		uri test-get
		# print: "host: " + uri.host
		# print: "path and query: " + uri.path-and-query
		# print: "port: " + uri.port.to-str
	else
		print: "did not parse"

split-with-splitter<?a> record
	before arr ?a
	at ?a
	after arr ?a

split<?a> record
	before arr ?a
	after arr ?a

# TODO: ->UTILS
split-at-first opt split-with-splitter<?a>(a arr ?a, pred act bool(?a))
	idx <- a find-index pred
	# TODO: parens should be unnecessary
	some: split-with-splitter<?a>: (a slice-up-to idx), a[idx], (a slice-after idx)

# If splitter is not present, right part is empty
try-split split ?a(a arr ?a, pred act bool(?a))
	if index ?= a find-index pred
		split<?a>: (a slice-up-to index), (a slice-after index)
	else
		split<?a>: a, []

# If splitter is not present, right part is empty
try-split-from-right split ?a(a arr ?a, pred act bool(?a))
	if index ?= a find-rindex pred
		split<?a>: (a slice-up-to index), (a slice-after index)
	else
		split<?a>: a, []

# nghttp2-session-callbacks-new foo() extern<"nghttp2_session_callbacks_new"> noctx summon
# nghttp2-session-client-new foo() extern<"nghttp2_session_client"> noctx summon
# nghttp2-session-callbacks-del foo() extern<"nghttp2_session_callbacks_del"> noctx summon
# nghttp2-submit-settings foo() extern<"nghttp2_submit_settings"> noctx summon
# nghttp2-session-want-read foo() extern<"nghttp2_session_want_read"> noctx summon
# nghttp2-session-want-write foo() extern<"nghttp2_session_want_write"> noctx summon
# nghttp2-session-del foo() extern<"nghttp2_session_del"> noctx summon



request record mut
	host c-str
	path c-str
	hostport c-str
	stream-id int32
	port nat16

test-get void(u uri) trusted summon
	# act = zero as<by-val<sigaction>>
	# act = new<by-val<sigaction>>
	#	sa-handler. sig-ign
	#	sa-flags. zero
	#	sa-restorer. null
	#	sa-mask. zero
	# sigpipe act

	# Ignore SIGPIPE errors (WARN: This has a global effect!)
	if sigpipe.sigignore != 0
		check-errno

	# ssl-load-error-strings
	i = OPENSSL_init_ssl: 0, null.as-ref
	assert: i == 0

	fd = u connect-to-uri

	ssl-ctx = TLS_client_method SSL_CTX_new
	forbid: ssl-ctx.as-any-ptr null?
	ssl = ssl-ctx SSL_new
	forbid: ssl.as-any-ptr null?

	ssl ssl-handshake fd

	todo

ssl-handshake void(ssl ssl, fd fd-t) summon
	err = ssl SSL_set_fd fd
	# TODO: handle errors
	forbid: err == 0
	ERR_clear_error
	rv = ssl SSL_connect
	# TODO: handle other return values
	assert: rv == 1



# ALGORITHM:
# eat 'https://'
# eat up to `:/?#`
# if saw `:`, eat up to `/`
# if saw `/`, eat up to `?`

# BETTER: do it in reverse
# Parse off '#' from right
# Parse off '?' from right
# Then parse the *first* '/'
# Then take a ':' from the left part
parse-uri opt uri(uri str)
	# Must start with https
	after-https <- uri try-remove-str-start "https://"

	host-and-port-split-path-and-query-and-hash = after-https try-split {it == "/"}
	host-and-port = host-and-port-split-path-and-query-and-hash before
	path-and-query-and-hash = host-and-port-split-path-and-query-and-hash after

	host-split-port = host-and-port try-split {it == ":"}
	host = host-split-port before
	port-str = host-split-port after
	port = port-str.literal as<nat16>

	path-and-query-split-after-hash = path-and-query-and-hash try-split-from-right {it == "#"}
	path-and-query = path-and-query-split-after-hash before
	after-hash = path-and-query-split-after-hash after

	# TODO: not bothering to split out query for now.

	some: uri: host, port, path-and-query, after-hash
