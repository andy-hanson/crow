import
	crow/col/arr-util: flatten
	crow/io/print: out, print
	crow/private/thread-utils: count-processors
	crow/str-util: join

main fut nat(_ str[]) unsafe summon
	out print "running with {count-processors} processors"
	# TODO: a module with helpers to do things like filter in parallel
	primes <- for x : 1_000_000 .. 1_010_000 parallel
		if x is-prime
			(x,),
	out print "primes: {", " join (for x : primes.flatten; x to-str)}"
	()

parallel-range<a> record
	.inner range a

parallel<a> parallel-range a(a range a)
	a,

# TODO: be generic!
for-loop fut nat64[][](a parallel-range nat64, f fun fut nat64[](nat64))
	tasks fut<nat64[]>[] = for x : a.inner
		launch: () =>
			f[x]
	tasks wait-all

# intentionally inefficient to demonstrate parallel speedup
is-prime bool(a nat)
	!(2 .. a exists x => a is-multiple-of x)
