import
	crow.col.deque: deque
	crow.col.dict: dict
	crow.col.frozen-unordered-set: frozen-unordered-set
	crow.col.index-set: index-set
	crow.col.list: list
	crow.col.lookup: lookup
	crow.col.mut-deque: mut-deque
	crow.col.mut-dict: mut-dict
	crow.col.mut-grid: mut-grid
	crow.col.mut-list: mut-list
	crow.col.mut-lookup: mut-lookup
	crow.col.mut-priority-queue: mut-priority-queue
	crow.col.mut-set: mut-set
	crow.col.mut-stack: mut-stack
	crow.col.priority-queue: priority-queue
	crow.col.set: set
	crow.col.stack: stack
	crow.col.tree-set: tree-set
	crow.col.unordered-set-2: unordered-set
	crow.col.queue: queue
	crow.crypto.password: password-hash, quality-moderate
	crow.io.time-format: gmt
	crow.iter: iter
	crow.json: parse-json
	crow.log: info, log
	crow.parse-command: parse-named-args
	crow.perf: perf-now
	crow.reader: reader, take-quoted-str!
	crow.serialize: from-bytes
	crow.test.test-runner: run-all-tests

main fut nat(_ arr str) summon
	drop: [].from-bytes as<arr nat8>
	drop: "" password-hash quality-moderate
	drop: deque<nat>
	drop: dict<nat, nat>
	drop: frozen-unordered-set<nat>
	drop: index-set
	drop: list<nat>
	drop: lookup<nat, str>
	drop: mut-deque<nat>
	drop: mut-dict<nat, nat>
	drop: mut-grid<nat>
	drop: mut-list<nat>
	drop: mut-lookup<nat, nat>
	drop: mut-priority-queue<nat, nat>
	drop: mut-set<nat>
	drop: mut-stack<nat>
	drop: perf-now
	drop: priority-queue<nat, nat>
	drop: set<nat>
	drop: stack<nat>
	drop: tree-set<nat>
	drop: unordered-set<nat>
	drop: queue<nat>
	drop: gmt
	drop: 0 -> 0 iter
	drop: "" parse-json
	drop: [] parse-named-args []
	run-all-tests
	0 resolved

test
	1 + 1 is 2
	info log "I am a test!"

test
	info log "READER TEST START"

	r = "\"j\"" reader
	if s ?= r take-quoted-str!
		info log "GOT A STRING: {s}"
	else
		info log "GOT NOTHIN"

	info log "READER TEST DONE"
