import
	#crow/col/set: ~, alloc-count, deep-size-bytes, overhead-bytes, set, size
	#crow/col/tree-set: ~, alloc-count, arr, dbg, deep-size-bytes, overhead-bytes, size, tree-set
	#crow/col/unordered-set: ~, alloc-count, overhead-bytes, unordered-set, size
	crow/col/unordered-set-2: ~, alloc-count, overhead-bytes, unordered-set, size
	#crow/col/lookup: dbg
	#crow/io/duration: msec
	crow/io/print: print
	crow/io/time: get-monotime-nsec
	#crow/perf: count, perf-get-measure, perf-reset, total-duration

main fut nat(_ arr str) unsafe summon
	42 srand
	
	max-value = 2000000
	iters = 1000000

	#start-s = get-monotime-nsec
	#perf-reset: ["bin-search"]
	#s = set<nat> add-test-recur iters, max-value
	#end-s = get-monotime-nsec
	#print: "s took: {(end-s - start-s) / 1000000}ms"
	#m = "bin-search" perf-get-measure
	#print: "bin-search: {m count} times, {m.total-duration msec}ms"
	#print: "s size is: {s size}"
	#print: "s deep-size-bytes is {s deep-size-bytes}"
	#print: "s overhead-bytes is {s overhead-bytes}"
	#print: "s alloc-count is {s alloc-count}"
	#perf-reset: []

	42 srand
	start-us = get-monotime-nsec
	us = unordered-set<nat> add-test-recur iters, max-value
	end-us = get-monotime-nsec
	print: "us took: {(end-us - start-us) / 1000000}ms"

	print: "us size is: {us size}"
	print: "us overhead-bytes is {us overhead-bytes}"
	print: "us alloc-count is {us alloc-count}"
	#print: "us dbg is:"
	#print: us.inner dbg

	#if false
	#	42 srand
	#	start-ts = get-monotime-nsec
	#	ts = tree-set<nat> add-test-recur iters, max-value
	#	end-ts = get-monotime-nsec
	#	print: "ts took: {(end-ts - start-ts) / 1000000}ms"
	#	print: "ts size is {ts size}"
	#	print: "ts deep-size-bytes is {ts deep-size-bytes}"
	#	print: "ts overhead-bytes is {ts overhead-bytes}"
	#	print: "ts alloc-count is {ts alloc-count}"
	#	print: "ts dbg is {ts dbg}"
	#
	#	s-arr = s arr
	#	ts-arr = ts arr
	#
	#	s-arr is ts-arr

	0 resolved

#.add-test-recur set nat(a set nat, iters nat, max-value nat) summon
#	if iters == 0
#		a
#	else
#		a ~ max-value.rand-nat add-test-recur iters - 1, max-value

.add-test-recur unordered-set nat(a unordered-set nat, iters nat, max-value nat) summon
	if iters == 0
		a
	else
		n = max-value.rand-nat
		#print: "Add {n}"
		an = a ~ n
		#print: an.inner.dbg
		an add-test-recur iters - 1, max-value

#.add-test-recur tree-set nat(a tree-set nat, iters nat, max-value nat) summon
#	if iters == 0
#		a
#	else
#		a ~ max-value.rand-nat add-test-recur iters - 1, max-value

rand-nat nat(max nat) summon
	rand.to-nat mod max

rand int32() noctx extern summon

srand void(a nat32) noctx extern summon
