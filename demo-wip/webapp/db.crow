import
	crow/crypto/experimental/login-cookie:
		cookie, cookie-matches, from-bytes, generate-login-cookie, login-cookie,
		parse-login-cookie, to-bytes, to-str
	crow/crypto/password-hash: password-hash, password-matches-hash, quality-moderate
	crow/io/print: err, out, print
	crow/reader: parse-nat
	crow/serialize: from-bytes, to-bytes
	crow/str-util: try-split-once
	lmdb/main:
		abortable-write-transaction, add, count, database, from-lmdb-key, get, lmdb-db, lmdb-env,
		lmdb-key-flags, lmdb-txn, open-lmdb-env, map, read-transaction, set, to-lmdb-key,
		transaction-abort, transaction-commit, try-add, with-block, write-transaction, zip

main fut nat(_ str[]) unsafe summon
	with db : open-real-db
		if true
			match db register-user "alice", "swordfish"
			as register-user-success user-id
				out print "Success: user is {user-id}"
			as user-already-exists
				err print "That user already exists"

		cookie = match db login "alice", "swordfish"
		as ok o
			o
		as err _
			throw "TODO"
		first-post = db add-post cookie, "hello world"
		pi = db get-post-info first-post
		out print "{pi user-name} ({pi user}): {pi content}"

		out print "users:"
		for user : db list-users
			out print user.to-str
		out print "posts:"
		for post : db list-posts
			out print post.to-str
		()

user alias
	nat

user-info record
	user user
	user-name str

to-str str(a user-info)
	"user {a user}: {a user-name}"

post alias
	nat

post-info record
	post post
	user user
	user-name str
	content str

to-str str(a post-info)
	"post {a post}: {a user-name} (user {a user}) says: {a content}"

user-cookie record
	user nat
	inner login-cookie

parse-user-cookie user-cookie?(a str)
	if split ?= a try-split-once "|"
		if user ?= split.a parse-nat
			if inner ?= split.b parse-login-cookie
				(user, inner),

to-str str(a user-cookie)
	"{a user}|{a inner}"

db record mut
	.env lmdb-env
	.user-from-name lmdb-db<str, user>
	.user-name lmdb-db<user, str>
	.user-password-hash lmdb-db<user, nat8[]>
	.user-login-cookie lmdb-db<user, login-cookie>
	.post-user lmdb-db<post, user>
	.post-content lmdb-db<post, str>

open-db record
	db-path str
.open-db open-db(db-path str)
	db-path,

open-real-db open-db()
	db-path open-db

with-block<a> fut a(a open-db, f act fut a(db)) unsafe summon is-sendable<a>
	with env : a.db-path open-lmdb-env true
		with user-from-name : env database@<str, user> "user-from-name"
			with user-name : env database@<user, str> "user-name"
				with user-pw-hash : env database@<user, nat8[]> "user-password-hash"
					with user-login : env database@<user, login-cookie> "user-login-cookie"
						with post-user : env database@<post, user> "post-user"
							with post-content : env database@<post, str> "post-content"
								f[(env, user-from-name, user-name, user-pw-hash, user-login, post-user, post-content)]

list-users user-info[](db db) summon
	with txn : db.env read-transaction
		txn map db.user-name, (user, name) =>
			user, name

user-name str(db db, user user) summon
	with txn : db.env read-transaction
		(txn get db.user-name, user)!

list-posts post-info[](db db) summon
	with txn : db.env read-transaction
		txn zip db.post-user, db.post-content, (post, user, content) =>
			user-name = (txn get db.user-name, user)!
			post, user, user-name, content

register-user-result union
	register-user-success user
	user-already-exists
== bool(a register-user-result, b register-user-result) noctx
	match a
	as register-user-success sa
		match b
		as register-user-success sb
			sa == sb
		as user-already-exists
			false
	as user-already-exists
		match b
		as register-user-success _
			false
		as user-already-exists
			true

register-user register-user-result(db db, user-name str, password str) summon
	with txn : db.env abortable-write-transaction
		new-user-id = txn count db.user-from-name
		user-count-check = txn count db.user-name
		assert new-user-id == user-count-check
		if txn try-add db.user-from-name, user-name, new-user-id
			txn add db.user-name, new-user-id, user-name
			hash = password password-hash quality-moderate
			txn add db.user-password-hash, new-user-id, hash
			new-user-id.register-user-success, transaction-commit
		else
			user-already-exists, transaction-abort

login-error enum
	empty-name-or-password
	user-does-not-exist
	wrong-password

login result<user-cookie, login-error>(db db, user-name str, password str) summon
	if user-name.is-empty || password.is-empty
		empty-name-or-password err
	else
		with txn : db.env write-transaction
			if user ?= db get-user txn, user-name
				hash = (txn get db.user-password-hash, user)!
				if password password-matches-hash hash
					cookie = generate-login-cookie
					txn set db.user-login-cookie, user, cookie
					(user, cookie) ok
				else
					wrong-password err
			else
				user-does-not-exist err

.get-post-info post-info(db db, post post) summon
	with txn : db.env read-transaction
		user = (txn get db.post-user, post)!
		user-name = (txn get db.user-name, user)!
		content = (txn get db.post-content, post)!
		post, user, user-name, content

add-post post(db db, cookie user-cookie, content str) summon
	with txn : db.env write-transaction
		user = db authenticate txn, cookie
		post = txn count db.post-user
		txn add db.post-user, post, user
		txn add db.post-content, post, content
		post

.get-user user?(db db, txn lmdb-txn, user-name str) summon
	txn get db.user-from-name, user-name

.authenticate user(db db, txn lmdb-txn, cookie user-cookie) summon
	if db try-authenticate txn, cookie
		cookie user
	else
		throw "Login cookie invalid (may have expired)"

.try-authenticate bool(db db, txn lmdb-txn, cookie user-cookie) summon
	if login-cookie ?= txn get db.user-login-cookie, cookie.user
		login-cookie cookie-matches cookie.inner.cookie, cookie-expire-seconds

.db-path str()
	"demo-wip/webapp/db"

cookie-expire-seconds nat()
	5 * 60
