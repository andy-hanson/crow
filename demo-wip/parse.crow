import
	crow/io/print: out, print
	crow/json
	crow/parse
	crow/math/vec

main nat^(_ string[]) summon
	match person parse "andy hanson"
	as ok v
		out print "{v}"
	as err e
		out print "{e}"

	match vec2 parse "<1.2,    3.4>"
	as ok v
		out print "{v}"
	as err e
		out print "{e}"

	match json parse sample-json
	as ok j
		out print "{j}"
	as err e
		out print "{e}"

	()

sample-json string()
	# TODO: add some whitespace
	"""\{"x":1,"y":[false,\{"z":3},[],\{}]}"""

person record
	first string
	last string

to-string string(a person)
	"first: {a first}, last: {a.last}"

person grammar person()
	word ~~ spaces ~~ word map (first, last) => first, last

vec2 grammar vec2-64()
	"<" ~~ float ~~ "," ~~ spaces ~~ float ~~ ">" map (x, y) => x, y

json grammar json()
	# Need to make it lazy due to recursion.
	# Since grammar just holds a function anyway it's easy to make it lazy..
	with : lazy
		t grammar json = "true".exact map (_ => true json)
		f grammar json = "false".exact map (_ => false json)
		n grammar json = "null".exact map (_ => ())
		nm grammar json = float map (x => x json-number)
		s grammar json = quoted-string map (x => x json)
		# TODO: handle whitespace!
		l grammar json = "[" ~~ (json separated-by ",") ~~ "]" map (x => x.json-list)
		o grammar json = json-object map (x => x.json-object)
		t / f / n / nm / s / l / o

# TODO: handle whitespace!
.json-object grammar json[string]()
	pair grammar<(string, json)> = quoted-string ~~ ":" ~~ json
	pairs grammar<(string, json)[]> = pair separated-by ","
	pairs2 grammar<json[string]> = pairs map x => x.to-dict
	"\{" ~~ pairs2 ~~ "}"
