import
	collection.arr-util: each
	collection.mut-list: ~=, move-to-arr!, mut-list, reduce-size-if-more-than!, size
	io.file: try-read-file, write-file
	io.print: print, print-no-newline
	path: base-name

handle-output arr failure
	original-path str
	output-path str
	actual str
	overwrite-output? bool
spec
	summon
body
	match output-path try-read-file
	as none
		if overwrite-output?
			output-path write-file actual
			[]
		else
			[original-path failure output-path.base-name ~ " does not exist. actual was:\n" ~ actual]
	as some s
		if s.value == actual
			[]
		elif overwrite-output?
			output-path write-file actual
			[]
		else
			message = output-path.base-name ~ " was not as expected. actual:\n" ~ actual
			[original-path failure message]

flat-map-with-max-size arr ?out(a arr ?in, max-size nat, mapper act arr<?out>(?in)) trusted
	res = mut-list<?out>
	a each \x
		if res.size < max-size
			res ~= mapper[x]
			res reduce-size-if-more-than! max-size
	res move-to-arr!

test-options record
	print-tests? bool
	overwrite-output? bool
	max-failures nat

failure record
	path str
	message str

first-failures result<str, arr failure>(a result<str, arr failure>, b fun result<str, arr failure>())
	match a
	as ok ok-a
		match b[]
		as ok ok-b
			ok: ok-a.value ~ "\n" ~ ok-b.value
		as err e
			e
	as err e
		e

print-failures nat(failures result<str, arr failure>, options test-options) summon
	match failures
	as ok o
		print: o value
		0
	as err e
		e.value each {it print-failure}
		n-failures = e.value.size
		print: if n-failures == options.max-failures
			"hit maximum of " ~ options.max-failures.to-str ~ " failures"
		else
			n-failures.to-str ~ " failures"
		n-failures

.print-failure void(failure failure) summon
	print-bold
	print-no-newline: failure path
	print-reset
	print-no-newline: " "
	print: failure message

# TODO:MOVE
.print-bold void() summon
	print-no-newline: "\x1b[1m"

.print-reset void() summon
	print-no-newline: "\x1b[m"
