import
	crow/col/mut-arr: ~~=, move-to-arr, mut-arr, new, reduce-size-if-more-than, size
	crow/io/file: try-read-file, write-file
	crow/io/path: base-name
	crow/io/print: out, print, print-no-newline
	crow/str-util: normalize-newlines

handle-output failure[](
	original-path str,
	output-path str,
	actual str,
	overwrite-output bool,
) summon
	actual-normalized = actual normalize-newlines
	if text ?= output-path try-read-file
		if text == actual-normalized
			()
		elif overwrite-output
			output-path write-file actual-normalized
			()
		else
			message = "{output-path base-name} was not as expected. actual:\n{actual-normalized}"
			(original-path, message),
	elif overwrite-output
		output-path write-file actual-normalized
		()
	else
		(original-path, "{output-path base-name} does not exist. actual was:\n{actual-normalized}"),

flat-map-with-max-size<out, in> out[](a in[], max-size nat, mapper act out[](in)) trusted
	res out mut[] = ()
	for x : a
		if res.size < max-size
			res ~~= mapper[x]
			res reduce-size-if-more-than max-size
	res move-to-arr

test-options record
	print-tests bool
	overwrite-output bool
	max-failures nat
	match-test str

failure record
	path str
	message str

first-failures result<str, failure[]>(a result<str, failure[]>, b fun result<str, failure[]>())
	match a
	as ok ok-a
		match b[]
		as ok ok-b
			"{ok-a}\n{ok-b}" ok
		as err e
			e err
	as err e
		e err

print-failures nat(failures result<str, failure[]>, options test-options) summon
	match failures
	as ok o
		out print o
		0
	as err e
		for failure : e
			failure print-failure
		n-failures = e size
		out print if n-failures == options.max-failures
			"hit maximum of {options max-failures} failures"
		else
			"{n-failures} failures"
		n-failures

.print-failure void(failure failure) summon
	print-bold
	out print-no-newline failure.path
	print-reset
	out print-no-newline " "
	out print failure.message

# TODO:MOVE
.print-bold void() summon
	out print-no-newline "\x1b[1m"

.print-reset void() summon
	out print-no-newline "\x1b[m"
