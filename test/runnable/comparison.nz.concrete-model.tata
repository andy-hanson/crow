program(
	[
		struct(
			name: ctx
			ptr?: true
			body: record(
				[
					field(gctx-ptr, false, type(false, ptr))
					field(vat-id, false, type(false, nat))
					field(actor-id, false, type(false, nat))
					field(gc-ctx-ptr, false, type(false, ptr))
					field(exception-ctx-ptr, false, type(false, ptr))]))
		struct(name: nat8, body: builtin(nat-8, []))
		struct(name: ptr, body: builtin(ptr, [type(false, nat8)]))
		struct(name: nat, body: builtin(nat-64, []))
		struct(name: int32, body: builtin(int-32, []))
		struct(name: char, body: builtin(char, []))
		struct(name: ptr, body: builtin(ptr, [type(false, char)]))
		struct(name: ptr, body: builtin(ptr, [type(false, ptr)]))
		struct(
			name: fut
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(state, true, type(false, fut-state))]))
		struct(name: lock, ptr?: true, body: record([field(is-locked, false, type(false, atomic-bool))]))
		struct(name: atomic-bool, mut?: true, ptr?: true, body: record([field(value, true, type(false, bool))]))
		struct(name: bool, body: builtin(bool, []))
		struct(
			name: fut-state
			body: union([type(false, fut-state-callbacks), type(false, fut-state-resolved), type(false, exception)]))
		struct(name: fut-state-callbacks, body: record([field(head, false, type(false, opt))]))
		struct(
			name: fut-callback-node
			ptr?: true
			body: record([field(cb, false, type(false, fun-mut1)), field(next-node, false, type(false, opt))]))
		struct(name: void, body: builtin(void, []))
		struct(name: exception, body: record([field(message, false, type(false, arr))]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, int32))]))
		struct(name: err, body: record([field(value, false, type(false, exception))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: none, body: record([]))
		struct(name: some, body: record([field(value, false, type(true, fut-callback-node))]))
		struct(name: fut-state-resolved, body: record([field(value, false, type(false, int32))]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, arr)]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, arr)]))
		struct(name: comparison, body: union([type(false, less), type(false, equal), type(false, greater)]))
		struct(name: less, body: record([]))
		struct(name: equal, body: record([]))
		struct(name: greater, body: record([]))
		struct(
			name: global-ctx
			mut?: true
			ptr?: true
			body: record(
				[
					field(lk, false, type(false, lock))
					field(vats, true, type(false, arr))
					field(n-live-threads, true, type(false, nat))
					field(may-be-work-to-do, false, type(false, condition))
					field(is-shut-down, true, type(false, bool))
					field(any-unhandled-exceptions?, true, type(false, bool))]))
		struct(
			name: vat
			mut?: true
			ptr?: true
			body: record(
				[
					field(gctx, false, type(true, global-ctx))
					field(id, false, type(false, nat))
					field(gc, false, type(false, gc))
					field(tasks-lock, false, type(false, lock))
					field(tasks, false, type(false, mut-bag))
					field(currently-running-actors, false, type(false, mut-arr))
					field(n-threads-running, true, type(false, nat))
					field(next-actor-id, false, type(false, thread-safe-counter))
					field(exception-handler, true, type(false, fun-mut1))]))
		struct(
			name: gc
			mut?: true
			ptr?: true
			body: record(
				[
					field(lk, false, type(false, lock))
					field(context-head, true, type(false, opt))
					field(needs-gc, true, type(false, bool))
					field(is-doing-gc, true, type(false, bool))
					field(begin, false, type(false, ptr))
					field(next-byte, false, type(false, ptr))]))
		struct(
			name: gc-ctx
			mut?: true
			ptr?: true
			body: record([field(gc, true, type(true, gc)), field(next-ctx, true, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, gc-ctx))]))
		struct(
			name: task
			body: record([field(actor-id, false, type(false, nat)), field(fun, false, type(false, fun-mut0))]))
		struct(
			name: fun-mut0
			body: record([field(fun-ptr, false, type(false, fun-ptr2)), field(closure, false, type(false, ptr))]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr)]))
		struct(name: mut-bag, mut?: true, ptr?: true, body: record([field(head, true, type(false, opt))]))
		struct(
			name: mut-bag-node
			mut?: true
			ptr?: true
			body: record([field(value, false, type(false, task)), field(next-node, true, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, mut-bag-node))]))
		struct(
			name: mut-arr
			mut?: true
			ptr?: true
			body: record(
				[
					field(frozen?, true, type(false, bool))
					field(size, true, type(false, nat))
					field(capacity, true, type(false, nat))
					field(data, true, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, nat)]))
		struct(
			name: thread-safe-counter
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(value, true, type(false, nat))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr), type(false, exception)]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(true, vat)]))
		struct(
			name: condition
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(value, true, type(false, nat))]))
		struct(name: int, body: builtin(int-64, []))
		struct(
			name: exception-ctx
			mut?: true
			ptr?: true
			body: record([field(jmp-buf-ptr, true, type(false, ptr)), field(thrown-exception, true, type(false, exception))]))
		struct(
			name: jmp-buf-tag
			body: record(
				[
					field(jmp-buf, false, type(false, bytes64))
					field(mask-was-saved, false, type(false, int32))
					field(saved-mask, false, type(false, bytes128))]))
		struct(
			name: bytes64
			body: record([field(n0, false, type(false, bytes32)), field(n1, false, type(false, bytes32))]))
		struct(
			name: bytes32
			body: record([field(n0, false, type(false, bytes16)), field(n1, false, type(false, bytes16))]))
		struct(name: bytes16, body: record([field(n0, false, type(false, nat)), field(n1, false, type(false, nat))]))
		struct(
			name: bytes128
			body: record([field(n0, false, type(false, bytes64)), field(n1, false, type(false, bytes64))]))
		struct(name: ptr, body: builtin(ptr, [type(false, jmp-buf-tag)]))
		struct(
			name: thread-local-stuff
			ptr?: true
			body: record([field(exception-ctx, false, type(true, exception-ctx))]))
		struct(name: ptr, body: builtin(ptr, [type(false, bool)]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(
			name: fun2
			body: record([field(fun-ptr, false, type(false, fun-ptr4)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr4
			body: builtin(
				fun-ptr
				[type(true, fut), type(true, ctx), type(false, ptr), type(false, arr), type(false, fun-ptr2)]))
		struct(
			name: fut
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(state, true, type(false, fut-state))]))
		struct(
			name: fut-state
			body: union([type(false, fut-state-callbacks), type(false, fut-state-resolved), type(false, exception)]))
		struct(name: fut-state-callbacks, body: record([field(head, false, type(false, opt))]))
		struct(
			name: fut-callback-node
			ptr?: true
			body: record([field(cb, false, type(false, fun-mut1)), field(next-node, false, type(false, opt))]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, void))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, fut-callback-node))]))
		struct(name: fut-state-resolved, body: record([field(value, false, type(false, void))]))
		struct(
			name: fun-ref0
			body: record(
				[field(vat-and-actor, false, type(false, vat-and-actor-id)), field(fun, false, type(false, fun-mut0))]))
		struct(
			name: vat-and-actor-id
			body: record([field(vat, false, type(false, nat)), field(actor, false, type(false, nat))]))
		struct(
			name: fun-mut0
			body: record([field(fun-ptr, false, type(false, fun-ptr2)), field(closure, false, type(false, ptr))]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, ptr)]))
		struct(
			name: fun-ref1
			body: record(
				[field(vat-and-actor, false, type(false, vat-and-actor-id)), field(fun, false, type(false, fun-mut1))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, ptr), type(false, void)]))
		struct(
			name: lambda(then, 0)
			ptr?: true
			body: record([field(cb, false, type(false, fun-ref1)), field(res, false, type(true, fut))]))
		struct(name: lambda(forward-to, 0), body: record([field(to, false, type(true, fut))]))
		struct(
			name: lambda(call, 0)
			ptr?: true
			body: record(
				[
					field(f, false, type(false, fun-ref1))
					field(p0, false, type(false, void))
					field(res, false, type(true, fut))]))
		struct(
			name: lambda(lambda(call, 0), 0)
			ptr?: true
			body: record(
				[
					field(f, false, type(false, fun-ref1))
					field(p0, false, type(false, void))
					field(res, false, type(true, fut))]))
		struct(name: lambda(lambda(call, 0), 1), body: record([field(res, false, type(true, fut))]))
		struct(name: lambda(then2, 0), ptr?: true, body: record([field(cb, false, type(false, fun-ref0))]))
		struct(
			name: lambda(call, 0)
			ptr?: true
			body: record([field(f, false, type(false, fun-ref0)), field(res, false, type(true, fut))]))
		struct(
			name: lambda(lambda(call, 0), 0)
			ptr?: true
			body: record([field(f, false, type(false, fun-ref0)), field(res, false, type(true, fut))]))
		struct(name: lambda(lambda(call, 0), 1), body: record([field(res, false, type(true, fut))]))
		struct(
			name: lambda(add-first-task, 0)
			ptr?: true
			body: record([field(all-args, false, type(false, arr)), field(main-ptr, false, type(false, fun-ptr2))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, arr), type(true, ctx), type(false, ptr), type(false, ptr)]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, arr), type(true, ctx), type(false, ptr), type(false, nat)]))
		struct(
			name: mut-arr
			mut?: true
			ptr?: true
			body: record(
				[
					field(frozen?, true, type(false, bool))
					field(size, true, type(false, nat))
					field(capacity, true, type(false, nat))
					field(data, true, type(false, ptr))]))
		struct(
			name: lambda(map, 0)
			ptr?: true
			body: record([field(mapper, false, type(false, fun-mut1)), field(a, false, type(false, arr))]))
		struct(
			name: thread-args
			ptr?: true
			body: record([field(thread-id, false, type(false, nat)), field(gctx, false, type(true, global-ctx))]))
		struct(name: ptr, body: builtin(ptr, [type(false, thread-args)]))
		struct(name: fun-ptr1, body: builtin(fun-ptr, [type(false, ptr), type(false, ptr)]))
		struct(
			name: chosen-task
			body: record([field(vat, false, type(true, vat)), field(task-or-gc, false, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, task))]))
		struct(name: no-chosen-task, body: record([field(last-thread-out, false, type(false, bool))]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, chosen-task))]))
		struct(name: err, body: record([field(value, false, type(false, no-chosen-task))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, chosen-task))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, opt))]))
		struct(
			name: task-and-nodes
			body: record([field(task, false, type(false, task)), field(nodes, false, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, task-and-nodes))]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: cell, mut?: true, ptr?: true, body: record([field(value, true, type(false, nat))]))
		struct(name: cell, mut?: true, ptr?: true, body: record([field(value, true, type(false, ptr))]))
		struct(name: my-record, body: record([field(x, false, type(false, nat)), field(y, false, type(false, nat))]))
		struct(
			name: my-byref-record
			ptr?: true
			body: record([field(x, false, type(false, nat)), field(y, false, type(false, nat))]))
		struct(name: my-union, body: union([type(false, my-record), type(false, my-other-record)]))
		struct(name: my-other-record, body: record([]))]
	[
		fun(
			false
			rt-main
			type(false, int32)
			none
			[param(argc, type(false, int32)), param(argv, type(false, ptr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				seq(
					call(drop, [call(to-str, [call(deref, [param-ref(argv)])])])
					let(
						n-threads
						call(as, [call(one, [])])
						let(
							gctx-by-val
							call(
								as
								[
									call(
										global-ctx
										[
											call(new-lock, [])
											call(empty-arr, [])
											local-ref(n-threads)
											call(new-condition, [])
											call(false, [])
											call(false, [])])])
							let(
								gctx
								call(ref-of-val, [local-ref(gctx-by-val)])
								let(
									vat-by-val
									call(new-vat, [local-ref(gctx), call(zero, []), local-ref(n-threads)])
									let(
										vat
										call(ref-of-val, [local-ref(vat-by-val)])
										seq(
											set-field(
												local-ref(gctx)
												vats
												call(arr, [call(one, []), call(ptr-to, [local-ref(vat)])]))
											let(
												main-fut
												call(
													do-main
													[
														local-ref(gctx)
														local-ref(vat)
														param-ref(argc)
														param-ref(argv)
														param-ref(main-ptr)])
												seq(
													call(run-threads, [local-ref(n-threads), local-ref(gctx)])
													cond(
														call(any-unhandled-exceptions?, [local-ref(gctx)])
														call(one, [])
														match(
															"<<matched>>"
															call(must-be-resolved, [local-ref(main-fut)])
															[
																case(some(o), call(value, [local-ref(o)]))
																case(
																	some(e)
																	seq(
																		seq(
																			call(print-err-sync-no-newline, [arr(0, 12)])
																			call(
																				print-err-sync
																				[
																					call(
																						message
																						[call(value, [local-ref(e)])])]))
																		call(one, [])))])))))))))))))
		fun(false, drop, type(false, void), none, [param(t, type(false, arr))], expr-body(call(pass, [])))
		fun(false, pass, type(false, void), none, [], builtin([]))
		fun(
			false
			to-str
			type(false, arr)
			none
			[param(a, type(false, ptr))]
			expr-body(call(arr-from-begin-end, [param-ref(a), call(find-cstr-end, [param-ref(a)])])))
		fun(
			false
			arr-from-begin-end
			type(false, arr)
			none
			[param(begin, type(false, ptr)), param(end, type(false, ptr))]
			expr-body(call(arr, [call(-, [param-ref(end), param-ref(begin)]), param-ref(begin)])))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(data, type(false, ptr))]
			new-record)
		fun(
			false
			-
			type(false, nat)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(call(to-nat, [call(-, [param-ref(a), call(to-nat, [param-ref(b)])])])))
		fun(false, to-nat, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, char)]))
		fun(
			false
			-
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, char)]))
		fun(
			false
			find-cstr-end
			type(false, ptr)
			none
			[param(a, type(false, ptr))]
			expr-body(call(find-char-in-cstr, [param-ref(a), call(literal, [arr(0, 1)])])))
		fun(
			false
			find-char-in-cstr
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(c, type(false, char))]
			expr-body(
				cond(
					call(==, [call(deref, [param-ref(a)]), param-ref(c)])
					param-ref(a)
					cond(
						call(==, [call(deref, [param-ref(a)]), call(literal, [arr(0, 1)])])
						call(todo, [])
						call(find-char-in-cstr, [call(incr, [param-ref(a)]), param-ref(c)])))))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, char)), param(b, type(false, char))]
			expr-body(
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, char)), param(b, type(false, char))]
			builtin([type(false, char)]))
		fun(false, false, type(false, bool), none, [], builtin([]))
		fun(false, true, type(false, bool), none, [], builtin([]))
		fun(false, deref, type(false, char), none, [param(p, type(false, ptr))], builtin([type(false, char)]))
		fun(
			false
			literal
			type(false, char)
			none
			[param(a, type(false, arr))]
			expr-body(call(noctx-at, [param-ref(a), call(zero, [])])))
		fun(
			false
			noctx-at
			type(false, char)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(deref, [call(+, [call(data, [param-ref(a)]), param-ref(index)])]))))
		fun(
			false
			hard-assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(call(if, [param-ref(condition), call(pass, []), call(hard-fail, [arr(0, 0)])])))
		fun(
			false
			if
			type(false, void)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, void)), param(if-false, type(false, void))]
			builtin([type(false, void)]))
		fun(false, hard-fail, type(false, void), none, [param(reason, type(false, arr))], builtin([type(false, void)]))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([type(false, nat)]))
		fun(false, size, type(false, nat), none, [param(a, type(false, arr))], field-get(0))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, char)]))
		fun(false, data, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(false, zero, type(false, nat), none, [], builtin([]))
		fun(false, todo, type(false, ptr), none, [], expr-body(call(hard-fail, [arr(0, 2)])))
		fun(false, hard-fail, type(false, ptr), none, [param(reason, type(false, arr))], builtin([type(false, ptr)]))
		fun(
			false
			incr
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			expr-body(call(+, [param-ref(p), call(one, [])])))
		fun(false, one, type(false, nat), none, [], builtin([]))
		fun(false, deref, type(false, ptr), none, [param(p, type(false, ptr))], builtin([type(false, ptr)]))
		fun(false, as, type(false, nat), none, [param(value, type(false, nat))], builtin([type(false, nat)]))
		fun(
			false
			as
			type(false, global-ctx)
			none
			[param(value, type(false, global-ctx))]
			builtin([type(false, global-ctx)]))
		fun(
			false
			global-ctx
			type(false, global-ctx)
			none
			[
				param(lk, type(false, lock))
				param(vats, type(false, arr))
				param(n-live-threads, type(false, nat))
				param(may-be-work-to-do, type(false, condition))
				param(is-shut-down, type(false, bool))
				param(any-unhandled-exceptions?, type(false, bool))]
			new-record)
		fun(false, new-lock, type(false, lock), none, [], expr-body(call(lock, [call(new-atomic-bool, [])])))
		fun(false, lock, type(false, lock), none, [param(is-locked, type(false, atomic-bool))], new-record)
		fun(false, new-atomic-bool, type(false, atomic-bool), none, [], expr-body(call(atomic-bool, [call(false, [])])))
		fun(false, atomic-bool, type(false, atomic-bool), none, [param(value, type(false, bool))], new-record)
		fun(false, empty-arr, type(false, arr), none, [], expr-body(call(arr, [call(zero, []), call(null, [])])))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(data, type(false, ptr))]
			new-record)
		fun(false, null, type(false, ptr), none, [], builtin([type(true, vat)]))
		fun(
			false
			new-condition
			type(false, condition)
			none
			[]
			expr-body(call(condition, [call(new-lock, []), call(zero, [])])))
		fun(
			false
			condition
			type(false, condition)
			none
			[param(lk, type(false, lock)), param(value, type(false, nat))]
			new-record)
		fun(
			false
			ref-of-val
			type(true, global-ctx)
			none
			[param(b, type(false, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(
			false
			new-vat
			type(false, vat)
			none
			[param(gctx, type(true, global-ctx)), param(id, type(false, nat)), param(max-threads, type(false, nat))]
			expr-body(
				let(
					actors
					call(new-mut-arr-by-val-with-capacity-from-unmanaged-memory, [param-ref(max-threads)])
					call(
						vat
						[
							param-ref(gctx)
							param-ref(id)
							call(new-gc, [])
							call(new-lock, [])
							call(new-mut-bag, [])
							local-ref(actors)
							call(zero, [])
							call(new-thread-safe-counter, [])
							lambda(lambda(new-vat, 0), some(null))]))))
		fun(
			false
			new-mut-arr-by-val-with-capacity-from-unmanaged-memory
			type(false, mut-arr)
			none
			[param(capacity, type(false, nat))]
			expr-body(
				call(
					mut-arr
					[
						call(false, [])
						call(zero, [])
						param-ref(capacity)
						call(unmanaged-alloc-elements, [param-ref(capacity)])])))
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[
				param(frozen?, type(false, bool))
				param(size, type(false, nat))
				param(capacity, type(false, nat))
				param(data, type(false, ptr))]
			new-record)
		fun(
			false
			unmanaged-alloc-elements
			type(false, ptr)
			none
			[param(size-elements, type(false, nat))]
			expr-body(
				let(
					bytes
					call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])
					call(ptr-cast, [local-ref(bytes)]))))
		fun(
			false
			unmanaged-alloc-bytes
			type(false, ptr)
			none
			[param(size, type(false, nat))]
			expr-body(
				let(
					res
					call(malloc, [param-ref(size)])
					seq(call(hard-forbid, [call(null?, [local-ref(res)])]), local-ref(res)))))
		fun(false, malloc, type(false, ptr), none, [param(size, type(false, nat))], extern(false))
		fun(
			false
			hard-forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(call(hard-assert, [call(not, [param-ref(condition)])])))
		fun(false, not, type(false, bool), none, [param(a, type(false, bool))], builtin([]))
		fun(
			false
			null?
			type(false, bool)
			none
			[param(a, type(false, ptr))]
			expr-body(call(==, [call(to-nat, [param-ref(a)]), call(to-nat, [call(null, [])])])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(false, to-nat, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, nat8)]))
		fun(false, null, type(false, ptr), none, [], builtin([type(false, nat8)]))
		fun(
			false
			wrap-mul
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, nat)]))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat), type(false, nat8)]))
		fun(
			false
			vat
			type(false, vat)
			none
			[
				param(gctx, type(true, global-ctx))
				param(id, type(false, nat))
				param(gc, type(false, gc))
				param(tasks-lock, type(false, lock))
				param(tasks, type(false, mut-bag))
				param(currently-running-actors, type(false, mut-arr))
				param(n-threads-running, type(false, nat))
				param(next-actor-id, type(false, thread-safe-counter))
				param(exception-handler, type(false, fun-mut1))]
			new-record)
		fun(
			false
			new-gc
			type(false, gc)
			none
			[]
			expr-body(
				call(
					gc
					[
						call(new-lock, [])
						to-union(0, call(none, []))
						call(false, [])
						call(false, [])
						call(null, [])
						call(null, [])])))
		fun(
			false
			gc
			type(false, gc)
			none
			[
				param(lk, type(false, lock))
				param(context-head, type(false, opt))
				param(needs-gc, type(false, bool))
				param(is-doing-gc, type(false, bool))
				param(begin, type(false, ptr))
				param(next-byte, type(false, ptr))]
			new-record)
		fun(false, none, type(false, none), none, [], new-record)
		fun(false, new-mut-bag, type(false, mut-bag), none, [], expr-body(call(mut-bag, [to-union(0, call(none, []))])))
		fun(false, mut-bag, type(false, mut-bag), none, [param(head, type(false, opt))], new-record)
		fun(
			false
			new-thread-safe-counter
			type(false, thread-safe-counter)
			none
			[]
			expr-body(call(new-thread-safe-counter, [call(zero, [])])))
		fun(
			false
			new-thread-safe-counter
			type(false, thread-safe-counter)
			none
			[param(init, type(false, nat))]
			expr-body(call(thread-safe-counter, [call(new-lock, []), param-ref(init)])))
		fun(
			false
			thread-safe-counter
			type(false, thread-safe-counter)
			none
			[param(lk, type(false, lock)), param(value, type(false, nat))]
			new-record)
		fun(
			true
			default-exception-handler
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				seq(
					seq(
						call(print-err-sync-no-newline, [arr(0, 3)])
						call(
							print-err-sync
							[
								call(
									if
									[
										call(empty?, [call(message, [param-ref(e)])])
										arr(0, 5)
										call(message, [param-ref(e)])])]))
					set-field(call(get-gctx, []), any-unhandled-exceptions?, call(true, [])))))
		fun(
			false
			print-err-sync-no-newline
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body(call(write-sync-no-newline, [call(stderr-fd, []), param-ref(s)])))
		fun(
			false
			write-sync-no-newline
			type(false, void)
			none
			[param(fd, type(false, int32)), param(s, type(false, arr))]
			expr-body(
				seq(
					call(hard-assert, [call(==, [call(size-of, []), call(size-of, [])])])
					let(
						res
						call(
							write
							[param-ref(fd), call(as-any-ptr, [call(data, [param-ref(s)])]), call(size, [param-ref(s)])])
						cond(
							call(==, [local-ref(res), call(unsafe-to-int, [call(size, [param-ref(s)])])])
							call(pass, [])
							call(todo, []))))))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, char)]))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, nat8)]))
		fun(
			false
			write
			type(false, int)
			none
			[param(fd, type(false, int32)), param(buff, type(false, ptr)), param(n-bytes, type(false, nat))]
			extern(false))
		fun(false, as-any-ptr, type(false, ptr), none, [param(some-ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([type(false, int)]))
		fun(false, unsafe-to-int, type(false, int), none, [param(a, type(false, nat))], builtin([]))
		fun(false, todo, type(false, void), none, [], expr-body(call(hard-fail, [arr(0, 2)])))
		fun(false, stderr-fd, type(false, int32), none, [], expr-body(call(two, [])))
		fun(false, two, type(false, int32), none, [], expr-body(call(wrap-incr, [call(one, [])])))
		fun(
			false
			wrap-incr
			type(false, int32)
			none
			[param(a, type(false, int32))]
			expr-body(call(wrap-add, [param-ref(a), call(one, [])])))
		fun(
			false
			wrap-add
			type(false, int32)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			builtin([]))
		fun(false, one, type(false, int32), none, [], builtin([]))
		fun(
			false
			print-err-sync
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body(seq(call(print-err-sync-no-newline, [param-ref(s)]), call(print-err-sync-no-newline, [arr(0, 4)]))))
		fun(
			false
			if
			type(false, arr)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, arr)), param(if-false, type(false, arr))]
			builtin([type(false, arr)]))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body(call(zero?, [call(size, [param-ref(a)])])))
		fun(
			false
			zero?
			type(false, bool)
			none
			[param(n, type(false, nat))]
			expr-body(call(==, [param-ref(n), call(zero, [])])))
		fun(false, message, type(false, arr), none, [param(a, type(false, exception))], field-get(0))
		fun(
			true
			get-gctx
			type(true, global-ctx)
			none
			[]
			expr-body(call(as-ref, [call(gctx-ptr, [call(get-ctx, [])])])))
		fun(
			false
			as-ref
			type(true, global-ctx)
			none
			[param(p, type(false, ptr))]
			builtin([type(true, global-ctx)]))
		fun(false, gctx-ptr, type(false, ptr), none, [param(a, type(true, ctx))], field-get(0))
		fun(true, get-ctx, type(true, ctx), none, [], builtin([]))
		fun(
			true
			lambda(new-vat, 0)
			type(false, void)
			some(param("<<closure>>", type(false, ptr)))
			[param(it, type(false, exception))]
			expr-body(call(default-exception-handler, [param-ref(it)])))
		fun(false, ref-of-val, type(true, vat), none, [param(b, type(false, vat))], builtin([type(true, vat)]))
		fun(false, ptr-to, type(false, ptr), none, [param(t, type(true, vat))], builtin([type(true, vat)]))
		fun(
			false
			do-main
			type(true, fut)
			none
			[
				param(gctx, type(true, global-ctx))
				param(vat, type(true, vat))
				param(argc, type(false, int32))
				param(argv, type(false, ptr))
				param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				let(
					ectx
					call(new-exception-ctx, [])
					let(
						tls
						call(as, [call(thread-local-stuff, [call(ref-of-val, [local-ref(ectx)])])])
						let(
							ctx-by-val
							call(
								new-ctx
								[param-ref(gctx), call(ref-of-val, [local-ref(tls)]), param-ref(vat), call(zero, [])])
							let(
								ctx
								call(ref-of-val, [local-ref(ctx-by-val)])
								let(
									add
									call(as, [lambda(lambda(do-main, 0), some(null))])
									let(
										all-args
										call(
											arr
											[call(unsafe-to-nat, [call(to-int, [param-ref(argc)])]), param-ref(argv)])
										call(
											call-with-ctx
											[local-ref(ctx), local-ref(add), local-ref(all-args), param-ref(main-ptr)])))))))))
		fun(
			false
			new-exception-ctx
			type(false, exception-ctx)
			none
			[]
			expr-body(call(exception-ctx, [call(null, []), call(exception, [record([0, null])])])))
		fun(
			false
			exception-ctx
			type(false, exception-ctx)
			none
			[param(jmp-buf-ptr, type(false, ptr)), param(thrown-exception, type(false, exception))]
			new-record)
		fun(false, null, type(false, ptr), none, [], builtin([type(false, jmp-buf-tag)]))
		fun(false, exception, type(false, exception), none, [param(message, type(false, arr))], new-record)
		fun(
			false
			as
			type(false, thread-local-stuff)
			none
			[param(value, type(false, thread-local-stuff))]
			builtin([type(false, thread-local-stuff)]))
		fun(
			false
			thread-local-stuff
			type(false, thread-local-stuff)
			none
			[param(exception-ctx, type(true, exception-ctx))]
			new-record)
		fun(
			false
			ref-of-val
			type(true, exception-ctx)
			none
			[param(b, type(false, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			false
			new-ctx
			type(false, ctx)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(vat, type(true, vat))
				param(actor-id, type(false, nat))]
			expr-body(
				call(
					ctx
					[
						call(as-any-ptr, [param-ref(gctx)])
						call(id, [param-ref(vat)])
						param-ref(actor-id)
						call(as-any-ptr, [call(get-gc-ctx, [call(ref-of-val, [call(gc, [param-ref(vat)])])])])
						call(as-any-ptr, [call(exception-ctx, [param-ref(tls)])])])))
		fun(
			false
			ctx
			type(false, ctx)
			none
			[
				param(gctx-ptr, type(false, ptr))
				param(vat-id, type(false, nat))
				param(actor-id, type(false, nat))
				param(gc-ctx-ptr, type(false, ptr))
				param(exception-ctx-ptr, type(false, ptr))]
			new-record)
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(some-ref, type(true, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(false, id, type(false, nat), none, [param(a, type(true, vat))], field-get(1))
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(some-ref, type(true, gc-ctx))]
			builtin([type(true, gc-ctx)]))
		fun(
			false
			get-gc-ctx
			type(true, gc-ctx)
			none
			[param(gc, type(true, gc))]
			expr-body(
				seq(
					call(acquire-lock, [call(ref-of-val, [call(lk, [param-ref(gc)])])])
					let(
						res
						match(
							"<<matched>>"
							call(context-head, [param-ref(gc)])
							[
								case(
									none
									let(
										c
										call(as-ref, [call(malloc, [call(size-of, [])])])
										seq(
											seq(
												set-field(local-ref(c), gc, param-ref(gc))
												set-field(local-ref(c), next-ctx, to-union(0, call(none, []))))
											local-ref(c))))
								case(
									some(s)
									let(
										c
										call(value, [local-ref(s)])
										seq(
											seq(
												set-field(param-ref(gc), context-head, call(next-ctx, [local-ref(c)]))
												set-field(local-ref(c), next-ctx, to-union(0, call(none, []))))
											local-ref(c))))])
						seq(call(release-lock, [call(ref-of-val, [call(lk, [param-ref(gc)])])]), local-ref(res))))))
		fun(
			false
			acquire-lock
			type(false, void)
			none
			[param(a, type(true, lock))]
			expr-body(call(acquire-lock-recur, [param-ref(a), call(zero, [])])))
		fun(
			false
			acquire-lock-recur
			type(false, void)
			none
			[param(a, type(true, lock)), param(n-tries, type(false, nat))]
			expr-body(
				cond(
					call(try-acquire-lock, [param-ref(a)])
					call(pass, [])
					cond(
						call(==, [param-ref(n-tries), call(thousand, [])])
						call(hard-fail, [arr(0, 6)])
						seq(
							call(yield-thread, [])
							call(acquire-lock-recur, [param-ref(a), call(noctx-incr, [param-ref(n-tries)])]))))))
		fun(
			false
			try-acquire-lock
			type(false, bool)
			none
			[param(a, type(true, lock))]
			expr-body(call(try-set, [call(ref-of-val, [call(is-locked, [param-ref(a)])])])))
		fun(
			false
			try-set
			type(false, bool)
			none
			[param(a, type(true, atomic-bool))]
			expr-body(call(try-change, [param-ref(a), call(false, [])])))
		fun(
			false
			try-change
			type(false, bool)
			none
			[param(a, type(true, atomic-bool)), param(old-value, type(false, bool))]
			expr-body(
				call(
					compare-exchange-strong
					[
						call(ptr-to, [call(value, [param-ref(a)])])
						call(ptr-to, [param-ref(old-value)])
						call(not, [param-ref(old-value)])])))
		fun(
			false
			compare-exchange-strong
			type(false, bool)
			none
			[
				param(value-ptr, type(false, ptr))
				param(expected-ptr, type(false, ptr))
				param(desired, type(false, bool))]
			builtin([]))
		fun(false, ptr-to, type(false, ptr), none, [param(t, type(false, bool))], builtin([type(false, bool)]))
		fun(false, value, type(false, bool), none, [param(a, type(true, atomic-bool))], field-get(0))
		fun(
			false
			ref-of-val
			type(true, atomic-bool)
			none
			[param(b, type(false, atomic-bool))]
			builtin([type(true, atomic-bool)]))
		fun(false, is-locked, type(false, atomic-bool), none, [param(a, type(true, lock))], field-get(0))
		fun(false, thousand, type(false, nat), none, [], expr-body(call(wrap-mul, [call(hundred, []), call(ten, [])])))
		fun(false, hundred, type(false, nat), none, [], expr-body(call(wrap-mul, [call(ten, []), call(ten, [])])))
		fun(false, ten, type(false, nat), none, [], expr-body(call(wrap-incr, [call(nine, [])])))
		fun(
			false
			wrap-incr
			type(false, nat)
			none
			[param(a, type(false, nat))]
			expr-body(call(wrap-add, [param-ref(a), call(one, [])])))
		fun(
			false
			wrap-add
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(false, nine, type(false, nat), none, [], expr-body(call(wrap-incr, [call(eight, [])])))
		fun(false, eight, type(false, nat), none, [], expr-body(call(wrap-incr, [call(seven, [])])))
		fun(false, seven, type(false, nat), none, [], expr-body(call(wrap-incr, [call(six, [])])))
		fun(false, six, type(false, nat), none, [], expr-body(call(wrap-incr, [call(five, [])])))
		fun(false, five, type(false, nat), none, [], expr-body(call(wrap-incr, [call(four, [])])))
		fun(false, four, type(false, nat), none, [], expr-body(call(wrap-incr, [call(three, [])])))
		fun(false, three, type(false, nat), none, [], expr-body(call(wrap-incr, [call(two, [])])))
		fun(false, two, type(false, nat), none, [], expr-body(call(wrap-incr, [call(one, [])])))
		fun(
			false
			yield-thread
			type(false, void)
			none
			[]
			expr-body(let(err, call(pthread-yield, []), call(hard-assert, [call(zero?, [local-ref(err)])]))))
		fun(false, pthread-yield, type(false, int32), none, [], extern(false))
		fun(
			false
			zero?
			type(false, bool)
			none
			[param(i, type(false, int32))]
			expr-body(call(==, [param-ref(i), call(zero, [])])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			expr-body(
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			builtin([type(false, int32)]))
		fun(false, zero, type(false, int32), none, [], builtin([]))
		fun(
			false
			noctx-incr
			type(false, nat)
			none
			[param(n, type(false, nat))]
			expr-body(
				seq(call(hard-assert, [call(<, [param-ref(n), call(billion, [])])]), call(wrap-incr, [param-ref(n)]))))
		fun(
			false
			billion
			type(false, nat)
			none
			[]
			expr-body(call(wrap-mul, [call(million, []), call(thousand, [])])))
		fun(
			false
			million
			type(false, nat)
			none
			[]
			expr-body(call(wrap-mul, [call(thousand, []), call(thousand, [])])))
		fun(false, ref-of-val, type(true, lock), none, [param(b, type(false, lock))], builtin([type(true, lock)]))
		fun(false, lk, type(false, lock), none, [param(a, type(true, gc))], field-get(0))
		fun(false, context-head, type(false, opt), none, [param(a, type(true, gc))], field-get(1))
		fun(false, as-ref, type(true, gc-ctx), none, [param(p, type(false, ptr))], builtin([type(true, gc-ctx)]))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, gc-ctx)]))
		fun(false, value, type(true, gc-ctx), none, [param(a, type(false, some))], field-get(0))
		fun(false, next-ctx, type(false, opt), none, [param(a, type(true, gc-ctx))], field-get(1))
		fun(
			false
			release-lock
			type(false, void)
			none
			[param(l, type(true, lock))]
			expr-body(call(must-unset, [call(ref-of-val, [call(is-locked, [param-ref(l)])])])))
		fun(
			false
			must-unset
			type(false, void)
			none
			[param(a, type(true, atomic-bool))]
			expr-body(let(did-unset, call(try-unset, [param-ref(a)]), call(hard-assert, [local-ref(did-unset)]))))
		fun(
			false
			try-unset
			type(false, bool)
			none
			[param(a, type(true, atomic-bool))]
			expr-body(call(try-change, [param-ref(a), call(true, [])])))
		fun(false, ref-of-val, type(true, gc), none, [param(b, type(false, gc))], builtin([type(true, gc)]))
		fun(false, gc, type(false, gc), none, [param(a, type(true, vat))], field-get(2))
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(some-ref, type(true, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			false
			exception-ctx
			type(true, exception-ctx)
			none
			[param(a, type(true, thread-local-stuff))]
			field-get(0))
		fun(
			false
			ref-of-val
			type(true, thread-local-stuff)
			none
			[param(b, type(false, thread-local-stuff))]
			builtin([type(true, thread-local-stuff)]))
		fun(false, ref-of-val, type(true, ctx), none, [param(b, type(false, ctx))], builtin([type(true, ctx)]))
		fun(false, as, type(false, fun2), none, [param(value, type(false, fun2))], builtin([type(false, fun2)]))
		fun(
			true
			add-first-task
			type(true, fut)
			none
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				call(
					then2
					[
						call(as, [call(resolved, [call(pass, [])])])
						record(
							[
								call(cur-actor, [])
								lambda(
									lambda(add-first-task, 0)
									some(alloc(record([param-ref(all-args), param-ref(main-ptr)]))))])])))
		fun(
			true
			then2
			type(true, fut)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-ref0))]
			expr-body(
				call(
					then
					[
						param-ref(f)
						record([call(cur-actor, []), lambda(lambda(then2, 0), some(alloc(record([param-ref(cb)]))))])])))
		fun(
			true
			then
			type(true, fut)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-ref1))]
			expr-body(
				let(
					res
					call(new-unresolved-fut, [])
					seq(
						call(
							then-void
							[param-ref(f), lambda(lambda(then, 0), some(alloc(record([param-ref(cb), local-ref(res)]))))])
						local-ref(res)))))
		fun(
			true
			new-unresolved-fut
			type(true, fut)
			none
			[]
			expr-body(
				call(fut, [call(new-lock, []), to-union(0, call(fut-state-callbacks, [to-union(0, call(none, []))]))])))
		fun(
			true
			fut
			type(true, fut)
			none
			[param(lk, type(false, lock)), param(state, type(false, fut-state))]
			new-record)
		fun(
			true
			fut-state-callbacks
			type(false, fut-state-callbacks)
			none
			[param(head, type(false, opt))]
			new-record)
		fun(
			true
			then-void
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-mut1))]
			expr-body(
				seq(
					seq(
						call(acquire-lock, [call(ref-of-val, [call(lk, [param-ref(f)])])])
						match(
							"<<matched>>"
							call(state, [param-ref(f)])
							[
								case(
									some(cbs)
									set-field(
										param-ref(f)
										state
										to-union(
											0
											call(
												fut-state-callbacks
												[
													to-union(
														1
														call(
															some
															[
																call(
																	fut-callback-node
																	[param-ref(cb), call(head, [local-ref(cbs)])])]))]))))
								case(
									some(r)
									call(call, [param-ref(cb), to-union(0, call(ok, [call(value, [local-ref(r)])]))]))
								case(some(e), call(call, [param-ref(cb), to-union(1, call(err, [local-ref(e)]))]))]))
					call(release-lock, [call(ref-of-val, [call(lk, [param-ref(f)])])]))))
		fun(false, lk, type(false, lock), none, [param(a, type(true, fut))], field-get(0))
		fun(false, state, type(false, fut-state), none, [param(a, type(true, fut))], field-get(1))
		fun(
			true
			fut-state-callbacks
			type(false, fut-state-callbacks)
			none
			[param(head, type(false, opt))]
			new-record)
		fun(false, some, type(false, some), none, [param(value, type(true, fut-callback-node))], new-record)
		fun(
			true
			fut-callback-node
			type(true, fut-callback-node)
			none
			[param(cb, type(false, fun-mut1)), param(next-node, type(false, opt))]
			new-record)
		fun(false, head, type(false, opt), none, [param(a, type(false, fut-state-callbacks))], field-get(0))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body(
				call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)]), param-ref(p0)])))
		fun(
			false
			call
			type(false, void)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, result))]
			builtin([type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		fun(false, fun-ptr, type(false, fun-ptr3), none, [param(a, type(false, fun-mut1))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut1))], field-get(1))
		fun(false, ok, type(false, ok), none, [param(value, type(false, void))], new-record)
		fun(false, value, type(false, void), none, [param(a, type(false, fut-state-resolved))], field-get(0))
		fun(false, err, type(false, err), none, [param(value, type(false, exception))], new-record)
		fun(
			true
			forward-to
			type(false, void)
			none
			[param(from, type(true, fut)), param(to, type(true, fut))]
			expr-body(
				call(then-void, [param-ref(from), lambda(lambda(forward-to, 0), some(alloc(record([param-ref(to)]))))])))
		fun(
			true
			then-void
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-mut1))]
			expr-body(
				seq(
					seq(
						call(acquire-lock, [call(ref-of-val, [call(lk, [param-ref(f)])])])
						match(
							"<<matched>>"
							call(state, [param-ref(f)])
							[
								case(
									some(cbs)
									set-field(
										param-ref(f)
										state
										to-union(
											0
											call(
												fut-state-callbacks
												[
													to-union(
														1
														call(
															some
															[
																call(
																	fut-callback-node
																	[param-ref(cb), call(head, [local-ref(cbs)])])]))]))))
								case(
									some(r)
									call(call, [param-ref(cb), to-union(0, call(ok, [call(value, [local-ref(r)])]))]))
								case(some(e), call(call, [param-ref(cb), to-union(1, call(err, [local-ref(e)]))]))]))
					call(release-lock, [call(ref-of-val, [call(lk, [param-ref(f)])])]))))
		fun(false, lk, type(false, lock), none, [param(a, type(true, fut))], field-get(0))
		fun(false, state, type(false, fut-state), none, [param(a, type(true, fut))], field-get(1))
		fun(false, some, type(false, some), none, [param(value, type(true, fut-callback-node))], new-record)
		fun(
			true
			fut-callback-node
			type(true, fut-callback-node)
			none
			[param(cb, type(false, fun-mut1)), param(next-node, type(false, opt))]
			new-record)
		fun(false, head, type(false, opt), none, [param(a, type(false, fut-state-callbacks))], field-get(0))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body(
				call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)]), param-ref(p0)])))
		fun(
			false
			call
			type(false, void)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, result))]
			builtin([type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		fun(false, fun-ptr, type(false, fun-ptr3), none, [param(a, type(false, fun-mut1))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut1))], field-get(1))
		fun(false, ok, type(false, ok), none, [param(value, type(false, int32))], new-record)
		fun(false, value, type(false, int32), none, [param(a, type(false, fut-state-resolved))], field-get(0))
		fun(
			true
			resolve-or-reject
			type(false, void)
			none
			[param(f, type(true, fut)), param(result, type(false, result))]
			expr-body(
				seq(
					seq(
						seq(
							call(acquire-lock, [call(ref-of-val, [call(lk, [param-ref(f)])])])
							match(
								"<<matched>>"
								call(state, [param-ref(f)])
								[
									case(
										some(cbs)
										call(resolve-or-reject-recur, [call(head, [local-ref(cbs)]), param-ref(result)]))
									case(none, call(hard-fail, [arr(0, 7)]))
									case(none, call(hard-fail, [arr(0, 7)]))]))
						set-field(
							param-ref(f)
							state
							match(
								"<<matched>>"
								param-ref(result)
								[
									case(some(o), to-union(1, call(fut-state-resolved, [call(value, [local-ref(o)])])))
									case(some(e), let(ex, call(value, [local-ref(e)]), to-union(2, local-ref(ex))))])))
					call(release-lock, [call(ref-of-val, [call(lk, [param-ref(f)])])]))))
		fun(
			true
			resolve-or-reject-recur
			type(false, void)
			none
			[param(node, type(false, opt)), param(value, type(false, result))]
			expr-body(
				match(
					"<<matched>>"
					param-ref(node)
					[
						case(none, call(pass, []))
						case(
							some(s)
							seq(
								call(drop, [call(call, [call(cb, [call(value, [local-ref(s)])]), param-ref(value)])])
								call(
									resolve-or-reject-recur
									[call(next-node, [call(value, [local-ref(s)])]), param-ref(value)])))])))
		fun(false, drop, type(false, void), none, [param(t, type(false, void))], expr-body(call(pass, [])))
		fun(false, cb, type(false, fun-mut1), none, [param(a, type(true, fut-callback-node))], field-get(0))
		fun(false, value, type(true, fut-callback-node), none, [param(a, type(false, some))], field-get(0))
		fun(false, next-node, type(false, opt), none, [param(a, type(true, fut-callback-node))], field-get(1))
		fun(
			true
			fut-state-resolved
			type(false, fut-state-resolved)
			none
			[param(value, type(false, int32))]
			new-record)
		fun(false, value, type(false, int32), none, [param(a, type(false, ok))], field-get(0))
		fun(false, value, type(false, exception), none, [param(a, type(false, err))], field-get(0))
		fun(
			true
			lambda(forward-to, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(forward-to, 0))))
			[param(it, type(false, result))]
			expr-body(call(resolve-or-reject, [get-field(param-ref("<<closure>>"), to), param-ref(it)])))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ref1)), param(p0, type(false, void))]
			expr-body(
				let(
					vat
					call(get-vat, [call(vat, [call(vat-and-actor, [param-ref(f)])])])
					let(
						res
						call(new-unresolved-fut, [])
						seq(
							call(
								add-task
								[
									local-ref(vat)
									call(
										task
										[
											call(actor, [call(vat-and-actor, [param-ref(f)])])
											lambda(
												lambda(call, 0)
												some(alloc(record([param-ref(f), param-ref(p0), local-ref(res)]))))])])
							local-ref(res))))))
		fun(
			true
			get-vat
			type(true, vat)
			none
			[param(vat-id, type(false, nat))]
			expr-body(call(at, [call(vats, [call(get-gctx, [])]), param-ref(vat-id)])))
		fun(
			true
			at
			type(true, vat)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(noctx-at, [param-ref(a), param-ref(index)]))))
		fun(
			true
			assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(call(assert, [param-ref(condition), arr(0, 8)])))
		fun(
			true
			assert
			type(false, void)
			none
			[param(condition, type(false, bool)), param(message, type(false, arr))]
			expr-body(call(if, [param-ref(condition), call(pass, []), call(fail, [param-ref(message)])])))
		fun(
			true
			fail
			type(false, void)
			none
			[param(reason, type(false, arr))]
			expr-body(call(throw, [call(exception, [param-ref(reason)])])))
		fun(
			true
			throw
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				let(
					exn-ctx
					call(get-exception-ctx, [])
					seq(
						seq(
							seq(
								call(hard-forbid, [call(null?, [call(jmp-buf-ptr, [local-ref(exn-ctx)])])])
								set-field(local-ref(exn-ctx), thrown-exception, param-ref(e)))
							call(longjmp, [call(jmp-buf-ptr, [local-ref(exn-ctx)]), call(number-to-throw, [])]))
						call(todo, [])))))
		fun(
			true
			get-exception-ctx
			type(true, exception-ctx)
			none
			[]
			expr-body(call(as-ref, [call(exception-ctx-ptr, [call(get-ctx, [])])])))
		fun(
			false
			as-ref
			type(true, exception-ctx)
			none
			[param(p, type(false, ptr))]
			builtin([type(true, exception-ctx)]))
		fun(false, exception-ctx-ptr, type(false, ptr), none, [param(a, type(true, ctx))], field-get(4))
		fun(
			false
			null?
			type(false, bool)
			none
			[param(a, type(false, ptr))]
			expr-body(call(==, [call(to-nat, [param-ref(a)]), call(to-nat, [call(null, [])])])))
		fun(false, to-nat, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, jmp-buf-tag)]))
		fun(false, jmp-buf-ptr, type(false, ptr), none, [param(a, type(true, exception-ctx))], field-get(0))
		fun(
			false
			longjmp
			type(false, void)
			none
			[param(env, type(false, ptr)), param(val, type(false, int32))]
			extern(false))
		fun(true, number-to-throw, type(false, int32), none, [], expr-body(call(seven, [])))
		fun(false, seven, type(false, int32), none, [], expr-body(call(wrap-incr, [call(six, [])])))
		fun(false, six, type(false, int32), none, [], expr-body(call(wrap-incr, [call(five, [])])))
		fun(false, five, type(false, int32), none, [], expr-body(call(wrap-incr, [call(four, [])])))
		fun(false, four, type(false, int32), none, [], expr-body(call(wrap-incr, [call(three, [])])))
		fun(false, three, type(false, int32), none, [], expr-body(call(wrap-incr, [call(two, [])])))
		fun(false, size, type(false, nat), none, [param(a, type(false, arr))], field-get(0))
		fun(
			false
			noctx-at
			type(true, vat)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(deref, [call(+, [call(data, [param-ref(a)]), param-ref(index)])]))))
		fun(false, deref, type(true, vat), none, [param(p, type(false, ptr))], builtin([type(true, vat)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(true, vat)]))
		fun(false, data, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(false, vats, type(false, arr), none, [param(a, type(true, global-ctx))], field-get(1))
		fun(false, vat, type(false, nat), none, [param(a, type(false, vat-and-actor-id))], field-get(0))
		fun(false, vat-and-actor, type(false, vat-and-actor-id), none, [param(a, type(false, fun-ref1))], field-get(0))
		fun(
			true
			add-task
			type(false, void)
			none
			[param(v, type(true, vat)), param(t, type(false, task))]
			expr-body(
				let(
					node
					call(new-mut-bag-node, [param-ref(t)])
					seq(
						seq(
							seq(
								call(acquire-lock, [call(ref-of-val, [call(tasks-lock, [param-ref(v)])])])
								call(add, [call(ref-of-val, [call(tasks, [param-ref(v)])]), local-ref(node)]))
							call(release-lock, [call(ref-of-val, [call(tasks-lock, [param-ref(v)])])]))
						call(broadcast, [call(ref-of-val, [call(may-be-work-to-do, [call(gctx, [param-ref(v)])])])])))))
		fun(
			true
			new-mut-bag-node
			type(true, mut-bag-node)
			none
			[param(value, type(false, task))]
			expr-body(call(mut-bag-node, [param-ref(value), to-union(0, call(none, []))])))
		fun(
			true
			mut-bag-node
			type(true, mut-bag-node)
			none
			[param(value, type(false, task)), param(next-node, type(false, opt))]
			new-record)
		fun(false, tasks-lock, type(false, lock), none, [param(a, type(true, vat))], field-get(3))
		fun(
			false
			add
			type(false, void)
			none
			[param(bag, type(true, mut-bag)), param(node, type(true, mut-bag-node))]
			expr-body(
				seq(
					set-field(param-ref(node), next-node, call(head, [param-ref(bag)]))
					set-field(param-ref(bag), head, to-union(1, call(some, [param-ref(node)]))))))
		fun(false, head, type(false, opt), none, [param(a, type(true, mut-bag))], field-get(0))
		fun(false, some, type(false, some), none, [param(value, type(true, mut-bag-node))], new-record)
		fun(
			false
			ref-of-val
			type(true, mut-bag)
			none
			[param(b, type(false, mut-bag))]
			builtin([type(true, mut-bag)]))
		fun(false, tasks, type(false, mut-bag), none, [param(a, type(true, vat))], field-get(4))
		fun(
			false
			broadcast
			type(false, void)
			none
			[param(c, type(true, condition))]
			expr-body(
				seq(
					seq(
						call(acquire-lock, [call(ref-of-val, [call(lk, [param-ref(c)])])])
						set-field(param-ref(c), value, call(noctx-incr, [call(value, [param-ref(c)])])))
					call(release-lock, [call(ref-of-val, [call(lk, [param-ref(c)])])]))))
		fun(false, lk, type(false, lock), none, [param(a, type(true, condition))], field-get(0))
		fun(false, value, type(false, nat), none, [param(a, type(true, condition))], field-get(1))
		fun(
			false
			ref-of-val
			type(true, condition)
			none
			[param(b, type(false, condition))]
			builtin([type(true, condition)]))
		fun(false, may-be-work-to-do, type(false, condition), none, [param(a, type(true, global-ctx))], field-get(3))
		fun(false, gctx, type(true, global-ctx), none, [param(a, type(true, vat))], field-get(0))
		fun(
			false
			task
			type(false, task)
			none
			[param(actor-id, type(false, nat)), param(fun, type(false, fun-mut0))]
			new-record)
		fun(false, actor, type(false, nat), none, [param(a, type(false, vat-and-actor-id))], field-get(1))
		fun(
			true
			catch
			type(false, void)
			none
			[param(try, type(false, fun-mut0)), param(catcher, type(false, fun-mut1))]
			expr-body(call(catch-with-exception-ctx, [call(get-exception-ctx, []), param-ref(try), param-ref(catcher)])))
		fun(
			true
			catch-with-exception-ctx
			type(false, void)
			none
			[
				param(ec, type(true, exception-ctx))
				param(try, type(false, fun-mut0))
				param(catcher, type(false, fun-mut1))]
			expr-body(
				let(
					old-thrown-exception
					call(thrown-exception, [param-ref(ec)])
					let(
						old-jmp-buf
						call(jmp-buf-ptr, [param-ref(ec)])
						let(
							store
							call(jmp-buf-tag, [call(zero, []), call(zero, []), call(zero, [])])
							seq(
								set-field(param-ref(ec), jmp-buf-ptr, call(ptr-to, [local-ref(store)]))
								let(
									setjmp-result
									call(setjmp, [call(jmp-buf-ptr, [param-ref(ec)])])
									cond(
										call(==, [local-ref(setjmp-result), call(zero, [])])
										let(
											res
											call(call, [param-ref(try)])
											seq(
												seq(
													set-field(param-ref(ec), jmp-buf-ptr, local-ref(old-jmp-buf))
													set-field(
														param-ref(ec)
														thrown-exception
														local-ref(old-thrown-exception)))
												local-ref(res)))
										seq(
											call(
												assert
												[call(==, [local-ref(setjmp-result), call(number-to-throw, [])])])
											let(
												thrown-exception
												call(thrown-exception, [param-ref(ec)])
												seq(
													seq(
														set-field(param-ref(ec), jmp-buf-ptr, local-ref(old-jmp-buf))
														set-field(
															param-ref(ec)
															thrown-exception
															local-ref(old-thrown-exception)))
													call(call, [param-ref(catcher), local-ref(thrown-exception)]))))))))))))
		fun(false, thrown-exception, type(false, exception), none, [param(a, type(true, exception-ctx))], field-get(1))
		fun(
			false
			jmp-buf-tag
			type(false, jmp-buf-tag)
			none
			[
				param(jmp-buf, type(false, bytes64))
				param(mask-was-saved, type(false, int32))
				param(saved-mask, type(false, bytes128))]
			new-record)
		fun(false, zero, type(false, bytes64), none, [], expr-body(call(bytes64, [call(zero, []), call(zero, [])])))
		fun(
			false
			bytes64
			type(false, bytes64)
			none
			[param(n0, type(false, bytes32)), param(n1, type(false, bytes32))]
			new-record)
		fun(false, zero, type(false, bytes32), none, [], expr-body(call(bytes32, [call(zero, []), call(zero, [])])))
		fun(
			false
			bytes32
			type(false, bytes32)
			none
			[param(n0, type(false, bytes16)), param(n1, type(false, bytes16))]
			new-record)
		fun(false, zero, type(false, bytes16), none, [], expr-body(call(bytes16, [call(zero, []), call(zero, [])])))
		fun(
			false
			bytes16
			type(false, bytes16)
			none
			[param(n0, type(false, nat)), param(n1, type(false, nat))]
			new-record)
		fun(false, zero, type(false, bytes128), none, [], expr-body(call(bytes128, [call(zero, []), call(zero, [])])))
		fun(
			false
			bytes128
			type(false, bytes128)
			none
			[param(n0, type(false, bytes64)), param(n1, type(false, bytes64))]
			new-record)
		fun(
			false
			ptr-to
			type(false, ptr)
			none
			[param(t, type(false, jmp-buf-tag))]
			builtin([type(false, jmp-buf-tag)]))
		fun(false, setjmp, type(false, int32), none, [param(env, type(false, ptr))], extern(false))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut0))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut0))]
			expr-body(call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)])])))
		fun(
			false
			call
			type(false, void)
			none
			[param(f, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, ptr))]
			builtin([type(false, void), type(true, ctx), type(false, ptr)]))
		fun(false, fun-ptr, type(false, fun-ptr2), none, [param(a, type(false, fun-mut0))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut0))], field-get(1))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, exception))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, exception))]
			expr-body(
				call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)]), param-ref(p0)])))
		fun(
			false
			call
			type(false, void)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, exception))]
			builtin([type(false, void), type(true, ctx), type(false, ptr), type(false, exception)]))
		fun(false, fun-ptr, type(false, fun-ptr3), none, [param(a, type(false, fun-mut1))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut1))], field-get(1))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, void))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, void))]
			expr-body(
				call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)]), param-ref(p0)])))
		fun(
			false
			call
			type(true, fut)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, void))]
			builtin([type(true, fut), type(true, ctx), type(false, ptr), type(false, void)]))
		fun(false, fun-ptr, type(false, fun-ptr3), none, [param(a, type(false, fun-mut1))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut1))], field-get(1))
		fun(false, fun, type(false, fun-mut1), none, [param(a, type(false, fun-ref1))], field-get(1))
		fun(
			true
			lambda(lambda(call, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 0))))
			[]
			expr-body(
				call(
					forward-to
					[
						call(
							call
							[
								call(fun, [get-field(param-ref("<<closure>>"), f)])
								get-field(param-ref("<<closure>>"), p0)])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			true
			reject
			type(false, void)
			none
			[param(f, type(true, fut)), param(e, type(false, exception))]
			expr-body(call(resolve-or-reject, [param-ref(f), to-union(1, call(err, [param-ref(e)]))])))
		fun(
			true
			lambda(lambda(call, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 1))))
			[param(it, type(false, exception))]
			expr-body(call(reject, [get-field(param-ref("<<closure>>"), res), param-ref(it)])))
		fun(
			true
			lambda(call, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(call, 0))))
			[]
			expr-body(
				call(
					catch
					[
						lambda(
							lambda(lambda(call, 0), 0)
							some(alloc(
								record(
									[
										get-field(param-ref("<<closure>>"), f)
										get-field(param-ref("<<closure>>"), p0)
										get-field(param-ref("<<closure>>"), res)]))))
						lambda(
							lambda(lambda(call, 0), 1)
							some(alloc(record([get-field(param-ref("<<closure>>"), res)]))))])))
		fun(false, value, type(false, void), none, [param(a, type(false, ok))], field-get(0))
		fun(
			true
			lambda(then, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(then, 0))))
			[param(result, type(false, result))]
			expr-body(
				match(
					"<<matched>>"
					param-ref(result)
					[
						case(
							some(o)
							call(
								forward-to
								[
									call(call, [get-field(param-ref("<<closure>>"), cb), call(value, [local-ref(o)])])
									get-field(param-ref("<<closure>>"), res)]))
						case(
							some(e)
							call(reject, [get-field(param-ref("<<closure>>"), res), call(value, [local-ref(e)])]))])))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ref0))]
			expr-body(
				let(
					vat
					call(get-vat, [call(vat, [call(vat-and-actor, [param-ref(f)])])])
					let(
						res
						call(new-unresolved-fut, [])
						seq(
							call(
								add-task
								[
									local-ref(vat)
									call(
										task
										[
											call(actor, [call(vat-and-actor, [param-ref(f)])])
											lambda(lambda(call, 0), some(alloc(record([param-ref(f), local-ref(res)]))))])])
							local-ref(res))))))
		fun(false, vat-and-actor, type(false, vat-and-actor-id), none, [param(a, type(false, fun-ref0))], field-get(0))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-mut0))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f)])))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut0))]
			expr-body(call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)])])))
		fun(
			false
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, ptr))]
			builtin([type(true, fut), type(true, ctx), type(false, ptr)]))
		fun(false, fun-ptr, type(false, fun-ptr2), none, [param(a, type(false, fun-mut0))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut0))], field-get(1))
		fun(false, fun, type(false, fun-mut0), none, [param(a, type(false, fun-ref0))], field-get(1))
		fun(
			true
			lambda(lambda(call, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 0))))
			[]
			expr-body(
				call(
					forward-to
					[
						call(call, [call(fun, [get-field(param-ref("<<closure>>"), f)])])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			true
			lambda(lambda(call, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 1))))
			[param(it, type(false, exception))]
			expr-body(call(reject, [get-field(param-ref("<<closure>>"), res), param-ref(it)])))
		fun(
			true
			lambda(call, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(call, 0))))
			[]
			expr-body(
				call(
					catch
					[
						lambda(
							lambda(lambda(call, 0), 0)
							some(alloc(
								record(
									[get-field(param-ref("<<closure>>"), f), get-field(param-ref("<<closure>>"), res)]))))
						lambda(
							lambda(lambda(call, 0), 1)
							some(alloc(record([get-field(param-ref("<<closure>>"), res)]))))])))
		fun(
			true
			lambda(then2, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(then2, 0))))
			[param(ignore, type(false, void))]
			expr-body(call(call, [get-field(param-ref("<<closure>>"), cb)])))
		fun(
			true
			cur-actor
			type(false, vat-and-actor-id)
			none
			[]
			expr-body(
				let(
					c
					call(get-ctx, [])
					call(vat-and-actor-id, [call(vat-id, [local-ref(c)]), call(actor-id, [local-ref(c)])]))))
		fun(
			false
			vat-and-actor-id
			type(false, vat-and-actor-id)
			none
			[param(vat, type(false, nat)), param(actor, type(false, nat))]
			new-record)
		fun(false, vat-id, type(false, nat), none, [param(a, type(true, ctx))], field-get(1))
		fun(false, actor-id, type(false, nat), none, [param(a, type(true, ctx))], field-get(2))
		fun(false, as, type(true, fut), none, [param(value, type(true, fut))], builtin([type(true, fut)]))
		fun(
			true
			resolved
			type(true, fut)
			none
			[param(value, type(false, void))]
			expr-body(call(fut, [call(new-lock, []), to-union(1, call(fut-state-resolved, [param-ref(value)]))])))
		fun(
			true
			fut
			type(true, fut)
			none
			[param(lk, type(false, lock)), param(state, type(false, fut-state))]
			new-record)
		fun(
			true
			fut-state-resolved
			type(false, fut-state-resolved)
			none
			[param(value, type(false, void))]
			new-record)
		fun(
			true
			tail
			type(false, arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(slice-starting-at, [param-ref(a), call(one, [])]))))
		fun(
			true
			forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(call(forbid, [param-ref(condition), arr(0, 9)])))
		fun(
			true
			forbid
			type(false, void)
			none
			[param(condition, type(false, bool)), param(message, type(false, arr))]
			expr-body(call(if, [param-ref(condition), call(fail, [param-ref(message)]), call(pass, [])])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body(call(zero?, [call(size, [param-ref(a)])])))
		fun(false, size, type(false, nat), none, [param(a, type(false, arr))], field-get(0))
		fun(
			true
			slice-starting-at
			type(false, arr)
			none
			[param(a, type(false, arr)), param(begin, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<=, [param-ref(begin), call(size, [param-ref(a)])])])
					call(
						slice
						[param-ref(a), param-ref(begin), call(-, [call(size, [param-ref(a)]), param-ref(begin)])]))))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(call(not, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			true
			slice
			type(false, arr)
			none
			[param(a, type(false, arr)), param(begin, type(false, nat)), param(size, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<=, [call(+, [param-ref(begin), param-ref(size)]), call(size, [param-ref(a)])])])
					call(arr, [param-ref(size), call(+, [call(data, [param-ref(a)]), param-ref(begin)])]))))
		fun(
			true
			+
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				let(
					res
					call(wrap-add, [param-ref(a), param-ref(b)])
					seq(
						call(
							assert
							[
								call(
									and
									[call(>=, [local-ref(res), param-ref(a)]), call(>=, [local-ref(res), param-ref(b)])])])
						local-ref(res)))))
		fun(
			false
			and
			type(false, bool)
			none
			[param(a, type(false, bool)), param(b, type(false, bool))]
			builtin([]))
		fun(
			false
			>=
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(call(not, [call(<, [param-ref(a), param-ref(b)])])))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(data, type(false, ptr))]
			new-record)
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, ptr)]))
		fun(false, data, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			true
			-
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(>=, [param-ref(a), param-ref(b)])])
					call(wrap-sub, [param-ref(a), param-ref(b)]))))
		fun(
			false
			wrap-sub
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(
			false
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, arr))]
			builtin([type(true, fut), type(true, ctx), type(false, arr)]))
		fun(
			true
			map
			type(false, arr)
			none
			[param(a, type(false, arr)), param(mapper, type(false, fun-mut1))]
			expr-body(
				call(
					make-arr
					[
						call(size, [param-ref(a)])
						lambda(lambda(map, 0), some(alloc(record([param-ref(mapper), param-ref(a)]))))])))
		fun(
			true
			make-arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body(call(freeze, [call(make-mut-arr, [param-ref(size), param-ref(f)])])))
		fun(
			false
			freeze
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(seq(set-field(param-ref(a), frozen?, call(true, [])), call(unsafe-as-arr, [param-ref(a)]))))
		fun(
			false
			unsafe-as-arr
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(arr, [call(size, [param-ref(a)]), call(data, [param-ref(a)])])))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(data, type(false, ptr))]
			new-record)
		fun(false, size, type(false, nat), none, [param(a, type(true, mut-arr))], field-get(1))
		fun(false, data, type(false, ptr), none, [param(a, type(true, mut-arr))], field-get(3))
		fun(
			true
			make-mut-arr
			type(true, mut-arr)
			none
			[param(size, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body(
				let(
					res
					call(new-uninitialized-mut-arr, [param-ref(size)])
					seq(call(make-mut-arr-worker, [local-ref(res), call(zero, []), param-ref(f)]), local-ref(res)))))
		fun(
			true
			new-uninitialized-mut-arr
			type(true, mut-arr)
			none
			[param(size, type(false, nat))]
			expr-body(
				call(
					mut-arr
					[call(false, []), param-ref(size), param-ref(size), call(uninitialized-data, [param-ref(size)])])))
		fun(
			true
			mut-arr
			type(true, mut-arr)
			none
			[
				param(frozen?, type(false, bool))
				param(size, type(false, nat))
				param(capacity, type(false, nat))
				param(data, type(false, ptr))]
			new-record)
		fun(
			true
			uninitialized-data
			type(false, ptr)
			none
			[param(size, type(false, nat))]
			expr-body(
				let(
					bptr
					call(alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					call(ptr-cast, [local-ref(bptr)]))))
		fun(
			true
			alloc
			type(false, ptr)
			none
			[param(size, type(false, nat))]
			expr-body(call(gc-alloc, [call(get-gc, []), param-ref(size)])))
		fun(
			true
			gc-alloc
			type(false, ptr)
			none
			[param(gc, type(true, gc)), param(size, type(false, nat))]
			expr-body(call(unmanaged-alloc-bytes, [param-ref(size)])))
		fun(true, get-gc, type(true, gc), none, [], expr-body(call(gc, [call(get-gc-ctx, [])])))
		fun(false, gc, type(true, gc), none, [param(a, type(true, gc-ctx))], field-get(0))
		fun(
			true
			get-gc-ctx
			type(true, gc-ctx)
			none
			[]
			expr-body(call(as-ref, [call(gc-ctx-ptr, [call(get-ctx, [])])])))
		fun(false, gc-ctx-ptr, type(false, ptr), none, [param(a, type(true, ctx))], field-get(3))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, arr)]))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, arr), type(false, nat8)]))
		fun(
			true
			make-mut-arr-worker
			type(false, void)
			none
			[param(m, type(true, mut-arr)), param(i, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(m)])])
					call(pass, [])
					seq(
						call(set-at, [param-ref(m), param-ref(i), call(call, [param-ref(f), param-ref(i)])])
						call(make-mut-arr-worker, [param-ref(m), call(incr, [param-ref(i)]), param-ref(f)])))))
		fun(
			true
			set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, arr))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(noctx-set-at, [param-ref(a), param-ref(index), param-ref(value)]))))
		fun(
			false
			noctx-set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, arr))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(set, [call(+, [call(data, [param-ref(a)]), param-ref(index)]), param-ref(value)]))))
		fun(
			false
			set
			type(false, void)
			none
			[param(p, type(false, ptr)), param(value, type(false, arr))]
			builtin([type(false, arr)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, arr)]))
		fun(
			true
			call
			type(false, arr)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, nat))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, arr)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, nat))]
			expr-body(
				call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)]), param-ref(p0)])))
		fun(
			false
			call
			type(false, arr)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, nat))]
			builtin([type(false, arr), type(true, ctx), type(false, ptr), type(false, nat)]))
		fun(false, fun-ptr, type(false, fun-ptr3), none, [param(a, type(false, fun-mut1))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut1))], field-get(1))
		fun(
			true
			incr
			type(false, nat)
			none
			[param(n, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(n), call(billion, [])])])
					call(wrap-add, [param-ref(n), call(one, [])]))))
		fun(
			true
			call
			type(false, arr)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, ptr))]
			expr-body(call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, arr)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, ptr))]
			expr-body(
				call(call, [call(fun-ptr, [param-ref(f)]), param-ref(c), call(closure, [param-ref(f)]), param-ref(p0)])))
		fun(
			false
			call
			type(false, arr)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, ptr))]
			builtin([type(false, arr), type(true, ctx), type(false, ptr), type(false, ptr)]))
		fun(false, fun-ptr, type(false, fun-ptr3), none, [param(a, type(false, fun-mut1))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun-mut1))], field-get(1))
		fun(
			true
			at
			type(false, ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(noctx-at, [param-ref(a), param-ref(index)]))))
		fun(
			false
			noctx-at
			type(false, ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(deref, [call(+, [call(data, [param-ref(a)]), param-ref(index)])]))))
		fun(
			true
			lambda(map, 0)
			type(false, arr)
			some(param("<<closure>>", type(true, lambda(map, 0))))
			[param(i, type(false, nat))]
			expr-body(
				call(
					call
					[
						get-field(param-ref("<<closure>>"), mapper)
						call(at, [get-field(param-ref("<<closure>>"), a), param-ref(i)])])))
		fun(
			true
			lambda(lambda(add-first-task, 0), 0)
			type(false, arr)
			some(param("<<closure>>", type(false, ptr)))
			[param(it, type(false, ptr))]
			expr-body(call(to-str, [param-ref(it)])))
		fun(
			true
			lambda(add-first-task, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(add-first-task, 0))))
			[]
			expr-body(
				let(
					args
					call(tail, [get-field(param-ref("<<closure>>"), all-args)])
					call(
						call
						[
							get-field(param-ref("<<closure>>"), main-ptr)
							call(get-ctx, [])
							call(map, [local-ref(args), lambda(lambda(lambda(add-first-task, 0), 0), some(null))])]))))
		fun(
			true
			lambda(do-main, 0)
			type(true, fut)
			some(param("<<closure>>", type(false, ptr)))
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(call(add-first-task, [param-ref(all-args), param-ref(main-ptr)])))
		fun(false, unsafe-to-nat, type(false, nat), none, [param(a, type(false, int))], builtin([]))
		fun(false, to-int, type(false, int), none, [param(i, type(false, int32))], builtin([]))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[
				param(c, type(true, ctx))
				param(f, type(false, fun2))
				param(p0, type(false, arr))
				param(p1, type(false, fun-ptr2))]
			expr-body(
				call(
					call
					[
						call(fun-ptr, [param-ref(f)])
						param-ref(c)
						call(closure, [param-ref(f)])
						param-ref(p0)
						param-ref(p1)])))
		fun(
			false
			call
			type(true, fut)
			none
			[
				param(f, type(false, fun-ptr4))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, arr))
				param(p3, type(false, fun-ptr2))]
			builtin([type(true, fut), type(true, ctx), type(false, ptr), type(false, arr), type(false, fun-ptr2)]))
		fun(false, fun-ptr, type(false, fun-ptr4), none, [param(a, type(false, fun2))], field-get(0))
		fun(false, closure, type(false, ptr), none, [param(a, type(false, fun2))], field-get(1))
		fun(
			false
			run-threads
			type(false, void)
			none
			[param(n-threads, type(false, nat)), param(gctx, type(true, global-ctx))]
			expr-body(
				let(
					threads
					call(unmanaged-alloc-elements, [param-ref(n-threads)])
					let(
						thread-args
						call(unmanaged-alloc-elements, [param-ref(n-threads)])
						let(
							actual-n-threads
							call(noctx-decr, [param-ref(n-threads)])
							seq(
								seq(
									seq(
										seq(
											call(
												start-threads-recur
												[
													call(zero, [])
													local-ref(actual-n-threads)
													local-ref(threads)
													local-ref(thread-args)
													param-ref(gctx)])
											call(thread-function, [local-ref(actual-n-threads), param-ref(gctx)]))
										call(
											join-threads-recur
											[call(zero, []), local-ref(actual-n-threads), local-ref(threads)]))
									call(unmanaged-free, [local-ref(threads)]))
								call(unmanaged-free, [local-ref(thread-args)])))))))
		fun(
			false
			unmanaged-alloc-elements
			type(false, ptr)
			none
			[param(size-elements, type(false, nat))]
			expr-body(
				let(
					bytes
					call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])
					call(ptr-cast, [local-ref(bytes)]))))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, thread-args)]))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, thread-args), type(false, nat8)]))
		fun(
			false
			noctx-decr
			type(false, nat)
			none
			[param(n, type(false, nat))]
			expr-body(
				seq(call(hard-forbid, [call(zero?, [param-ref(n)])]), call(wrap-sub, [param-ref(n), call(one, [])]))))
		fun(
			false
			start-threads-recur
			type(false, void)
			none
			[
				param(i, type(false, nat))
				param(n-threads, type(false, nat))
				param(threads, type(false, ptr))
				param(thread-args-begin, type(false, ptr))
				param(gctx, type(true, global-ctx))]
			expr-body(
				cond(
					call(==, [param-ref(i), param-ref(n-threads)])
					call(pass, [])
					let(
						thread-arg-ptr
						call(+, [param-ref(thread-args-begin), param-ref(i)])
						seq(
							call(set, [local-ref(thread-arg-ptr), call(thread-args, [param-ref(i), param-ref(gctx)])])
							let(
								thread-ptr
								call(+, [param-ref(threads), param-ref(i)])
								let(
									fn
									call(as, [lambda(lambda(start-threads-recur, 0), none)])
									let(
										err
										call(
											pthread-create
											[
												call(as-cell, [local-ref(thread-ptr)])
												call(null, [])
												local-ref(fn)
												call(as-any-ptr, [local-ref(thread-arg-ptr)])])
										cond(
											call(zero?, [local-ref(err)])
											call(
												start-threads-recur
												[
													call(noctx-incr, [param-ref(i)])
													param-ref(n-threads)
													param-ref(threads)
													param-ref(thread-args-begin)
													param-ref(gctx)])
											cond(
												call(==, [local-ref(err), call(eagain, [])])
												call(todo, [])
												call(todo, [])))))))))))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, thread-args)]))
		fun(
			false
			set
			type(false, void)
			none
			[param(p, type(false, ptr)), param(value, type(false, thread-args))]
			builtin([type(false, thread-args)]))
		fun(
			false
			thread-args
			type(false, thread-args)
			none
			[param(thread-id, type(false, nat)), param(gctx, type(true, global-ctx))]
			new-record)
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, nat)]))
		fun(
			false
			as
			type(false, fun-ptr1)
			none
			[param(value, type(false, fun-ptr1))]
			builtin([type(false, fun-ptr1)]))
		fun(
			false
			thread-fun
			type(false, ptr)
			none
			[param(args-ptr, type(false, ptr))]
			expr-body(
				let(
					args
					call(as-ref, [param-ref(args-ptr)])
					seq(
						call(thread-function, [call(thread-id, [local-ref(args)]), call(gctx, [local-ref(args)])])
						call(null, [])))))
		fun(
			false
			as-ref
			type(true, thread-args)
			none
			[param(p, type(false, ptr))]
			builtin([type(true, thread-args)]))
		fun(
			false
			thread-function
			type(false, void)
			none
			[param(thread-id, type(false, nat)), param(gctx, type(true, global-ctx))]
			expr-body(
				let(
					ectx
					call(new-exception-ctx, [])
					let(
						tls
						call(as, [call(thread-local-stuff, [call(ref-of-val, [local-ref(ectx)])])])
						call(
							thread-function-recur
							[param-ref(thread-id), param-ref(gctx), call(ref-of-val, [local-ref(tls)])])))))
		fun(
			false
			thread-function-recur
			type(false, void)
			none
			[
				param(thread-id, type(false, nat))
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))]
			expr-body(
				cond(
					call(is-shut-down, [param-ref(gctx)])
					seq(
						seq(
							seq(
								call(acquire-lock, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])
								set-field(
									param-ref(gctx)
									n-live-threads
									call(noctx-decr, [call(n-live-threads, [param-ref(gctx)])])))
							call(assert-vats-are-shut-down, [call(zero, []), call(vats, [param-ref(gctx)])]))
						call(release-lock, [call(ref-of-val, [call(lk, [param-ref(gctx)])])]))
					seq(
						call(hard-assert, [call(>, [call(n-live-threads, [param-ref(gctx)]), call(zero, [])])])
						let(
							last-checked
							call(get-last-checked, [call(ref-of-val, [call(may-be-work-to-do, [param-ref(gctx)])])])
							seq(
								match(
									"<<matched>>"
									call(choose-task, [param-ref(gctx)])
									[
										case(
											some(ok-chosen-task)
											call(
												do-task
												[
													param-ref(gctx)
													param-ref(tls)
													call(value, [local-ref(ok-chosen-task)])]))
										case(
											some(e)
											seq(
												seq(
													seq(
														cond(
															call(last-thread-out, [call(value, [local-ref(e)])])
															seq(
																seq(
																	call(
																		hard-forbid
																		[call(is-shut-down, [param-ref(gctx)])])
																	set-field(
																		param-ref(gctx)
																		is-shut-down
																		call(true, [])))
																call(
																	broadcast
																	[
																		call(
																			ref-of-val
																			[call(may-be-work-to-do, [param-ref(gctx)])])]))
															call(
																wait-on
																[
																	call(
																		ref-of-val
																		[call(may-be-work-to-do, [param-ref(gctx)])])
																	local-ref(last-checked)]))
														call(
															acquire-lock
															[call(ref-of-val, [call(lk, [param-ref(gctx)])])]))
													set-field(
														param-ref(gctx)
														n-live-threads
														call(noctx-incr, [call(n-live-threads, [param-ref(gctx)])])))
												call(release-lock, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])))])
								call(thread-function-recur, [param-ref(thread-id), param-ref(gctx), param-ref(tls)])))))))
		fun(false, is-shut-down, type(false, bool), none, [param(a, type(true, global-ctx))], field-get(4))
		fun(false, lk, type(false, lock), none, [param(a, type(true, global-ctx))], field-get(0))
		fun(false, n-live-threads, type(false, nat), none, [param(a, type(true, global-ctx))], field-get(2))
		fun(
			false
			assert-vats-are-shut-down
			type(false, void)
			none
			[param(i, type(false, nat)), param(vats, type(false, arr))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(vats)])])
					call(pass, [])
					let(
						vat
						call(noctx-at, [param-ref(vats), param-ref(i)])
						seq(
							seq(
								seq(
									seq(
										seq(
											call(acquire-lock, [call(ref-of-val, [call(tasks-lock, [local-ref(vat)])])])
											call(
												hard-forbid
												[call(needs-gc, [call(ref-of-val, [call(gc, [local-ref(vat)])])])]))
										call(hard-assert, [call(zero?, [call(n-threads-running, [local-ref(vat)])])]))
									call(
										hard-assert
										[call(empty?, [call(ref-of-val, [call(tasks, [local-ref(vat)])])])]))
								call(release-lock, [call(ref-of-val, [call(tasks-lock, [local-ref(vat)])])]))
							call(assert-vats-are-shut-down, [call(noctx-incr, [param-ref(i)]), param-ref(vats)]))))))
		fun(false, needs-gc, type(false, bool), none, [param(a, type(true, gc))], field-get(2))
		fun(false, n-threads-running, type(false, nat), none, [param(a, type(true, vat))], field-get(6))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(m, type(true, mut-bag))]
			expr-body(call(empty?, [call(head, [param-ref(m)])])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(
				match("<<matched>>", param-ref(a), [case(some(n), call(true, [])), case(some(s), call(false, []))])))
		fun(
			false
			>
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(call(not, [call(<=, [param-ref(a), param-ref(b)])])))
		fun(
			false
			get-last-checked
			type(false, nat)
			none
			[param(c, type(true, condition))]
			expr-body(call(value, [param-ref(c)])))
		fun(
			false
			choose-task
			type(false, result)
			none
			[param(gctx, type(true, global-ctx))]
			expr-body(
				seq(
					call(acquire-lock, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])
					let(
						res
						call(
							as
							[
								match(
									"<<matched>>"
									call(choose-task-recur, [call(vats, [param-ref(gctx)]), call(zero, [])])
									[
										case(
											none
											seq(
												seq(
													set-field(
														param-ref(gctx)
														n-live-threads
														call(noctx-decr, [call(n-live-threads, [param-ref(gctx)])]))
													call(
														hard-assert
														[call(zero?, [call(n-live-threads, [param-ref(gctx)])])]))
												to-union(
													1
													call(
														err
														[
															call(
																no-chosen-task
																[call(zero?, [call(n-live-threads, [param-ref(gctx)])])])]))))
										case(some(s), to-union(0, call(ok, [call(value, [local-ref(s)])])))])])
						seq(call(release-lock, [call(ref-of-val, [call(lk, [param-ref(gctx)])])]), local-ref(res))))))
		fun(false, as, type(false, result), none, [param(value, type(false, result))], builtin([type(false, result)]))
		fun(
			false
			choose-task-recur
			type(false, opt)
			none
			[param(vats, type(false, arr)), param(i, type(false, nat))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(vats)])])
					to-union(0, call(none, []))
					let(
						vat
						call(noctx-at, [param-ref(vats), param-ref(i)])
						match(
							"<<matched>>"
							call(choose-task-in-vat, [local-ref(vat)])
							[
								case(none, call(choose-task-recur, [param-ref(vats), call(noctx-incr, [param-ref(i)])]))
								case(
									some(s)
									to-union(
										1
										call(some, [call(chosen-task, [local-ref(vat), call(value, [local-ref(s)])])])))])))))
		fun(
			false
			choose-task-in-vat
			type(false, opt)
			none
			[param(vat, type(true, vat))]
			expr-body(
				seq(
					call(acquire-lock, [call(ref-of-val, [call(tasks-lock, [param-ref(vat)])])])
					let(
						res
						call(
							as
							[
								cond(
									call(needs-gc, [call(ref-of-val, [call(gc, [param-ref(vat)])])])
									cond(
										call(zero?, [call(n-threads-running, [param-ref(vat)])])
										to-union(1, call(some, [to-union(0, call(none, []))]))
										to-union(0, call(none, [])))
									match(
										"<<matched>>"
										call(find-and-remove-first-doable-task, [param-ref(vat)])
										[
											case(none, to-union(0, call(none, [])))
											case(
												some(s)
												to-union(
													1
													call(some, [to-union(1, call(some, [call(value, [local-ref(s)])]))])))]))])
						seq(
							seq(
								cond(
									call(empty?, [local-ref(res)])
									call(pass, [])
									set-field(
										param-ref(vat)
										n-threads-running
										call(noctx-incr, [call(n-threads-running, [param-ref(vat)])])))
								call(release-lock, [call(ref-of-val, [call(tasks-lock, [param-ref(vat)])])]))
							local-ref(res))))))
		fun(false, as, type(false, opt), none, [param(value, type(false, opt))], builtin([type(false, opt)]))
		fun(false, some, type(false, some), none, [param(value, type(false, opt))], new-record)
		fun(
			false
			find-and-remove-first-doable-task
			type(false, opt)
			none
			[param(vat, type(true, vat))]
			expr-body(
				let(
					tasks
					call(ref-of-val, [call(tasks, [param-ref(vat)])])
					let(
						th
						call(head, [local-ref(tasks)])
						let(
							res
							call(
								find-and-remove-first-doable-task-recur
								[param-ref(vat), call(head, [local-ref(tasks)])])
							match(
								"<<matched>>"
								local-ref(res)
								[
									case(none, to-union(0, call(none, [])))
									case(
										some(s)
										seq(
											set-field(
												local-ref(tasks)
												head
												call(nodes, [call(value, [local-ref(s)])]))
											to-union(1, call(some, [call(task, [call(value, [local-ref(s)])])]))))]))))))
		fun(
			false
			find-and-remove-first-doable-task-recur
			type(false, opt)
			none
			[param(vat, type(true, vat)), param(opt-node, type(false, opt))]
			expr-body(
				match(
					"<<matched>>"
					param-ref(opt-node)
					[
						case(none, to-union(0, call(none, [])))
						case(
							some(s)
							let(
								node
								call(value, [local-ref(s)])
								let(
									task
									call(value, [local-ref(node)])
									let(
										actors
										call(ref-of-val, [call(currently-running-actors, [param-ref(vat)])])
										let(
											task-ok
											cond(
												call(contains?, [local-ref(actors), call(actor-id, [local-ref(task)])])
												call(false, [])
												seq(
													call(
														push-capacity-must-be-sufficient
														[local-ref(actors), call(actor-id, [local-ref(task)])])
													call(true, [])))
											cond(
												local-ref(task-ok)
												to-union(
													1
													call(
														some
														[
															call(
																task-and-nodes
																[local-ref(task), call(next-node, [local-ref(node)])])]))
												match(
													"<<matched>>"
													call(
														find-and-remove-first-doable-task-recur
														[param-ref(vat), call(next-node, [local-ref(node)])])
													[
														case(none, to-union(0, call(none, [])))
														case(
															some(ss)
															let(
																tn
																call(as, [call(value, [local-ref(ss)])])
																seq(
																	set-field(
																		local-ref(node)
																		next-node
																		call(nodes, [local-ref(tn)]))
																	to-union(
																		1
																		call(
																			some
																			[
																				call(
																					task-and-nodes
																					[
																						call(task, [local-ref(tn)])
																						to-union(
																							1
																							call(
																								some
																								[local-ref(node)]))])])))))])))))))])))
		fun(false, value, type(true, mut-bag-node), none, [param(a, type(false, some))], field-get(0))
		fun(false, value, type(false, task), none, [param(a, type(true, mut-bag-node))], field-get(0))
		fun(
			false
			ref-of-val
			type(true, mut-arr)
			none
			[param(b, type(false, mut-arr))]
			builtin([type(true, mut-arr)]))
		fun(false, currently-running-actors, type(false, mut-arr), none, [param(a, type(true, vat))], field-get(5))
		fun(
			false
			contains?
			type(false, bool)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat))]
			expr-body(call(contains-recur?, [call(temp-as-arr, [param-ref(a)]), param-ref(value), call(zero, [])])))
		fun(
			false
			contains-recur?
			type(false, bool)
			none
			[param(a, type(false, arr)), param(value, type(false, nat)), param(i, type(false, nat))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(a)])])
					call(false, [])
					call(
						or
						[
							call(==, [call(noctx-at, [param-ref(a), param-ref(i)]), param-ref(value)])
							call(contains-recur?, [param-ref(a), param-ref(value), call(noctx-incr, [param-ref(i)])])]))))
		fun(false, size, type(false, nat), none, [param(a, type(false, arr))], field-get(0))
		fun(false, or, type(false, bool), none, [param(a, type(false, bool)), param(b, type(false, bool))], builtin([]))
		fun(
			false
			noctx-at
			type(false, nat)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(deref, [call(+, [call(data, [param-ref(a)]), param-ref(index)])]))))
		fun(false, deref, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, nat)]))
		fun(false, data, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			false
			temp-as-arr
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(arr, [call(size, [param-ref(a)]), call(data, [param-ref(a)])])))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(data, type(false, ptr))]
			new-record)
		fun(false, size, type(false, nat), none, [param(a, type(true, mut-arr))], field-get(1))
		fun(false, data, type(false, ptr), none, [param(a, type(true, mut-arr))], field-get(3))
		fun(false, actor-id, type(false, nat), none, [param(a, type(false, task))], field-get(0))
		fun(
			false
			push-capacity-must-be-sufficient
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [call(size, [param-ref(a)]), call(capacity, [param-ref(a)])])])
					let(
						old-size
						call(size, [param-ref(a)])
						seq(
							set-field(param-ref(a), size, call(noctx-incr, [local-ref(old-size)]))
							call(noctx-set-at, [param-ref(a), local-ref(old-size), param-ref(value)]))))))
		fun(false, capacity, type(false, nat), none, [param(a, type(true, mut-arr))], field-get(2))
		fun(
			false
			noctx-set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, nat))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(set, [call(+, [call(data, [param-ref(a)]), param-ref(index)]), param-ref(value)]))))
		fun(
			false
			set
			type(false, void)
			none
			[param(p, type(false, ptr)), param(value, type(false, nat))]
			builtin([type(false, nat)]))
		fun(false, some, type(false, some), none, [param(value, type(false, task-and-nodes))], new-record)
		fun(
			false
			task-and-nodes
			type(false, task-and-nodes)
			none
			[param(task, type(false, task)), param(nodes, type(false, opt))]
			new-record)
		fun(false, next-node, type(false, opt), none, [param(a, type(true, mut-bag-node))], field-get(1))
		fun(
			false
			as
			type(false, task-and-nodes)
			none
			[param(value, type(false, task-and-nodes))]
			builtin([type(false, task-and-nodes)]))
		fun(false, value, type(false, task-and-nodes), none, [param(a, type(false, some))], field-get(0))
		fun(false, nodes, type(false, opt), none, [param(a, type(false, task-and-nodes))], field-get(1))
		fun(false, task, type(false, task), none, [param(a, type(false, task-and-nodes))], field-get(0))
		fun(false, some, type(false, some), none, [param(value, type(false, task))], new-record)
		fun(false, value, type(false, task), none, [param(a, type(false, some))], field-get(0))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(
				match("<<matched>>", param-ref(a), [case(some(n), call(true, [])), case(some(s), call(false, []))])))
		fun(false, some, type(false, some), none, [param(value, type(false, chosen-task))], new-record)
		fun(
			false
			chosen-task
			type(false, chosen-task)
			none
			[param(vat, type(true, vat)), param(task-or-gc, type(false, opt))]
			new-record)
		fun(false, value, type(false, opt), none, [param(a, type(false, some))], field-get(0))
		fun(false, err, type(false, err), none, [param(value, type(false, no-chosen-task))], new-record)
		fun(
			false
			no-chosen-task
			type(false, no-chosen-task)
			none
			[param(last-thread-out, type(false, bool))]
			new-record)
		fun(false, ok, type(false, ok), none, [param(value, type(false, chosen-task))], new-record)
		fun(false, value, type(false, chosen-task), none, [param(a, type(false, some))], field-get(0))
		fun(
			false
			do-task
			type(false, void)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(chosen-task, type(false, chosen-task))]
			expr-body(
				let(
					vat
					call(vat, [param-ref(chosen-task)])
					seq(
						seq(
							seq(
								match(
									"<<matched>>"
									call(task-or-gc, [param-ref(chosen-task)])
									[
										case(
											none
											seq(
												call(todo, [])
												call(
													broadcast
													[call(ref-of-val, [call(may-be-work-to-do, [param-ref(gctx)])])])))
										case(
											some(some-task)
											let(
												task
												call(value, [local-ref(some-task)])
												let(
													ctx
													call(
														new-ctx
														[
															param-ref(gctx)
															param-ref(tls)
															local-ref(vat)
															call(actor-id, [local-ref(task)])])
													seq(
														seq(
															seq(
																seq(
																	call(
																		call-with-ctx
																		[
																			call(ref-of-val, [local-ref(ctx)])
																			call(fun, [local-ref(task)])])
																	call(
																		acquire-lock
																		[
																			call(
																				ref-of-val
																				[call(tasks-lock, [local-ref(vat)])])]))
																call(
																	noctx-must-remove-unordered
																	[
																		call(
																			ref-of-val
																			[
																				call(
																					currently-running-actors
																					[local-ref(vat)])])
																		call(actor-id, [local-ref(task)])]))
															call(
																release-lock
																[call(ref-of-val, [call(tasks-lock, [local-ref(vat)])])]))
														call(return-ctx, [call(ref-of-val, [local-ref(ctx)])])))))])
								call(acquire-lock, [call(ref-of-val, [call(tasks-lock, [local-ref(vat)])])]))
							set-field(
								local-ref(vat)
								n-threads-running
								call(noctx-decr, [call(n-threads-running, [local-ref(vat)])])))
						call(release-lock, [call(ref-of-val, [call(tasks-lock, [local-ref(vat)])])])))))
		fun(false, vat, type(true, vat), none, [param(a, type(false, chosen-task))], field-get(0))
		fun(false, task-or-gc, type(false, opt), none, [param(a, type(false, chosen-task))], field-get(1))
		fun(false, fun, type(false, fun-mut0), none, [param(a, type(false, task))], field-get(1))
		fun(
			false
			noctx-must-remove-unordered
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat))]
			expr-body(call(noctx-must-remove-unordered-recur, [param-ref(a), call(zero, []), param-ref(value)])))
		fun(
			false
			noctx-must-remove-unordered-recur
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, nat))]
			expr-body(
				cond(
					call(==, [param-ref(index), call(size, [param-ref(a)])])
					call(hard-fail, [arr(0, 10)])
					cond(
						call(==, [call(noctx-at, [param-ref(a), param-ref(index)]), param-ref(value)])
						call(drop, [call(noctx-remove-unordered-at-index, [param-ref(a), param-ref(index)])])
						call(
							noctx-must-remove-unordered-recur
							[param-ref(a), call(noctx-incr, [param-ref(index)]), param-ref(value)])))))
		fun(
			false
			noctx-at
			type(false, nat)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(deref, [call(+, [call(data, [param-ref(a)]), param-ref(index)])]))))
		fun(false, drop, type(false, void), none, [param(t, type(false, nat))], expr-body(call(pass, [])))
		fun(
			false
			noctx-remove-unordered-at-index
			type(false, nat)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat))]
			expr-body(
				let(
					res
					call(noctx-at, [param-ref(a), param-ref(index)])
					seq(
						seq(
							call(noctx-set-at, [param-ref(a), param-ref(index), call(noctx-last, [param-ref(a)])])
							set-field(param-ref(a), size, call(noctx-decr, [call(size, [param-ref(a)])])))
						local-ref(res)))))
		fun(
			false
			noctx-last
			type(false, nat)
			none
			[param(a, type(true, mut-arr))]
			expr-body(
				seq(
					call(hard-forbid, [call(empty?, [param-ref(a)])])
					call(noctx-at, [param-ref(a), call(noctx-decr, [call(size, [param-ref(a)])])]))))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(zero?, [call(size, [param-ref(a)])])))
		fun(
			false
			return-ctx
			type(false, void)
			none
			[param(c, type(true, ctx))]
			expr-body(call(return-gc-ctx, [call(as-ref, [call(gc-ctx-ptr, [param-ref(c)])])])))
		fun(
			false
			return-gc-ctx
			type(false, void)
			none
			[param(gc-ctx, type(true, gc-ctx))]
			expr-body(
				let(
					gc
					call(gc, [param-ref(gc-ctx)])
					seq(
						seq(
							seq(
								call(acquire-lock, [call(ref-of-val, [call(lk, [local-ref(gc)])])])
								set-field(param-ref(gc-ctx), next-ctx, call(context-head, [local-ref(gc)])))
							set-field(local-ref(gc), context-head, to-union(1, call(some, [param-ref(gc-ctx)]))))
						call(release-lock, [call(ref-of-val, [call(lk, [local-ref(gc)])])])))))
		fun(false, some, type(false, some), none, [param(value, type(true, gc-ctx))], new-record)
		fun(false, value, type(false, chosen-task), none, [param(a, type(false, ok))], field-get(0))
		fun(false, last-thread-out, type(false, bool), none, [param(a, type(false, no-chosen-task))], field-get(0))
		fun(false, value, type(false, no-chosen-task), none, [param(a, type(false, err))], field-get(0))
		fun(
			false
			wait-on
			type(false, void)
			none
			[param(c, type(true, condition)), param(last-checked, type(false, nat))]
			expr-body(
				cond(
					call(==, [call(value, [param-ref(c)]), param-ref(last-checked)])
					seq(call(yield-thread, []), call(wait-on, [param-ref(c), param-ref(last-checked)]))
					call(pass, []))))
		fun(false, thread-id, type(false, nat), none, [param(a, type(true, thread-args))], field-get(0))
		fun(false, gctx, type(true, global-ctx), none, [param(a, type(true, thread-args))], field-get(1))
		fun(
			false
			lambda(start-threads-recur, 0)
			type(false, ptr)
			none
			[param(args-ptr, type(false, ptr))]
			expr-body(call(thread-fun, [param-ref(args-ptr)])))
		fun(
			false
			pthread-create
			type(false, int32)
			none
			[
				param(thread, type(true, cell))
				param(attr, type(false, ptr))
				param(start-routine, type(false, fun-ptr1))
				param(arg, type(false, ptr))]
			extern(false))
		fun(
			false
			as-cell
			type(true, cell)
			none
			[param(p, type(false, ptr))]
			expr-body(call(as-ref, [call(as-any-ptr, [param-ref(p)])])))
		fun(false, as-ref, type(true, cell), none, [param(p, type(false, ptr))], builtin([type(true, cell)]))
		fun(false, as-any-ptr, type(false, ptr), none, [param(some-ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(false, as-any-ptr, type(false, ptr), none, [param(some-ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(false, eagain, type(false, int32), none, [], expr-body(call(wrap-add, [call(ten, []), call(one, [])])))
		fun(false, ten, type(false, int32), none, [], expr-body(call(wrap-add, [call(five, []), call(five, [])])))
		fun(
			false
			join-threads-recur
			type(false, void)
			none
			[param(i, type(false, nat)), param(n-threads, type(false, nat)), param(threads, type(false, ptr))]
			expr-body(
				cond(
					call(==, [param-ref(i), param-ref(n-threads)])
					call(pass, [])
					seq(
						call(join-one-thread, [call(deref, [call(+, [param-ref(threads), param-ref(i)])])])
						call(
							join-threads-recur
							[call(noctx-incr, [param-ref(i)]), param-ref(n-threads), param-ref(threads)])))))
		fun(
			false
			join-one-thread
			type(false, void)
			none
			[param(tid, type(false, nat))]
			expr-body(
				let(
					thread-return
					call(as, [call(cell, [call(null, [])])])
					let(
						err
						call(pthread-join, [param-ref(tid), call(ref-of-val, [local-ref(thread-return)])])
						seq(
							cond(
								call(zero?, [local-ref(err)])
								call(pass, [])
								cond(
									call(==, [local-ref(err), call(einval, [])])
									call(todo, [])
									cond(call(==, [local-ref(err), call(esrch, [])]), call(todo, []), call(todo, []))))
							call(
								hard-assert
								[call(null?, [call(get, [call(ref-of-val, [local-ref(thread-return)])])])]))))))
		fun(false, as, type(false, cell), none, [param(value, type(false, cell))], builtin([type(false, cell)]))
		fun(false, cell, type(false, cell), none, [param(value, type(false, ptr))], new-record)
		fun(
			false
			pthread-join
			type(false, int32)
			none
			[param(thread, type(false, nat)), param(thread-return, type(true, cell))]
			extern(false))
		fun(false, ref-of-val, type(true, cell), none, [param(b, type(false, cell))], builtin([type(true, cell)]))
		fun(
			false
			einval
			type(false, int32)
			none
			[]
			expr-body(call(wrap-add, [call(wrap-add, [call(ten, []), call(ten, [])]), call(two, [])])))
		fun(false, esrch, type(false, int32), none, [], expr-body(call(three, [])))
		fun(false, get, type(false, ptr), none, [param(c, type(true, cell))], expr-body(call(value, [param-ref(c)])))
		fun(false, value, type(false, ptr), none, [param(a, type(true, cell))], field-get(0))
		fun(
			false
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, ptr))]
			expr-body(call(free, [call(ptr-cast, [param-ref(p)])])))
		fun(false, free, type(false, void), none, [param(p, type(false, ptr))], extern(false))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat8), type(false, nat)]))
		fun(
			false
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, ptr))]
			expr-body(call(free, [call(ptr-cast, [param-ref(p)])])))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat8), type(false, thread-args)]))
		fun(false, any-unhandled-exceptions?, type(false, bool), none, [param(a, type(true, global-ctx))], field-get(5))
		fun(
			false
			must-be-resolved
			type(false, result)
			none
			[param(f, type(true, fut))]
			expr-body(
				match(
					"<<matched>>"
					call(state, [param-ref(f)])
					[
						case(none, call(hard-unreachable, []))
						case(some(r), to-union(0, call(ok, [call(value, [local-ref(r)])])))
						case(some(e), to-union(1, call(err, [local-ref(e)])))])))
		fun(false, hard-unreachable, type(false, result), none, [], expr-body(call(hard-fail, [arr(0, 11)])))
		fun(
			false
			hard-fail
			type(false, result)
			none
			[param(reason, type(false, arr))]
			builtin([type(false, result)]))
		fun(
			true
			main
			type(true, fut)
			none
			[param(args, type(false, arr))]
			expr-body(
				seq(
					seq(
						seq(call(test-compare-records, []), call(test-compare-byref-records, []))
						call(test-compare-unions, []))
					call(resolved, [call(literal, [arr(0, 13)])]))))
		fun(
			true
			test-compare-records
			type(false, void)
			none
			[]
			expr-body(
				let(
					a
					call(my-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 15)])])
					let(
						b
						call(my-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 16)])])
						let(
							c
							call(my-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 15)])])
							let(
								d
								call(my-record, [call(literal, [arr(0, 13)]), call(literal, [arr(0, 16)])])
								seq(
									seq(
										call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(b)])])])
										call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(c)])])]))
									call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(d)])])]))))))))
		fun(
			true
			my-record
			type(false, my-record)
			none
			[param(x, type(false, nat)), param(y, type(false, nat))]
			new-record)
		fun(
			true
			literal
			type(false, nat)
			none
			[param(s, type(false, arr))]
			expr-body(
				cond(
					call(empty?, [param-ref(s)])
					call(zero, [])
					let(
						higher-digits
						call(as, [call(literal, [call(rtail, [param-ref(s)])])])
						call(
							+
							[
								call(*, [local-ref(higher-digits), call(ten, [])])
								call(char-to-nat, [call(last, [param-ref(s)])])])))))
		fun(
			true
			rtail
			type(false, arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(slice, [param-ref(a), call(zero, []), call(decr, [call(size, [param-ref(a)])])]))))
		fun(
			true
			slice
			type(false, arr)
			none
			[param(a, type(false, arr)), param(begin, type(false, nat)), param(size, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<=, [call(+, [param-ref(begin), param-ref(size)]), call(size, [param-ref(a)])])])
					call(arr, [param-ref(size), call(+, [call(data, [param-ref(a)]), param-ref(begin)])]))))
		fun(
			true
			decr
			type(false, nat)
			none
			[param(a, type(false, nat))]
			expr-body(seq(call(forbid, [call(zero?, [param-ref(a)])]), call(wrap-decr, [param-ref(a)]))))
		fun(
			false
			wrap-decr
			type(false, nat)
			none
			[param(a, type(false, nat))]
			expr-body(call(wrap-sub, [param-ref(a), call(one, [])])))
		fun(
			true
			*
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				cond(
					call(or, [call(zero?, [param-ref(a)]), call(zero?, [param-ref(b)])])
					call(zero, [])
					let(
						res
						call(wrap-mul, [param-ref(a), param-ref(b)])
						seq(
							seq(
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(b)]), param-ref(a)])])
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(a)]), param-ref(b)])]))
							local-ref(res))))))
		fun(
			true
			/
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(seq(call(forbid, [call(zero?, [param-ref(b)])]), call(unsafe-div, [param-ref(a), param-ref(b)]))))
		fun(
			false
			unsafe-div
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(
			false
			char-to-nat
			type(false, nat)
			none
			[param(c, type(false, char))]
			expr-body(
				cond(
					call(==, [param-ref(c), call(literal, [arr(0, 13)])])
					call(zero, [])
					cond(
						call(==, [param-ref(c), call(literal, [arr(0, 14)])])
						call(one, [])
						cond(
							call(==, [param-ref(c), call(literal, [arr(0, 15)])])
							call(two, [])
							cond(
								call(==, [param-ref(c), call(literal, [arr(0, 16)])])
								call(three, [])
								cond(
									call(==, [param-ref(c), call(literal, [arr(0, 17)])])
									call(four, [])
									cond(
										call(==, [param-ref(c), call(literal, [arr(0, 18)])])
										call(five, [])
										cond(
											call(==, [param-ref(c), call(literal, [arr(0, 19)])])
											call(six, [])
											cond(
												call(==, [param-ref(c), call(literal, [arr(0, 20)])])
												call(seven, [])
												cond(
													call(==, [param-ref(c), call(literal, [arr(0, 21)])])
													call(eight, [])
													cond(
														call(==, [param-ref(c), call(literal, [arr(0, 22)])])
														call(nine, [])
														call(todo, [])))))))))))))
		fun(false, todo, type(false, nat), none, [], expr-body(call(hard-fail, [arr(0, 2)])))
		fun(false, hard-fail, type(false, nat), none, [param(reason, type(false, arr))], builtin([type(false, nat)]))
		fun(
			true
			last
			type(false, char)
			none
			[param(a, type(false, arr))]
			expr-body(
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(at, [param-ref(a), call(decr, [call(size, [param-ref(a)])])]))))
		fun(
			true
			at
			type(false, char)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(noctx-at, [param-ref(a), param-ref(index)]))))
		fun(
			false
			print-sync
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body(seq(call(print-sync-no-newline, [param-ref(s)]), call(print-sync-no-newline, [arr(0, 4)]))))
		fun(
			false
			print-sync-no-newline
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body(call(write-sync-no-newline, [call(stdout-fd, []), param-ref(s)])))
		fun(false, stdout-fd, type(false, int32), none, [], expr-body(call(one, [])))
		fun(
			true
			to-str
			type(false, arr)
			none
			[param(c, type(false, comparison))]
			expr-body(
				match("<<matched>>", param-ref(c), [case(none, arr(0, 23)), case(none, arr(0, 24)), case(none, arr(0, 25))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, my-record)), param(b, type(false, my-record))]
			builtin([type(false, my-record)]))
		fun(
			true
			test-compare-byref-records
			type(false, void)
			none
			[]
			expr-body(
				let(
					a
					call(my-byref-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 15)])])
					let(
						b
						call(my-byref-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 16)])])
						let(
							c
							call(my-byref-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 15)])])
							let(
								d
								call(my-byref-record, [call(literal, [arr(0, 13)]), call(literal, [arr(0, 16)])])
								seq(
									seq(
										call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(b)])])])
										call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(c)])])]))
									call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(d)])])]))))))))
		fun(
			true
			my-byref-record
			type(true, my-byref-record)
			none
			[param(x, type(false, nat)), param(y, type(false, nat))]
			new-record)
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(true, my-byref-record)), param(b, type(true, my-byref-record))]
			builtin([type(true, my-byref-record)]))
		fun(
			true
			test-compare-unions
			type(false, void)
			none
			[]
			expr-body(
				let(
					a
					call(as, [to-union(0, call(my-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 15)])]))])
					let(
						b
						call(as, [to-union(1, call(my-other-record, []))])
						let(
							c
							call(
								as
								[to-union(0, call(my-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 15)])]))])
							let(
								d
								call(
									as
									[to-union(0, call(my-record, [call(literal, [arr(0, 14)]), call(literal, [arr(0, 14)])]))])
								seq(
									seq(
										call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(b)])])])
										call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(c)])])]))
									call(print-sync, [call(to-str, [call(<=>, [local-ref(a), local-ref(d)])])]))))))))
		fun(
			false
			as
			type(false, my-union)
			none
			[param(value, type(false, my-union))]
			builtin([type(false, my-union)]))
		fun(false, my-other-record, type(false, my-other-record), none, [], new-record)
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, my-union)), param(b, type(false, my-union))]
			builtin([type(false, my-union)]))
		fun(
			true
			resolved
			type(true, fut)
			none
			[param(value, type(false, int32))]
			expr-body(call(fut, [call(new-lock, []), to-union(1, call(fut-state-resolved, [param-ref(value)]))])))
		fun(
			true
			literal
			type(false, int32)
			none
			[param(s, type(false, arr))]
			expr-body(call(unsafe-to-int32, [call(as, [call(literal, [param-ref(s)])])])))
		fun(false, unsafe-to-int32, type(false, int32), none, [param(a, type(false, int))], builtin([]))
		fun(false, as, type(false, int), none, [param(value, type(false, int))], builtin([type(false, int)]))
		fun(
			true
			literal
			type(false, int)
			none
			[param(s, type(false, arr))]
			expr-body(
				let(
					fst
					call(at, [param-ref(s), call(zero, [])])
					cond(
						call(==, [local-ref(fst), call(literal, [arr(0, 26)])])
						let(n, call(as, [call(literal, [call(tail, [param-ref(s)])])]), call(neg, [local-ref(n)]))
						cond(
							call(==, [local-ref(fst), call(literal, [arr(0, 27)])])
							call(to-int, [call(as, [call(literal, [call(tail, [param-ref(s)])])])])
							call(to-int, [call(as, [call(literal, [param-ref(s)])])]))))))
		fun(
			true
			tail
			type(false, arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(slice-starting-at, [param-ref(a), call(one, [])]))))
		fun(
			true
			slice-starting-at
			type(false, arr)
			none
			[param(a, type(false, arr)), param(begin, type(false, nat))]
			expr-body(
				seq(
					call(assert, [call(<=, [param-ref(begin), call(size, [param-ref(a)])])])
					call(
						slice
						[param-ref(a), param-ref(begin), call(-, [call(size, [param-ref(a)]), param-ref(begin)])]))))
		fun(
			true
			neg
			type(false, int)
			none
			[param(n, type(false, nat))]
			expr-body(call(neg, [call(to-int, [param-ref(n)])])))
		fun(
			true
			neg
			type(false, int)
			none
			[param(i, type(false, int))]
			expr-body(call(*, [param-ref(i), call(neg-one, [])])))
		fun(
			true
			*
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(
				seq(
					seq(
						seq(
							seq(
								call(assert, [call(>, [param-ref(a), call(neg-million, [])])])
								call(assert, [call(<, [param-ref(a), call(million, [])])]))
							call(assert, [call(>, [param-ref(b), call(neg-million, [])])]))
						call(assert, [call(<, [param-ref(b), call(million, [])])]))
					call(wrap-mul, [param-ref(a), param-ref(b)]))))
		fun(
			false
			>
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(call(not, [call(<=, [param-ref(a), param-ref(b)])])))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(call(not, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(
			false
			neg-million
			type(false, int)
			none
			[]
			expr-body(call(wrap-mul, [call(million, []), call(neg-one, [])])))
		fun(
			false
			wrap-mul
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([]))
		fun(
			false
			million
			type(false, int)
			none
			[]
			expr-body(call(wrap-mul, [call(thousand, []), call(thousand, [])])))
		fun(false, thousand, type(false, int), none, [], expr-body(call(wrap-mul, [call(hundred, []), call(ten, [])])))
		fun(false, hundred, type(false, int), none, [], expr-body(call(wrap-mul, [call(ten, []), call(ten, [])])))
		fun(false, ten, type(false, int), none, [], expr-body(call(wrap-incr, [call(nine, [])])))
		fun(
			false
			wrap-incr
			type(false, int)
			none
			[param(a, type(false, int))]
			expr-body(call(wrap-add, [param-ref(a), call(one, [])])))
		fun(
			false
			wrap-add
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([]))
		fun(false, one, type(false, int), none, [], builtin([]))
		fun(false, nine, type(false, int), none, [], expr-body(call(wrap-incr, [call(eight, [])])))
		fun(false, eight, type(false, int), none, [], expr-body(call(wrap-incr, [call(seven, [])])))
		fun(false, seven, type(false, int), none, [], expr-body(call(wrap-incr, [call(six, [])])))
		fun(false, six, type(false, int), none, [], expr-body(call(wrap-incr, [call(five, [])])))
		fun(false, five, type(false, int), none, [], expr-body(call(wrap-incr, [call(four, [])])))
		fun(false, four, type(false, int), none, [], expr-body(call(wrap-incr, [call(three, [])])))
		fun(false, three, type(false, int), none, [], expr-body(call(wrap-incr, [call(two, [])])))
		fun(false, two, type(false, int), none, [], expr-body(call(wrap-incr, [call(one, [])])))
		fun(false, neg-one, type(false, int), none, [], expr-body(call(wrap-sub, [call(zero, []), call(one, [])])))
		fun(
			false
			wrap-sub
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([]))
		fun(false, zero, type(false, int), none, [], builtin([]))
		fun(
			true
			to-int
			type(false, int)
			none
			[param(n, type(false, nat))]
			expr-body(
				seq(call(assert, [call(<, [param-ref(n), call(million, [])])]), call(unsafe-to-int, [param-ref(n)]))))]
	rt-main
	main
	ctx)
