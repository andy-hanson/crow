program(
	[
		struct(
			name: ctx
			ptr: true
			body: record(
				[
					field(gctx-ptr, const, type(false, mut-ptr))
					field(island-id, const, type(false, nat64))
					field(exclusion, const, type(false, nat64))
					field(gc-ctx-ptr, const, type(false, mut-ptr))
					field(thread-local-stuff, const, type(true, thread-local-stuff))]))
		struct(name: nat8, body: builtin(nat-8, []))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, nat8)]))
		struct(name: nat64, body: builtin(nat-64, []))
		struct(
			name: thread-local-stuff
			ptr: true
			body: record(
				[
					field(thread-id, const, type(false, nat64))
					field(print-lock, const, type(true, lock))
					field(exception-ctx-ptr, const, type(false, mut-ptr))
					field(log-ctx-ptr, const, type(false, mut-ptr))
					field(perf-ctx-ptr, const, type(false, mut-ptr))]))
		struct(name: lock, ptr: true, body: record([field(mutex, const, type(false, pthread_mutex_t))]))
		struct(
			name: pthread_mutex_t
			mut: true
			ptr: true
			body: record(
				[
					field(n0, mutable, type(false, nat64))
					field(n1, mutable, type(false, nat64))
					field(n2, mutable, type(false, nat64))
					field(n3, mutable, type(false, nat64))
					field(n4, mutable, type(false, nat64))]))
		struct(name: bool, body: builtin(bool, []))
		struct(
			name: mark-ctx
			ptr: true
			body: record(
				[
					field(memory-size-words, const, type(false, nat64))
					field(marks, const, type(false, mut-ptr))
					field(memory-start, const, type(false, mut-ptr))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, bool)]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, nat64)]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, nat8)]))
		struct(name: void, body: builtin(void, []))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, nat64)]))
		struct(name: comparison, body: enum)
		struct(name: int32, body: builtin(int-32, []))
		struct(name: char, body: builtin(char, []))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, char)]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, const-ptr)]))
		struct(
			name: fut
			mut: true
			ptr: true
			body: record([field(lk, const, type(false, lock)), field(state, mutable, type(false, fut-state))]))
		struct(
			name: fut-state
			body: union([none, some(type(true, fut-state-callbacks)), some(type(false, nat64)), some(type(false, exception))]))
		struct(
			name: fut-state-callbacks
			ptr: true
			body: record([field(cb, const, type(false, fun-act1)), field(next, const, type(false, opt))]))
		struct(
			name: exception
			body: record([field(message, const, type(false, str)), field(backtrace, const, type(false, backtrace))]))
		struct(name: str, body: record([field(chars, const, type(false, arr))]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: backtrace, body: record([field(return-stack, const, type(false, arr))]))
		struct(name: sym, body: record([field(to-c-str, const, type(false, const-ptr))]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, sym)]))
		struct(name: result, body: union([some(type(false, nat64)), some(type(false, exception))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, result)]))
		struct(name: opt, body: union([none, some(type(true, fut-state-callbacks))]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, str)]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, arr)]))
		struct(
			name: global-ctx
			mut: true
			ptr: true
			body: record(
				[
					field(lk, const, type(false, lock))
					field(print-lock, const, type(false, lock))
					field(syms-lock, const, type(false, lock))
					field(dynamic-syms, mutable, type(false, opt))
					field(islands, mutable, type(false, arr))
					field(n-live-threads, mutable, type(false, nat64))
					field(may-be-work-to-do, const, type(false, condition))
					field(is-shut-down, mutable, type(false, bool))
					field(any-unhandled-exceptions, mutable, type(false, bool))]))
		struct(
			name: dynamic-sym-node
			ptr: true
			body: record([field(sym, const, type(false, sym)), field(next, const, type(false, opt))]))
		struct(name: opt, body: union([none, some(type(true, dynamic-sym-node))]))
		struct(
			name: island
			mut: true
			ptr: true
			body: record(
				[
					field(gctx, const, type(true, global-ctx))
					field(id, const, type(false, nat64))
					field(gc, const, type(false, gc))
					field(gc-root, const, type(false, island-gc-root))
					field(tasks-lock, const, type(false, lock))
					field(n-threads-running, mutable, type(false, nat64))
					field(next-exclusion, const, type(false, thread-safe-counter))]))
		struct(
			name: gc
			mut: true
			ptr: true
			body: record(
				[
					field(lk, const, type(false, lock))
					field(gc-count, mutable, type(false, nat64))
					field(context-head, mutable, type(false, opt))
					field(needs-gc, mutable, type(false, bool))
					field(size-words, mutable, type(false, nat64))
					field(mark-begin, const, type(false, mut-ptr))
					field(mark-cur, mutable, type(false, mut-ptr))
					field(mark-end, mutable, type(false, mut-ptr))
					field(data-begin, const, type(false, mut-ptr))
					field(data-cur, mutable, type(false, mut-ptr))
					field(data-end, mutable, type(false, mut-ptr))]))
		struct(
			name: gc-ctx
			mut: true
			ptr: true
			body: record([field(gc, mutable, type(true, gc)), field(next-ctx, mutable, type(false, opt))]))
		struct(name: opt, body: union([none, some(type(true, gc-ctx))]))
		struct(
			name: island-gc-root
			mut: true
			ptr: true
			body: record(
				[
					field(tasks, const, type(false, task-queue))
					field(exception-handler, mutable, type(false, fun1))
					field(log-handler, mutable, type(false, fun1))]))
		struct(
			name: task-queue
			mut: true
			ptr: true
			body: record(
				[
					field(head, mutable, type(false, opt))
					field(currently-running-exclusions, const, type(false, mut-arr))]))
		struct(
			name: task-queue-node
			mut: true
			ptr: true
			body: record([field(task, const, type(false, task)), field(next, mutable, type(false, opt))]))
		struct(
			name: task
			body: record(
				[
					field(time, const, type(false, nat64))
					field(exclusion, const, type(false, nat64))
					field(action, const, type(false, fun-act0))]))
		struct(name: fun-act0, body: builtin(fun, [type(false, void)]))
		struct(name: opt, body: union([none, some(type(true, task-queue-node))]))
		struct(
			name: mut-arr
			mut: true
			ptr: true
			body: record([field(backing, mutable, type(false, fix-arr)), field(size, mutable, type(false, nat64))]))
		struct(name: fix-arr, body: record([field(inner, const, type(false, arr))]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: fun1, body: builtin(fun, [type(false, void), type(false, exception)]))
		struct(
			name: logged
			ptr: true
			body: record([field(level, const, type(false, log-level)), field(message, const, type(false, str))]))
		struct(name: log-level, body: enum)
		struct(name: fun1, body: builtin(fun, [type(false, void), type(true, logged)]))
		struct(
			name: thread-safe-counter
			mut: true
			ptr: true
			body: record([field(lk, const, type(false, lock)), field(value, mutable, type(false, nat64))]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(true, island)]))
		struct(
			name: condition
			mut: true
			ptr: true
			body: record(
				[
					field(mutex-attr, const, type(false, pthread_mutexattr_t))
					field(mutex, const, type(false, pthread_mutex_t))
					field(cond-attr, const, type(false, pthread_condattr_t))
					field(cond, const, type(false, pthread_cond_t))
					field(sequence, mutable, type(false, nat64))]))
		struct(name: pthread_mutexattr_t, ptr: true, body: record([field(sizer, const, type(false, nat32))]))
		struct(name: nat32, body: builtin(nat-32, []))
		struct(name: pthread_condattr_t, ptr: true, body: record([field(sizer, const, type(false, nat32))]))
		struct(name: pthread_cond_t, ptr: true, body: record([field(sizer, const, type(false, bytes48))]))
		struct(
			name: bytes48
			body: record([field(n0, const, type(false, bytes32)), field(n1, const, type(false, bytes16))]))
		struct(
			name: bytes32
			body: record([field(n0, const, type(false, bytes16)), field(n1, const, type(false, bytes16))]))
		struct(
			name: bytes16
			body: record([field(n0, const, type(false, nat64)), field(n1, const, type(false, nat64))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(true, island)]))
		struct(
			name: range
			body: record(
				[
					field(ignore, const, type(false, void))
					field(low, const, type(false, nat64))
					field(high, const, type(false, nat64))]))
		struct(name: int64, body: builtin(int-64, []))
		struct(name: writer, body: record([field(chars, const, type(true, mut-arr))]))
		struct(
			name: mut-arr
			mut: true
			ptr: true
			body: record([field(backing, mutable, type(false, fix-arr)), field(size, mutable, type(false, nat64))]))
		struct(name: fix-arr, body: record([field(inner, const, type(false, arr))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, char)]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, char)]))
		struct(name: lambda(~=, 0), body: record([field(a, const, type(true, mut-arr))]))
		struct(
			name: exception-ctx
			mut: true
			ptr: true
			body: record(
				[
					field(jmp-buf-ptr, mutable, type(false, mut-ptr))
					field(thrown-exception, mutable, type(false, exception))]))
		struct(
			name: __jmp_buf_tag
			body: record(
				[
					field(__jmpbuf, const, type(false, bytes64))
					field(__mask_was_saved, const, type(false, int32))
					field(__saved_mask, const, type(false, bytes128))]))
		struct(
			name: bytes64
			body: record([field(n0, const, type(false, bytes32)), field(n1, const, type(false, bytes32))]))
		struct(
			name: bytes128
			body: record([field(n0, const, type(false, bytes64)), field(n1, const, type(false, bytes64))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, __jmp_buf_tag)]))
		struct(
			name: backtrace-arrs
			ptr: true
			body: record(
				[
					field(code-ptrs, const, type(false, mut-ptr))
					field(code-names, const, type(false, mut-ptr))
					field(funs, const, type(false, mut-ptr))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, const-ptr)]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, sym)]))
		struct(
			name: named-val
			body: record([field(name, const, type(false, sym)), field(val, const, type(false, const-ptr))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, named-val)]))
		struct(name: opt, body: union([none, some(type(true, backtrace-arrs))]))
		struct(name: opt, body: union([none, some(type(false, mut-ptr))]))
		struct(name: opt, body: union([none, some(type(false, mut-ptr))]))
		struct(name: opt, body: union([none, some(type(false, mut-ptr))]))
		struct(name: opt, body: union([none, some(type(false, mut-ptr))]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, named-val)]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, const-ptr)]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, sym)]))
		struct(name: lambda(to-str, 0), body: record([field(res, const, type(false, writer))]))
		struct(name: opt, body: union([none, some(type(false, const-ptr))]))
		struct(name: log-ctx, mut: true, ptr: true, body: record([field(handler, mutable, type(false, fun1))]))
		struct(
			name: perf-ctx
			mut: true
			ptr: true
			body: record(
				[field(measure-names, mutable, type(false, arr)), field(measure-values, mutable, type(false, fix-arr))]))
		struct(
			name: measure-value
			body: record([field(count, const, type(false, nat64)), field(total-ns, const, type(false, nat64))]))
		struct(name: fix-arr, body: record([field(inner, const, type(false, arr))]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, measure-value)]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, str)]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, measure-value)]))
		struct(
			name: arr
			body: record([field(size, const, type(false, nat64)), field(begin-ptr, const, type(false, const-ptr))]))
		struct(name: fun-act2, body: builtin(fun, [type(true, fut), type(false, arr), type(false, fun-ptr2)]))
		struct(
			name: fut
			mut: true
			ptr: true
			body: record([field(lk, const, type(false, lock)), field(state, mutable, type(false, fut-state))]))
		struct(
			name: fut-state
			body: union([none, some(type(true, fut-state-callbacks)), some(type(false, void)), some(type(false, exception))]))
		struct(
			name: fut-state-callbacks
			ptr: true
			body: record([field(cb, const, type(false, fun-act1)), field(next, const, type(false, opt))]))
		struct(name: result, body: union([some(type(false, void)), some(type(false, exception))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, result)]))
		struct(name: opt, body: union([none, some(type(true, fut-state-callbacks))]))
		struct(
			name: fun-ref0
			body: record(
				[
					field(island-and-exclusion, const, type(false, island-and-exclusion))
					field(action, const, type(false, fun-act0))]))
		struct(
			name: island-and-exclusion
			body: record([field(island, const, type(false, nat64)), field(exclusion, const, type(false, nat64))]))
		struct(name: fun-act0, body: builtin(fun, [type(true, fut)]))
		struct(
			name: fun-ref1
			body: record(
				[
					field(island-and-exclusion, const, type(false, island-and-exclusion))
					field(action, const, type(false, fun-act1))]))
		struct(name: fun-act1, body: builtin(fun, [type(true, fut), type(false, void)]))
		struct(
			name: lambda(callback!, 0)
			ptr: true
			body: record([field(f, const, type(true, fut)), field(cb, const, type(false, fun-act1))]))
		struct(
			name: lambda(then, 0)
			ptr: true
			body: record([field(cb, const, type(false, fun-ref1)), field(res, const, type(true, fut))]))
		struct(
			name: lambda(callback!, 0)
			ptr: true
			body: record([field(f, const, type(true, fut)), field(cb, const, type(false, fun-act1))]))
		struct(name: lambda(forward-to!, 0), body: record([field(to, const, type(true, fut))]))
		struct(name: fun-act0, body: builtin(fun, [type(false, fut-state)]))
		struct(
			name: lambda(resolve-or-reject!, 0)
			ptr: true
			body: record([field(f, const, type(true, fut)), field(result, const, type(false, result))]))
		struct(
			name: lambda(subscript, 0)
			ptr: true
			body: record(
				[
					field(f, const, type(false, fun-ref1))
					field(p0, const, type(false, void))
					field(res, const, type(true, fut))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, exception)]))
		struct(
			name: lambda(lambda(subscript, 0), 0)
			ptr: true
			body: record(
				[
					field(f, const, type(false, fun-ref1))
					field(p0, const, type(false, void))
					field(res, const, type(true, fut))]))
		struct(name: lambda(lambda(subscript, 0), 1), body: record([field(res, const, type(true, fut))]))
		struct(name: lambda(then-void, 0), ptr: true, body: record([field(cb, const, type(false, fun-ref0))]))
		struct(
			name: lambda(subscript, 0)
			ptr: true
			body: record([field(f, const, type(false, fun-ref0)), field(res, const, type(true, fut))]))
		struct(
			name: lambda(lambda(subscript, 0), 0)
			ptr: true
			body: record([field(f, const, type(false, fun-ref0)), field(res, const, type(true, fut))]))
		struct(name: lambda(lambda(subscript, 0), 1), body: record([field(res, const, type(true, fut))]))
		struct(
			name: lambda(add-first-task, 0)
			ptr: true
			body: record([field(main-ptr, const, type(false, fun-ptr2)), field(all-args, const, type(false, arr))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, str), type(false, const-ptr)]))
		struct(name: fun-act1, body: builtin(fun, [type(false, str), type(false, nat64)]))
		struct(
			name: lambda(map, 0)
			ptr: true
			body: record([field(f, const, type(false, fun-act1)), field(a, const, type(false, arr))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, const-ptr)]))
		struct(
			name: thread-args
			ptr: true
			body: record([field(thread-id, const, type(false, nat64)), field(gctx, const, type(true, global-ctx))]))
		struct(name: mut-ptr, body: builtin(ptr-mut, [type(false, thread-args)]))
		struct(name: cell, mut: true, ptr: true, body: record([field(inner-value, mutable, type(false, nat64))]))
		struct(name: fun-ptr1, body: builtin(fun-ptr, [type(false, mut-ptr), type(false, mut-ptr)]))
		struct(
			name: choose-task-result
			body: union([some(type(false, chosen-task)), some(type(false, no-chosen-task))]))
		struct(
			name: chosen-task
			body: record([field(task-island, const, type(true, island)), field(task-or-gc, const, type(false, task-or-gc))]))
		struct(name: task-or-gc, body: union([some(type(false, task)), none]))
		struct(
			name: no-chosen-task
			body: record(
				[
					field(no-tasks-and-last-thread-out, const, type(false, bool))
					field(first-task-time, const, type(false, opt))]))
		struct(name: opt, body: union([none, some(type(false, nat64))]))
		struct(
			name: timespec
			body: record([field(tv_sec, const, type(false, int64)), field(tv_nsec, const, type(false, int64))]))
		struct(name: cell, mut: true, ptr: true, body: record([field(inner-value, mutable, type(false, timespec))]))
		struct(
			name: choose-task-in-island-result
			body: union([some(type(false, task)), none, some(type(false, no-task))]))
		struct(
			name: no-task
			body: record([field(any-tasks, const, type(false, bool)), field(first-task-time, const, type(false, opt))]))
		struct(name: pop-task-result, body: union([some(type(false, task)), some(type(false, no-task))]))
		struct(name: const-ptr, body: builtin(ptr-const, [type(false, timespec)]))
		struct(name: cell, mut: true, ptr: true, body: record([field(inner-value, mutable, type(false, mut-ptr))]))
		struct(
			name: my-record
			body: record([field(x, const, type(false, nat64)), field(y, const, type(false, nat64))]))]
	[
		fun(
			noctx
			mark
			type(false, bool)
			none
			[
				param(ctx, type(true, mark-ctx))
				param(ptr-any, type(false, const-ptr))
				param(size-bytes, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(is-word-aligned, [param-ref(ptr-any)])])
					let(
						size-words
						call(words-of-bytes, [param-ref(size-bytes)])
						let(
							ptr
							call(ptr-cast, [param-ref(ptr-any)])
							let(
								index
								call(-, [local-ref(ptr), call(as-const, [call(memory-start, [param-ref(ctx)])])])
								cond(
									call(<, [local-ref(index), call(memory-size-words, [param-ref(ctx)])])
									seq(
										call(
											hard-assert
											[
												call(
													<=
													[
														call(wrap-add, [local-ref(index), local-ref(size-words)])
														call(memory-size-words, [param-ref(ctx)])])])
										let(
											mark-start
											call(+, [call(marks, [param-ref(ctx)]), local-ref(index)])
											let(
												mark-end
												call(+, [local-ref(mark-start), local-ref(size-words)])
												call(
													mark-range-recur
													[call(false, []), local-ref(mark-start), local-ref(mark-end)]))))
									seq(
										call(
											hard-assert
											[
												call(
													>
													[
														call(wrap-add, [local-ref(index), local-ref(size-words)])
														call(memory-size-words, [param-ref(ctx)])])])
										call(false, [])))))))))
		fun(
			noctx
			hard-assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(param-ref(condition), call(void, []), call(abort, []))))
		fun(noctx, void, type(false, void), none, [], builtin([]))
		fun(noctx, abort, type(false, void), none, [], extern)
		fun(
			noctx
			is-word-aligned
			type(false, bool)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(is-word-aligned, [call(as-mut, [param-ref(a)])])))
		fun(
			noctx
			is-word-aligned
			type(false, bool)
			none
			[param(a, type(false, mut-ptr))]
			expr-body(call(==, [call(&, [call(to-nat64, [param-ref(a)]), 7]), 0])))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			noctx
			&
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(noctx, to-nat64, type(false, nat64), none, [param(a, type(false, mut-ptr))], builtin([type(false, nat8)]))
		fun(noctx, as-mut, type(false, mut-ptr), none, [param(a, type(false, const-ptr))], builtin([type(false, nat8)]))
		fun(
			noctx
			words-of-bytes
			type(false, nat64)
			none
			[param(size-bytes, type(false, nat64))]
			expr-body(call(unsafe-div, [call(round-up-to-multiple-of-8, [param-ref(size-bytes)]), 8])))
		fun(
			noctx
			unsafe-div
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			noctx
			round-up-to-multiple-of-8
			type(false, nat64)
			none
			[param(n, type(false, nat64))]
			expr-body(call(&, [call(wrap-add, [param-ref(n), 7]), call(~, [7])])))
		fun(
			noctx
			wrap-add
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(noctx, ~, type(false, nat64), none, [param(a, type(false, nat64))], builtin([]))
		fun(
			noctx
			ptr-cast
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(as-const, [call(ptr-cast, [call(as-mut, [param-ref(a)])])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, nat64)]))
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, nat64), type(false, nat8)]))
		fun(
			noctx
			-
			type(false, nat64)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(-, [call(as-mut, [param-ref(a)]), call(as-mut, [param-ref(b)])])))
		fun(
			noctx
			-
			type(false, nat64)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				call(
					unsafe-div
					[
						call(wrap-sub, [call(to-nat64, [param-ref(a)]), call(to-nat64, [param-ref(b)])])
						call(size-of, [])])))
		fun(
			noctx
			wrap-sub
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(noctx, to-nat64, type(false, nat64), none, [param(a, type(false, mut-ptr))], builtin([type(false, nat64)]))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, nat64)]))
		fun(
			noctx
			as-mut
			type(false, mut-ptr)
			none
			[param(a, type(false, const-ptr))]
			builtin([type(false, nat64)]))
		fun(noctx, memory-start, type(false, mut-ptr), none, [param(a, type(true, mark-ctx))], field-get(2))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(cmp, [param-ref(a), param-ref(b)])))
		fun(
			noctx
			is-less
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			noctx
			cmp
			type(false, comparison)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				cond(
					call(is-less, [param-ref(a), param-ref(b)])
					call(less, [])
					cond(call(==, [param-ref(a), param-ref(b)]), call(equal, []), call(greater, [])))))
		fun(noctx, less, type(false, comparison), none, [], create-enum(0))
		fun(noctx, equal, type(false, comparison), none, [], create-enum(1))
		fun(noctx, greater, type(false, comparison), none, [], create-enum(2))
		fun(
			noctx
			<
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				match-enum(call(<=>, [param-ref(a), param-ref(b)]), [call(true, []), call(false, []), call(false, [])])))
		fun(noctx, true, type(false, bool), none, [], builtin([]))
		fun(noctx, false, type(false, bool), none, [], builtin([]))
		fun(noctx, memory-size-words, type(false, nat64), none, [param(a, type(true, mark-ctx))], field-get(0))
		fun(
			noctx
			<=
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			noctx
			!
			type(false, bool)
			none
			[param(a, type(false, bool))]
			expr-body(cond(param-ref(a), call(false, []), call(true, []))))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, bool)]))
		fun(noctx, marks, type(false, mut-ptr), none, [param(a, type(true, mark-ctx))], field-get(1))
		fun(
			noctx
			mark-range-recur
			type(false, bool)
			none
			[
				param(marked-anything, type(false, bool))
				param(cur, type(false, mut-ptr))
				param(end, type(false, mut-ptr))]
			expr-body(
				cond(
					call(==, [param-ref(cur), param-ref(end)])
					param-ref(marked-anything)
					let(
						new-marked-anything
						call(||, [param-ref(marked-anything), call(!, [call(*, [param-ref(cur)])])])
						seq(
							call(set-deref, [param-ref(cur), call(true, [])])
							call(
								mark-range-recur
								[local-ref(new-marked-anything), call(+, [param-ref(cur), 1]), param-ref(end)]))))))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, bool)]))
		fun(noctx, ||, type(false, bool), none, [param(a, type(false, bool)), param(b, type(false, bool))], builtin([]))
		fun(noctx, *, type(false, bool), none, [param(a, type(false, mut-ptr))], builtin([type(false, bool)]))
		fun(
			noctx
			set-deref
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(value, type(false, bool))]
			builtin([type(false, bool)]))
		fun(
			noctx
			>
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(<, [param-ref(b), param-ref(a)])))
		fun(
			noctx
			rt-main
			type(false, int32)
			none
			[
				param(argc, type(false, int32))
				param(argv, type(false, const-ptr))
				param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				seq(
					call(do-init-constants, [])
					let(
						n-threads
						call(get_nprocs, [])
						let(
							f
							call(false, [])
							let(
								gctx-by-val
								call(
									new
									[
										call(lbv, [])
										call(lbv, [])
										call(lbv, [])
										call(none, [])
										call(empty-arr, [])
										local-ref(n-threads)
										call(create-condition, [])
										local-ref(f)
										local-ref(f)])
								let(
									gctx
									call(ref-of-val, [local-ref(gctx-by-val)])
									let(
										island-by-val
										call(island, [local-ref(gctx), 0, local-ref(n-threads)])
										let(
											island
											call(ref-of-val, [local-ref(island-by-val)])
											seq(
												call(
													set-islands
													[
														local-ref(gctx)
														call(arr-of-single, [call(ptr-to, [local-ref(island)])])])
												let(
													main-fut
													call(
														add-main-task
														[
															local-ref(gctx)
															call(wrap-sub, [local-ref(n-threads), 1])
															local-ref(island)
															param-ref(argc)
															param-ref(argv)
															param-ref(main-ptr)])
													seq(
														seq(
															call(run-threads, [local-ref(n-threads), local-ref(gctx)])
															call(
																destroy-condition
																[
																	call(
																		ref-of-val
																		[call(may-be-work-to-do, [local-ref(gctx)])])]))
														call(
															exit-code-from-main-fut
															[local-ref(gctx), local-ref(main-fut)])))))))))))))
		fun(noctx, do-init-constants, type(false, void), none, [], expr-body(call(init-constants, [])))
		fun(noctx, init-constants, type(false, void), none, [], builtin([]))
		fun(noctx, get_nprocs, type(false, nat64), none, [], extern)
		fun(
			noctx
			new
			type(false, global-ctx)
			none
			[
				param(lk, type(false, lock))
				param(print-lock, type(false, lock))
				param(syms-lock, type(false, lock))
				param(dynamic-syms, type(false, opt))
				param(islands, type(false, arr))
				param(n-live-threads, type(false, nat64))
				param(may-be-work-to-do, type(false, condition))
				param(is-shut-down, type(false, bool))
				param(any-unhandled-exceptions, type(false, bool))]
			new-record)
		fun(noctx, lbv, type(false, lock), none, [], expr-body(call(lock-by-val, [])))
		fun(
			noctx
			lock-by-val
			type(false, lock)
			none
			[]
			expr-body(
				let(
					res
					call(new, [call(new, [0, 0, 0, 0, 0])])
					let(
						attr
						call(zeroed, [])
						let(
							mutex
							call(ref-of-val, [call(mutex, [call(ref-of-val, [local-ref(res)])])])
							seq(
								call(
									hard-assert-posix-error
									[call(pthread_mutex_init, [local-ref(mutex), call(ref-of-val, [local-ref(attr)])])])
								local-ref(res)))))))
		fun(noctx, new, type(false, lock), none, [param(mutex, type(false, pthread_mutex_t))], new-record)
		fun(
			noctx
			new
			type(false, pthread_mutex_t)
			none
			[
				param(n0, type(false, nat64))
				param(n1, type(false, nat64))
				param(n2, type(false, nat64))
				param(n3, type(false, nat64))
				param(n4, type(false, nat64))]
			new-record)
		fun(noctx, zeroed, type(false, pthread_mutexattr_t), none, [], builtin([type(false, pthread_mutexattr_t)]))
		fun(
			noctx
			ref-of-val
			type(true, pthread_mutex_t)
			none
			[param(a, type(false, pthread_mutex_t))]
			builtin([type(true, pthread_mutex_t)]))
		fun(noctx, mutex, type(false, pthread_mutex_t), none, [param(a, type(true, lock))], field-get(0))
		fun(noctx, ref-of-val, type(true, lock), none, [param(a, type(false, lock))], builtin([type(true, lock)]))
		fun(
			noctx
			hard-assert-posix-error
			type(false, void)
			none
			[param(err, type(false, int32))]
			expr-body(call(hard-assert, [call(==, [param-ref(err), 0])])))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			builtin([]))
		fun(
			noctx
			pthread_mutex_init
			type(false, int32)
			none
			[param(mutex, type(true, pthread_mutex_t)), param(attr, type(true, pthread_mutexattr_t))]
			extern)
		fun(
			noctx
			ref-of-val
			type(true, pthread_mutexattr_t)
			none
			[param(a, type(false, pthread_mutexattr_t))]
			builtin([type(true, pthread_mutexattr_t)]))
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(noctx, empty-arr, type(false, arr), none, [], expr-body(call(new, [0, call(null, [])])))
		fun(
			noctx
			new
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, const-ptr))]
			new-record)
		fun(noctx, null, type(false, const-ptr), none, [], expr-body(call(as-const, [call(null, [])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(true, island)]))
		fun(noctx, null, type(false, mut-ptr), none, [], builtin([type(true, island)]))
		fun(
			noctx
			create-condition
			type(false, condition)
			none
			[]
			expr-body(
				let(
					res
					call(new, [call(zeroed, []), call(zeroed, []), call(zeroed, []), call(zeroed, []), 0])
					seq(
						seq(
							seq(
								seq(
									seq(
										call(
											hard-assert-posix-error
											[
												call(
													pthread_mutexattr_init
													[
														call(
															ref-of-val
															[call(mutex-attr, [call(ref-of-val, [local-ref(res)])])])])])
										call(
											hard-assert-posix-error
											[
												call(
													pthread_mutex_init
													[
														call(
															ref-of-val
															[call(mutex, [call(ref-of-val, [local-ref(res)])])])
														call(
															ref-of-val
															[call(mutex-attr, [call(ref-of-val, [local-ref(res)])])])])]))
									call(
										hard-assert-posix-error
										[
											call(
												pthread_condattr_init
												[
													call(
														ref-of-val
														[call(cond-attr, [call(ref-of-val, [local-ref(res)])])])])]))
								call(
									hard-assert-posix-error
									[
										call(
											pthread_condattr_setclock
											[
												call(
													ref-of-val
													[call(cond-attr, [call(ref-of-val, [local-ref(res)])])])
												call(CLOCK_MONOTONIC, [])])]))
							call(
								hard-assert-posix-error
								[
									call(
										pthread_cond_init
										[
											call(ref-of-val, [call(cond, [call(ref-of-val, [local-ref(res)])])])
											call(ref-of-val, [call(cond-attr, [call(ref-of-val, [local-ref(res)])])])])]))
						local-ref(res)))))
		fun(
			noctx
			new
			type(false, condition)
			none
			[
				param(mutex-attr, type(false, pthread_mutexattr_t))
				param(mutex, type(false, pthread_mutex_t))
				param(cond-attr, type(false, pthread_condattr_t))
				param(cond, type(false, pthread_cond_t))
				param(sequence, type(false, nat64))]
			new-record)
		fun(noctx, zeroed, type(false, pthread_mutex_t), none, [], builtin([type(false, pthread_mutex_t)]))
		fun(noctx, zeroed, type(false, pthread_condattr_t), none, [], builtin([type(false, pthread_condattr_t)]))
		fun(noctx, zeroed, type(false, pthread_cond_t), none, [], builtin([type(false, pthread_cond_t)]))
		fun(
			noctx
			pthread_mutexattr_init
			type(false, int32)
			none
			[param(attr, type(true, pthread_mutexattr_t))]
			extern)
		fun(noctx, mutex-attr, type(false, pthread_mutexattr_t), none, [param(a, type(true, condition))], field-get(0))
		fun(
			noctx
			ref-of-val
			type(true, condition)
			none
			[param(a, type(false, condition))]
			builtin([type(true, condition)]))
		fun(noctx, mutex, type(false, pthread_mutex_t), none, [param(a, type(true, condition))], field-get(1))
		fun(
			noctx
			pthread_condattr_init
			type(false, int32)
			none
			[param(attr, type(true, pthread_condattr_t))]
			extern)
		fun(
			noctx
			ref-of-val
			type(true, pthread_condattr_t)
			none
			[param(a, type(false, pthread_condattr_t))]
			builtin([type(true, pthread_condattr_t)]))
		fun(noctx, cond-attr, type(false, pthread_condattr_t), none, [param(a, type(true, condition))], field-get(2))
		fun(
			noctx
			pthread_condattr_setclock
			type(false, int32)
			none
			[param(attr, type(true, pthread_condattr_t)), param(clock-id, type(false, int32))]
			extern)
		fun(noctx, CLOCK_MONOTONIC, type(false, int32), none, [], expr-body(1))
		fun(
			noctx
			pthread_cond_init
			type(false, int32)
			none
			[param(cond, type(true, pthread_cond_t)), param(cond-attr, type(true, pthread_condattr_t))]
			extern)
		fun(
			noctx
			ref-of-val
			type(true, pthread_cond_t)
			none
			[param(a, type(false, pthread_cond_t))]
			builtin([type(true, pthread_cond_t)]))
		fun(noctx, cond, type(false, pthread_cond_t), none, [param(a, type(true, condition))], field-get(3))
		fun(
			noctx
			ref-of-val
			type(true, global-ctx)
			none
			[param(a, type(false, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(
			noctx
			island
			type(false, island)
			none
			[param(gctx, type(true, global-ctx)), param(id, type(false, nat64)), param(max-threads, type(false, nat64))]
			expr-body(
				let(
					q
					call(new, [param-ref(max-threads)])
					let(
						gc-root
						call(new, [local-ref(q), lambda(0, void), lambda(0, void)])
						call(
							new
							[
								param-ref(gctx)
								param-ref(id)
								call(gc, [])
								local-ref(gc-root)
								call(lock-by-val, [])
								0
								call(new, [])])))))
		fun(
			noctx
			new
			type(false, task-queue)
			none
			[param(max-threads, type(false, nat64))]
			expr-body(
				call(
					new
					[call(none, []), call(mut-arr-by-val-with-capacity-from-unmanaged-memory, [param-ref(max-threads)])])))
		fun(
			noctx
			new
			type(false, task-queue)
			none
			[param(head, type(false, opt)), param(currently-running-exclusions, type(false, mut-arr))]
			new-record)
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(
			noctx
			mut-arr-by-val-with-capacity-from-unmanaged-memory
			type(false, mut-arr)
			none
			[param(capacity, type(false, nat64))]
			expr-body(
				let(
					backing
					call(unmanaged-alloc-zeroed-elements, [param-ref(capacity)])
					call(new, [call(subscript, [local-ref(backing), call(.., [0, param-ref(capacity)])]), 0]))))
		fun(
			noctx
			unmanaged-alloc-zeroed-elements
			type(false, mut-ptr)
			none
			[param(size-elements, type(false, nat64))]
			expr-body(
				let(
					res
					call(unmanaged-alloc-elements, [param-ref(size-elements)])
					seq(call(set-zero-range, [local-ref(res), param-ref(size-elements)]), local-ref(res)))))
		fun(
			noctx
			unmanaged-alloc-elements
			type(false, mut-ptr)
			none
			[param(size-elements, type(false, nat64))]
			expr-body(
				call(
					ptr-cast
					[call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])])))
		fun(
			noctx
			unmanaged-alloc-bytes
			type(false, mut-ptr)
			none
			[param(size, type(false, nat64))]
			expr-body(
				let(
					res
					call(malloc, [param-ref(size)])
					seq(call(hard-assert, [call(!=, [local-ref(res), call(null, [])])]), local-ref(res)))))
		fun(noctx, malloc, type(false, mut-ptr), none, [param(size, type(false, nat64))], extern)
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, nat8)]))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(noctx, null, type(false, mut-ptr), none, [], builtin([type(false, nat8)]))
		fun(
			noctx
			wrap-mul
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			noctx
			set-zero-range
			type(false, void)
			none
			[param(begin, type(false, mut-ptr)), param(size, type(false, nat64))]
			expr-body(
				call(
					drop
					[
						call(
							memset
							[
								call(as-any-mut-ptr, [param-ref(begin)])
								0
								call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(noctx, drop, type(false, void), none, [param("_", type(false, mut-ptr))], expr-body(call(void, [])))
		fun(
			noctx
			memset
			type(false, mut-ptr)
			none
			[param(begin, type(false, mut-ptr)), param(value, type(false, int32)), param(size, type(false, nat64))]
			extern)
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(false, mut-ptr))]
			builtin([type(false, mut-ptr)]))
		fun(
			noctx
			new
			type(false, mut-arr)
			none
			[param(backing, type(false, fix-arr)), param(size, type(false, nat64))]
			new-record)
		fun(
			noctx
			subscript
			type(false, fix-arr)
			none
			[param(a, type(false, mut-ptr)), param(range, type(false, range))]
			expr-body(call(new, [call(subscript, [call(as-const, [param-ref(a)]), param-ref(range)])])))
		fun(noctx, new, type(false, fix-arr), none, [param(inner, type(false, arr))], new-record)
		fun(
			noctx
			subscript
			type(false, arr)
			none
			[param(a, type(false, const-ptr)), param(r, type(false, range))]
			expr-body(
				call(
					new
					[
						call(wrap-sub, [call(high, [param-ref(r)]), call(low, [param-ref(r)])])
						call(+, [param-ref(a), call(low, [param-ref(r)])])])))
		fun(
			noctx
			new
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, const-ptr))]
			new-record)
		fun(noctx, high, type(false, nat64), none, [param(a, type(false, range))], field-get(2))
		fun(noctx, low, type(false, nat64), none, [param(a, type(false, range))], field-get(1))
		fun(
			noctx
			+
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(offset, type(false, nat64))]
			expr-body(call(as-const, [call(+, [call(as-mut, [param-ref(a)]), param-ref(offset)])])))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, nat64)]))
		fun(
			noctx
			..
			type(false, range)
			none
			[param(low, type(false, nat64)), param(high, type(false, nat64))]
			expr-body(
				cond(
					call(<, [param-ref(low), param-ref(high)])
					call(new, [call(void, []), param-ref(low), param-ref(high)])
					call(new, [call(void, []), param-ref(high), param-ref(high)]))))
		fun(
			noctx
			new
			type(false, range)
			none
			[param(ignore, type(false, void)), param(low, type(false, nat64)), param(high, type(false, nat64))]
			new-record)
		fun(
			noctx
			new
			type(false, island-gc-root)
			none
			[
				param(tasks, type(false, task-queue))
				param(exception-handler, type(false, fun1))
				param(log-handler, type(false, fun1))]
			new-record)
		fun(
			ctx
			default-exception-handler
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				seq(
					seq(
						call(print-err-no-newline, [record([arr(0, 0)])])
						call(print-err, [call(to-str, [param-ref(e)])]))
					call(set-any-unhandled-exceptions, [call(get-global-ctx, []), call(true, [])]))))
		fun(
			noctx
			print-err-no-newline
			type(false, void)
			none
			[param(s, type(false, str))]
			expr-body(call(write-no-newline, [call(stderr, []), param-ref(s)])))
		fun(
			noctx
			write-no-newline
			type(false, void)
			none
			[param(fd, type(false, int32)), param(a, type(false, str))]
			expr-body(
				seq(
					call(hard-assert, [call(==, [call(size-of, []), call(size-of, [])])])
					let(
						res
						call(
							write
							[
								param-ref(fd)
								call(as-any-const-ptr, [call(begin-ptr, [call(chars, [param-ref(a)])])])
								call(size-bytes, [param-ref(a)])])
						cond(
							call(!=, [local-ref(res), call(unsafe-to-int64, [call(size-bytes, [param-ref(a)])])])
							call(todo, [])
							void)))))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, char)]))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, nat8)]))
		fun(
			noctx
			write
			type(false, int64)
			none
			[param(fd, type(false, int32)), param(buf, type(false, const-ptr)), param(n-bytes, type(false, nat64))]
			extern)
		fun(
			noctx
			as-any-const-ptr
			type(false, const-ptr)
			none
			[param(reference, type(false, const-ptr))]
			expr-body(call(as-const, [call(as-any-mut-ptr, [param-ref(reference)])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, nat8)]))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(false, const-ptr))]
			builtin([type(false, const-ptr)]))
		fun(noctx, begin-ptr, type(false, const-ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(noctx, chars, type(false, arr), none, [param(a, type(false, str))], field-get(0))
		fun(
			noctx
			size-bytes
			type(false, nat64)
			none
			[param(a, type(false, str))]
			expr-body(call(size, [call(chars, [param-ref(a)])])))
		fun(noctx, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			builtin([]))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(noctx, unsafe-to-int64, type(false, int64), none, [param(a, type(false, nat64))], builtin([]))
		fun(noctx, todo, type(false, void), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(noctx, zeroed, type(false, void), none, [], builtin([type(false, void)]))
		fun(noctx, stderr, type(false, int32), none, [], expr-body(2))
		fun(
			noctx
			print-err
			type(false, void)
			none
			[param(s, type(false, str))]
			expr-body(seq(call(print-err-no-newline, [param-ref(s)]), call(print-err-no-newline, [record([arr(0, 1)])]))))
		fun(
			ctx
			to-str
			type(false, str)
			none
			[param(a, type(false, exception))]
			expr-body(
				let(
					res
					call(new, [])
					seq(
						seq(
							call(
								~=
								[
									local-ref(res)
									cond(
										call(is-empty, [call(message, [param-ref(a)])])
										record([arr(0, 4)])
										call(message, [param-ref(a)]))])
							call(
								each
								[
									call(return-stack, [call(backtrace, [param-ref(a)])])
									lambda(0, alloc(record([local-ref(res)])))]))
						call(move-to-str!, [local-ref(res)])))))
		fun(ctx, new, type(false, writer), none, [], expr-body(call(new, [call(new, [create-arr(arr, [])])])))
		fun(ctx, new, type(false, writer), none, [param(chars, type(true, mut-arr))], new-record)
		fun(
			ctx
			new
			type(true, mut-arr)
			none
			[param(a, type(false, arr))]
			expr-body(call(to-mut-arr, [param-ref(a)])))
		fun(
			ctx
			to-mut-arr
			type(true, mut-arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				let(
					backing
					call(empty-fix-arr, [])
					let(
						res
						call(new, [local-ref(backing), 0])
						seq(call(~=, [local-ref(res), param-ref(a)]), local-ref(res))))))
		fun(
			noctx
			empty-fix-arr
			type(false, fix-arr)
			none
			[]
			expr-body(let(inner, call(empty-arr, []), call(new, [local-ref(inner)]))))
		fun(noctx, empty-arr, type(false, arr), none, [], expr-body(call(new, [0, call(null, [])])))
		fun(
			noctx
			new
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, const-ptr))]
			new-record)
		fun(noctx, null, type(false, const-ptr), none, [], expr-body(call(as-const, [call(null, [])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, char)]))
		fun(noctx, null, type(false, mut-ptr), none, [], builtin([type(false, char)]))
		fun(noctx, new, type(false, fix-arr), none, [param(inner, type(false, arr))], new-record)
		fun(
			ctx
			new
			type(true, mut-arr)
			none
			[param(backing, type(false, fix-arr)), param(size, type(false, nat64))]
			new-record)
		fun(
			ctx
			~=
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(values, type(false, arr))]
			expr-body(call(each, [param-ref(values), lambda(0, alloc(record([param-ref(a)])))])))
		fun(
			ctx
			each
			type(false, void)
			none
			[param(a, type(false, arr)), param(f, type(false, fun-act1))]
			expr-body(call(each-recur, [call(begin-ptr, [param-ref(a)]), call(end-ptr, [param-ref(a)]), param-ref(f)])))
		fun(
			ctx
			each-recur
			type(false, void)
			none
			[param(cur, type(false, const-ptr)), param(end, type(false, const-ptr)), param(f, type(false, fun-act1))]
			expr-body(
				cond(
					call(!=, [param-ref(cur), param-ref(end)])
					seq(
						call(subscript, [param-ref(f), call(*, [param-ref(cur)])])
						call(each-recur, [call(+, [param-ref(cur), 1]), param-ref(end), param-ref(f)]))
					void)))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(==, [call(as-mut, [param-ref(a)]), call(as-mut, [param-ref(b)])])))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, char)]))
		fun(noctx, as-mut, type(false, mut-ptr), none, [param(a, type(false, const-ptr))], builtin([type(false, char)]))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			ctx
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, char))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, char))]
			builtin([type(false, void), type(false, char)]))
		fun(ctx, get-ctx, type(true, ctx), none, [], builtin([]))
		fun(
			noctx
			*
			type(false, char)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(*, [call(as-mut, [param-ref(a)])])))
		fun(noctx, *, type(false, char), none, [param(a, type(false, mut-ptr))], builtin([type(false, char)]))
		fun(
			noctx
			+
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(offset, type(false, nat64))]
			expr-body(call(as-const, [call(+, [call(as-mut, [param-ref(a)]), param-ref(offset)])])))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, char)]))
		fun(
			noctx
			end-ptr
			type(false, const-ptr)
			none
			[param(a, type(false, arr))]
			expr-body(call(+, [call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])))
		fun(
			ctx
			~=
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, char))]
			expr-body(
				seq(
					seq(
						seq(
							call(incr-capacity!, [param-ref(a)])
							call(assert, [call(<, [call(size, [param-ref(a)]), call(capacity, [param-ref(a)])])]))
						call(
							set-subscript
							[call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)]), param-ref(value)]))
					call(set-size, [param-ref(a), call(+, [call(size, [param-ref(a)]), 1])]))))
		fun(
			ctx
			incr-capacity!
			type(false, void)
			none
			[param(a, type(true, mut-arr))]
			expr-body(
				call(
					ensure-capacity
					[param-ref(a), call(round-up-to-power-of-two, [call(+, [call(size, [param-ref(a)]), 1])])])))
		fun(
			ctx
			ensure-capacity
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(min-capacity, type(false, nat64))]
			expr-body(
				cond(
					call(<, [call(capacity, [param-ref(a)]), param-ref(min-capacity)])
					call(increase-capacity-to!, [param-ref(a), param-ref(min-capacity)])
					void)))
		fun(
			noctx
			capacity
			type(false, nat64)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(size, [call(backing, [param-ref(a)])])))
		fun(
			noctx
			size
			type(false, nat64)
			none
			[param(a, type(false, fix-arr))]
			expr-body(call(size, [call(inner, [param-ref(a)])])))
		fun(noctx, inner, type(false, arr), none, [param(a, type(false, fix-arr))], field-get(0))
		fun(noctx, backing, type(false, fix-arr), none, [param(a, type(true, mut-arr))], field-get(0))
		fun(
			ctx
			increase-capacity-to!
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(new-capacity, type(false, nat64))]
			expr-body(
				seq(
					call(assert, [call(>, [param-ref(new-capacity), call(capacity, [param-ref(a)])])])
					let(
						old-begin
						call(begin-ptr, [param-ref(a)])
						seq(
							seq(
								call(
									set-backing
									[param-ref(a), call(uninitialized-fix-arr, [param-ref(new-capacity)])])
								call(
									copy-data-from!
									[
										call(begin-ptr, [param-ref(a)])
										call(as-const, [local-ref(old-begin)])
										call(size, [param-ref(a)])]))
							call(
								set-zero-elements
								[
									call(
										subscript
										[
											call(backing, [param-ref(a)])
											call(
												..
												[
													call(+, [call(size, [param-ref(a)]), 1])
													call(size, [call(backing, [param-ref(a)])])])])]))))))
		fun(
			ctx
			assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(call(!, [param-ref(condition)]), call(throw, [record([arr(0, 2)])]), void)))
		fun(
			ctx
			throw
			type(false, void)
			none
			[param(message, type(false, str))]
			expr-body(call(throw, [call(new, [param-ref(message), call(get-backtrace, [])])])))
		fun(
			ctx
			throw
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				let(
					exn-ctx
					call(get-exception-ctx, [])
					seq(
						seq(
							seq(
								call(hard-assert, [call(!=, [call(jmp-buf-ptr, [local-ref(exn-ctx)]), call(null, [])])])
								call(set-thrown-exception, [local-ref(exn-ctx), param-ref(e)]))
							call(longjmp, [call(jmp-buf-ptr, [local-ref(exn-ctx)]), call(number-to-throw, [])]))
						call(hard-unreachable, [])))))
		fun(
			ctx
			get-exception-ctx
			type(true, exception-ctx)
			none
			[]
			expr-body(call(as-ref, [call(exception-ctx-ptr, [call(thread-local-stuff, [call(get-ctx, [])])])])))
		fun(
			noctx
			as-ref
			type(true, exception-ctx)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(true, exception-ctx)]))
		fun(
			noctx
			exception-ctx-ptr
			type(false, mut-ptr)
			none
			[param(a, type(true, thread-local-stuff))]
			field-get(2))
		fun(noctx, thread-local-stuff, type(true, thread-local-stuff), none, [param(a, type(true, ctx))], field-get(4))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, __jmp_buf_tag)]))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(noctx, jmp-buf-ptr, type(false, mut-ptr), none, [param(a, type(true, exception-ctx))], field-get(0))
		fun(noctx, null, type(false, mut-ptr), none, [], builtin([type(false, __jmp_buf_tag)]))
		fun(
			noctx
			set-thrown-exception
			type(false, void)
			none
			[param(a, type(true, exception-ctx)), param(thrown-exception, type(false, exception))]
			field-set(1))
		fun(
			noctx
			longjmp
			type(false, void)
			none
			[param(env, type(false, mut-ptr)), param(val, type(false, int32))]
			extern)
		fun(ctx, number-to-throw, type(false, int32), none, [], expr-body(7))
		fun(noctx, hard-unreachable, type(false, void), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(
			noctx
			new
			type(false, exception)
			none
			[param(message, type(false, str)), param(backtrace, type(false, backtrace))]
			new-record)
		fun(
			ctx
			get-backtrace
			type(false, backtrace)
			none
			[]
			expr-body(
				match-union(
					call(try-alloc-backtrace-arrs, [])
					[
						case(none, call(new, [call(new, [create-arr(arr, [])])]))
						case(
							some(arrs)
							let(
								n-code-ptrs
								call(backtrace-and-get-n-code-ptrs, [local-ref(arrs)])
								seq(
									call(hard-assert, [call(<=, [local-ref(n-code-ptrs), call(code-ptrs-size, [])])])
									call(fill-arrs, [local-ref(arrs), local-ref(n-code-ptrs)]))))])))
		fun(
			ctx
			try-alloc-backtrace-arrs
			type(false, opt)
			none
			[]
			expr-body(
				match-union(
					call(try-alloc-uninitialized, [8])
					[
						case(none, call(none, []))
						case(
							some(code-ptrs)
							match-union(
								call(try-alloc-uninitialized, [8])
								[
									case(none, call(none, []))
									case(
										some(code-names)
										match-union(
											call(try-alloc-uninitialized, [call(size, [call(all-funs, [])])])
											[
												case(none, call(none, []))
												case(
													some(funs)
													call(
														some
														[
															call(
																new
																[
																	local-ref(code-ptrs)
																	local-ref(code-names)
																	local-ref(funs)])]))]))]))])))
		fun(
			ctx
			try-alloc-uninitialized
			type(false, opt)
			none
			[param(size, type(false, nat64))]
			expr-body(
				match-union(
					call(try-alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					[case(none, call(none, [])), case(some(res), call(some, [call(ptr-cast, [local-ref(res)])]))])))
		fun(
			ctx
			try-alloc
			type(false, opt)
			none
			[param(size-bytes, type(false, nat64))]
			expr-body(call(try-gc-alloc, [call(get-gc, []), param-ref(size-bytes)])))
		fun(
			noctx
			try-gc-alloc
			type(false, opt)
			none
			[param(gc, type(true, gc)), param(size-bytes, type(false, nat64))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gc)])])])
					let(
						res
						call(try-gc-alloc-recur, [param-ref(gc), param-ref(size-bytes)])
						seq(
							seq(
								call(maybe-set-needs-gc!, [param-ref(gc)])
								call(release!, [call(ref-of-val, [call(lk, [param-ref(gc)])])]))
							local-ref(res))))))
		fun(
			noctx
			acquire!
			type(false, void)
			none
			[param(a, type(true, lock))]
			expr-body(
				call(
					hard-assert-posix-error
					[call(pthread_mutex_lock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])))
		fun(noctx, pthread_mutex_lock, type(false, int32), none, [param(mutex, type(true, pthread_mutex_t))], extern)
		fun(noctx, lk, type(false, lock), none, [param(a, type(true, gc))], field-get(0))
		fun(
			noctx
			try-gc-alloc-recur
			type(false, opt)
			none
			[param(gc, type(true, gc)), param(size-bytes, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(size-bytes), 16777216])])
					let(
						size-words
						call(words-of-bytes, [param-ref(size-bytes)])
						let(
							cur
							call(data-cur, [param-ref(gc)])
							let(
								next
								call(+, [local-ref(cur), local-ref(size-words)])
								cond(
									call(<, [local-ref(next), call(data-end, [param-ref(gc)])])
									cond(
										call(
											range-free
											[
												call(mark-cur, [param-ref(gc)])
												call(+, [call(mark-cur, [param-ref(gc)]), local-ref(size-words)])])
										seq(
											seq(
												call(
													set-mark-cur
													[
														param-ref(gc)
														call(
															+
															[call(mark-cur, [param-ref(gc)]), local-ref(size-words)])])
												call(set-data-cur, [param-ref(gc), local-ref(next)]))
											call(some, [call(ptr-cast, [local-ref(cur)])]))
										seq(
											seq(
												call(
													set-mark-cur
													[param-ref(gc), call(+, [call(mark-cur, [param-ref(gc)]), 1])])
												call(
													set-data-cur
													[param-ref(gc), call(+, [call(data-cur, [param-ref(gc)]), 1])]))
											call(try-gc-alloc-recur, [param-ref(gc), param-ref(size-bytes)])))
									call(none, []))))))))
		fun(noctx, data-cur, type(false, mut-ptr), none, [param(a, type(true, gc))], field-get(9))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, nat64)]))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				cond(
					call(is-less, [param-ref(a), param-ref(b)])
					call(less, [])
					cond(call(==, [param-ref(a), param-ref(b)]), call(equal, []), call(greater, [])))))
		fun(
			noctx
			is-less
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, nat64)]))
		fun(
			noctx
			<
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				match-enum(call(<=>, [param-ref(a), param-ref(b)]), [call(true, []), call(false, []), call(false, [])])))
		fun(noctx, data-end, type(false, mut-ptr), none, [param(a, type(true, gc))], field-get(10))
		fun(
			noctx
			range-free
			type(false, bool)
			none
			[param(mark, type(false, mut-ptr)), param(end, type(false, mut-ptr))]
			expr-body(
				cond(
					call(==, [param-ref(mark), param-ref(end)])
					call(true, [])
					cond(
						call(*, [param-ref(mark)])
						call(false, [])
						call(range-free, [call(+, [param-ref(mark), 1]), param-ref(end)])))))
		fun(noctx, mark-cur, type(false, mut-ptr), none, [param(a, type(true, gc))], field-get(6))
		fun(
			noctx
			set-mark-cur
			type(false, void)
			none
			[param(a, type(true, gc)), param(mark-cur, type(false, mut-ptr))]
			field-set(6))
		fun(
			noctx
			set-data-cur
			type(false, void)
			none
			[param(a, type(true, gc)), param(data-cur, type(false, mut-ptr))]
			field-set(9))
		fun(noctx, some, type(false, opt), none, [param(a, type(false, mut-ptr))], new-union)
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, nat8), type(false, nat64)]))
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(
			noctx
			maybe-set-needs-gc!
			type(false, void)
			none
			[param(gc, type(true, gc))]
			expr-body(
				let(
					cur-word
					call(-, [call(mark-cur, [param-ref(gc)]), call(mark-begin, [param-ref(gc)])])
					cond(
						call(>, [local-ref(cur-word), call(unsafe-div, [call(size-words, [param-ref(gc)]), 2])])
						call(set-needs-gc, [param-ref(gc), call(true, [])])
						void))))
		fun(
			noctx
			-
			type(false, nat64)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				call(
					unsafe-div
					[
						call(wrap-sub, [call(to-nat64, [param-ref(a)]), call(to-nat64, [param-ref(b)])])
						call(size-of, [])])))
		fun(noctx, to-nat64, type(false, nat64), none, [param(a, type(false, mut-ptr))], builtin([type(false, bool)]))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, bool)]))
		fun(noctx, mark-begin, type(false, mut-ptr), none, [param(a, type(true, gc))], field-get(5))
		fun(noctx, size-words, type(false, nat64), none, [param(a, type(true, gc))], field-get(4))
		fun(
			noctx
			set-needs-gc
			type(false, void)
			none
			[param(a, type(true, gc)), param(needs-gc, type(false, bool))]
			field-set(3))
		fun(
			noctx
			release!
			type(false, void)
			none
			[param(a, type(true, lock))]
			expr-body(
				call(
					hard-assert-posix-error
					[call(pthread_mutex_unlock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])))
		fun(noctx, pthread_mutex_unlock, type(false, int32), none, [param(mutex, type(true, pthread_mutex_t))], extern)
		fun(ctx, get-gc, type(true, gc), none, [], expr-body(call(gc, [call(get-gc-ctx, [])])))
		fun(noctx, gc, type(true, gc), none, [param(a, type(true, gc-ctx))], field-get(0))
		fun(
			ctx
			get-gc-ctx
			type(true, gc-ctx)
			none
			[]
			expr-body(call(as-ref, [call(gc-ctx-ptr, [call(get-ctx, [])])])))
		fun(noctx, as-ref, type(true, gc-ctx), none, [param(a, type(false, mut-ptr))], builtin([type(true, gc-ctx)]))
		fun(noctx, gc-ctx-ptr, type(false, mut-ptr), none, [param(a, type(true, ctx))], field-get(3))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, const-ptr)]))
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(noctx, some, type(false, opt), none, [param(a, type(false, mut-ptr))], new-union)
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, const-ptr), type(false, nat8)]))
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(
			ctx
			try-alloc-uninitialized
			type(false, opt)
			none
			[param(size, type(false, nat64))]
			expr-body(
				match-union(
					call(try-alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					[case(none, call(none, [])), case(some(res), call(some, [call(ptr-cast, [local-ref(res)])]))])))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, sym)]))
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(noctx, some, type(false, opt), none, [param(a, type(false, mut-ptr))], new-union)
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, sym), type(false, nat8)]))
		fun(
			ctx
			try-alloc-uninitialized
			type(false, opt)
			none
			[param(size, type(false, nat64))]
			expr-body(
				match-union(
					call(try-alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					[case(none, call(none, [])), case(some(res), call(some, [call(ptr-cast, [local-ref(res)])]))])))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, named-val)]))
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(noctx, some, type(false, opt), none, [param(a, type(false, mut-ptr))], new-union)
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, named-val), type(false, nat8)]))
		fun(noctx, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(noctx, all-funs, type(false, arr), none, [], builtin([]))
		fun(noctx, some, type(false, opt), none, [param(a, type(true, backtrace-arrs))], new-union)
		fun(
			ctx
			new
			type(true, backtrace-arrs)
			none
			[
				param(code-ptrs, type(false, mut-ptr))
				param(code-names, type(false, mut-ptr))
				param(funs, type(false, mut-ptr))]
			new-record)
		fun(noctx, new, type(false, backtrace), none, [param(return-stack, type(false, arr))], new-record)
		fun(noctx, new, type(false, arr), none, [param(a, type(false, arr))], expr-body(param-ref(a)))
		fun(
			ctx
			backtrace-and-get-n-code-ptrs
			type(false, nat64)
			none
			[param(arrs, type(true, backtrace-arrs))]
			expr-body(
				call(
					int32-to-nat64
					[
						call(
							backtrace
							[call(code-ptrs, [param-ref(arrs)]), call(nat64-to-int32, [call(code-ptrs-size, [])])])])))
		fun(
			ctx
			int32-to-nat64
			type(false, nat64)
			none
			[param(a, type(false, int32))]
			expr-body(call(unsafe-to-nat64, [call(to-int64, [param-ref(a)])])))
		fun(noctx, unsafe-to-nat64, type(false, nat64), none, [param(a, type(false, int64))], builtin([]))
		fun(noctx, to-int64, type(false, int64), none, [param(i, type(false, int32))], builtin([]))
		fun(
			noctx
			backtrace
			type(false, int32)
			none
			[param(array, type(false, mut-ptr)), param(size, type(false, int32))]
			extern)
		fun(noctx, code-ptrs, type(false, mut-ptr), none, [param(a, type(true, backtrace-arrs))], field-get(0))
		fun(
			ctx
			nat64-to-int32
			type(false, int32)
			none
			[param(a, type(false, nat64))]
			expr-body(call(unsafe-to-int32, [call(nat64-to-int64, [param-ref(a)])])))
		fun(noctx, unsafe-to-int32, type(false, int32), none, [param(a, type(false, int64))], builtin([]))
		fun(
			ctx
			nat64-to-int64
			type(false, int64)
			none
			[param(a, type(false, nat64))]
			expr-body(call(unsafe-to-int64, [param-ref(a)])))
		fun(ctx, code-ptrs-size, type(false, nat64), none, [], expr-body(8))
		fun(
			ctx
			fill-arrs
			type(false, backtrace)
			none
			[param(arrs, type(true, backtrace-arrs)), param(n-code-ptrs, type(false, nat64))]
			expr-body(
				seq(
					seq(
						call(
							copy-data-from!
							[
								call(funs, [param-ref(arrs)])
								call(begin-ptr, [call(all-funs, [])])
								call(size, [call(all-funs, [])])])
						call(sort!, [call(funs, [param-ref(arrs)]), call(size, [call(all-funs, [])])]))
					let(
						end-code-names
						call(+, [call(code-names, [param-ref(arrs)]), param-ref(n-code-ptrs)])
						seq(
							call(
								fill-code-names!
								[
									call(code-names, [param-ref(arrs)])
									local-ref(end-code-names)
									call(as-const, [call(code-ptrs, [param-ref(arrs)])])
									call(as-const, [call(funs, [param-ref(arrs)])])])
							call(
								new
								[
									call(
										subscript
										[
											call(as-const, [call(code-names, [param-ref(arrs)])])
											call(.., [0, param-ref(n-code-ptrs)])])]))))))
		fun(
			ctx
			copy-data-from!
			type(false, void)
			none
			[param(to, type(false, mut-ptr)), param(from, type(false, const-ptr)), param(len, type(false, nat64))]
			expr-body(
				call(
					drop
					[
						call(
							memcpy
							[
								call(as-any-mut-ptr, [param-ref(to)])
								call(as-any-const-ptr, [param-ref(from)])
								call(wrap-mul, [param-ref(len), call(size-of, [])])])])))
		fun(
			noctx
			memcpy
			type(false, mut-ptr)
			none
			[param(dest, type(false, mut-ptr)), param(src, type(false, const-ptr)), param(size, type(false, nat64))]
			extern)
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(false, mut-ptr))]
			builtin([type(false, mut-ptr)]))
		fun(
			noctx
			as-any-const-ptr
			type(false, const-ptr)
			none
			[param(reference, type(false, const-ptr))]
			expr-body(call(as-const, [call(as-any-mut-ptr, [param-ref(reference)])])))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(false, const-ptr))]
			builtin([type(false, const-ptr)]))
		fun(noctx, funs, type(false, mut-ptr), none, [param(a, type(true, backtrace-arrs))], field-get(2))
		fun(noctx, begin-ptr, type(false, const-ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			noctx
			sort!
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(size, type(false, nat64))]
			expr-body(
				cond(
					call(>, [param-ref(size), 1])
					seq(
						call(swap!, [param-ref(a), 0, call(unsafe-div, [param-ref(size), 2])])
						let(
							after-pivot
							call(
								partition!
								[
									param-ref(a)
									call(val, [call(*, [param-ref(a)])])
									1
									call(wrap-sub, [param-ref(size), 1])])
							let(
								new-pivot-index
								call(wrap-sub, [local-ref(after-pivot), 1])
								seq(
									seq(
										call(swap!, [param-ref(a), 0, local-ref(new-pivot-index)])
										call(sort!, [param-ref(a), local-ref(new-pivot-index)]))
									call(
										sort!
										[
											call(+, [param-ref(a), local-ref(after-pivot)])
											call(wrap-sub, [param-ref(size), local-ref(after-pivot)])])))))
					void)))
		fun(
			noctx
			swap!
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(lo, type(false, nat64)), param(hi, type(false, nat64))]
			expr-body(
				let(
					temp
					call(subscript, [param-ref(a), param-ref(lo)])
					seq(
						call(
							set-subscript
							[param-ref(a), param-ref(lo), call(subscript, [param-ref(a), param-ref(hi)])])
						call(set-subscript, [param-ref(a), param-ref(hi), local-ref(temp)])))))
		fun(
			noctx
			subscript
			type(false, named-val)
			none
			[param(a, type(false, mut-ptr)), param(n, type(false, nat64))]
			expr-body(call(*, [call(+, [param-ref(a), param-ref(n)])])))
		fun(noctx, *, type(false, named-val), none, [param(a, type(false, mut-ptr))], builtin([type(false, named-val)]))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, named-val)]))
		fun(
			noctx
			set-subscript
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(n, type(false, nat64)), param(value, type(false, named-val))]
			expr-body(call(set-deref, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			noctx
			set-deref
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(value, type(false, named-val))]
			builtin([type(false, named-val)]))
		fun(
			noctx
			partition!
			type(false, nat64)
			none
			[
				param(a, type(false, mut-ptr))
				param(pivot, type(false, const-ptr))
				param(l, type(false, nat64))
				param(r, type(false, nat64))]
			expr-body(
				cond(
					call(<=, [param-ref(l), param-ref(r)])
					cond(
						call(<, [call(val, [call(subscript, [param-ref(a), param-ref(l)])]), param-ref(pivot)])
						call(
							partition!
							[param-ref(a), param-ref(pivot), call(wrap-add, [param-ref(l), 1]), param-ref(r)])
						seq(
							call(swap!, [param-ref(a), param-ref(l), param-ref(r)])
							call(
								partition!
								[param-ref(a), param-ref(pivot), param-ref(l), call(wrap-sub, [param-ref(r), 1])])))
					param-ref(l))))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(==, [call(as-mut, [param-ref(a)]), call(as-mut, [param-ref(b)])])))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(<=>, [call(as-mut, [param-ref(a)]), call(as-mut, [param-ref(b)])])))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				cond(
					call(is-less, [param-ref(a), param-ref(b)])
					call(less, [])
					cond(call(==, [param-ref(a), param-ref(b)]), call(equal, []), call(greater, [])))))
		fun(
			noctx
			is-less
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, nat8)]))
		fun(
			noctx
			<
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(
				match-enum(call(<=>, [param-ref(a), param-ref(b)]), [call(true, []), call(false, []), call(false, [])])))
		fun(noctx, val, type(false, const-ptr), none, [param(a, type(false, named-val))], field-get(1))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, sym)]))
		fun(noctx, code-names, type(false, mut-ptr), none, [param(a, type(true, backtrace-arrs))], field-get(1))
		fun(
			ctx
			fill-code-names!
			type(false, void)
			none
			[
				param(code-names, type(false, mut-ptr))
				param(end-code-names, type(false, mut-ptr))
				param(code-ptrs, type(false, const-ptr))
				param(funs, type(false, const-ptr))]
			expr-body(
				cond(
					call(<, [param-ref(code-names), param-ref(end-code-names)])
					seq(
						call(
							set-deref
							[
								param-ref(code-names)
								call(
									get-fun-name
									[call(*, [param-ref(code-ptrs)]), param-ref(funs), call(size, [call(all-funs, [])])])])
						call(
							fill-code-names!
							[
								call(+, [param-ref(code-names), 1])
								param-ref(end-code-names)
								call(+, [param-ref(code-ptrs), 1])
								param-ref(funs)]))
					void)))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, sym)]))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				cond(
					call(is-less, [param-ref(a), param-ref(b)])
					call(less, [])
					cond(call(==, [param-ref(a), param-ref(b)]), call(equal, []), call(greater, [])))))
		fun(
			noctx
			is-less
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, sym)]))
		fun(
			noctx
			<
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				match-enum(call(<=>, [param-ref(a), param-ref(b)]), [call(true, []), call(false, []), call(false, [])])))
		fun(
			noctx
			set-deref
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(value, type(false, sym))]
			builtin([type(false, sym)]))
		fun(
			noctx
			get-fun-name
			type(false, sym)
			none
			[
				param(code-ptr, type(false, const-ptr))
				param(funs, type(false, const-ptr))
				param(size, type(false, nat64))]
			expr-body(
				cond(
					call(<, [param-ref(size), 2])
					record([c-str(0)])
					cond(
						call(<, [param-ref(code-ptr), call(val, [call(subscript, [param-ref(funs), 1])])])
						call(name, [call(*, [param-ref(funs)])])
						call(
							get-fun-name
							[param-ref(code-ptr), call(+, [param-ref(funs), 1]), call(wrap-sub, [param-ref(size), 1])])))))
		fun(
			noctx
			subscript
			type(false, named-val)
			none
			[param(a, type(false, const-ptr)), param(n, type(false, nat64))]
			expr-body(call(*, [call(+, [param-ref(a), param-ref(n)])])))
		fun(
			noctx
			*
			type(false, named-val)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(*, [call(as-mut, [param-ref(a)])])))
		fun(
			noctx
			as-mut
			type(false, mut-ptr)
			none
			[param(a, type(false, const-ptr))]
			builtin([type(false, named-val)]))
		fun(
			noctx
			+
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(offset, type(false, nat64))]
			expr-body(call(as-const, [call(+, [call(as-mut, [param-ref(a)]), param-ref(offset)])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, named-val)]))
		fun(noctx, name, type(false, sym), none, [param(a, type(false, named-val))], field-get(0))
		fun(
			noctx
			*
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(*, [call(as-mut, [param-ref(a)])])))
		fun(noctx, *, type(false, const-ptr), none, [param(a, type(false, mut-ptr))], builtin([type(false, const-ptr)]))
		fun(
			noctx
			as-mut
			type(false, mut-ptr)
			none
			[param(a, type(false, const-ptr))]
			builtin([type(false, const-ptr)]))
		fun(
			noctx
			+
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(offset, type(false, nat64))]
			expr-body(call(as-const, [call(+, [call(as-mut, [param-ref(a)]), param-ref(offset)])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, const-ptr)]))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, const-ptr)]))
		fun(
			noctx
			subscript
			type(false, arr)
			none
			[param(a, type(false, const-ptr)), param(r, type(false, range))]
			expr-body(
				call(
					new
					[
						call(wrap-sub, [call(high, [param-ref(r)]), call(low, [param-ref(r)])])
						call(+, [param-ref(a), call(low, [param-ref(r)])])])))
		fun(
			noctx
			new
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, const-ptr))]
			new-record)
		fun(
			noctx
			+
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(offset, type(false, nat64))]
			expr-body(call(as-const, [call(+, [call(as-mut, [param-ref(a)]), param-ref(offset)])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, sym)]))
		fun(noctx, as-mut, type(false, mut-ptr), none, [param(a, type(false, const-ptr))], builtin([type(false, sym)]))
		fun(
			noctx
			begin-ptr
			type(false, mut-ptr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(begin-ptr, [call(backing, [param-ref(a)])])))
		fun(
			noctx
			begin-ptr
			type(false, mut-ptr)
			none
			[param(a, type(false, fix-arr))]
			expr-body(call(as-mut, [call(begin-ptr, [call(inner, [param-ref(a)])])])))
		fun(
			noctx
			set-backing
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(backing, type(false, fix-arr))]
			field-set(0))
		fun(
			ctx
			uninitialized-fix-arr
			type(false, fix-arr)
			none
			[param(size, type(false, nat64))]
			expr-body(
				let(
					ptr
					call(alloc-uninitialized, [param-ref(size)])
					call(subscript, [local-ref(ptr), call(.., [0, param-ref(size)])]))))
		fun(
			ctx
			alloc-uninitialized
			type(false, mut-ptr)
			none
			[param(size, type(false, nat64))]
			expr-body(call(ptr-cast, [call(alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, char), type(false, nat8)]))
		fun(
			ctx
			alloc
			type(false, mut-ptr)
			none
			[param(size-bytes, type(false, nat64))]
			expr-body(call(gc-alloc, [call(get-gc, []), param-ref(size-bytes)])))
		fun(
			ctx
			gc-alloc
			type(false, mut-ptr)
			none
			[param(gc, type(true, gc)), param(size, type(false, nat64))]
			expr-body(
				match-union(
					call(try-gc-alloc, [param-ref(gc), param-ref(size)])
					[case(none, call(todo, [])), case(some(res), local-ref(res))])))
		fun(noctx, todo, type(false, mut-ptr), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(noctx, zeroed, type(false, mut-ptr), none, [], builtin([type(false, mut-ptr)]))
		fun(
			noctx
			subscript
			type(false, fix-arr)
			none
			[param(a, type(false, mut-ptr)), param(range, type(false, range))]
			expr-body(call(new, [call(subscript, [call(as-const, [param-ref(a)]), param-ref(range)])])))
		fun(
			noctx
			subscript
			type(false, arr)
			none
			[param(a, type(false, const-ptr)), param(r, type(false, range))]
			expr-body(
				call(
					new
					[
						call(wrap-sub, [call(high, [param-ref(r)]), call(low, [param-ref(r)])])
						call(+, [param-ref(a), call(low, [param-ref(r)])])])))
		fun(
			ctx
			copy-data-from!
			type(false, void)
			none
			[param(to, type(false, mut-ptr)), param(from, type(false, const-ptr)), param(len, type(false, nat64))]
			expr-body(
				call(
					drop
					[
						call(
							memcpy
							[
								call(as-any-mut-ptr, [param-ref(to)])
								call(as-any-const-ptr, [param-ref(from)])
								call(wrap-mul, [param-ref(len), call(size-of, [])])])])))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(false, mut-ptr))]
			builtin([type(false, mut-ptr)]))
		fun(noctx, size, type(false, nat64), none, [param(a, type(true, mut-arr))], field-get(1))
		fun(
			noctx
			set-zero-elements
			type(false, void)
			none
			[param(a, type(false, fix-arr))]
			expr-body(call(set-zero-range, [call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])))
		fun(
			noctx
			set-zero-range
			type(false, void)
			none
			[param(begin, type(false, mut-ptr)), param(size, type(false, nat64))]
			expr-body(
				call(
					drop
					[
						call(
							memset
							[
								call(as-any-mut-ptr, [param-ref(begin)])
								0
								call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(
			ctx
			subscript
			type(false, fix-arr)
			none
			[param(a, type(false, fix-arr)), param(range, type(false, range))]
			expr-body(call(new, [call(subscript, [call(inner, [param-ref(a)]), param-ref(range)])])))
		fun(
			ctx
			subscript
			type(false, arr)
			none
			[param(a, type(false, arr)), param(range, type(false, range))]
			expr-body(
				seq(
					call(hard-assert, [call(<=, [call(high, [param-ref(range)]), call(size, [param-ref(a)])])])
					call(
						new
						[
							call(wrap-sub, [call(high, [param-ref(range)]), call(low, [param-ref(range)])])
							call(+, [call(begin-ptr, [param-ref(a)]), call(low, [param-ref(range)])])]))))
		fun(
			ctx
			+
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				let(
					res
					call(wrap-add, [param-ref(a), param-ref(b)])
					seq(
						call(
							assert
							[
								call(
									&&
									[call(>=, [local-ref(res), param-ref(a)]), call(>=, [local-ref(res), param-ref(b)])])])
						local-ref(res)))))
		fun(noctx, &&, type(false, bool), none, [param(a, type(false, bool)), param(b, type(false, bool))], builtin([]))
		fun(
			noctx
			>=
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(!, [call(<, [param-ref(a), param-ref(b)])])))
		fun(
			ctx
			round-up-to-power-of-two
			type(false, nat64)
			none
			[param(n, type(false, nat64))]
			expr-body(call(round-up-to-power-of-two-recur, [1, param-ref(n)])))
		fun(
			ctx
			round-up-to-power-of-two-recur
			type(false, nat64)
			none
			[param(acc, type(false, nat64)), param(n, type(false, nat64))]
			expr-body(
				cond(
					call(>=, [param-ref(acc), param-ref(n)])
					param-ref(acc)
					call(round-up-to-power-of-two-recur, [call(*, [param-ref(acc), 2]), param-ref(n)]))))
		fun(
			ctx
			*
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				cond(
					call(||, [call(==, [param-ref(a), 0]), call(==, [param-ref(b), 0])])
					0
					let(
						res
						call(wrap-mul, [param-ref(a), param-ref(b)])
						seq(
							seq(
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(b)]), param-ref(a)])])
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(a)]), param-ref(b)])]))
							local-ref(res))))))
		fun(
			ctx
			/
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(seq(call(forbid, [call(==, [param-ref(b), 0])]), call(unsafe-div, [param-ref(a), param-ref(b)]))))
		fun(
			ctx
			forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(param-ref(condition), call(throw, [record([arr(0, 3)])]), void)))
		fun(
			noctx
			set-subscript
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(n, type(false, nat64)), param(value, type(false, char))]
			expr-body(call(set-deref, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			noctx
			set-deref
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(value, type(false, char))]
			builtin([type(false, char)]))
		fun(
			noctx
			set-size
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(size, type(false, nat64))]
			field-set(1))
		fun(
			ctx
			lambda(~=, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(~=, 0))))
			[param(x, type(false, char))]
			expr-body(call(~=, [get-field(param-ref("<<closure>>"), a), param-ref(x)])))
		fun(
			ctx
			~=
			type(false, void)
			none
			[param(a, type(false, writer)), param(b, type(false, str))]
			expr-body(call(~=, [call(chars, [param-ref(a)]), call(chars, [param-ref(b)])])))
		fun(noctx, chars, type(true, mut-arr), none, [param(a, type(false, writer))], field-get(0))
		fun(
			noctx
			is-empty
			type(false, bool)
			none
			[param(a, type(false, str))]
			expr-body(call(is-empty, [call(chars, [param-ref(a)])])))
		fun(
			noctx
			is-empty
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body(call(==, [call(size, [param-ref(a)]), 0])))
		fun(noctx, message, type(false, str), none, [param(a, type(false, exception))], field-get(0))
		fun(
			ctx
			each
			type(false, void)
			none
			[param(a, type(false, arr)), param(f, type(false, fun-act1))]
			expr-body(call(each-recur, [call(begin-ptr, [param-ref(a)]), call(end-ptr, [param-ref(a)]), param-ref(f)])))
		fun(
			ctx
			each-recur
			type(false, void)
			none
			[param(cur, type(false, const-ptr)), param(end, type(false, const-ptr)), param(f, type(false, fun-act1))]
			expr-body(
				cond(
					call(!=, [param-ref(cur), param-ref(end)])
					seq(
						call(subscript, [param-ref(f), call(*, [param-ref(cur)])])
						call(each-recur, [call(+, [param-ref(cur), 1]), param-ref(end), param-ref(f)]))
					void)))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(==, [call(as-mut, [param-ref(a)]), call(as-mut, [param-ref(b)])])))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			ctx
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, sym))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, sym))]
			builtin([type(false, void), type(false, sym)]))
		fun(
			noctx
			*
			type(false, sym)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(*, [call(as-mut, [param-ref(a)])])))
		fun(noctx, *, type(false, sym), none, [param(a, type(false, mut-ptr))], builtin([type(false, sym)]))
		fun(noctx, begin-ptr, type(false, const-ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			noctx
			end-ptr
			type(false, const-ptr)
			none
			[param(a, type(false, arr))]
			expr-body(call(+, [call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])))
		fun(noctx, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(noctx, return-stack, type(false, arr), none, [param(a, type(false, backtrace))], field-get(0))
		fun(noctx, backtrace, type(false, backtrace), none, [param(a, type(false, exception))], field-get(1))
		fun(
			ctx
			~=
			type(false, void)
			none
			[param(a, type(false, writer)), param(b, type(false, const-ptr))]
			expr-body(call(~=, [param-ref(a), call(to-str, [param-ref(b)])])))
		fun(
			noctx
			to-str
			type(false, str)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(str, [call(arr-from-begin-end, [param-ref(a), call(find-cstr-end, [param-ref(a)])])])))
		fun(noctx, str, type(false, str), none, [param(a, type(false, arr))], expr-body(call(new, [param-ref(a)])))
		fun(noctx, new, type(false, str), none, [param(chars, type(false, arr))], new-record)
		fun(
			noctx
			arr-from-begin-end
			type(false, arr)
			none
			[param(begin, type(false, const-ptr)), param(end, type(false, const-ptr))]
			expr-body(
				seq(
					call(hard-assert, [call(<=, [param-ref(begin), param-ref(end)])])
					call(new, [call(-, [param-ref(end), param-ref(begin)]), param-ref(begin)]))))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(<=>, [call(as-mut, [param-ref(a)]), call(as-mut, [param-ref(b)])])))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				cond(
					call(is-less, [param-ref(a), param-ref(b)])
					call(less, [])
					cond(call(==, [param-ref(a), param-ref(b)]), call(equal, []), call(greater, [])))))
		fun(
			noctx
			is-less
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, char)]))
		fun(
			noctx
			<=
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			noctx
			<
			type(false, bool)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(
				match-enum(call(<=>, [param-ref(a), param-ref(b)]), [call(true, []), call(false, []), call(false, [])])))
		fun(
			noctx
			-
			type(false, nat64)
			none
			[param(a, type(false, const-ptr)), param(b, type(false, const-ptr))]
			expr-body(call(-, [call(as-mut, [param-ref(a)]), call(as-mut, [param-ref(b)])])))
		fun(
			noctx
			-
			type(false, nat64)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				call(
					unsafe-div
					[
						call(wrap-sub, [call(to-nat64, [param-ref(a)]), call(to-nat64, [param-ref(b)])])
						call(size-of, [])])))
		fun(noctx, to-nat64, type(false, nat64), none, [param(a, type(false, mut-ptr))], builtin([type(false, char)]))
		fun(
			noctx
			find-cstr-end
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr))]
			expr-body(
				match-union(
					call(find-char-in-cstr, [param-ref(a), 0])
					[case(none, call(hard-unreachable, [])), case(some(v), local-ref(v))])))
		fun(
			noctx
			find-char-in-cstr
			type(false, opt)
			none
			[param(a, type(false, const-ptr)), param(c, type(false, char))]
			expr-body(
				cond(
					call(==, [call(*, [param-ref(a)]), param-ref(c)])
					call(some, [param-ref(a)])
					cond(
						call(==, [call(*, [param-ref(a)]), 0])
						call(none, [])
						call(find-char-in-cstr, [call(+, [param-ref(a), 1]), param-ref(c)])))))
		fun(
			noctx
			==
			type(false, bool)
			none
			[param(a, type(false, char)), param(b, type(false, char))]
			expr-body(call(==, [call(to-nat8, [param-ref(a)]), call(to-nat8, [param-ref(b)])])))
		fun(noctx, ==, type(false, bool), none, [param(a, type(false, nat8)), param(b, type(false, nat8))], builtin([]))
		fun(noctx, to-nat8, type(false, nat8), none, [param(c, type(false, char))], builtin([]))
		fun(noctx, some, type(false, opt), none, [param(a, type(false, const-ptr))], new-union)
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(
			noctx
			hard-unreachable
			type(false, const-ptr)
			none
			[]
			expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(noctx, zeroed, type(false, const-ptr), none, [], builtin([type(false, const-ptr)]))
		fun(noctx, to-c-str, type(false, const-ptr), none, [param(a, type(false, sym))], field-get(0))
		fun(
			ctx
			lambda(to-str, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(to-str, 0))))
			[param(x, type(false, sym))]
			expr-body(
				seq(
					call(~=, [get-field(param-ref("<<closure>>"), res), record([arr(0, 5)])])
					call(~=, [get-field(param-ref("<<closure>>"), res), call(to-c-str, [param-ref(x)])]))))
		fun(
			ctx
			move-to-str!
			type(false, str)
			none
			[param(a, type(false, writer))]
			expr-body(call(str, [call(move-to-arr!, [call(chars, [param-ref(a)])])])))
		fun(
			noctx
			move-to-arr!
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(cast-immutable, [call(move-to-fix-arr!, [param-ref(a)])])))
		fun(
			noctx
			cast-immutable
			type(false, arr)
			none
			[param(a, type(false, fix-arr))]
			expr-body(call(inner, [param-ref(a)])))
		fun(
			noctx
			move-to-fix-arr!
			type(false, fix-arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(
				let(
					res
					call(subscript, [call(begin-ptr, [param-ref(a)]), call(.., [0, call(size, [param-ref(a)])])])
					seq(
						seq(
							call(set-backing, [param-ref(a), call(empty-fix-arr, [])])
							call(set-size, [param-ref(a), 0]))
						local-ref(res)))))
		fun(
			noctx
			set-any-unhandled-exceptions
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(any-unhandled-exceptions, type(false, bool))]
			field-set(8))
		fun(
			ctx
			get-global-ctx
			type(true, global-ctx)
			none
			[]
			expr-body(call(as-ref, [call(gctx-ptr, [call(get-ctx, [])])])))
		fun(
			noctx
			as-ref
			type(true, global-ctx)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(true, global-ctx)]))
		fun(noctx, gctx-ptr, type(false, mut-ptr), none, [param(a, type(true, ctx))], field-get(0))
		fun(
			ctx
			lambda(island, 0)
			type(false, void)
			some(param("<<closure>>", type(false, void)))
			[param(exn, type(false, exception))]
			expr-body(call(default-exception-handler, [param-ref(exn)])))
		fun(
			ctx
			default-log-handler
			type(false, void)
			none
			[param(a, type(true, logged))]
			expr-body(
				call(
					print
					[
						call(
							~
							[
								call(~, [call(to-str, [call(level, [param-ref(a)])]), record([arr(0, 9)])])
								call(message, [param-ref(a)])])])))
		fun(
			noctx
			print
			type(false, void)
			none
			[param(a, type(false, str))]
			expr-body(seq(call(print-no-newline, [param-ref(a)]), call(print-no-newline, [record([arr(0, 1)])]))))
		fun(
			noctx
			print-no-newline
			type(false, void)
			none
			[param(a, type(false, str))]
			expr-body(call(write-no-newline, [call(stdout, []), param-ref(a)])))
		fun(noctx, stdout, type(false, int32), none, [], expr-body(1))
		fun(
			ctx
			~
			type(false, str)
			none
			[param(a, type(false, str)), param(b, type(false, str))]
			expr-body(call(new, [call(~, [call(chars, [param-ref(a)]), call(chars, [param-ref(b)])])])))
		fun(
			ctx
			~
			type(false, arr)
			none
			[param(a, type(false, arr)), param(b, type(false, arr))]
			expr-body(
				let(
					res-size
					call(wrap-add, [call(size, [param-ref(a)]), call(size, [param-ref(b)])])
					let(
						res
						call(alloc-uninitialized, [local-ref(res-size)])
						seq(
							seq(
								call(
									copy-data-from!
									[local-ref(res), call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])
								call(
									copy-data-from!
									[
										call(+, [local-ref(res), call(size, [param-ref(a)])])
										call(begin-ptr, [param-ref(b)])
										call(size, [param-ref(b)])]))
							call(new, [local-ref(res-size), call(as-const, [local-ref(res)])]))))))
		fun(
			ctx
			to-str
			type(false, str)
			none
			[param(a, type(false, log-level))]
			expr-body(match-enum(param-ref(a), [record([arr(0, 6)]), record([arr(0, 7)]), record([arr(0, 8)])])))
		fun(noctx, level, type(false, log-level), none, [param(a, type(true, logged))], field-get(0))
		fun(noctx, message, type(false, str), none, [param(a, type(true, logged))], field-get(1))
		fun(
			ctx
			lambda(island, 1)
			type(false, void)
			some(param("<<closure>>", type(false, void)))
			[param(log, type(true, logged))]
			expr-body(call(default-log-handler, [param-ref(log)])))
		fun(
			noctx
			new
			type(false, island)
			none
			[
				param(gctx, type(true, global-ctx))
				param(id, type(false, nat64))
				param(gc, type(false, gc))
				param(gc-root, type(false, island-gc-root))
				param(tasks-lock, type(false, lock))
				param(n-threads-running, type(false, nat64))
				param(next-exclusion, type(false, thread-safe-counter))]
			new-record)
		fun(
			noctx
			gc
			type(false, gc)
			none
			[]
			expr-body(
				let(
					mark
					call(ptr-cast, [call(malloc, [50331648])])
					let(
						mark-end
						call(+, [local-ref(mark), 50331648])
						let(
							bytes
							call(ptr-cast, [call(malloc, [call(wrap-mul, [50331648, call(size-of, [])])])])
							seq(
								call(hard-assert, [call(is-word-aligned, [call(as-any-mut-ptr, [local-ref(bytes)])])])
								let(
									bytes-end
									call(+, [local-ref(bytes), 50331648])
									seq(
										call(drop, [call(memset, [call(as-any-mut-ptr, [local-ref(mark)]), 0, 50331648])])
										let(
											res
											call(
												new
												[
													call(lock-by-val, [])
													0
													call(none, [])
													call(false, [])
													50331648
													local-ref(mark)
													local-ref(mark)
													local-ref(mark-end)
													local-ref(bytes)
													local-ref(bytes)
													local-ref(bytes-end)])
											seq(call(validate-gc, [call(ref-of-val, [local-ref(res)])]), local-ref(res)))))))))))
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, bool), type(false, nat8)]))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(false, mut-ptr))]
			builtin([type(false, mut-ptr)]))
		fun(
			noctx
			new
			type(false, gc)
			none
			[
				param(lk, type(false, lock))
				param(gc-count, type(false, nat64))
				param(context-head, type(false, opt))
				param(needs-gc, type(false, bool))
				param(size-words, type(false, nat64))
				param(mark-begin, type(false, mut-ptr))
				param(mark-cur, type(false, mut-ptr))
				param(mark-end, type(false, mut-ptr))
				param(data-begin, type(false, mut-ptr))
				param(data-cur, type(false, mut-ptr))
				param(data-end, type(false, mut-ptr))]
			new-record)
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(
			noctx
			validate-gc
			type(false, void)
			none
			[param(gc, type(true, gc))]
			expr-body(
				seq(
					seq(
						seq(
							seq(
								seq(
									seq(
										seq(
											call(
												hard-assert
												[
													call(
														is-word-aligned
														[call(as-any-mut-ptr, [call(mark-begin, [param-ref(gc)])])])])
											call(
												hard-assert
												[
													call(
														is-word-aligned
														[call(as-any-mut-ptr, [call(data-begin, [param-ref(gc)])])])]))
										call(
											hard-assert
											[
												call(
													is-word-aligned
													[call(as-any-mut-ptr, [call(data-cur, [param-ref(gc)])])])]))
									call(
										hard-assert
										[call(<=, [call(mark-begin, [param-ref(gc)]), call(mark-cur, [param-ref(gc)])])]))
								call(
									hard-assert
									[call(<=, [call(mark-cur, [param-ref(gc)]), call(mark-end, [param-ref(gc)])])]))
							call(
								hard-assert
								[call(<=, [call(data-begin, [param-ref(gc)]), call(data-cur, [param-ref(gc)])])]))
						call(
							hard-assert
							[call(<=, [call(data-cur, [param-ref(gc)]), call(data-end, [param-ref(gc)])])]))
					let(
						mark-idx
						call(-, [call(mark-cur, [param-ref(gc)]), call(mark-begin, [param-ref(gc)])])
						let(
							data-idx
							call(-, [call(data-cur, [param-ref(gc)]), call(data-begin, [param-ref(gc)])])
							seq(
								seq(
									call(
										hard-assert
										[
											call(
												==
												[
													call(
														-
														[
															call(mark-end, [param-ref(gc)])
															call(mark-begin, [param-ref(gc)])])
													call(size-words, [param-ref(gc)])])])
									call(
										hard-assert
										[
											call(
												==
												[
													call(
														-
														[
															call(data-end, [param-ref(gc)])
															call(data-begin, [param-ref(gc)])])
													call(size-words, [param-ref(gc)])])]))
								call(hard-assert, [call(==, [local-ref(mark-idx), local-ref(data-idx)])])))))))
		fun(noctx, data-begin, type(false, mut-ptr), none, [param(a, type(true, gc))], field-get(8))
		fun(
			noctx
			<=>
			type(false, comparison)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				cond(
					call(is-less, [param-ref(a), param-ref(b)])
					call(less, [])
					cond(call(==, [param-ref(a), param-ref(b)]), call(equal, []), call(greater, [])))))
		fun(
			noctx
			is-less
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			builtin([type(false, bool)]))
		fun(
			noctx
			<=
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			noctx
			<
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(
				match-enum(call(<=>, [param-ref(a), param-ref(b)]), [call(true, []), call(false, []), call(false, [])])))
		fun(noctx, mark-end, type(false, mut-ptr), none, [param(a, type(true, gc))], field-get(7))
		fun(
			noctx
			<=
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(noctx, ref-of-val, type(true, gc), none, [param(a, type(false, gc))], builtin([type(true, gc)]))
		fun(noctx, new, type(false, thread-safe-counter), none, [], expr-body(call(new, [0])))
		fun(
			noctx
			new
			type(false, thread-safe-counter)
			none
			[param(init, type(false, nat64))]
			expr-body(call(new, [call(lock-by-val, []), param-ref(init)])))
		fun(
			noctx
			new
			type(false, thread-safe-counter)
			none
			[param(lk, type(false, lock)), param(value, type(false, nat64))]
			new-record)
		fun(noctx, ref-of-val, type(true, island), none, [param(a, type(false, island))], builtin([type(true, island)]))
		fun(
			noctx
			set-islands
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(islands, type(false, arr))]
			field-set(4))
		fun(
			noctx
			arr-of-single
			type(false, arr)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(new, [1, param-ref(a)])))
		fun(noctx, ptr-to, type(false, const-ptr), none, [param(a, type(true, island))], builtin([type(true, island)]))
		fun(
			noctx
			add-main-task
			type(true, fut)
			none
			[
				param(gctx, type(true, global-ctx))
				param(thread-id, type(false, nat64))
				param(island, type(true, island))
				param(argc, type(false, int32))
				param(argv, type(false, const-ptr))
				param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				let(
					ectx
					call(exception-ctx, [])
					let(
						log-ctx
						call(log-ctx, [])
						let(
							perf-ctx
							call(perf-ctx, [])
							let(
								ectx-ptr
								call(as-any-mut-ptr, [call(ref-of-val, [local-ref(ectx)])])
								let(
									log-ctx-ptr
									call(as-any-mut-ptr, [call(ref-of-val, [local-ref(log-ctx)])])
									let(
										perf-ptr
										call(as-any-mut-ptr, [call(ref-of-val, [local-ref(perf-ctx)])])
										let(
											print-lock
											call(ref-of-val, [call(print-lock, [param-ref(gctx)])])
											let(
												tls
												call(
													new
													[
														param-ref(thread-id)
														local-ref(print-lock)
														local-ref(ectx-ptr)
														local-ref(log-ctx-ptr)
														local-ref(perf-ptr)])
												let(
													ctx-by-val
													call(
														new-ctx
														[
															param-ref(gctx)
															call(ref-of-val, [local-ref(tls)])
															param-ref(island)
															0])
													let(
														ctx
														call(ref-of-val, [local-ref(ctx-by-val)])
														let(
															add
															lambda(0, void)
															let(
																all-args
																call(
																	subscript
																	[
																		param-ref(argv)
																		call(
																			..
																			[
																				0
																				call(
																					unsafe-to-nat64
																					[call(to-int64, [param-ref(argc)])])])])
																call(
																	call-with-ctx
																	[
																		local-ref(add)
																		local-ref(ctx)
																		local-ref(all-args)
																		param-ref(main-ptr)])))))))))))))))
		fun(
			noctx
			exception-ctx
			type(false, exception-ctx)
			none
			[]
			expr-body(
				call(new, [call(null, []), call(new, [record([record([0, null])]), call(new, [call(empty-arr, [])])])])))
		fun(
			noctx
			new
			type(false, exception-ctx)
			none
			[param(jmp-buf-ptr, type(false, mut-ptr)), param(thrown-exception, type(false, exception))]
			new-record)
		fun(noctx, empty-arr, type(false, arr), none, [], expr-body(call(new, [0, call(null, [])])))
		fun(noctx, null, type(false, const-ptr), none, [], expr-body(call(as-const, [call(null, [])])))
		fun(noctx, null, type(false, mut-ptr), none, [], builtin([type(false, sym)]))
		fun(noctx, log-ctx, type(false, log-ctx), none, [], expr-body(call(new, [call(zeroed, [])])))
		fun(noctx, new, type(false, log-ctx), none, [param(handler, type(false, fun1))], new-record)
		fun(noctx, zeroed, type(false, fun1), none, [], builtin([type(false, fun1)]))
		fun(
			noctx
			perf-ctx
			type(false, perf-ctx)
			none
			[]
			expr-body(call(new, [call(empty-arr, []), call(empty-fix-arr, [])])))
		fun(
			noctx
			new
			type(false, perf-ctx)
			none
			[param(measure-names, type(false, arr)), param(measure-values, type(false, fix-arr))]
			new-record)
		fun(noctx, empty-arr, type(false, arr), none, [], expr-body(call(new, [0, call(null, [])])))
		fun(
			noctx
			new
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, const-ptr))]
			new-record)
		fun(noctx, null, type(false, const-ptr), none, [], expr-body(call(as-const, [call(null, [])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, str)]))
		fun(noctx, null, type(false, mut-ptr), none, [], builtin([type(false, str)]))
		fun(
			noctx
			empty-fix-arr
			type(false, fix-arr)
			none
			[]
			expr-body(let(inner, call(empty-arr, []), call(new, [local-ref(inner)]))))
		fun(noctx, empty-arr, type(false, arr), none, [], expr-body(call(new, [0, call(null, [])])))
		fun(
			noctx
			new
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, const-ptr))]
			new-record)
		fun(noctx, null, type(false, const-ptr), none, [], expr-body(call(as-const, [call(null, [])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, measure-value)]))
		fun(noctx, null, type(false, mut-ptr), none, [], builtin([type(false, measure-value)]))
		fun(noctx, new, type(false, fix-arr), none, [param(inner, type(false, arr))], new-record)
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(true, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			noctx
			ref-of-val
			type(true, exception-ctx)
			none
			[param(a, type(false, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(true, log-ctx))]
			builtin([type(true, log-ctx)]))
		fun(
			noctx
			ref-of-val
			type(true, log-ctx)
			none
			[param(a, type(false, log-ctx))]
			builtin([type(true, log-ctx)]))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(true, perf-ctx))]
			builtin([type(true, perf-ctx)]))
		fun(
			noctx
			ref-of-val
			type(true, perf-ctx)
			none
			[param(a, type(false, perf-ctx))]
			builtin([type(true, perf-ctx)]))
		fun(noctx, print-lock, type(false, lock), none, [param(a, type(true, global-ctx))], field-get(1))
		fun(
			noctx
			new
			type(false, thread-local-stuff)
			none
			[
				param(thread-id, type(false, nat64))
				param(print-lock, type(true, lock))
				param(exception-ctx-ptr, type(false, mut-ptr))
				param(log-ctx-ptr, type(false, mut-ptr))
				param(perf-ctx-ptr, type(false, mut-ptr))]
			new-record)
		fun(
			noctx
			new-ctx
			type(false, ctx)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(island, type(true, island))
				param(exclusion, type(false, nat64))]
			expr-body(
				let(
					gc-ctx
					call(get-gc-ctx, [call(ref-of-val, [call(gc, [param-ref(island)])])])
					seq(
						call(
							set-handler
							[
								call(as-ref, [call(log-ctx-ptr, [param-ref(tls)])])
								call(log-handler, [call(ref-of-val, [call(gc-root, [param-ref(island)])])])])
						call(
							new
							[
								call(as-any-mut-ptr, [param-ref(gctx)])
								call(id, [param-ref(island)])
								param-ref(exclusion)
								call(as-any-mut-ptr, [local-ref(gc-ctx)])
								param-ref(tls)])))))
		fun(
			noctx
			get-gc-ctx
			type(true, gc-ctx)
			none
			[param(gc, type(true, gc))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gc)])])])
					let(
						res
						match-union(
							call(context-head, [param-ref(gc)])
							[
								case(
									none
									let(
										c
										call(as-ref, [call(malloc, [call(size-of, [])])])
										seq(
											seq(
												call(set-gc, [local-ref(c), param-ref(gc)])
												call(set-next-ctx, [local-ref(c), call(none, [])]))
											local-ref(c))))
								case(
									some(c)
									seq(
										seq(
											call(set-context-head, [param-ref(gc), call(next-ctx, [local-ref(c)])])
											call(set-next-ctx, [local-ref(c), call(none, [])]))
										local-ref(c)))])
						seq(call(release!, [call(ref-of-val, [call(lk, [param-ref(gc)])])]), local-ref(res))))))
		fun(noctx, context-head, type(false, opt), none, [param(a, type(true, gc))], field-get(2))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, gc-ctx)]))
		fun(
			noctx
			set-gc
			type(false, void)
			none
			[param(a, type(true, gc-ctx)), param(gc, type(true, gc))]
			field-set(0))
		fun(
			noctx
			set-next-ctx
			type(false, void)
			none
			[param(a, type(true, gc-ctx)), param(next-ctx, type(false, opt))]
			field-set(1))
		fun(
			noctx
			set-context-head
			type(false, void)
			none
			[param(a, type(true, gc)), param(context-head, type(false, opt))]
			field-set(2))
		fun(noctx, next-ctx, type(false, opt), none, [param(a, type(true, gc-ctx))], field-get(1))
		fun(noctx, gc, type(false, gc), none, [param(a, type(true, island))], field-get(2))
		fun(
			noctx
			set-handler
			type(false, void)
			none
			[param(a, type(true, log-ctx)), param(handler, type(false, fun1))]
			field-set(0))
		fun(noctx, as-ref, type(true, log-ctx), none, [param(a, type(false, mut-ptr))], builtin([type(true, log-ctx)]))
		fun(noctx, log-ctx-ptr, type(false, mut-ptr), none, [param(a, type(true, thread-local-stuff))], field-get(3))
		fun(noctx, log-handler, type(false, fun1), none, [param(a, type(true, island-gc-root))], field-get(2))
		fun(
			noctx
			ref-of-val
			type(true, island-gc-root)
			none
			[param(a, type(false, island-gc-root))]
			builtin([type(true, island-gc-root)]))
		fun(noctx, gc-root, type(false, island-gc-root), none, [param(a, type(true, island))], field-get(3))
		fun(
			noctx
			new
			type(false, ctx)
			none
			[
				param(gctx-ptr, type(false, mut-ptr))
				param(island-id, type(false, nat64))
				param(exclusion, type(false, nat64))
				param(gc-ctx-ptr, type(false, mut-ptr))
				param(thread-local-stuff, type(true, thread-local-stuff))]
			new-record)
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(true, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(noctx, id, type(false, nat64), none, [param(a, type(true, island))], field-get(1))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(true, gc-ctx))]
			builtin([type(true, gc-ctx)]))
		fun(
			noctx
			ref-of-val
			type(true, thread-local-stuff)
			none
			[param(a, type(false, thread-local-stuff))]
			builtin([type(true, thread-local-stuff)]))
		fun(noctx, ref-of-val, type(true, ctx), none, [param(a, type(false, ctx))], builtin([type(true, ctx)]))
		fun(
			ctx
			add-first-task
			type(true, fut)
			none
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				let(
					res
					call(
						then-void
						[
							call(delay, [])
							record(
								[
									call(cur-island-and-exclusion, [])
									lambda(0, alloc(record([param-ref(main-ptr), param-ref(all-args)])))])])
					seq(call(handle-exceptions, [local-ref(res)]), local-ref(res)))))
		fun(
			ctx
			then-void
			type(true, fut)
			none
			[param(a, type(true, fut)), param(cb, type(false, fun-ref0))]
			expr-body(
				call(
					then
					[
						param-ref(a)
						record([call(cur-island-and-exclusion, []), lambda(0, alloc(record([param-ref(cb)])))])])))
		fun(
			ctx
			then
			type(true, fut)
			none
			[param(a, type(true, fut)), param(cb, type(false, fun-ref1))]
			expr-body(
				let(
					res
					call(unresolved, [])
					seq(
						call(callback!, [param-ref(a), lambda(0, alloc(record([param-ref(cb), local-ref(res)])))])
						local-ref(res)))))
		fun(
			ctx
			unresolved
			type(true, fut)
			none
			[]
			expr-body(call(new, [call(lock-by-val, []), call(fut-state-no-callbacks, [])])))
		fun(
			ctx
			new
			type(true, fut)
			none
			[param(lk, type(false, lock)), param(state, type(false, fut-state))]
			new-record)
		fun(noctx, fut-state-no-callbacks, type(false, fut-state), none, [], new-union)
		fun(
			ctx
			callback!
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-act1))]
			expr-body(
				call(
					with-lock
					[
						call(ref-of-val, [call(lk, [param-ref(f)])])
						lambda(0, alloc(record([param-ref(f), param-ref(cb)])))])))
		fun(
			ctx
			with-lock
			type(false, void)
			none
			[param(a, type(true, lock)), param(f, type(false, fun-act0))]
			expr-body(
				seq(
					call(acquire!, [param-ref(a)])
					let(res, call(subscript, [param-ref(f)]), seq(call(release!, [param-ref(a)]), local-ref(res))))))
		fun(
			ctx
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act0))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, [])])))
		fun(
			noctx
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act0)), param(c, type(true, ctx))]
			builtin([type(false, void)]))
		fun(noctx, lk, type(false, lock), none, [param(a, type(true, fut))], field-get(0))
		fun(noctx, state, type(false, fut-state), none, [param(a, type(true, fut))], field-get(1))
		fun(
			noctx
			set-state
			type(false, void)
			none
			[param(a, type(true, fut)), param(state, type(false, fut-state))]
			field-set(1))
		fun(
			noctx
			fut-state-callbacks
			type(false, fut-state)
			none
			[param(a, type(true, fut-state-callbacks))]
			new-union)
		fun(
			ctx
			new
			type(true, fut-state-callbacks)
			none
			[param(cb, type(false, fun-act1)), param(next, type(false, opt))]
			new-record)
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(noctx, some, type(false, opt), none, [param(a, type(true, fut-state-callbacks))], new-union)
		fun(
			ctx
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, result))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, result))]
			builtin([type(false, void), type(false, result)]))
		fun(noctx, ok, type(false, result), none, [param(a, type(false, void))], new-union)
		fun(noctx, err, type(false, result), none, [param(a, type(false, exception))], new-union)
		fun(
			ctx
			lambda(callback!, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(callback!, 0))))
			[]
			expr-body(
				match-union(
					call(state, [get-field(param-ref("<<closure>>"), f)])
					[
						case(
							none
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									call(
										fut-state-callbacks
										[call(new, [get-field(param-ref("<<closure>>"), cb), call(none, [])])])]))
						case(
							some(cbs)
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									call(
										fut-state-callbacks
										[
											call(
												new
												[get-field(param-ref("<<closure>>"), cb), call(some, [local-ref(cbs)])])])]))
						case(
							some(r)
							call(subscript, [get-field(param-ref("<<closure>>"), cb), call(ok, [local-ref(r)])]))
						case(
							some(e)
							call(subscript, [get-field(param-ref("<<closure>>"), cb), call(err, [local-ref(e)])]))])))
		fun(
			ctx
			forward-to!
			type(false, void)
			none
			[param(from, type(true, fut)), param(to, type(true, fut))]
			expr-body(call(callback!, [param-ref(from), lambda(0, alloc(record([param-ref(to)])))])))
		fun(
			ctx
			callback!
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-act1))]
			expr-body(
				call(
					with-lock
					[
						call(ref-of-val, [call(lk, [param-ref(f)])])
						lambda(1, alloc(record([param-ref(f), param-ref(cb)])))])))
		fun(noctx, lk, type(false, lock), none, [param(a, type(true, fut))], field-get(0))
		fun(noctx, state, type(false, fut-state), none, [param(a, type(true, fut))], field-get(1))
		fun(
			noctx
			set-state
			type(false, void)
			none
			[param(a, type(true, fut)), param(state, type(false, fut-state))]
			field-set(1))
		fun(
			noctx
			fut-state-callbacks
			type(false, fut-state)
			none
			[param(a, type(true, fut-state-callbacks))]
			new-union)
		fun(
			ctx
			new
			type(true, fut-state-callbacks)
			none
			[param(cb, type(false, fun-act1)), param(next, type(false, opt))]
			new-record)
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(noctx, some, type(false, opt), none, [param(a, type(true, fut-state-callbacks))], new-union)
		fun(
			ctx
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, result))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, result))]
			builtin([type(false, void), type(false, result)]))
		fun(noctx, ok, type(false, result), none, [param(a, type(false, nat64))], new-union)
		fun(noctx, err, type(false, result), none, [param(a, type(false, exception))], new-union)
		fun(
			ctx
			lambda(callback!, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(callback!, 0))))
			[]
			expr-body(
				match-union(
					call(state, [get-field(param-ref("<<closure>>"), f)])
					[
						case(
							none
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									call(
										fut-state-callbacks
										[call(new, [get-field(param-ref("<<closure>>"), cb), call(none, [])])])]))
						case(
							some(cbs)
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									call(
										fut-state-callbacks
										[
											call(
												new
												[get-field(param-ref("<<closure>>"), cb), call(some, [local-ref(cbs)])])])]))
						case(
							some(r)
							call(subscript, [get-field(param-ref("<<closure>>"), cb), call(ok, [local-ref(r)])]))
						case(
							some(e)
							call(subscript, [get-field(param-ref("<<closure>>"), cb), call(err, [local-ref(e)])]))])))
		fun(
			ctx
			resolve-or-reject!
			type(false, void)
			none
			[param(f, type(true, fut)), param(result, type(false, result))]
			expr-body(
				let(
					old-state
					call(
						with-lock
						[
							call(ref-of-val, [call(lk, [param-ref(f)])])
							lambda(0, alloc(record([param-ref(f), param-ref(result)])))])
					match-union(
						local-ref(old-state)
						[
							case(none, call(void, []))
							case(some(cbs), call(call-callbacks!, [local-ref(cbs), param-ref(result)]))
							case(none, call(hard-unreachable, []))
							case(none, call(hard-unreachable, []))]))))
		fun(
			ctx
			with-lock
			type(false, fut-state)
			none
			[param(a, type(true, lock)), param(f, type(false, fun-act0))]
			expr-body(
				seq(
					call(acquire!, [param-ref(a)])
					let(res, call(subscript, [param-ref(f)]), seq(call(release!, [param-ref(a)]), local-ref(res))))))
		fun(
			ctx
			subscript
			type(false, fut-state)
			none
			[param(a, type(false, fun-act0))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, [])])))
		fun(
			noctx
			call-with-ctx
			type(false, fut-state)
			none
			[param(f, type(false, fun-act0)), param(c, type(true, ctx))]
			builtin([type(false, fut-state)]))
		fun(noctx, fut-state-resolved, type(false, fut-state), none, [param(a, type(false, nat64))], new-union)
		fun(noctx, fut-state-exception, type(false, fut-state), none, [param(a, type(false, exception))], new-union)
		fun(
			ctx
			lambda(resolve-or-reject!, 0)
			type(false, fut-state)
			some(param("<<closure>>", type(true, lambda(resolve-or-reject!, 0))))
			[]
			expr-body(
				let(
					old
					call(state, [get-field(param-ref("<<closure>>"), f)])
					seq(
						call(
							set-state
							[
								get-field(param-ref("<<closure>>"), f)
								match-union(
									get-field(param-ref("<<closure>>"), result)
									[
										case(some(o), call(fut-state-resolved, [local-ref(o)]))
										case(some(e), call(fut-state-exception, [local-ref(e)]))])])
						local-ref(old)))))
		fun(
			ctx
			call-callbacks!
			type(false, void)
			none
			[param(cbs, type(true, fut-state-callbacks)), param(value, type(false, result))]
			expr-body(
				seq(
					call(subscript, [call(cb, [param-ref(cbs)]), param-ref(value)])
					match-union(
						call(next, [param-ref(cbs)])
						[case(none, void), case(some(next), call(call-callbacks!, [local-ref(next), param-ref(value)]))]))))
		fun(noctx, cb, type(false, fun-act1), none, [param(a, type(true, fut-state-callbacks))], field-get(0))
		fun(noctx, next, type(false, opt), none, [param(a, type(true, fut-state-callbacks))], field-get(1))
		fun(
			ctx
			lambda(forward-to!, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(forward-to!, 0))))
			[param(it, type(false, result))]
			expr-body(call(resolve-or-reject!, [get-field(param-ref("<<closure>>"), to), param-ref(it)])))
		fun(
			ctx
			subscript
			type(true, fut)
			none
			[param(f, type(false, fun-ref1)), param(p0, type(false, void))]
			expr-body(
				let(
					island
					call(get-island, [call(island, [call(island-and-exclusion, [param-ref(f)])])])
					let(
						res
						call(unresolved, [])
						seq(
							call(
								add-task
								[
									local-ref(island)
									call(exclusion, [call(island-and-exclusion, [param-ref(f)])])
									lambda(3, alloc(record([param-ref(f), param-ref(p0), local-ref(res)])))])
							local-ref(res))))))
		fun(
			ctx
			get-island
			type(true, island)
			none
			[param(island-id, type(false, nat64))]
			expr-body(call(subscript, [call(islands, [call(get-global-ctx, [])]), param-ref(island-id)])))
		fun(
			ctx
			subscript
			type(true, island)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(noctx, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			noctx
			unsafe-at
			type(true, island)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])))
		fun(
			noctx
			subscript
			type(true, island)
			none
			[param(a, type(false, const-ptr)), param(n, type(false, nat64))]
			expr-body(call(*, [call(+, [param-ref(a), param-ref(n)])])))
		fun(
			noctx
			*
			type(true, island)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(*, [call(as-mut, [param-ref(a)])])))
		fun(noctx, *, type(true, island), none, [param(a, type(false, mut-ptr))], builtin([type(true, island)]))
		fun(
			noctx
			as-mut
			type(false, mut-ptr)
			none
			[param(a, type(false, const-ptr))]
			builtin([type(true, island)]))
		fun(
			noctx
			+
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(offset, type(false, nat64))]
			expr-body(call(as-const, [call(+, [call(as-mut, [param-ref(a)]), param-ref(offset)])])))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(true, island)]))
		fun(noctx, begin-ptr, type(false, const-ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(noctx, islands, type(false, arr), none, [param(a, type(true, global-ctx))], field-get(4))
		fun(noctx, island, type(false, nat64), none, [param(a, type(false, island-and-exclusion))], field-get(0))
		fun(
			noctx
			island-and-exclusion
			type(false, island-and-exclusion)
			none
			[param(a, type(false, fun-ref1))]
			field-get(0))
		fun(
			ctx
			add-task
			type(false, void)
			none
			[param(a, type(true, island)), param(exclusion, type(false, nat64)), param(action, type(false, fun-act0))]
			expr-body(call(add-task, [param-ref(a), call(no-timestamp, []), param-ref(exclusion), param-ref(action)])))
		fun(
			ctx
			add-task
			type(false, void)
			none
			[
				param(a, type(true, island))
				param(timestamp, type(false, nat64))
				param(exclusion, type(false, nat64))
				param(action, type(false, fun-act0))]
			expr-body(
				let(
					node
					call(new, [call(new, [param-ref(timestamp), param-ref(exclusion), param-ref(action)])])
					seq(
						seq(
							seq(
								call(acquire!, [call(ref-of-val, [call(tasks-lock, [param-ref(a)])])])
								call(insert-task!, [call(tasks, [param-ref(a)]), local-ref(node)]))
							call(release!, [call(ref-of-val, [call(tasks-lock, [param-ref(a)])])]))
						call(broadcast!, [call(ref-of-val, [call(may-be-work-to-do, [call(gctx, [param-ref(a)])])])])))))
		fun(
			ctx
			new
			type(true, task-queue-node)
			none
			[param(task, type(false, task))]
			expr-body(call(new, [param-ref(task), call(none, [])])))
		fun(
			ctx
			new
			type(true, task-queue-node)
			none
			[param(task, type(false, task)), param(next, type(false, opt))]
			new-record)
		fun(
			noctx
			new
			type(false, task)
			none
			[
				param(time, type(false, nat64))
				param(exclusion, type(false, nat64))
				param(action, type(false, fun-act0))]
			new-record)
		fun(noctx, tasks-lock, type(false, lock), none, [param(a, type(true, island))], field-get(4))
		fun(
			noctx
			insert-task!
			type(false, void)
			none
			[param(a, type(true, task-queue)), param(inserted, type(true, task-queue-node))]
			expr-body(
				let(
					size-before
					call(size, [param-ref(a)])
					seq(
						match-union(
							call(head, [param-ref(a)])
							[
								case(none, call(set-head, [param-ref(a), call(some, [param-ref(inserted)])]))
								case(
									some(head)
									cond(
										call(
											<=
											[
												call(time, [call(task, [local-ref(head)])])
												call(time, [call(task, [param-ref(inserted)])])])
										call(insert-recur, [local-ref(head), param-ref(inserted)])
										seq(
											call(set-next, [param-ref(inserted), call(some, [local-ref(head)])])
											call(set-head, [param-ref(a), call(some, [param-ref(inserted)])]))))])
						let(
							size-after
							call(size, [param-ref(a)])
							call(
								hard-assert
								[call(==, [call(wrap-add, [local-ref(size-before), 1]), local-ref(size-after)])]))))))
		fun(
			noctx
			size
			type(false, nat64)
			none
			[param(a, type(true, task-queue))]
			expr-body(call(size-recur, [call(head, [param-ref(a)]), 0])))
		fun(
			noctx
			size-recur
			type(false, nat64)
			none
			[param(node, type(false, opt)), param(acc, type(false, nat64))]
			expr-body(
				match-union(
					param-ref(node)
					[
						case(none, param-ref(acc))
						case(
							some(n)
							call(size-recur, [call(next, [local-ref(n)]), call(wrap-add, [param-ref(acc), 1])]))])))
		fun(noctx, next, type(false, opt), none, [param(a, type(true, task-queue-node))], field-get(1))
		fun(noctx, head, type(false, opt), none, [param(a, type(true, task-queue))], field-get(0))
		fun(
			noctx
			set-head
			type(false, void)
			none
			[param(a, type(true, task-queue)), param(head, type(false, opt))]
			field-set(0))
		fun(noctx, some, type(false, opt), none, [param(a, type(true, task-queue-node))], new-union)
		fun(noctx, time, type(false, nat64), none, [param(a, type(false, task))], field-get(0))
		fun(noctx, task, type(false, task), none, [param(a, type(true, task-queue-node))], field-get(0))
		fun(
			noctx
			insert-recur
			type(false, void)
			none
			[param(prev, type(true, task-queue-node)), param(inserted, type(true, task-queue-node))]
			expr-body(
				match-union(
					call(next, [param-ref(prev)])
					[
						case(none, call(set-next, [param-ref(prev), call(some, [param-ref(inserted)])]))
						case(
							some(cur)
							cond(
								call(
									<=
									[
										call(time, [call(task, [local-ref(cur)])])
										call(time, [call(task, [param-ref(inserted)])])])
								call(insert-recur, [local-ref(cur), param-ref(inserted)])
								seq(
									call(set-next, [param-ref(inserted), call(some, [local-ref(cur)])])
									call(set-next, [param-ref(prev), call(some, [param-ref(inserted)])]))))])))
		fun(
			noctx
			set-next
			type(false, void)
			none
			[param(a, type(true, task-queue-node)), param(next, type(false, opt))]
			field-set(1))
		fun(
			noctx
			tasks
			type(true, task-queue)
			none
			[param(a, type(true, island))]
			expr-body(call(ref-of-val, [call(tasks, [call(ref-of-val, [call(gc-root, [param-ref(a)])])])])))
		fun(
			noctx
			ref-of-val
			type(true, task-queue)
			none
			[param(a, type(false, task-queue))]
			builtin([type(true, task-queue)]))
		fun(noctx, tasks, type(false, task-queue), none, [param(a, type(true, island-gc-root))], field-get(0))
		fun(
			noctx
			broadcast!
			type(false, void)
			none
			[param(a, type(true, condition))]
			expr-body(
				seq(
					seq(
						seq(
							call(
								hard-assert-posix-error
								[call(pthread_mutex_lock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
							call(
								hard-assert-posix-error
								[call(pthread_cond_broadcast, [call(ref-of-val, [call(cond, [param-ref(a)])])])]))
						call(set-sequence, [param-ref(a), call(wrap-add, [call(sequence, [param-ref(a)]), 1])]))
					call(
						hard-assert-posix-error
						[call(pthread_mutex_unlock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])]))))
		fun(noctx, pthread_cond_broadcast, type(false, int32), none, [param(cond, type(true, pthread_cond_t))], extern)
		fun(
			noctx
			set-sequence
			type(false, void)
			none
			[param(a, type(true, condition)), param(sequence, type(false, nat64))]
			field-set(4))
		fun(noctx, sequence, type(false, nat64), none, [param(a, type(true, condition))], field-get(4))
		fun(noctx, may-be-work-to-do, type(false, condition), none, [param(a, type(true, global-ctx))], field-get(6))
		fun(noctx, gctx, type(true, global-ctx), none, [param(a, type(true, island))], field-get(0))
		fun(noctx, no-timestamp, type(false, nat64), none, [], expr-body(0))
		fun(noctx, exclusion, type(false, nat64), none, [param(a, type(false, island-and-exclusion))], field-get(1))
		fun(
			ctx
			catch
			type(false, void)
			none
			[param(try, type(false, fun-act0)), param(catcher, type(false, fun-act1))]
			expr-body(call(catch-with-exception-ctx, [call(get-exception-ctx, []), param-ref(try), param-ref(catcher)])))
		fun(
			ctx
			catch-with-exception-ctx
			type(false, void)
			none
			[
				param(ec, type(true, exception-ctx))
				param(try, type(false, fun-act0))
				param(catcher, type(false, fun-act1))]
			expr-body(
				let(
					old-thrown-exception
					call(thrown-exception, [param-ref(ec)])
					let(
						old-jmp-buf
						call(jmp-buf-ptr, [param-ref(ec)])
						let(
							store
							call(new, [call(zero, []), 0, call(zero, [])])
							seq(
								call(set-jmp-buf-ptr, [param-ref(ec), call(ptr-to, [local-ref(store)])])
								let(
									setjmp-result
									call(setjmp, [call(jmp-buf-ptr, [param-ref(ec)])])
									cond(
										call(==, [local-ref(setjmp-result), 0])
										let(
											res
											call(subscript, [param-ref(try)])
											seq(
												seq(
													call(set-jmp-buf-ptr, [param-ref(ec), local-ref(old-jmp-buf)])
													call(
														set-thrown-exception
														[param-ref(ec), local-ref(old-thrown-exception)]))
												local-ref(res)))
										seq(
											call(
												hard-assert
												[call(==, [local-ref(setjmp-result), call(number-to-throw, [])])])
											let(
												thrown-exception
												call(thrown-exception, [param-ref(ec)])
												seq(
													seq(
														call(set-jmp-buf-ptr, [param-ref(ec), local-ref(old-jmp-buf)])
														call(
															set-thrown-exception
															[param-ref(ec), local-ref(old-thrown-exception)]))
													call(subscript, [param-ref(catcher), local-ref(thrown-exception)]))))))))))))
		fun(noctx, thrown-exception, type(false, exception), none, [param(a, type(true, exception-ctx))], field-get(1))
		fun(
			noctx
			new
			type(false, __jmp_buf_tag)
			none
			[
				param(__jmpbuf, type(false, bytes64))
				param(__mask_was_saved, type(false, int32))
				param(__saved_mask, type(false, bytes128))]
			new-record)
		fun(noctx, zero, type(false, bytes64), none, [], expr-body(call(new, [call(zero, []), call(zero, [])])))
		fun(
			noctx
			new
			type(false, bytes64)
			none
			[param(n0, type(false, bytes32)), param(n1, type(false, bytes32))]
			new-record)
		fun(noctx, zero, type(false, bytes32), none, [], expr-body(call(new, [call(zero, []), call(zero, [])])))
		fun(
			noctx
			new
			type(false, bytes32)
			none
			[param(n0, type(false, bytes16)), param(n1, type(false, bytes16))]
			new-record)
		fun(noctx, zero, type(false, bytes16), none, [], expr-body(call(new, [0, 0])))
		fun(
			noctx
			new
			type(false, bytes16)
			none
			[param(n0, type(false, nat64)), param(n1, type(false, nat64))]
			new-record)
		fun(noctx, zero, type(false, bytes128), none, [], expr-body(call(new, [call(zero, []), call(zero, [])])))
		fun(
			noctx
			new
			type(false, bytes128)
			none
			[param(n0, type(false, bytes64)), param(n1, type(false, bytes64))]
			new-record)
		fun(
			noctx
			set-jmp-buf-ptr
			type(false, void)
			none
			[param(a, type(true, exception-ctx)), param(jmp-buf-ptr, type(false, mut-ptr))]
			field-set(0))
		fun(
			noctx
			ptr-to
			type(false, mut-ptr)
			none
			[param(a, type(false, __jmp_buf_tag))]
			builtin([type(false, __jmp_buf_tag)]))
		fun(noctx, setjmp, type(false, int32), none, [param(env, type(false, mut-ptr))], extern)
		fun(
			ctx
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, exception))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, exception))]
			builtin([type(false, void), type(false, exception)]))
		fun(
			ctx
			subscript
			type(true, fut)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, void))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(true, fut)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, void))]
			builtin([type(true, fut), type(false, void)]))
		fun(noctx, action, type(false, fun-act1), none, [param(a, type(false, fun-ref1))], field-get(1))
		fun(
			ctx
			lambda(lambda(subscript, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 0))))
			[]
			expr-body(
				call(
					forward-to!
					[
						call(
							subscript
							[
								call(action, [get-field(param-ref("<<closure>>"), f)])
								get-field(param-ref("<<closure>>"), p0)])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			ctx
			reject!
			type(false, void)
			none
			[param(f, type(true, fut)), param(e, type(false, exception))]
			expr-body(call(resolve-or-reject!, [param-ref(f), call(err, [param-ref(e)])])))
		fun(
			ctx
			lambda(lambda(subscript, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 1))))
			[param(err, type(false, exception))]
			expr-body(call(reject!, [get-field(param-ref("<<closure>>"), res), param-ref(err)])))
		fun(
			ctx
			lambda(subscript, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(subscript, 0))))
			[]
			expr-body(
				call(
					catch
					[
						lambda(
							2
							alloc(
								record(
									[
										get-field(param-ref("<<closure>>"), f)
										get-field(param-ref("<<closure>>"), p0)
										get-field(param-ref("<<closure>>"), res)])))
						lambda(0, alloc(record([get-field(param-ref("<<closure>>"), res)])))])))
		fun(
			ctx
			lambda(then, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(then, 0))))
			[param(result, type(false, result))]
			expr-body(
				match-union(
					param-ref(result)
					[
						case(
							some(o)
							call(
								forward-to!
								[
									call(subscript, [get-field(param-ref("<<closure>>"), cb), local-ref(o)])
									get-field(param-ref("<<closure>>"), res)]))
						case(some(e), call(reject!, [get-field(param-ref("<<closure>>"), res), local-ref(e)]))])))
		fun(
			ctx
			subscript
			type(true, fut)
			none
			[param(f, type(false, fun-ref0))]
			expr-body(
				let(
					res
					call(unresolved, [])
					seq(
						call(
							add-task
							[
								call(get-island, [call(island, [call(island-and-exclusion, [param-ref(f)])])])
								call(exclusion, [call(island-and-exclusion, [param-ref(f)])])
								lambda(5, alloc(record([param-ref(f), local-ref(res)])))])
						local-ref(res)))))
		fun(
			noctx
			island-and-exclusion
			type(false, island-and-exclusion)
			none
			[param(a, type(false, fun-ref0))]
			field-get(0))
		fun(
			ctx
			subscript
			type(true, fut)
			none
			[param(a, type(false, fun-act0))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, [])])))
		fun(
			noctx
			call-with-ctx
			type(true, fut)
			none
			[param(f, type(false, fun-act0)), param(c, type(true, ctx))]
			builtin([type(true, fut)]))
		fun(noctx, action, type(false, fun-act0), none, [param(a, type(false, fun-ref0))], field-get(1))
		fun(
			ctx
			lambda(lambda(subscript, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 0))))
			[]
			expr-body(
				call(
					forward-to!
					[
						call(subscript, [call(action, [get-field(param-ref("<<closure>>"), f)])])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			ctx
			lambda(lambda(subscript, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 1))))
			[param(err, type(false, exception))]
			expr-body(call(reject!, [get-field(param-ref("<<closure>>"), res), param-ref(err)])))
		fun(
			ctx
			lambda(subscript, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(subscript, 0))))
			[]
			expr-body(
				call(
					catch
					[
						lambda(
							4
							alloc(
								record(
									[get-field(param-ref("<<closure>>"), f), get-field(param-ref("<<closure>>"), res)])))
						lambda(1, alloc(record([get-field(param-ref("<<closure>>"), res)])))])))
		fun(
			ctx
			lambda(then-void, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(then-void, 0))))
			[param(ignore, type(false, void))]
			expr-body(call(subscript, [get-field(param-ref("<<closure>>"), cb)])))
		fun(
			ctx
			cur-island-and-exclusion
			type(false, island-and-exclusion)
			none
			[]
			expr-body(
				let(c, call(get-ctx, []), call(new, [call(island-id, [local-ref(c)]), call(exclusion, [local-ref(c)])]))))
		fun(
			noctx
			new
			type(false, island-and-exclusion)
			none
			[param(island, type(false, nat64)), param(exclusion, type(false, nat64))]
			new-record)
		fun(noctx, island-id, type(false, nat64), none, [param(a, type(true, ctx))], field-get(1))
		fun(noctx, exclusion, type(false, nat64), none, [param(a, type(true, ctx))], field-get(2))
		fun(ctx, delay, type(true, fut), none, [], expr-body(call(resolved, [call(void, [])])))
		fun(
			ctx
			resolved
			type(true, fut)
			none
			[param(value, type(false, void))]
			expr-body(call(new, [call(lock-by-val, []), call(fut-state-resolved, [param-ref(value)])])))
		fun(
			ctx
			new
			type(true, fut)
			none
			[param(lk, type(false, lock)), param(state, type(false, fut-state))]
			new-record)
		fun(noctx, fut-state-resolved, type(false, fut-state), none, [param(a, type(false, void))], new-union)
		fun(
			noctx
			subscript
			type(true, fut)
			none
			[param(a, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, arr))]
			builtin([type(true, fut), type(true, ctx), type(false, arr)]))
		fun(
			ctx
			map
			type(false, arr)
			none
			[param(a, type(false, arr)), param(f, type(false, fun-act1))]
			expr-body(
				call(make-arr, [call(size, [param-ref(a)]), lambda(0, alloc(record([param-ref(f), param-ref(a)])))])))
		fun(
			ctx
			make-arr
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(f, type(false, fun-act1))]
			expr-body(
				let(
					res
					call(alloc-uninitialized, [param-ref(size)])
					seq(
						call(fill-ptr-range, [local-ref(res), param-ref(size), param-ref(f)])
						call(new, [param-ref(size), call(as-const, [local-ref(res)])])))))
		fun(
			ctx
			alloc-uninitialized
			type(false, mut-ptr)
			none
			[param(size, type(false, nat64))]
			expr-body(call(ptr-cast, [call(alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, str), type(false, nat8)]))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, str)]))
		fun(
			ctx
			fill-ptr-range
			type(false, void)
			none
			[param(begin, type(false, mut-ptr)), param(size, type(false, nat64)), param(f, type(false, fun-act1))]
			expr-body(call(fill-ptr-range-recur, [param-ref(begin), 0, param-ref(size), param-ref(f)])))
		fun(
			ctx
			fill-ptr-range-recur
			type(false, void)
			none
			[
				param(begin, type(false, mut-ptr))
				param(i, type(false, nat64))
				param(size, type(false, nat64))
				param(f, type(false, fun-act1))]
			expr-body(
				cond(
					call(!=, [param-ref(i), param-ref(size)])
					seq(
						call(
							set-subscript
							[param-ref(begin), param-ref(i), call(subscript, [param-ref(f), param-ref(i)])])
						call(
							fill-ptr-range-recur
							[param-ref(begin), call(wrap-add, [param-ref(i), 1]), param-ref(size), param-ref(f)]))
					void)))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			noctx
			set-subscript
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(n, type(false, nat64)), param(value, type(false, str))]
			expr-body(call(set-deref, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			noctx
			set-deref
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(value, type(false, str))]
			builtin([type(false, str)]))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, str)]))
		fun(
			ctx
			subscript
			type(false, str)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, nat64))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, str)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, nat64))]
			builtin([type(false, str), type(false, nat64)]))
		fun(noctx, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			ctx
			subscript
			type(false, str)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, const-ptr))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, str)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, const-ptr))]
			builtin([type(false, str), type(false, const-ptr)]))
		fun(
			ctx
			subscript
			type(false, const-ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(
			noctx
			unsafe-at
			type(false, const-ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])))
		fun(
			noctx
			subscript
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(n, type(false, nat64))]
			expr-body(call(*, [call(+, [param-ref(a), param-ref(n)])])))
		fun(
			noctx
			*
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(*, [call(as-mut, [param-ref(a)])])))
		fun(noctx, *, type(false, const-ptr), none, [param(a, type(false, mut-ptr))], builtin([type(false, const-ptr)]))
		fun(
			noctx
			as-mut
			type(false, mut-ptr)
			none
			[param(a, type(false, const-ptr))]
			builtin([type(false, const-ptr)]))
		fun(
			noctx
			+
			type(false, const-ptr)
			none
			[param(a, type(false, const-ptr)), param(offset, type(false, nat64))]
			expr-body(call(as-const, [call(+, [call(as-mut, [param-ref(a)]), param-ref(offset)])])))
		fun(
			noctx
			as-const
			type(false, const-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, const-ptr)]))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, const-ptr)]))
		fun(noctx, begin-ptr, type(false, const-ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			ctx
			lambda(map, 0)
			type(false, str)
			some(param("<<closure>>", type(true, lambda(map, 0))))
			[param(i, type(false, nat64))]
			expr-body(
				call(
					subscript
					[
						get-field(param-ref("<<closure>>"), f)
						call(subscript, [get-field(param-ref("<<closure>>"), a), param-ref(i)])])))
		fun(
			ctx
			tail
			type(false, arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				seq(
					call(forbid, [call(is-empty, [param-ref(a)])])
					call(subscript, [param-ref(a), call(.., [1, call(size, [param-ref(a)])])]))))
		fun(
			noctx
			is-empty
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body(call(==, [call(size, [param-ref(a)]), 0])))
		fun(
			ctx
			subscript
			type(false, arr)
			none
			[param(a, type(false, arr)), param(range, type(false, range))]
			expr-body(
				seq(
					call(hard-assert, [call(<=, [call(high, [param-ref(range)]), call(size, [param-ref(a)])])])
					call(
						new
						[
							call(wrap-sub, [call(high, [param-ref(range)]), call(low, [param-ref(range)])])
							call(+, [call(begin-ptr, [param-ref(a)]), call(low, [param-ref(range)])])]))))
		fun(
			noctx
			new
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, const-ptr))]
			new-record)
		fun(
			ctx
			lambda(lambda(add-first-task, 0), 0)
			type(false, str)
			some(param("<<closure>>", type(false, void)))
			[param(arg, type(false, const-ptr))]
			expr-body(call(to-str, [param-ref(arg)])))
		fun(
			ctx
			lambda(add-first-task, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(add-first-task, 0))))
			[]
			expr-body(
				call(
					subscript
					[
						get-field(param-ref("<<closure>>"), main-ptr)
						call(get-ctx, [])
						call(map, [call(tail, [get-field(param-ref("<<closure>>"), all-args)]), lambda(0, void)])])))
		fun(
			ctx
			handle-exceptions
			type(false, void)
			none
			[param(a, type(true, fut))]
			expr-body(call(callback!, [param-ref(a), lambda(1, void)])))
		fun(
			ctx
			subscript
			type(false, void)
			none
			[param(a, type(false, fun1)), param(p0, type(false, exception))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			noctx
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun1)), param(c, type(true, ctx)), param(p0, type(false, exception))]
			builtin([type(false, void), type(false, exception)]))
		fun(
			ctx
			exception-handler
			type(false, fun1)
			none
			[param(a, type(true, island))]
			expr-body(call(exception-handler, [call(ref-of-val, [call(gc-root, [param-ref(a)])])])))
		fun(noctx, exception-handler, type(false, fun1), none, [param(a, type(true, island-gc-root))], field-get(1))
		fun(
			ctx
			get-cur-island
			type(true, island)
			none
			[]
			expr-body(call(get-island, [call(island-id, [call(get-ctx, [])])])))
		fun(
			ctx
			lambda(handle-exceptions, 0)
			type(false, void)
			some(param("<<closure>>", type(false, void)))
			[param(result, type(false, result))]
			expr-body(
				match-union(
					param-ref(result)
					[
						case(none, call(void, []))
						case(
							some(e)
							call(subscript, [call(exception-handler, [call(get-cur-island, [])]), local-ref(e)]))])))
		fun(
			ctx
			lambda(add-main-task, 0)
			type(true, fut)
			some(param("<<closure>>", type(false, void)))
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(call(add-first-task, [param-ref(all-args), param-ref(main-ptr)])))
		fun(
			noctx
			subscript
			type(false, arr)
			none
			[param(a, type(false, const-ptr)), param(r, type(false, range))]
			expr-body(
				call(
					new
					[
						call(wrap-sub, [call(high, [param-ref(r)]), call(low, [param-ref(r)])])
						call(+, [param-ref(a), call(low, [param-ref(r)])])])))
		fun(
			noctx
			call-with-ctx
			type(true, fut)
			none
			[
				param(f, type(false, fun-act2))
				param(c, type(true, ctx))
				param(p0, type(false, arr))
				param(p1, type(false, fun-ptr2))]
			builtin([type(true, fut), type(false, arr), type(false, fun-ptr2)]))
		fun(
			noctx
			run-threads
			type(false, void)
			none
			[param(n-threads, type(false, nat64)), param(gctx, type(true, global-ctx))]
			expr-body(
				let(
					threads
					call(unmanaged-alloc-elements, [param-ref(n-threads)])
					let(
						thread-args
						call(unmanaged-alloc-elements, [param-ref(n-threads)])
						let(
							actual-n-threads
							call(wrap-sub, [param-ref(n-threads), 1])
							seq(
								seq(
									seq(
										seq(
											call(
												start-threads-recur
												[
													0
													local-ref(actual-n-threads)
													local-ref(threads)
													local-ref(thread-args)
													param-ref(gctx)])
											call(thread-function, [local-ref(actual-n-threads), param-ref(gctx)]))
										call(
											join-threads-recur
											[0, local-ref(actual-n-threads), call(as-const, [local-ref(threads)])]))
									call(unmanaged-free, [local-ref(threads)]))
								call(unmanaged-free, [local-ref(thread-args)])))))))
		fun(
			noctx
			unmanaged-alloc-elements
			type(false, mut-ptr)
			none
			[param(size-elements, type(false, nat64))]
			expr-body(
				call(
					ptr-cast
					[call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])])))
		fun(
			noctx
			ptr-cast
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(false, thread-args), type(false, nat8)]))
		fun(noctx, size-of, type(false, nat64), none, [], builtin([type(false, thread-args)]))
		fun(
			noctx
			start-threads-recur
			type(false, void)
			none
			[
				param(i, type(false, nat64))
				param(n-threads, type(false, nat64))
				param(threads, type(false, mut-ptr))
				param(thread-args-begin, type(false, mut-ptr))
				param(gctx, type(true, global-ctx))]
			expr-body(
				cond(
					call(!=, [param-ref(i), param-ref(n-threads)])
					let(
						thread-arg-ptr
						call(+, [param-ref(thread-args-begin), param-ref(i)])
						seq(
							call(set-deref, [local-ref(thread-arg-ptr), call(new, [param-ref(i), param-ref(gctx)])])
							let(
								thread-ptr
								call(+, [param-ref(threads), param-ref(i)])
								seq(
									call(
										create-one-thread
										[
											call(as-cell, [local-ref(thread-ptr)])
											call(as-any-mut-ptr, [local-ref(thread-arg-ptr)])
											fun-ptr(some(thread-fun))])
									call(
										start-threads-recur
										[
											call(wrap-add, [param-ref(i), 1])
											param-ref(n-threads)
											param-ref(threads)
											param-ref(thread-args-begin)
											param-ref(gctx)])))))
					void)))
		fun(
			noctx
			+
			type(false, mut-ptr)
			none
			[param(a, type(false, mut-ptr)), param(offset, type(false, nat64))]
			builtin([type(false, thread-args)]))
		fun(
			noctx
			set-deref
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(value, type(false, thread-args))]
			builtin([type(false, thread-args)]))
		fun(
			noctx
			new
			type(false, thread-args)
			none
			[param(thread-id, type(false, nat64)), param(gctx, type(true, global-ctx))]
			new-record)
		fun(
			noctx
			create-one-thread
			type(false, void)
			none
			[
				param(tid, type(true, cell))
				param(thread-arg, type(false, mut-ptr))
				param(thread-fun, type(false, fun-ptr1))]
			expr-body(
				let(
					err
					call(pthread_create, [param-ref(tid), call(null, []), param-ref(thread-fun), param-ref(thread-arg)])
					cond(
						call(!=, [local-ref(err), 0])
						cond(call(==, [local-ref(err), call(EAGAIN, [])]), call(todo, []), call(todo, []))
						void))))
		fun(
			noctx
			pthread_create
			type(false, int32)
			none
			[
				param(thread, type(true, cell))
				param(attr, type(false, const-ptr))
				param(start-routine, type(false, fun-ptr1))
				param(arg, type(false, mut-ptr))]
			extern)
		fun(noctx, null, type(false, const-ptr), none, [], expr-body(call(as-const, [call(null, [])])))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(noctx, EAGAIN, type(false, int32), none, [], expr-body(11))
		fun(
			noctx
			as-cell
			type(true, cell)
			none
			[param(a, type(false, mut-ptr))]
			expr-body(call(as-ref, [call(as-any-mut-ptr, [param-ref(a)])])))
		fun(noctx, as-ref, type(true, cell), none, [param(a, type(false, mut-ptr))], builtin([type(true, cell)]))
		fun(
			noctx
			as-any-mut-ptr
			type(false, mut-ptr)
			none
			[param(reference, type(false, mut-ptr))]
			builtin([type(false, mut-ptr)]))
		fun(
			noctx
			thread-fun
			type(false, mut-ptr)
			none
			[param(args-ptr, type(false, mut-ptr))]
			expr-body(
				let(
					args
					call(as-ref, [param-ref(args-ptr)])
					seq(
						call(thread-function, [call(thread-id, [local-ref(args)]), call(gctx, [local-ref(args)])])
						call(null, [])))))
		fun(
			noctx
			as-ref
			type(true, thread-args)
			none
			[param(a, type(false, mut-ptr))]
			builtin([type(true, thread-args)]))
		fun(
			noctx
			thread-function
			type(false, void)
			none
			[param(thread-id, type(false, nat64)), param(gctx, type(true, global-ctx))]
			expr-body(
				let(
					ectx
					call(exception-ctx, [])
					let(
						log-ctx
						call(log-ctx, [])
						let(
							perf-ctx
							call(perf-ctx, [])
							let(
								print-lock
								call(ref-of-val, [call(print-lock, [param-ref(gctx)])])
								let(
									ectx-ptr
									call(as-any-mut-ptr, [call(ref-of-val, [local-ref(ectx)])])
									let(
										log-ctx-ptr
										call(as-any-mut-ptr, [call(ref-of-val, [local-ref(log-ctx)])])
										let(
											perf-ptr
											call(as-any-mut-ptr, [call(ref-of-val, [local-ref(perf-ctx)])])
											let(
												tls
												call(
													new
													[
														param-ref(thread-id)
														local-ref(print-lock)
														local-ref(ectx-ptr)
														local-ref(log-ctx-ptr)
														local-ref(perf-ptr)])
												call(
													thread-function-recur
													[param-ref(gctx), call(ref-of-val, [local-ref(tls)])])))))))))))
		fun(
			noctx
			thread-function-recur
			type(false, void)
			none
			[param(gctx, type(true, global-ctx)), param(tls, type(true, thread-local-stuff))]
			expr-body(
				cond(
					call(is-shut-down, [param-ref(gctx)])
					seq(
						seq(
							seq(
								call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])
								call(
									set-n-live-threads
									[param-ref(gctx), call(wrap-sub, [call(n-live-threads, [param-ref(gctx)]), 1])]))
							call(assert-islands-are-shut-down, [0, call(islands, [param-ref(gctx)])]))
						call(release!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])]))
					seq(
						call(hard-assert, [call(>, [call(n-live-threads, [param-ref(gctx)]), 0])])
						let(
							last-checked
							call(get-sequence, [call(ref-of-val, [call(may-be-work-to-do, [param-ref(gctx)])])])
							seq(
								match-union(
									call(choose-task, [param-ref(gctx)])
									[
										case(some(t), call(do-task, [param-ref(gctx), param-ref(tls), local-ref(t)]))
										case(
											some(n)
											seq(
												seq(
													seq(
														cond(
															call(no-tasks-and-last-thread-out, [local-ref(n)])
															seq(
																seq(
																	call(
																		hard-forbid
																		[call(is-shut-down, [param-ref(gctx)])])
																	call(
																		set-is-shut-down
																		[param-ref(gctx), call(true, [])]))
																call(
																	broadcast!
																	[
																		call(
																			ref-of-val
																			[call(may-be-work-to-do, [param-ref(gctx)])])]))
															call(
																wait-on
																[
																	call(
																		ref-of-val
																		[call(may-be-work-to-do, [param-ref(gctx)])])
																	call(first-task-time, [local-ref(n)])
																	local-ref(last-checked)]))
														call(
															acquire!
															[call(ref-of-val, [call(lk, [param-ref(gctx)])])]))
													call(
														set-n-live-threads
														[
															param-ref(gctx)
															call(wrap-add, [call(n-live-threads, [param-ref(gctx)]), 1])]))
												call(release!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])))])
								call(thread-function-recur, [param-ref(gctx), param-ref(tls)])))))))
		fun(noctx, is-shut-down, type(false, bool), none, [param(a, type(true, global-ctx))], field-get(7))
		fun(noctx, lk, type(false, lock), none, [param(a, type(true, global-ctx))], field-get(0))
		fun(
			noctx
			set-n-live-threads
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(n-live-threads, type(false, nat64))]
			field-set(5))
		fun(noctx, n-live-threads, type(false, nat64), none, [param(a, type(true, global-ctx))], field-get(5))
		fun(
			noctx
			assert-islands-are-shut-down
			type(false, void)
			none
			[param(i, type(false, nat64)), param(islands, type(false, arr))]
			expr-body(
				cond(
					call(!=, [param-ref(i), call(size, [param-ref(islands)])])
					let(
						island
						call(noctx-at, [param-ref(islands), param-ref(i)])
						seq(
							seq(
								seq(
									seq(
										seq(
											call(acquire!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])])
											call(
												hard-forbid
												[call(needs-gc, [call(ref-of-val, [call(gc, [local-ref(island)])])])]))
										call(hard-assert, [call(==, [call(n-threads-running, [local-ref(island)]), 0])]))
									call(hard-assert, [call(is-empty, [call(tasks, [local-ref(island)])])]))
								call(release!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])]))
							call(assert-islands-are-shut-down, [call(wrap-add, [param-ref(i), 1]), param-ref(islands)])))
					void)))
		fun(
			noctx
			noctx-at
			type(true, island)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(
			noctx
			hard-forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(param-ref(condition), call(abort, []), void)))
		fun(noctx, needs-gc, type(false, bool), none, [param(a, type(true, gc))], field-get(3))
		fun(noctx, n-threads-running, type(false, nat64), none, [param(a, type(true, island))], field-get(5))
		fun(
			noctx
			is-empty
			type(false, bool)
			none
			[param(a, type(true, task-queue))]
			expr-body(call(is-empty, [call(head, [param-ref(a)])])))
		fun(
			noctx
			is-empty
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(
				match-union(
					param-ref(a)
					[case(none, call(true, [])), case(some(x), seq(call(drop, [local-ref(x)]), call(false, [])))])))
		fun(noctx, drop, type(false, void), none, [param("_", type(true, task-queue-node))], expr-body(call(void, [])))
		fun(
			noctx
			get-sequence
			type(false, nat64)
			none
			[param(a, type(true, condition))]
			expr-body(
				seq(
					call(
						hard-assert-posix-error
						[call(pthread_mutex_lock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
					let(
						res
						call(sequence, [param-ref(a)])
						seq(
							call(
								hard-assert-posix-error
								[call(pthread_mutex_unlock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
							local-ref(res))))))
		fun(
			noctx
			choose-task
			type(false, choose-task-result)
			none
			[param(gctx, type(true, global-ctx))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])
					let(
						cur-time
						call(get-monotime-nsec, [])
						let(
							res
							match-union(
								call(
									choose-task-recur
									[
										call(islands, [param-ref(gctx)])
										0
										local-ref(cur-time)
										call(false, [])
										call(none, [])])
								[
									case(some(c), call(rslt-chosen-task, [local-ref(c)]))
									case(
										some(n)
										seq(
											call(
												set-n-live-threads
												[
													param-ref(gctx)
													call(wrap-sub, [call(n-live-threads, [param-ref(gctx)]), 1])])
											let(
												no-task-and-last-thread-out
												call(
													&&
													[
														call(no-tasks-and-last-thread-out, [local-ref(n)])
														call(==, [call(n-live-threads, [param-ref(gctx)]), 0])])
												call(
													rslt-no-chosen-task
													[
														call(
															new
															[
																local-ref(no-task-and-last-thread-out)
																call(first-task-time, [local-ref(n)])])]))))])
							seq(call(release!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])]), local-ref(res)))))))
		fun(
			noctx
			get-monotime-nsec
			type(false, nat64)
			none
			[]
			expr-body(
				let(
					time-cell
					call(new, [call(new, [0, 0])])
					let(
						err
						call(clock_gettime, [call(CLOCK_MONOTONIC, []), call(ref-of-val, [local-ref(time-cell)])])
						cond(
							call(==, [local-ref(err), 0])
							let(
								time
								call(*, [call(ref-of-val, [local-ref(time-cell)])])
								call(
									unsafe-to-nat64
									[
										call(
											wrap-add
											[
												call(wrap-mul, [call(tv_sec, [local-ref(time)]), 1000000000])
												call(tv_nsec, [local-ref(time)])])]))
							call(todo, []))))))
		fun(noctx, new, type(false, cell), none, [param(inner-value, type(false, timespec))], new-record)
		fun(
			noctx
			new
			type(false, timespec)
			none
			[param(tv_sec, type(false, int64)), param(tv_nsec, type(false, int64))]
			new-record)
		fun(
			noctx
			clock_gettime
			type(false, int32)
			none
			[param(clock-id, type(false, int32)), param(timespec, type(true, cell))]
			extern)
		fun(noctx, ref-of-val, type(true, cell), none, [param(a, type(false, cell))], builtin([type(true, cell)]))
		fun(
			noctx
			*
			type(false, timespec)
			none
			[param(a, type(true, cell))]
			expr-body(call(inner-value, [param-ref(a)])))
		fun(noctx, inner-value, type(false, timespec), none, [param(a, type(true, cell))], field-get(0))
		fun(
			noctx
			wrap-add
			type(false, int64)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			builtin([]))
		fun(
			noctx
			wrap-mul
			type(false, int64)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			builtin([]))
		fun(noctx, tv_sec, type(false, int64), none, [param(a, type(false, timespec))], field-get(0))
		fun(noctx, tv_nsec, type(false, int64), none, [param(a, type(false, timespec))], field-get(1))
		fun(noctx, todo, type(false, nat64), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(noctx, zeroed, type(false, nat64), none, [], builtin([type(false, nat64)]))
		fun(
			noctx
			choose-task-recur
			type(false, choose-task-result)
			none
			[
				param(islands, type(false, arr))
				param(i, type(false, nat64))
				param(cur-time, type(false, nat64))
				param(any-tasks, type(false, bool))
				param(first-task-time, type(false, opt))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(islands)])])
					call(
						rslt-no-chosen-task
						[call(new, [call(!, [param-ref(any-tasks)]), param-ref(first-task-time)])])
					let(
						island
						call(noctx-at, [param-ref(islands), param-ref(i)])
						let(
							chose
							call(choose-task-in-island, [local-ref(island), param-ref(cur-time)])
							match-union(
								local-ref(chose)
								[
									case(
										some(t)
										call(
											rslt-chosen-task
											[call(new, [local-ref(island), call(togc-task, [local-ref(t)])])]))
									case(
										none
										call(rslt-chosen-task, [call(new, [local-ref(island), call(do-a-gc, [])])]))
									case(
										some(n)
										let(
											new-any-tasks
											call(||, [param-ref(any-tasks), call(any-tasks, [local-ref(n)])])
											let(
												new-first-task-time
												call(
													min-time
													[param-ref(first-task-time), call(first-task-time, [local-ref(n)])])
												call(
													choose-task-recur
													[
														param-ref(islands)
														call(wrap-add, [param-ref(i), 1])
														param-ref(cur-time)
														local-ref(new-any-tasks)
														local-ref(new-first-task-time)]))))]))))))
		fun(
			noctx
			rslt-no-chosen-task
			type(false, choose-task-result)
			none
			[param(a, type(false, no-chosen-task))]
			new-union)
		fun(
			noctx
			new
			type(false, no-chosen-task)
			none
			[param(no-tasks-and-last-thread-out, type(false, bool)), param(first-task-time, type(false, opt))]
			new-record)
		fun(
			noctx
			choose-task-in-island
			type(false, choose-task-in-island-result)
			none
			[param(island, type(true, island)), param(cur-time, type(false, nat64))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(tasks-lock, [param-ref(island)])])])
					let(
						res
						cond(
							call(needs-gc, [call(ref-of-val, [call(gc, [param-ref(island)])])])
							cond(
								call(==, [call(n-threads-running, [param-ref(island)]), 0])
								call(do-a-gc, [])
								call(tii-no-task, [call(new, [call(true, []), call(none, [])])]))
							match-union(
								call(pop-task!, [call(tasks, [param-ref(island)]), param-ref(cur-time)])
								[
									case(some(t), call(tii-task, [local-ref(t)]))
									case(some(n), call(tii-no-task, [local-ref(n)]))]))
						seq(
							seq(
								cond(
									call(!, [call(is-no-task, [local-ref(res)])])
									call(
										set-n-threads-running
										[
											param-ref(island)
											call(wrap-add, [call(n-threads-running, [param-ref(island)]), 1])])
									void)
								call(release!, [call(ref-of-val, [call(tasks-lock, [param-ref(island)])])]))
							local-ref(res))))))
		fun(noctx, do-a-gc, type(false, choose-task-in-island-result), none, [], new-union)
		fun(
			noctx
			tii-no-task
			type(false, choose-task-in-island-result)
			none
			[param(a, type(false, no-task))]
			new-union)
		fun(
			noctx
			new
			type(false, no-task)
			none
			[param(any-tasks, type(false, bool)), param(first-task-time, type(false, opt))]
			new-record)
		fun(noctx, none, type(false, opt), none, [], new-union)
		fun(
			noctx
			pop-task!
			type(false, pop-task-result)
			none
			[param(a, type(true, task-queue)), param(cur-time, type(false, nat64))]
			expr-body(
				let(
					exclusions
					call(ref-of-val, [call(currently-running-exclusions, [param-ref(a)])])
					let(
						res
						match-union(
							call(head, [param-ref(a)])
							[
								case(none, call(ptr-no-task, [call(new, [call(false, []), call(none, [])])]))
								case(
									some(head)
									let(
										task
										call(task, [local-ref(head)])
										cond(
											call(<=, [call(time, [local-ref(task)]), param-ref(cur-time)])
											cond(
												call(in, [call(exclusion, [local-ref(task)]), local-ref(exclusions)])
												call(
													pop-recur!
													[
														local-ref(head)
														local-ref(exclusions)
														param-ref(cur-time)
														call(to-opt-time, [call(time, [local-ref(task)])])])
												seq(
													call(set-head, [param-ref(a), call(next, [local-ref(head)])])
													call(ptr-task, [call(task, [local-ref(head)])])))
											call(
												ptr-no-task
												[
													call(
														new
														[call(true, []), call(some, [call(time, [local-ref(task)])])])]))))])
						seq(
							match-union(
								local-ref(res)
								[
									case(
										some(t)
										call(
											push-capacity-must-be-sufficient!
											[local-ref(exclusions), call(exclusion, [local-ref(t)])]))
									case(none, call(void, []))])
							local-ref(res))))))
		fun(
			noctx
			ref-of-val
			type(true, mut-arr)
			none
			[param(a, type(false, mut-arr))]
			builtin([type(true, mut-arr)]))
		fun(
			noctx
			currently-running-exclusions
			type(false, mut-arr)
			none
			[param(a, type(true, task-queue))]
			field-get(1))
		fun(noctx, ptr-no-task, type(false, pop-task-result), none, [param(a, type(false, no-task))], new-union)
		fun(
			noctx
			in
			type(false, bool)
			none
			[param(value, type(false, nat64)), param(a, type(true, mut-arr))]
			expr-body(call(in, [param-ref(value), call(temp-as-arr, [param-ref(a)])])))
		fun(
			noctx
			in
			type(false, bool)
			none
			[param(value, type(false, nat64)), param(a, type(false, arr))]
			expr-body(call(in-recur, [param-ref(value), param-ref(a), 0])))
		fun(
			noctx
			in-recur
			type(false, bool)
			none
			[param(value, type(false, nat64)), param(a, type(false, arr)), param(i, type(false, nat64))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(a)])])
					call(false, [])
					cond(
						call(==, [call(noctx-at, [param-ref(a), param-ref(i)]), param-ref(value)])
						call(true, [])
						call(in-recur, [param-ref(value), param-ref(a), call(wrap-add, [param-ref(i), 1])])))))
		fun(noctx, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			noctx
			noctx-at
			type(false, nat64)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(
			noctx
			unsafe-at
			type(false, nat64)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])))
		fun(
			noctx
			subscript
			type(false, nat64)
			none
			[param(a, type(false, const-ptr)), param(n, type(false, nat64))]
			expr-body(call(*, [call(+, [param-ref(a), param-ref(n)])])))
		fun(
			noctx
			*
			type(false, nat64)
			none
			[param(a, type(false, const-ptr))]
			expr-body(call(*, [call(as-mut, [param-ref(a)])])))
		fun(noctx, *, type(false, nat64), none, [param(a, type(false, mut-ptr))], builtin([type(false, nat64)]))
		fun(noctx, begin-ptr, type(false, const-ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			noctx
			temp-as-arr
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(temp-as-arr, [call(temp-as-fix-arr, [param-ref(a)])])))
		fun(
			noctx
			temp-as-arr
			type(false, arr)
			none
			[param(a, type(false, fix-arr))]
			expr-body(call(inner, [param-ref(a)])))
		fun(noctx, inner, type(false, arr), none, [param(a, type(false, fix-arr))], field-get(0))
		fun(
			noctx
			temp-as-fix-arr
			type(false, fix-arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(subscript, [call(begin-ptr, [param-ref(a)]), call(.., [0, call(size, [param-ref(a)])])])))
		fun(
			noctx
			begin-ptr
			type(false, mut-ptr)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(begin-ptr, [call(backing, [param-ref(a)])])))
		fun(
			noctx
			begin-ptr
			type(false, mut-ptr)
			none
			[param(a, type(false, fix-arr))]
			expr-body(call(as-mut, [call(begin-ptr, [call(inner, [param-ref(a)])])])))
		fun(noctx, backing, type(false, fix-arr), none, [param(a, type(true, mut-arr))], field-get(0))
		fun(noctx, size, type(false, nat64), none, [param(a, type(true, mut-arr))], field-get(1))
		fun(noctx, exclusion, type(false, nat64), none, [param(a, type(false, task))], field-get(1))
		fun(
			noctx
			pop-recur!
			type(false, pop-task-result)
			none
			[
				param(prev, type(true, task-queue-node))
				param(exclusions, type(true, mut-arr))
				param(cur-time, type(false, nat64))
				param(first-task-time, type(false, opt))]
			expr-body(
				match-union(
					call(next, [param-ref(prev)])
					[
						case(none, call(ptr-no-task, [call(new, [call(true, []), param-ref(first-task-time)])]))
						case(
							some(cur)
							let(
								task
								call(task, [local-ref(cur)])
								cond(
									call(<=, [call(time, [local-ref(task)]), param-ref(cur-time)])
									cond(
										call(in, [call(exclusion, [local-ref(task)]), param-ref(exclusions)])
										call(
											pop-recur!
											[
												local-ref(cur)
												param-ref(exclusions)
												param-ref(cur-time)
												match-union(
													param-ref(first-task-time)
													[
														case(none, call(to-opt-time, [call(time, [local-ref(task)])]))
														case(some(t), call(some, [local-ref(t)]))])])
										seq(
											call(set-next, [param-ref(prev), call(next, [local-ref(cur)])])
											call(ptr-task, [local-ref(task)])))
									call(
										ptr-no-task
										[call(new, [call(true, []), call(some, [call(time, [local-ref(task)])])])]))))])))
		fun(
			noctx
			to-opt-time
			type(false, opt)
			none
			[param(a, type(false, nat64))]
			expr-body(
				cond(call(!=, [param-ref(a), call(no-timestamp, [])]), call(some, [param-ref(a)]), call(none, []))))
		fun(noctx, some, type(false, opt), none, [param(a, type(false, nat64))], new-union)
		fun(noctx, ptr-task, type(false, pop-task-result), none, [param(a, type(false, task))], new-union)
		fun(
			noctx
			push-capacity-must-be-sufficient!
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat64))]
			expr-body(
				seq(
					seq(
						call(hard-assert, [call(<, [call(size, [param-ref(a)]), call(capacity, [param-ref(a)])])])
						call(
							set-subscript
							[call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)]), param-ref(value)]))
					call(set-size, [param-ref(a), call(wrap-add, [call(size, [param-ref(a)]), 1])]))))
		fun(
			noctx
			capacity
			type(false, nat64)
			none
			[param(a, type(true, mut-arr))]
			expr-body(call(size, [call(backing, [param-ref(a)])])))
		fun(
			noctx
			size
			type(false, nat64)
			none
			[param(a, type(false, fix-arr))]
			expr-body(call(size, [call(inner, [param-ref(a)])])))
		fun(
			noctx
			set-subscript
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(n, type(false, nat64)), param(value, type(false, nat64))]
			expr-body(call(set-deref, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			noctx
			set-deref
			type(false, void)
			none
			[param(a, type(false, mut-ptr)), param(value, type(false, nat64))]
			builtin([type(false, nat64)]))
		fun(
			noctx
			set-size
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(size, type(false, nat64))]
			field-set(1))
		fun(noctx, tii-task, type(false, choose-task-in-island-result), none, [param(a, type(false, task))], new-union)
		fun(
			noctx
			is-no-task
			type(false, bool)
			none
			[param(a, type(false, choose-task-in-island-result))]
			expr-body(
				match-union(
					param-ref(a)
					[case(none, call(false, [])), case(none, call(false, [])), case(none, call(true, []))])))
		fun(
			noctx
			set-n-threads-running
			type(false, void)
			none
			[param(a, type(true, island)), param(n-threads-running, type(false, nat64))]
			field-set(5))
		fun(
			noctx
			rslt-chosen-task
			type(false, choose-task-result)
			none
			[param(a, type(false, chosen-task))]
			new-union)
		fun(
			noctx
			new
			type(false, chosen-task)
			none
			[param(task-island, type(true, island)), param(task-or-gc, type(false, task-or-gc))]
			new-record)
		fun(noctx, togc-task, type(false, task-or-gc), none, [param(a, type(false, task))], new-union)
		fun(noctx, do-a-gc, type(false, task-or-gc), none, [], new-union)
		fun(noctx, any-tasks, type(false, bool), none, [param(a, type(false, no-task))], field-get(0))
		fun(
			noctx
			min-time
			type(false, opt)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(
				match-union(
					param-ref(a)
					[
						case(none, param-ref(b))
						case(
							some(ta)
							match-union(
								param-ref(b)
								[
									case(none, call(none, []))
									case(some(tb), call(some, [call(min, [local-ref(ta), local-ref(tb)])]))]))])))
		fun(
			noctx
			min
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(cond(call(<, [param-ref(a), param-ref(b)]), param-ref(a), param-ref(b))))
		fun(noctx, first-task-time, type(false, opt), none, [param(a, type(false, no-task))], field-get(1))
		fun(
			noctx
			no-tasks-and-last-thread-out
			type(false, bool)
			none
			[param(a, type(false, no-chosen-task))]
			field-get(0))
		fun(noctx, first-task-time, type(false, opt), none, [param(a, type(false, no-chosen-task))], field-get(1))
		fun(
			noctx
			do-task
			type(false, void)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(chosen-task, type(false, chosen-task))]
			expr-body(
				let(
					island
					call(task-island, [param-ref(chosen-task)])
					seq(
						seq(
							seq(
								match-union(
									call(task-or-gc, [param-ref(chosen-task)])
									[
										case(
											some(task)
											let(
												ctx
												call(
													new-ctx
													[
														param-ref(gctx)
														param-ref(tls)
														local-ref(island)
														call(exclusion, [local-ref(task)])])
												seq(
													seq(
														seq(
															seq(
																call(
																	call-with-ctx
																	[
																		call(action, [local-ref(task)])
																		call(ref-of-val, [local-ref(ctx)])])
																call(
																	acquire!
																	[
																		call(
																			ref-of-val
																			[call(tasks-lock, [local-ref(island)])])]))
															call(
																return-task!
																[call(tasks, [local-ref(island)]), local-ref(task)]))
														call(
															release!
															[call(ref-of-val, [call(tasks-lock, [local-ref(island)])])]))
													call(return-ctx, [call(ref-of-val, [local-ref(ctx)])]))))
										case(
											none
											seq(
												call(
													run-garbage-collection
													[
														call(ref-of-val, [call(gc, [local-ref(island)])])
														call(gc-root, [local-ref(island)])])
												call(
													broadcast!
													[call(ref-of-val, [call(may-be-work-to-do, [param-ref(gctx)])])])))])
								call(acquire!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])]))
							call(
								set-n-threads-running
								[local-ref(island), call(wrap-sub, [call(n-threads-running, [local-ref(island)]), 1])]))
						call(release!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])])))))
		fun(noctx, task-island, type(true, island), none, [param(a, type(false, chosen-task))], field-get(0))
		fun(noctx, task-or-gc, type(false, task-or-gc), none, [param(a, type(false, chosen-task))], field-get(1))
		fun(noctx, action, type(false, fun-act0), none, [param(a, type(false, task))], field-get(2))
		fun(
			noctx
			return-task!
			type(false, void)
			none
			[param(a, type(true, task-queue)), param(task, type(false, task))]
			expr-body(
				call(
					noctx-must-remove-unordered!
					[
						call(ref-of-val, [call(currently-running-exclusions, [param-ref(a)])])
						call(exclusion, [param-ref(task)])])))
		fun(
			noctx
			noctx-must-remove-unordered!
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat64))]
			expr-body(call(noctx-must-remove-unordered-recur!, [param-ref(a), 0, param-ref(value)])))
		fun(
			noctx
			noctx-must-remove-unordered-recur!
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat64)), param(value, type(false, nat64))]
			expr-body(
				cond(
					call(==, [param-ref(index), call(size, [param-ref(a)])])
					call(todo, [])
					cond(
						call(
							==
							[call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)]), param-ref(value)])
						call(drop, [call(noctx-remove-unordered-at!, [param-ref(a), param-ref(index)])])
						call(
							noctx-must-remove-unordered-recur!
							[param-ref(a), call(wrap-add, [param-ref(index), 1]), param-ref(value)])))))
		fun(
			noctx
			subscript
			type(false, nat64)
			none
			[param(a, type(false, mut-ptr)), param(n, type(false, nat64))]
			expr-body(call(*, [call(+, [param-ref(a), param-ref(n)])])))
		fun(noctx, drop, type(false, void), none, [param("_", type(false, nat64))], expr-body(call(void, [])))
		fun(
			noctx
			noctx-remove-unordered-at!
			type(false, nat64)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					let(
						res
						call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])
						let(
							new-size
							call(wrap-sub, [call(size, [param-ref(a)]), 1])
							seq(
								seq(
									call(
										set-subscript
										[
											call(begin-ptr, [param-ref(a)])
											param-ref(index)
											call(subscript, [call(begin-ptr, [param-ref(a)]), local-ref(new-size)])])
									call(set-size, [param-ref(a), local-ref(new-size)]))
								local-ref(res)))))))
		fun(
			noctx
			return-ctx
			type(false, void)
			none
			[param(c, type(true, ctx))]
			expr-body(call(return-gc-ctx, [call(as-ref, [call(gc-ctx-ptr, [param-ref(c)])])])))
		fun(
			noctx
			return-gc-ctx
			type(false, void)
			none
			[param(gc-ctx, type(true, gc-ctx))]
			expr-body(
				let(
					gc
					call(gc, [param-ref(gc-ctx)])
					seq(
						seq(
							seq(
								call(acquire!, [call(ref-of-val, [call(lk, [local-ref(gc)])])])
								call(set-next-ctx, [param-ref(gc-ctx), call(context-head, [local-ref(gc)])]))
							call(set-context-head, [local-ref(gc), call(some, [param-ref(gc-ctx)])]))
						call(release!, [call(ref-of-val, [call(lk, [local-ref(gc)])])])))))
		fun(noctx, some, type(false, opt), none, [param(a, type(true, gc-ctx))], new-union)
		fun(
			noctx
			run-garbage-collection
			type(false, void)
			none
			[param(gc, type(true, gc)), param(gc-root, type(false, island-gc-root))]
			expr-body(
				seq(
					seq(
						seq(
							call(hard-assert, [call(needs-gc, [param-ref(gc)])])
							call(set-gc-count, [param-ref(gc), call(wrap-add, [call(gc-count, [param-ref(gc)]), 1])]))
						call(
							drop
							[
								call(
									memset
									[
										call(as-any-mut-ptr, [call(mark-begin, [param-ref(gc)])])
										0
										call(size-words, [param-ref(gc)])])]))
					let(
						mark-ctx
						call(
							new
							[
								call(size-words, [param-ref(gc)])
								call(mark-begin, [param-ref(gc)])
								call(data-begin, [param-ref(gc)])])
						seq(
							call(mark-visit, [call(ref-of-val, [local-ref(mark-ctx)]), param-ref(gc-root)])
							let(
								prev-mark-cur
								call(mark-cur, [param-ref(gc)])
								seq(
									seq(
										seq(
											seq(
												call(set-mark-cur, [param-ref(gc), call(mark-begin, [param-ref(gc)])])
												call(set-data-cur, [param-ref(gc), call(data-begin, [param-ref(gc)])]))
											call(
												clear-free-mem!
												[
													call(mark-begin, [param-ref(gc)])
													local-ref(prev-mark-cur)
													call(data-begin, [param-ref(gc)])]))
										call(validate-gc, [param-ref(gc)]))
									call(set-needs-gc, [param-ref(gc), call(false, [])]))))))))
		fun(
			noctx
			set-gc-count
			type(false, void)
			none
			[param(a, type(true, gc)), param(gc-count, type(false, nat64))]
			field-set(1))
		fun(noctx, gc-count, type(false, nat64), none, [param(a, type(true, gc))], field-get(1))
		fun(
			noctx
			new
			type(false, mark-ctx)
			none
			[
				param(memory-size-words, type(false, nat64))
				param(marks, type(false, mut-ptr))
				param(memory-start, type(false, mut-ptr))]
			new-record)
		fun(
			noctx
			mark-visit
			type(false, void)
			none
			[param(mark-ctx, type(true, mark-ctx)), param(value, type(false, island-gc-root))]
			builtin([type(false, island-gc-root)]))
		fun(
			noctx
			ref-of-val
			type(true, mark-ctx)
			none
			[param(a, type(false, mark-ctx))]
			builtin([type(true, mark-ctx)]))
		fun(
			noctx
			clear-free-mem!
			type(false, void)
			none
			[
				param(mark-ptr, type(false, mut-ptr))
				param(mark-end, type(false, mut-ptr))
				param(data-ptr, type(false, mut-ptr))]
			expr-body(
				cond(
					call(!=, [param-ref(mark-ptr), param-ref(mark-end)])
					seq(
						cond(call(!, [call(*, [param-ref(mark-ptr)])]), call(set-deref, [param-ref(data-ptr), -369582283799201058]), void)
						call(
							clear-free-mem!
							[call(+, [param-ref(mark-ptr), 1]), param-ref(mark-end), param-ref(data-ptr)]))
					void)))
		fun(
			noctx
			!=
			type(false, bool)
			none
			[param(a, type(false, mut-ptr)), param(b, type(false, mut-ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			noctx
			set-is-shut-down
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(is-shut-down, type(false, bool))]
			field-set(7))
		fun(
			noctx
			wait-on
			type(false, void)
			none
			[
				param(a, type(true, condition))
				param(until-time, type(false, opt))
				param(last-sequence, type(false, nat64))]
			expr-body(
				seq(
					seq(
						call(
							hard-assert-posix-error
							[call(pthread_mutex_lock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
						cond(
							call(==, [call(sequence, [param-ref(a)]), param-ref(last-sequence)])
							call(
								hard-assert-posix-error
								[
									match-union(
										param-ref(until-time)
										[
											case(
												none
												call(
													pthread_cond_wait
													[
														call(ref-of-val, [call(cond, [param-ref(a)])])
														call(ref-of-val, [call(mutex, [param-ref(a)])])]))
											case(
												some(t)
												let(
													abstime
													call(to-timespec, [local-ref(t)])
													let(
														err
														call(
															pthread_cond_timedwait
															[
																call(ref-of-val, [call(cond, [param-ref(a)])])
																call(ref-of-val, [call(mutex, [param-ref(a)])])
																call(ptr-to, [local-ref(abstime)])])
														cond(
															call(==, [local-ref(err), call(ETIMEDOUT, [])])
															0
															local-ref(err)))))])])
							void))
					call(
						hard-assert-posix-error
						[call(pthread_mutex_unlock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])]))))
		fun(
			noctx
			pthread_cond_wait
			type(false, int32)
			none
			[param(cond, type(true, pthread_cond_t)), param(mutex, type(true, pthread_mutex_t))]
			extern)
		fun(
			noctx
			to-timespec
			type(false, timespec)
			none
			[param(a, type(false, nat64))]
			expr-body(
				let(
					seconds
					call(unsafe-to-int64, [call(unsafe-div, [param-ref(a), 1000000000])])
					let(
						ns
						call(unsafe-to-int64, [call(unsafe-mod, [param-ref(a), 1000000000])])
						call(new, [local-ref(seconds), local-ref(ns)])))))
		fun(
			noctx
			unsafe-mod
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			noctx
			pthread_cond_timedwait
			type(false, int32)
			none
			[
				param(cond, type(true, pthread_cond_t))
				param(mutex, type(true, pthread_mutex_t))
				param(abstime, type(false, const-ptr))]
			extern)
		fun(
			noctx
			ptr-to
			type(false, const-ptr)
			none
			[param(a, type(false, timespec))]
			builtin([type(false, timespec)]))
		fun(noctx, ETIMEDOUT, type(false, int32), none, [], expr-body(110))
		fun(noctx, thread-id, type(false, nat64), none, [param(a, type(true, thread-args))], field-get(0))
		fun(noctx, gctx, type(true, global-ctx), none, [param(a, type(true, thread-args))], field-get(1))
		fun(
			noctx
			join-threads-recur
			type(false, void)
			none
			[param(i, type(false, nat64)), param(n-threads, type(false, nat64)), param(threads, type(false, const-ptr))]
			expr-body(
				cond(
					call(!=, [param-ref(i), param-ref(n-threads)])
					seq(
						call(join-one-thread, [call(subscript, [param-ref(threads), param-ref(i)])])
						call(
							join-threads-recur
							[call(wrap-add, [param-ref(i), 1]), param-ref(n-threads), param-ref(threads)]))
					void)))
		fun(
			noctx
			join-one-thread
			type(false, void)
			none
			[param(tid, type(false, nat64))]
			expr-body(
				let(
					thread-return
					call(new, [call(null, [])])
					let(
						err
						call(pthread_join, [param-ref(tid), call(ref-of-val, [local-ref(thread-return)])])
						seq(
							cond(
								call(!=, [local-ref(err), 0])
								cond(
									call(==, [local-ref(err), call(EINVAL, [])])
									call(todo, [])
									cond(call(==, [local-ref(err), call(ESRCH, [])]), call(todo, []), call(todo, [])))
								void)
							call(
								hard-assert
								[call(==, [call(*, [call(ref-of-val, [local-ref(thread-return)])]), call(null, [])])]))))))
		fun(noctx, new, type(false, cell), none, [param(inner-value, type(false, mut-ptr))], new-record)
		fun(
			noctx
			pthread_join
			type(false, int32)
			none
			[param(thread, type(false, nat64)), param(thread-return, type(true, cell))]
			extern)
		fun(noctx, ref-of-val, type(true, cell), none, [param(a, type(false, cell))], builtin([type(true, cell)]))
		fun(noctx, EINVAL, type(false, int32), none, [], expr-body(22))
		fun(noctx, ESRCH, type(false, int32), none, [], expr-body(3))
		fun(
			noctx
			*
			type(false, mut-ptr)
			none
			[param(a, type(true, cell))]
			expr-body(call(inner-value, [param-ref(a)])))
		fun(noctx, inner-value, type(false, mut-ptr), none, [param(a, type(true, cell))], field-get(0))
		fun(
			noctx
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, mut-ptr))]
			expr-body(call(free, [call(as-any-mut-ptr, [param-ref(p)])])))
		fun(noctx, free, type(false, void), none, [param(p, type(false, mut-ptr))], extern)
		fun(
			noctx
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, mut-ptr))]
			expr-body(call(free, [call(as-any-mut-ptr, [param-ref(p)])])))
		fun(
			noctx
			destroy-condition
			type(false, void)
			none
			[param(a, type(true, condition))]
			expr-body(
				seq(
					seq(
						seq(
							call(
								hard-assert-posix-error
								[
									call(
										pthread_mutexattr_destroy
										[call(ref-of-val, [call(mutex-attr, [param-ref(a)])])])])
							call(
								hard-assert-posix-error
								[call(pthread_mutex_destroy, [call(ref-of-val, [call(mutex, [param-ref(a)])])])]))
						call(
							hard-assert-posix-error
							[call(pthread_condattr_destroy, [call(ref-of-val, [call(cond-attr, [param-ref(a)])])])]))
					call(
						hard-assert-posix-error
						[call(pthread_cond_destroy, [call(ref-of-val, [call(cond, [param-ref(a)])])])]))))
		fun(
			noctx
			pthread_mutexattr_destroy
			type(false, int32)
			none
			[param(attr, type(true, pthread_mutexattr_t))]
			extern)
		fun(noctx, pthread_mutex_destroy, type(false, int32), none, [param(mutex, type(true, pthread_mutex_t))], extern)
		fun(
			noctx
			pthread_condattr_destroy
			type(false, int32)
			none
			[param(attr, type(true, pthread_condattr_t))]
			extern)
		fun(noctx, pthread_cond_destroy, type(false, int32), none, [param(cond, type(true, pthread_cond_t))], extern)
		fun(
			noctx
			exit-code-from-main-fut
			type(false, int32)
			none
			[param(gctx, type(true, global-ctx)), param(main-fut, type(true, fut))]
			expr-body(
				match-union(
					call(state, [param-ref(main-fut)])
					[
						case(none, 1)
						case(none, 1)
						case(
							some(r)
							cond(
								call(any-unhandled-exceptions, [param-ref(gctx)])
								1
								call(unsafe-to-int32, [call(nat64-to-int64, [local-ref(r)])])))
						case(none, 1)])))
		fun(noctx, any-unhandled-exceptions, type(false, bool), none, [param(a, type(true, global-ctx))], field-get(8))
		fun(
			noctx
			nat64-to-int64
			type(false, int64)
			none
			[param(a, type(false, nat64))]
			expr-body(call(unsafe-to-int64, [param-ref(a)])))
		fun(
			ctx
			main
			type(true, fut)
			none
			[param("_", type(false, arr))]
			expr-body(
				let(
					m
					call(new, [1, 2])
					seq(
						seq(
							seq(
								seq(
									call(assert, [call(==, [call(x, [local-ref(m)]), 1])])
									call(assert, [call(==, [call(y, [local-ref(m)]), 2])]))
								call(print, [call(to-str, [call(x, [local-ref(m)])])]))
							call(print, [call(to-str, [call(y, [local-ref(m)])])]))
						call(resolved, [0])))))
		fun(
			ctx
			new
			type(false, my-record)
			none
			[param(x, type(false, nat64)), param(y, type(false, nat64))]
			new-record)
		fun(noctx, x, type(false, nat64), none, [param(a, type(false, my-record))], field-get(0))
		fun(noctx, y, type(false, nat64), none, [param(a, type(false, my-record))], field-get(1))
		fun(
			ctx
			to-str
			type(false, str)
			none
			[param(a, type(false, nat64))]
			expr-body(call(to-base, [param-ref(a), 10])))
		fun(
			ctx
			to-base
			type(false, str)
			none
			[param(a, type(false, nat64)), param(base, type(false, nat64))]
			expr-body(
				cond(
					call(<, [param-ref(a), param-ref(base)])
					call(digit-to-str, [param-ref(a)])
					call(
						~
						[
							call(to-base, [call(/, [param-ref(a), param-ref(base)]), param-ref(base)])
							call(digit-to-str, [call(mod, [param-ref(a), param-ref(base)])])]))))
		fun(
			ctx
			digit-to-str
			type(false, str)
			none
			[param(a, type(false, nat64))]
			expr-body(
				cond(
					call(==, [param-ref(a), 0])
					record([arr(0, 10)])
					cond(
						call(==, [param-ref(a), 1])
						record([arr(0, 11)])
						cond(
							call(==, [param-ref(a), 2])
							record([arr(0, 12)])
							cond(
								call(==, [param-ref(a), 3])
								record([arr(0, 13)])
								cond(
									call(==, [param-ref(a), 4])
									record([arr(0, 14)])
									cond(
										call(==, [param-ref(a), 5])
										record([arr(0, 15)])
										cond(
											call(==, [param-ref(a), 6])
											record([arr(0, 16)])
											cond(
												call(==, [param-ref(a), 7])
												record([arr(0, 17)])
												cond(
													call(==, [param-ref(a), 8])
													record([arr(0, 18)])
													cond(
														call(==, [param-ref(a), 9])
														record([arr(0, 19)])
														cond(
															call(==, [param-ref(a), 10])
															record([arr(0, 20)])
															cond(
																call(==, [param-ref(a), 11])
																record([arr(0, 21)])
																cond(
																	call(==, [param-ref(a), 12])
																	record([arr(0, 22)])
																	cond(
																		call(==, [param-ref(a), 13])
																		record([arr(0, 23)])
																		cond(
																			call(==, [param-ref(a), 14])
																			record([arr(0, 24)])
																			cond(
																				call(==, [param-ref(a), 15])
																				record([arr(0, 25)])
																				record([arr(0, 26)])))))))))))))))))))
		fun(
			ctx
			mod
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(seq(call(forbid, [call(==, [param-ref(b), 0])]), call(unsafe-mod, [param-ref(a), param-ref(b)]))))
		fun(
			ctx
			resolved
			type(true, fut)
			none
			[param(value, type(false, nat64))]
			expr-body(call(new, [call(lock-by-val, []), call(fut-state-resolved, [param-ref(value)])])))
		fun(noctx, static-syms, type(false, arr), none, [], builtin([]))]
	rt-main
	main
	ctx)
