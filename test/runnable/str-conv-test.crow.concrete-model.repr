program(
	[
		struct(
			name: ctx
			ptr?: true
			body: record(
				[
					field(gctx-ptr, false, type(false, ptr))
					field(island-id, false, type(false, nat64))
					field(exclusion, false, type(false, nat64))
					field(gc-ctx-ptr, false, type(false, ptr))
					field(thread-local-stuff, false, type(true, thread-local-stuff))]))
		struct(name: nat8, body: builtin(nat-8, []))
		struct(name: ptr, body: builtin(ptr, [type(false, nat8)]))
		struct(name: nat64, body: builtin(nat-64, []))
		struct(
			name: thread-local-stuff
			ptr?: true
			body: record(
				[
					field(thread-id, false, type(false, nat64))
					field(print-lock, false, type(true, lock))
					field(exception-ctx-ptr, false, type(false, ptr))
					field(log-ctx-ptr, false, type(false, ptr))
					field(perf-ctx-ptr, false, type(false, ptr))]))
		struct(name: lock, ptr?: true, body: record([field(is-locked, false, type(false, atomic-bool))]))
		struct(name: atomic-bool, mut?: true, ptr?: true, body: record([field(value, true, type(false, bool))]))
		struct(name: bool, body: builtin(bool, []))
		struct(
			name: mark-ctx
			ptr?: true
			body: record(
				[
					field(memory-size-words, false, type(false, nat64))
					field(marks, false, type(false, ptr))
					field(memory-start, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, bool)]))
		struct(name: ptr, body: builtin(ptr, [type(false, nat64)]))
		struct(name: void, body: builtin(void, []))
		struct(name: comparison, body: union([type(false, less), type(false, equal), type(false, greater)]))
		struct(name: less, body: record([]))
		struct(name: equal, body: record([]))
		struct(name: greater, body: record([]))
		struct(name: int32, body: builtin(int-32, []))
		struct(name: char, body: builtin(char, []))
		struct(name: ptr, body: builtin(ptr, [type(false, char)]))
		struct(name: ptr, body: builtin(ptr, [type(false, ptr)]))
		struct(
			name: fut
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(state, true, type(false, fut-state))]))
		struct(
			name: fut-state
			body: union(
				[
					type(false, fut-state-no-callbacks)
					type(true, fut-state-callbacks)
					type(false, fut-state-resolved)
					type(false, exception)]))
		struct(name: fut-state-no-callbacks, body: record([]))
		struct(
			name: fut-state-callbacks
			ptr?: true
			body: record([field(cb, false, type(false, fun-act1)), field(next, false, type(false, opt))]))
		struct(
			name: exception
			body: record([field(message, false, type(false, str)), field(backtrace, false, type(false, backtrace))]))
		struct(name: str, body: record([field(chars, false, type(false, arr))]))
		struct(
			name: arr
			body: record([field(size, false, type(false, nat64)), field(begin-ptr, false, type(false, ptr))]))
		struct(name: backtrace, body: record([field(return-stack, false, type(false, arr))]))
		struct(
			name: arr
			body: record([field(size, false, type(false, nat64)), field(begin-ptr, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, str)]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, nat64))]))
		struct(name: err, body: record([field(value, false, type(false, exception))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, result)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: none, body: record([]))
		struct(name: some, body: record([field(value, false, type(true, fut-state-callbacks))]))
		struct(name: fut-state-resolved, body: record([field(value, false, type(false, nat64))]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, arr)]))
		struct(
			name: global-ctx
			mut?: true
			ptr?: true
			body: record(
				[
					field(lk, false, type(false, lock))
					field(print-lock, false, type(false, lock))
					field(syms-lock, false, type(false, lock))
					field(dynamic-syms, true, type(false, opt))
					field(islands, true, type(false, arr))
					field(n-live-threads, true, type(false, nat64))
					field(may-be-work-to-do, false, type(false, condition))
					field(shut-down?, true, type(false, bool))
					field(any-unhandled-exceptions?, true, type(false, bool))]))
		struct(
			name: dynamic-sym-node
			ptr?: true
			body: record([field(sym, false, type(false, sym)), field(next, false, type(false, opt))]))
		struct(name: sym, body: record([field(to-c-str, false, type(false, ptr))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, dynamic-sym-node))]))
		struct(
			name: island
			mut?: true
			ptr?: true
			body: record(
				[
					field(gctx, false, type(true, global-ctx))
					field(id, false, type(false, nat64))
					field(gc, false, type(false, gc))
					field(gc-root, false, type(false, island-gc-root))
					field(tasks-lock, false, type(false, lock))
					field(n-threads-running, true, type(false, nat64))
					field(next-exclusion, false, type(false, thread-safe-counter))]))
		struct(
			name: gc
			mut?: true
			ptr?: true
			body: record(
				[
					field(lk, false, type(false, lock))
					field(gc-count, true, type(false, nat64))
					field(context-head, true, type(false, opt))
					field(needs-gc?, true, type(false, bool))
					field(size-words, true, type(false, nat64))
					field(mark-begin, false, type(false, ptr))
					field(mark-cur, true, type(false, ptr))
					field(mark-end, true, type(false, ptr))
					field(data-begin, false, type(false, ptr))
					field(data-cur, true, type(false, ptr))
					field(data-end, true, type(false, ptr))]))
		struct(
			name: gc-ctx
			mut?: true
			ptr?: true
			body: record([field(gc, true, type(true, gc)), field(next-ctx, true, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, gc-ctx))]))
		struct(
			name: island-gc-root
			mut?: true
			ptr?: true
			body: record(
				[
					field(tasks, false, type(false, task-queue))
					field(exception-handler, true, type(false, fun1))
					field(log-handler, true, type(false, fun1))]))
		struct(
			name: task-queue
			mut?: true
			ptr?: true
			body: record(
				[field(head, true, type(false, opt)), field(currently-running-exclusions, false, type(false, mut-list))]))
		struct(
			name: task-queue-node
			mut?: true
			ptr?: true
			body: record([field(task, false, type(false, task)), field(next, true, type(false, opt))]))
		struct(
			name: task
			body: record(
				[
					field(time, false, type(false, nat64))
					field(exclusion, false, type(false, nat64))
					field(action, false, type(false, fun-act0))]))
		struct(name: fun-act0, body: builtin(fun, [type(false, void)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, task-queue-node))]))
		struct(
			name: mut-list
			mut?: true
			ptr?: true
			body: record([field(backing, true, type(false, mut-arr)), field(size, true, type(false, nat64))]))
		struct(
			name: mut-arr
			body: record([field(ignore, false, type(false, void)), field(inner, false, type(false, arr))]))
		struct(
			name: arr
			body: record([field(size, false, type(false, nat64)), field(begin-ptr, false, type(false, ptr))]))
		struct(name: fun1, body: builtin(fun, [type(false, void), type(false, exception)]))
		struct(
			name: logged
			ptr?: true
			body: record([field(level, false, type(false, log-level)), field(message, false, type(false, str))]))
		struct(name: log-level, body: union([type(false, info), type(false, warn), type(false, error)]))
		struct(name: info, body: record([]))
		struct(name: warn, body: record([]))
		struct(name: error, body: record([]))
		struct(name: fun1, body: builtin(fun, [type(false, void), type(true, logged)]))
		struct(
			name: thread-safe-counter
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(value, true, type(false, nat64))]))
		struct(
			name: arr
			body: record([field(size, false, type(false, nat64)), field(begin-ptr, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(true, island)]))
		struct(
			name: condition
			mut?: true
			ptr?: true
			body: record(
				[
					field(mutex-attr, false, type(false, pthread_mutexattr_t))
					field(mutex, false, type(false, pthread_mutex_t))
					field(cond-attr, false, type(false, pthread_condattr_t))
					field(cond, false, type(false, pthread_cond_t))
					field(sequence, true, type(false, nat64))]))
		struct(name: pthread_mutexattr_t, ptr?: true, body: record([field(sizer, false, type(false, nat32))]))
		struct(name: nat32, body: builtin(nat-32, []))
		struct(name: pthread_mutex_t, ptr?: true, body: record([field(sizer, false, type(false, bytes40))]))
		struct(
			name: bytes40
			body: record([field(n0, false, type(false, bytes32)), field(n1, false, type(false, nat64))]))
		struct(
			name: bytes32
			body: record([field(n0, false, type(false, bytes16)), field(n1, false, type(false, bytes16))]))
		struct(
			name: bytes16
			body: record([field(n0, false, type(false, nat64)), field(n1, false, type(false, nat64))]))
		struct(name: pthread_condattr_t, ptr?: true, body: record([field(sizer, false, type(false, nat32))]))
		struct(name: pthread_cond_t, ptr?: true, body: record([field(sizer, false, type(false, bytes48))]))
		struct(
			name: bytes48
			body: record([field(n0, false, type(false, bytes32)), field(n1, false, type(false, bytes16))]))
		struct(name: int64, body: builtin(int-64, []))
		struct(name: writer, body: record([field(chars, false, type(true, mut-list))]))
		struct(
			name: mut-list
			mut?: true
			ptr?: true
			body: record([field(backing, true, type(false, mut-arr)), field(size, true, type(false, nat64))]))
		struct(
			name: mut-arr
			body: record([field(ignore, false, type(false, void)), field(inner, false, type(false, arr))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, char)]))
		struct(name: lambda(~=, 0), body: record([field(a, false, type(true, mut-list))]))
		struct(
			name: exception-ctx
			mut?: true
			ptr?: true
			body: record([field(jmp-buf-ptr, true, type(false, ptr)), field(thrown-exception, true, type(false, exception))]))
		struct(
			name: __jmp_buf_tag
			body: record(
				[
					field(__jmpbuf, false, type(false, bytes64))
					field(__mask_was_saved, false, type(false, int32))
					field(__saved_mask, false, type(false, bytes128))]))
		struct(
			name: bytes64
			body: record([field(n0, false, type(false, bytes32)), field(n1, false, type(false, bytes32))]))
		struct(
			name: bytes128
			body: record([field(n0, false, type(false, bytes64)), field(n1, false, type(false, bytes64))]))
		struct(name: ptr, body: builtin(ptr, [type(false, __jmp_buf_tag)]))
		struct(
			name: backtrace-arrs
			ptr?: true
			body: record(
				[
					field(code-ptrs, false, type(false, ptr))
					field(code-names, false, type(false, ptr))
					field(fun-ptrs, false, type(false, ptr))
					field(fun-names, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, ptr)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, backtrace-arrs))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, ptr))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, ptr))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, ptr))]))
		struct(
			name: arrow
			body: record([field(from, false, type(false, nat64)), field(to, false, type(false, nat64))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, str)]))
		struct(name: lambda(to-str, 0), body: record([field(res, false, type(false, writer))]))
		struct(name: log-ctx, mut?: true, ptr?: true, body: record([field(handler, true, type(false, fun1))]))
		struct(
			name: perf-ctx
			mut?: true
			ptr?: true
			body: record([field(measure-names, true, type(false, arr)), field(measure-values, true, type(false, mut-arr))]))
		struct(
			name: measure-value
			body: record([field(count, false, type(false, nat64)), field(total-ns, false, type(false, nat64))]))
		struct(
			name: mut-arr
			body: record([field(ignore, false, type(false, void)), field(inner, false, type(false, arr))]))
		struct(
			name: arr
			body: record([field(size, false, type(false, nat64)), field(begin-ptr, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, measure-value)]))
		struct(
			name: arr
			body: record([field(size, false, type(false, nat64)), field(begin-ptr, false, type(false, ptr))]))
		struct(name: fun-act2, body: builtin(fun, [type(true, fut), type(false, arr), type(false, fun-ptr2)]))
		struct(
			name: fut
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(state, true, type(false, fut-state))]))
		struct(
			name: fut-state
			body: union(
				[
					type(false, fut-state-no-callbacks)
					type(true, fut-state-callbacks)
					type(false, fut-state-resolved)
					type(false, exception)]))
		struct(
			name: fut-state-callbacks
			ptr?: true
			body: record([field(cb, false, type(false, fun-act1)), field(next, false, type(false, opt))]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, void))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, result)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, fut-state-callbacks))]))
		struct(name: fut-state-resolved, body: record([field(value, false, type(false, void))]))
		struct(
			name: fun-ref0
			body: record(
				[
					field(island-and-exclusion, false, type(false, island-and-exclusion))
					field(fun, false, type(false, fun-act0))]))
		struct(
			name: island-and-exclusion
			body: record([field(island, false, type(false, nat64)), field(exclusion, false, type(false, nat64))]))
		struct(name: fun-act0, body: builtin(fun, [type(true, fut)]))
		struct(
			name: fun-ref1
			body: record(
				[
					field(island-and-exclusion, false, type(false, island-and-exclusion))
					field(fun, false, type(false, fun-act1))]))
		struct(name: fun-act1, body: builtin(fun, [type(true, fut), type(false, void)]))
		struct(
			name: lambda(callback!, 0)
			ptr?: true
			body: record([field(f, false, type(true, fut)), field(cb, false, type(false, fun-act1))]))
		struct(
			name: lambda(then, 0)
			ptr?: true
			body: record([field(cb, false, type(false, fun-ref1)), field(res, false, type(true, fut))]))
		struct(
			name: lambda(callback!, 0)
			ptr?: true
			body: record([field(f, false, type(true, fut)), field(cb, false, type(false, fun-act1))]))
		struct(name: lambda(forward-to!, 0), body: record([field(to, false, type(true, fut))]))
		struct(name: fun-act0, body: builtin(fun, [type(false, fut-state)]))
		struct(
			name: lambda(resolve-or-reject!, 0)
			ptr?: true
			body: record([field(f, false, type(true, fut)), field(result, false, type(false, result))]))
		struct(
			name: lambda(subscript, 0)
			ptr?: true
			body: record(
				[
					field(f, false, type(false, fun-ref1))
					field(p0, false, type(false, void))
					field(res, false, type(true, fut))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, void), type(false, exception)]))
		struct(
			name: lambda(lambda(subscript, 0), 0)
			ptr?: true
			body: record(
				[
					field(f, false, type(false, fun-ref1))
					field(p0, false, type(false, void))
					field(res, false, type(true, fut))]))
		struct(name: lambda(lambda(subscript, 0), 1), body: record([field(res, false, type(true, fut))]))
		struct(name: lambda(then-void, 0), ptr?: true, body: record([field(cb, false, type(false, fun-ref0))]))
		struct(
			name: lambda(subscript, 0)
			ptr?: true
			body: record([field(f, false, type(false, fun-ref0)), field(res, false, type(true, fut))]))
		struct(
			name: lambda(lambda(subscript, 0), 0)
			ptr?: true
			body: record([field(f, false, type(false, fun-ref0)), field(res, false, type(true, fut))]))
		struct(name: lambda(lambda(subscript, 0), 1), body: record([field(res, false, type(true, fut))]))
		struct(
			name: lambda(add-first-task, 0)
			ptr?: true
			body: record([field(all-args, false, type(false, arr)), field(main-ptr, false, type(false, fun-ptr2))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, str), type(false, ptr)]))
		struct(name: fun-act1, body: builtin(fun, [type(false, str), type(false, nat64)]))
		struct(
			name: lambda(map, 0)
			ptr?: true
			body: record([field(f, false, type(false, fun-act1)), field(a, false, type(false, arr))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, ptr))]))
		struct(
			name: thread-args
			ptr?: true
			body: record([field(thread-id, false, type(false, nat64)), field(gctx, false, type(true, global-ctx))]))
		struct(name: ptr, body: builtin(ptr, [type(false, thread-args)]))
		struct(name: cell, mut?: true, ptr?: true, body: record([field(subscript, true, type(false, nat64))]))
		struct(name: fun-ptr1, body: builtin(fun-ptr, [type(false, ptr), type(false, ptr)]))
		struct(name: choose-task-result, body: union([type(false, chosen-task), type(false, no-chosen-task)]))
		struct(
			name: chosen-task
			body: record([field(task-island, false, type(true, island)), field(task-or-gc, false, type(false, task-or-gc))]))
		struct(name: task-or-gc, body: union([type(false, task), type(false, do-a-gc)]))
		struct(name: do-a-gc, body: record([]))
		struct(
			name: no-chosen-task
			body: record(
				[
					field(no-tasks-and-last-thread-out?, false, type(false, bool))
					field(first-task-time, false, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, nat64))]))
		struct(
			name: timespec
			body: record([field(tv-sec, false, type(false, int64)), field(tv-nsec, false, type(false, int64))]))
		struct(name: cell, mut?: true, ptr?: true, body: record([field(subscript, true, type(false, timespec))]))
		struct(
			name: choose-task-in-island-result
			body: union([type(false, task), type(false, do-a-gc), type(false, no-task)]))
		struct(
			name: no-task
			body: record([field(any-tasks?, false, type(false, bool)), field(first-task-time, false, type(false, opt))]))
		struct(name: pop-task-result, body: union([type(false, task), type(false, no-task)]))
		struct(name: ptr, body: builtin(ptr, [type(false, timespec)]))
		struct(name: cell, mut?: true, ptr?: true, body: record([field(subscript, true, type(false, ptr))]))
		struct(
			name: reader
			mut?: true
			ptr?: true
			body: record([field(cur, true, type(false, ptr)), field(end, false, type(false, ptr))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, opt), type(true, reader)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, int64))]))
		struct(name: fun-act1, body: builtin(fun, [type(false, opt), type(true, reader)]))
		struct(name: interp, body: record([field(inner, false, type(true, mut-list))]))
		struct(
			name: arr
			body: record([field(size, false, type(false, nat64)), field(begin-ptr, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, sym)]))]
	[
		fun(
			false
			mark
			type(false, bool)
			none
			[param(ctx, type(true, mark-ctx)), param(ptr-any, type(false, ptr)), param(size-bytes, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(word-aligned?, [param-ref(ptr-any)])])
					let(
						size-words
						call(words-of-bytes, [param-ref(size-bytes)])
						let(
							ptr
							call(ptr-cast, [param-ref(ptr-any)])
							let(
								index
								call(-, [local-ref(ptr), call(memory-start, [param-ref(ctx)])])
								let(
									gc-memory?
									call(<, [local-ref(index), call(memory-size-words, [param-ref(ctx)])])
									cond(
										local-ref(gc-memory?)
										seq(
											call(
												hard-assert
												[
													call(
														<=
														[
															call(wrap-add, [local-ref(index), local-ref(size-words)])
															call(memory-size-words, [param-ref(ctx)])])])
											let(
												mark-start
												call(+, [call(marks, [param-ref(ctx)]), local-ref(index)])
												let(
													mark-end
													call(+, [local-ref(mark-start), local-ref(size-words)])
													call(
														mark-range-recur
														[call(false, []), local-ref(mark-start), local-ref(mark-end)]))))
										seq(
											call(
												hard-assert
												[
													call(
														>
														[
															call(wrap-add, [local-ref(index), local-ref(size-words)])
															call(memory-size-words, [param-ref(ctx)])])])
											call(false, []))))))))))
		fun(
			false
			hard-assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(param-ref(condition), call(void, []), call(abort, []))))
		fun(false, void, type(false, void), none, [], builtin([]))
		fun(false, abort, type(false, void), none, [], extern(false))
		fun(
			false
			word-aligned?
			type(false, bool)
			none
			[param(a, type(false, ptr))]
			expr-body(call(==, [call(&, [call(to-nat64, [param-ref(a)]), 7]), 0])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			false
			&
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(false, to-nat64, type(false, nat64), none, [param(p, type(false, ptr))], builtin([type(false, nat8)]))
		fun(
			false
			words-of-bytes
			type(false, nat64)
			none
			[param(size-bytes, type(false, nat64))]
			expr-body(call(unsafe-div, [call(round-up-to-multiple-of-8, [param-ref(size-bytes)]), 8])))
		fun(
			false
			unsafe-div
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			false
			round-up-to-multiple-of-8
			type(false, nat64)
			none
			[param(n, type(false, nat64))]
			expr-body(call(&, [call(wrap-add, [param-ref(n), 7]), call(~, [7])])))
		fun(
			false
			wrap-add
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(false, ~, type(false, nat64), none, [param(a, type(false, nat64))], builtin([]))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat64), type(false, nat8)]))
		fun(
			false
			-
			type(false, nat64)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				call(
					unsafe-div
					[
						call(wrap-sub, [call(to-nat64, [param-ref(a)]), call(to-nat64, [param-ref(b)])])
						call(size-of, [])])))
		fun(
			false
			wrap-sub
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(false, to-nat64, type(false, nat64), none, [param(p, type(false, ptr))], builtin([type(false, nat64)]))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, nat64)]))
		fun(false, memory-start, type(false, ptr), none, [param(a, type(true, mark-ctx))], field-get(2))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				call(
					?
					[
						call(less?, [param-ref(a), param-ref(b)])
						to-union(0, call(less, []))
						call(
							?
							[
								call(==, [param-ref(a), param-ref(b)])
								to-union(1, call(equal, []))
								to-union(2, call(greater, []))])])))
		fun(
			false
			?
			type(false, comparison)
			none
			[
				param(cond, type(false, bool))
				param(if-true, type(false, comparison))
				param(if-false, type(false, comparison))]
			builtin([type(false, comparison)]))
		fun(
			false
			less?
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(false, less, type(false, less), none, [], new-record)
		fun(false, equal, type(false, equal), none, [], new-record)
		fun(false, greater, type(false, greater), none, [], new-record)
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				match-union(
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(false, true, type(false, bool), none, [], builtin([]))
		fun(false, false, type(false, bool), none, [], builtin([]))
		fun(false, memory-size-words, type(false, nat64), none, [param(a, type(true, mark-ctx))], field-get(0))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			false
			!
			type(false, bool)
			none
			[param(a, type(false, bool))]
			expr-body(cond(param-ref(a), call(false, []), call(true, []))))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(false, bool)]))
		fun(false, marks, type(false, ptr), none, [param(a, type(true, mark-ctx))], field-get(1))
		fun(
			false
			mark-range-recur
			type(false, bool)
			none
			[param(marked-anything?, type(false, bool)), param(cur, type(false, ptr)), param(end, type(false, ptr))]
			expr-body(
				cond(
					call(==, [param-ref(cur), param-ref(end)])
					param-ref(marked-anything?)
					let(
						new-marked-anything?
						call(||, [param-ref(marked-anything?), call(!, [call(subscript, [param-ref(cur)])])])
						seq(
							call(set-subscript, [param-ref(cur), call(true, [])])
							call(
								mark-range-recur
								[local-ref(new-marked-anything?), call(+, [param-ref(cur), 1]), param-ref(end)]))))))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, bool)]))
		fun(false, ||, type(false, bool), none, [param(a, type(false, bool)), param(b, type(false, bool))], builtin([]))
		fun(false, subscript, type(false, bool), none, [param(a, type(false, ptr))], builtin([type(false, bool)]))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(value, type(false, bool))]
			builtin([type(false, bool)]))
		fun(
			false
			>
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(<, [param-ref(b), param-ref(a)])))
		fun(
			false
			rt-main
			type(false, int32)
			none
			[param(argc, type(false, int32)), param(argv, type(false, ptr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				let(
					n-threads
					call(get_nprocs, [])
					let(
						f
						call(false, [])
						let(
							gctx-by-val
							call(
								as
								[
									call(
										global-ctx
										[
											call(lbv, [])
											call(lbv, [])
											call(lbv, [])
											to-union(0, call(none, []))
											record([0, null])
											local-ref(n-threads)
											call(create-condition, [])
											local-ref(f)
											local-ref(f)])])
							let(
								gctx
								call(ref-of-val, [local-ref(gctx-by-val)])
								let(
									island-by-val
									call(island, [local-ref(gctx), 0, local-ref(n-threads)])
									let(
										island
										call(ref-of-val, [local-ref(island-by-val)])
										seq(
											call(
												set-islands
												[local-ref(gctx), call(arr, [1, call(ptr-to, [local-ref(island)])])])
											let(
												main-fut
												call(
													add-main-task
													[
														local-ref(gctx)
														call(wrap-sub, [local-ref(n-threads), 1])
														local-ref(island)
														param-ref(argc)
														param-ref(argv)
														param-ref(main-ptr)])
												seq(
													seq(
														call(run-threads, [local-ref(n-threads), local-ref(gctx)])
														call(
															destroy-condition
															[
																call(
																	ref-of-val
																	[
																		call(
																			may-be-work-to-do
																			[call(ref-of-val, [local-ref(gctx-by-val)])])])]))
													match-union(
														call(state, [local-ref(main-fut)])
														[
															case(none, 1)
															case(none, 1)
															case(
																some(r)
																call(
																	?
																	[
																		call(
																			any-unhandled-exceptions?
																			[local-ref(gctx)])
																		1
																		call(
																			unsafe-to-int32
																			[
																				call(
																					unsafe-to-int64
																					[call(value, [local-ref(r)])])])]))
															case(none, 1)]))))))))))))
		fun(false, get_nprocs, type(false, nat64), none, [], extern(false))
		fun(
			false
			as
			type(false, global-ctx)
			none
			[param(value, type(false, global-ctx))]
			builtin([type(false, global-ctx)]))
		fun(
			false
			global-ctx
			type(false, global-ctx)
			none
			[
				param(lk, type(false, lock))
				param(print-lock, type(false, lock))
				param(syms-lock, type(false, lock))
				param(dynamic-syms, type(false, opt))
				param(islands, type(false, arr))
				param(n-live-threads, type(false, nat64))
				param(may-be-work-to-do, type(false, condition))
				param(shut-down?, type(false, bool))
				param(any-unhandled-exceptions?, type(false, bool))]
			new-record)
		fun(false, lbv, type(false, lock), none, [], expr-body(call(lock-by-val, [])))
		fun(false, lock-by-val, type(false, lock), none, [], expr-body(call(lock, [call(atomic-bool, [])])))
		fun(false, lock, type(false, lock), none, [param(is-locked, type(false, atomic-bool))], new-record)
		fun(false, atomic-bool, type(false, atomic-bool), none, [], expr-body(call(atomic-bool, [call(false, [])])))
		fun(false, atomic-bool, type(false, atomic-bool), none, [param(value, type(false, bool))], new-record)
		fun(false, none, type(false, none), none, [], new-record)
		fun(
			false
			create-condition
			type(false, condition)
			none
			[]
			expr-body(
				let(
					res
					call(
						as
						[call(condition, [call(zeroed, []), call(zeroed, []), call(zeroed, []), call(zeroed, []), 0])])
					seq(
						seq(
							seq(
								seq(
									seq(
										call(
											hard-assert-posix-error
											[
												call(
													pthread_mutexattr_init
													[
														call(
															ref-of-val
															[call(mutex-attr, [call(ref-of-val, [local-ref(res)])])])])])
										call(
											hard-assert-posix-error
											[
												call(
													pthread_mutex_init
													[
														call(
															ref-of-val
															[call(mutex, [call(ref-of-val, [local-ref(res)])])])
														call(
															ref-of-val
															[call(mutex-attr, [call(ref-of-val, [local-ref(res)])])])])]))
									call(
										hard-assert-posix-error
										[
											call(
												pthread_condattr_init
												[
													call(
														ref-of-val
														[call(cond-attr, [call(ref-of-val, [local-ref(res)])])])])]))
								call(
									hard-assert-posix-error
									[
										call(
											pthread_condattr_setclock
											[
												call(
													ref-of-val
													[call(cond-attr, [call(ref-of-val, [local-ref(res)])])])
												call(CLOCK_MONOTONIC, [])])]))
							call(
								hard-assert-posix-error
								[
									call(
										pthread_cond_init
										[
											call(ref-of-val, [call(cond, [call(ref-of-val, [local-ref(res)])])])
											call(ref-of-val, [call(cond-attr, [call(ref-of-val, [local-ref(res)])])])])]))
						local-ref(res)))))
		fun(
			false
			as
			type(false, condition)
			none
			[param(value, type(false, condition))]
			builtin([type(false, condition)]))
		fun(
			false
			condition
			type(false, condition)
			none
			[
				param(mutex-attr, type(false, pthread_mutexattr_t))
				param(mutex, type(false, pthread_mutex_t))
				param(cond-attr, type(false, pthread_condattr_t))
				param(cond, type(false, pthread_cond_t))
				param(sequence, type(false, nat64))]
			new-record)
		fun(false, zeroed, type(false, pthread_mutexattr_t), none, [], builtin([type(false, pthread_mutexattr_t)]))
		fun(false, zeroed, type(false, pthread_mutex_t), none, [], builtin([type(false, pthread_mutex_t)]))
		fun(false, zeroed, type(false, pthread_condattr_t), none, [], builtin([type(false, pthread_condattr_t)]))
		fun(false, zeroed, type(false, pthread_cond_t), none, [], builtin([type(false, pthread_cond_t)]))
		fun(
			false
			hard-assert-posix-error
			type(false, void)
			none
			[param(err, type(false, int32))]
			expr-body(call(hard-assert, [call(==, [param-ref(err), 0])])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			builtin([]))
		fun(
			false
			pthread_mutexattr_init
			type(false, int32)
			none
			[param(attr, type(true, pthread_mutexattr_t))]
			extern(false))
		fun(
			false
			ref-of-val
			type(true, pthread_mutexattr_t)
			none
			[param(a, type(false, pthread_mutexattr_t))]
			builtin([type(true, pthread_mutexattr_t)]))
		fun(false, mutex-attr, type(false, pthread_mutexattr_t), none, [param(a, type(true, condition))], field-get(0))
		fun(
			false
			ref-of-val
			type(true, condition)
			none
			[param(a, type(false, condition))]
			builtin([type(true, condition)]))
		fun(
			false
			pthread_mutex_init
			type(false, int32)
			none
			[param(mutex, type(true, pthread_mutex_t)), param(attr, type(true, pthread_mutexattr_t))]
			extern(false))
		fun(
			false
			ref-of-val
			type(true, pthread_mutex_t)
			none
			[param(a, type(false, pthread_mutex_t))]
			builtin([type(true, pthread_mutex_t)]))
		fun(false, mutex, type(false, pthread_mutex_t), none, [param(a, type(true, condition))], field-get(1))
		fun(
			false
			pthread_condattr_init
			type(false, int32)
			none
			[param(attr, type(true, pthread_condattr_t))]
			extern(false))
		fun(
			false
			ref-of-val
			type(true, pthread_condattr_t)
			none
			[param(a, type(false, pthread_condattr_t))]
			builtin([type(true, pthread_condattr_t)]))
		fun(false, cond-attr, type(false, pthread_condattr_t), none, [param(a, type(true, condition))], field-get(2))
		fun(
			false
			pthread_condattr_setclock
			type(false, int32)
			none
			[param(attr, type(true, pthread_condattr_t)), param(clock-id, type(false, int32))]
			extern(false))
		fun(false, CLOCK_MONOTONIC, type(false, int32), none, [], expr-body(1))
		fun(
			false
			pthread_cond_init
			type(false, int32)
			none
			[param(cond, type(true, pthread_cond_t)), param(cond-attr, type(true, pthread_condattr_t))]
			extern(false))
		fun(
			false
			ref-of-val
			type(true, pthread_cond_t)
			none
			[param(a, type(false, pthread_cond_t))]
			builtin([type(true, pthread_cond_t)]))
		fun(false, cond, type(false, pthread_cond_t), none, [param(a, type(true, condition))], field-get(3))
		fun(
			false
			ref-of-val
			type(true, global-ctx)
			none
			[param(a, type(false, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(
			false
			island
			type(false, island)
			none
			[param(gctx, type(true, global-ctx)), param(id, type(false, nat64)), param(max-threads, type(false, nat64))]
			expr-body(
				let(
					q
					call(task-queue, [param-ref(max-threads)])
					let(
						gc-root
						call(as, [call(island-gc-root, [local-ref(q), lambda(0, void), lambda(0, void)])])
						call(
							island
							[
								param-ref(gctx)
								param-ref(id)
								call(gc, [])
								local-ref(gc-root)
								call(lock-by-val, [])
								0
								call(thread-safe-counter, [])])))))
		fun(
			false
			task-queue
			type(false, task-queue)
			none
			[param(max-threads, type(false, nat64))]
			expr-body(
				call(
					task-queue
					[
						to-union(0, call(none, []))
						call(mut-list-by-val-with-capacity-from-unmanaged-memory, [param-ref(max-threads)])])))
		fun(
			false
			task-queue
			type(false, task-queue)
			none
			[param(head, type(false, opt)), param(currently-running-exclusions, type(false, mut-list))]
			new-record)
		fun(
			false
			mut-list-by-val-with-capacity-from-unmanaged-memory
			type(false, mut-list)
			none
			[param(capacity, type(false, nat64))]
			expr-body(
				let(
					backing
					call(mut-arr, [param-ref(capacity), call(unmanaged-alloc-zeroed-elements, [param-ref(capacity)])])
					call(mut-list, [local-ref(backing), 0]))))
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, ptr))]
			expr-body(call(mut-arr, [call(void, []), call(arr, [param-ref(size), param-ref(begin-ptr)])])))
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[param(ignore, type(false, void)), param(inner, type(false, arr))]
			new-record)
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, ptr))]
			new-record)
		fun(
			false
			unmanaged-alloc-zeroed-elements
			type(false, ptr)
			none
			[param(size-elements, type(false, nat64))]
			expr-body(
				let(
					res
					call(unmanaged-alloc-elements, [param-ref(size-elements)])
					seq(call(set-zero-range, [local-ref(res), param-ref(size-elements)]), local-ref(res)))))
		fun(
			false
			unmanaged-alloc-elements
			type(false, ptr)
			none
			[param(size-elements, type(false, nat64))]
			expr-body(
				call(
					ptr-cast
					[call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])])))
		fun(
			false
			unmanaged-alloc-bytes
			type(false, ptr)
			none
			[param(size, type(false, nat64))]
			expr-body(
				let(
					res
					call(malloc, [param-ref(size)])
					seq(call(hard-forbid, [call(null?, [local-ref(res)])]), local-ref(res)))))
		fun(false, malloc, type(false, ptr), none, [param(size, type(false, nat64))], extern(false))
		fun(
			false
			hard-forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(param-ref(condition), call(abort, []), void)))
		fun(
			false
			null?
			type(false, bool)
			none
			[param(a, type(false, ptr))]
			expr-body(call(==, [param-ref(a), call(null, [])])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, nat8)]))
		fun(false, null, type(false, ptr), none, [], builtin([type(false, nat8)]))
		fun(
			false
			wrap-mul
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			false
			set-zero-range
			type(false, void)
			none
			[param(begin, type(false, ptr)), param(size, type(false, nat64))]
			expr-body(
				call(
					drop
					[
						call(
							memset
							[
								call(as-any-ptr, [param-ref(begin)])
								0
								call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(false, drop, type(false, void), none, [param("_", type(false, ptr))], expr-body(call(void, [])))
		fun(
			false
			memset
			type(false, ptr)
			none
			[param(begin, type(false, ptr)), param(value, type(false, int32)), param(size, type(false, nat64))]
			extern(false))
		fun(false, as-any-ptr, type(false, ptr), none, [param(ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(
			false
			mut-list
			type(false, mut-list)
			none
			[param(backing, type(false, mut-arr)), param(size, type(false, nat64))]
			new-record)
		fun(
			false
			as
			type(false, island-gc-root)
			none
			[param(value, type(false, island-gc-root))]
			builtin([type(false, island-gc-root)]))
		fun(
			false
			island-gc-root
			type(false, island-gc-root)
			none
			[
				param(tasks, type(false, task-queue))
				param(exception-handler, type(false, fun1))
				param(log-handler, type(false, fun1))]
			new-record)
		fun(
			true
			default-exception-handler
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				seq(
					seq(
						call(print-err-no-newline, [record([arr(0, 0)])])
						call(print-err, [call(to-str, [param-ref(e)])]))
					call(set-any-unhandled-exceptions?, [call(get-global-ctx, []), call(true, [])]))))
		fun(
			false
			print-err-no-newline
			type(false, void)
			none
			[param(s, type(false, str))]
			expr-body(call(write-no-newline, [call(stderr, []), param-ref(s)])))
		fun(
			false
			write-no-newline
			type(false, void)
			none
			[param(fd, type(false, int32)), param(a, type(false, str))]
			expr-body(
				seq(
					call(hard-assert, [call(==, [call(size-of, []), call(size-of, [])])])
					let(
						res
						call(
							write
							[
								param-ref(fd)
								call(as-any-ptr, [call(begin-ptr, [call(chars, [param-ref(a)])])])
								call(size-bytes, [param-ref(a)])])
						cond(
							call(!=, [local-ref(res), call(unsafe-to-int64, [call(size-bytes, [param-ref(a)])])])
							call(todo, [])
							void)))))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, char)]))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, nat8)]))
		fun(
			false
			write
			type(false, int64)
			none
			[param(fd, type(false, int32)), param(buf, type(false, ptr)), param(n-bytes, type(false, nat64))]
			extern(false))
		fun(false, as-any-ptr, type(false, ptr), none, [param(ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(false, begin-ptr, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(false, chars, type(false, arr), none, [param(a, type(false, str))], field-get(0))
		fun(
			false
			size-bytes
			type(false, nat64)
			none
			[param(a, type(false, str))]
			expr-body(call(size, [call(chars, [param-ref(a)])])))
		fun(false, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			builtin([]))
		fun(
			false
			!=
			type(false, bool)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(false, unsafe-to-int64, type(false, int64), none, [param(a, type(false, nat64))], builtin([]))
		fun(false, todo, type(false, void), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(false, zeroed, type(false, void), none, [], builtin([type(false, void)]))
		fun(false, stderr, type(false, int32), none, [], expr-body(2))
		fun(
			false
			print-err
			type(false, void)
			none
			[param(s, type(false, str))]
			expr-body(seq(call(print-err-no-newline, [param-ref(s)]), call(print-err-no-newline, [record([arr(0, 1)])]))))
		fun(
			true
			to-str
			type(false, str)
			none
			[param(a, type(false, exception))]
			expr-body(
				let(
					res
					call(writer, [])
					seq(
						seq(
							call(
								~=
								[
									local-ref(res)
									call(
										?
										[
											call(empty?, [call(message, [param-ref(a)])])
											record([arr(0, 5)])
											call(message, [param-ref(a)])])])
							call(
								each
								[
									call(return-stack, [call(backtrace, [param-ref(a)])])
									lambda(0, alloc(record([local-ref(res)])))]))
						call(move-to-str!, [local-ref(res)])))))
		fun(true, writer, type(false, writer), none, [], expr-body(call(writer, [call(mut-list, [])])))
		fun(true, writer, type(false, writer), none, [param(chars, type(true, mut-list))], new-record)
		fun(true, mut-list, type(true, mut-list), none, [], expr-body(call(mut-list, [call(mut-arr, []), 0])))
		fun(
			true
			mut-list
			type(true, mut-list)
			none
			[param(backing, type(false, mut-arr)), param(size, type(false, nat64))]
			new-record)
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[]
			expr-body(call(mut-arr, [call(void, []), record([0, null])])))
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[param(ignore, type(false, void)), param(inner, type(false, arr))]
			new-record)
		fun(
			true
			~=
			type(false, void)
			none
			[param(a, type(false, writer)), param(b, type(false, str))]
			expr-body(call(~=, [call(chars, [param-ref(a)]), call(chars, [param-ref(b)])])))
		fun(
			true
			~=
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(values, type(false, arr))]
			expr-body(call(each, [param-ref(values), lambda(0, alloc(record([param-ref(a)])))])))
		fun(
			true
			each
			type(false, void)
			none
			[param(a, type(false, arr)), param(f, type(false, fun-act1))]
			expr-body(call(each-recur, [call(begin-ptr, [param-ref(a)]), call(end-ptr, [param-ref(a)]), param-ref(f)])))
		fun(
			true
			each-recur
			type(false, void)
			none
			[param(cur, type(false, ptr)), param(end, type(false, ptr)), param(f, type(false, fun-act1))]
			expr-body(
				cond(
					call(!=, [param-ref(cur), param-ref(end)])
					seq(
						call(subscript, [param-ref(f), call(subscript, [param-ref(cur)])])
						call(each-recur, [call(+, [param-ref(cur), 1]), param-ref(end), param-ref(f)]))
					void)))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, char)]))
		fun(
			false
			!=
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			true
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, char))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, char))]
			builtin([type(false, void), type(false, char)]))
		fun(true, get-ctx, type(true, ctx), none, [], builtin([]))
		fun(false, subscript, type(false, char), none, [param(a, type(false, ptr))], builtin([type(false, char)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(false, char)]))
		fun(
			false
			end-ptr
			type(false, ptr)
			none
			[param(a, type(false, arr))]
			expr-body(call(+, [call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])))
		fun(
			true
			~=
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(value, type(false, char))]
			expr-body(
				seq(
					seq(
						seq(
							call(incr-capacity!, [param-ref(a)])
							call(assert, [call(<, [call(size, [param-ref(a)]), call(capacity, [param-ref(a)])])]))
						call(
							set-subscript
							[call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)]), param-ref(value)]))
					call(set-size, [param-ref(a), call(+, [call(size, [param-ref(a)]), 1])]))))
		fun(
			true
			incr-capacity!
			type(false, void)
			none
			[param(a, type(true, mut-list))]
			expr-body(
				call(
					ensure-capacity
					[param-ref(a), call(round-up-to-power-of-two, [call(+, [call(size, [param-ref(a)]), 1])])])))
		fun(
			true
			ensure-capacity
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(min-capacity, type(false, nat64))]
			expr-body(
				cond(
					call(<, [call(capacity, [param-ref(a)]), param-ref(min-capacity)])
					call(increase-capacity-to!, [param-ref(a), param-ref(min-capacity)])
					void)))
		fun(
			false
			capacity
			type(false, nat64)
			none
			[param(a, type(true, mut-list))]
			expr-body(call(size, [call(backing, [param-ref(a)])])))
		fun(
			false
			size
			type(false, nat64)
			none
			[param(a, type(false, mut-arr))]
			expr-body(call(size, [call(inner, [param-ref(a)])])))
		fun(false, inner, type(false, arr), none, [param(a, type(false, mut-arr))], field-get(1))
		fun(false, backing, type(false, mut-arr), none, [param(a, type(true, mut-list))], field-get(0))
		fun(
			true
			increase-capacity-to!
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(new-capacity, type(false, nat64))]
			expr-body(
				seq(
					call(assert, [call(>, [param-ref(new-capacity), call(capacity, [param-ref(a)])])])
					let(
						old-begin
						call(begin-ptr, [param-ref(a)])
						seq(
							seq(
								call(
									set-backing
									[param-ref(a), call(uninitialized-mut-arr, [param-ref(new-capacity)])])
								call(
									copy-data-from
									[call(begin-ptr, [param-ref(a)]), local-ref(old-begin), call(size, [param-ref(a)])]))
							call(
								set-zero-elements
								[
									call(
										subscript
										[
											call(backing, [param-ref(a)])
											call(
												->
												[
													call(+, [call(size, [param-ref(a)]), 1])
													call(size, [call(backing, [param-ref(a)])])])])]))))))
		fun(
			true
			assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(call(!, [param-ref(condition)]), call(throw, [record([arr(0, 3)])]), void)))
		fun(
			true
			throw
			type(false, void)
			none
			[param(message, type(false, str))]
			expr-body(call(throw, [call(exception, [param-ref(message), call(get-backtrace, [])])])))
		fun(
			true
			throw
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				let(
					exn-ctx
					call(get-exception-ctx, [])
					seq(
						seq(
							seq(
								call(hard-forbid, [call(null?, [call(jmp-buf-ptr, [local-ref(exn-ctx)])])])
								call(set-thrown-exception, [local-ref(exn-ctx), param-ref(e)]))
							call(longjmp, [call(jmp-buf-ptr, [local-ref(exn-ctx)]), call(number-to-throw, [])]))
						call(hard-unreachable, [])))))
		fun(
			true
			get-exception-ctx
			type(true, exception-ctx)
			none
			[]
			expr-body(call(as-ref, [call(exception-ctx-ptr, [call(thread-local-stuff, [call(get-ctx, [])])])])))
		fun(
			false
			as-ref
			type(true, exception-ctx)
			none
			[param(a, type(false, ptr))]
			builtin([type(true, exception-ctx)]))
		fun(false, exception-ctx-ptr, type(false, ptr), none, [param(a, type(true, thread-local-stuff))], field-get(2))
		fun(false, thread-local-stuff, type(true, thread-local-stuff), none, [param(a, type(true, ctx))], field-get(4))
		fun(
			false
			null?
			type(false, bool)
			none
			[param(a, type(false, ptr))]
			expr-body(call(==, [param-ref(a), call(null, [])])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, __jmp_buf_tag)]))
		fun(false, null, type(false, ptr), none, [], builtin([type(false, __jmp_buf_tag)]))
		fun(false, jmp-buf-ptr, type(false, ptr), none, [param(a, type(true, exception-ctx))], field-get(0))
		fun(
			false
			set-thrown-exception
			type(false, void)
			none
			[param(a, type(true, exception-ctx)), param(thrown-exception, type(false, exception))]
			field-set(1))
		fun(
			false
			longjmp
			type(false, void)
			none
			[param(env, type(false, ptr)), param(val, type(false, int32))]
			extern(false))
		fun(true, number-to-throw, type(false, int32), none, [], expr-body(7))
		fun(false, hard-unreachable, type(false, void), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(
			false
			exception
			type(false, exception)
			none
			[param(message, type(false, str)), param(backtrace, type(false, backtrace))]
			new-record)
		fun(
			true
			get-backtrace
			type(false, backtrace)
			none
			[]
			expr-body(
				match-union(
					call(try-alloc-backtrace-arrs, [])
					[
						case(none, call(backtrace, [call(as, [record([0, null])])]))
						case(
							some("<<matched>>")
							let(
								arrs
								get-field(local-ref("<<matched>>"), value)
								let(
									n-code-ptrs
									call(
										unsafe-to-nat64
										[
											call(
												to-int64
												[
													call(
														backtrace
														[
															call(code-ptrs, [local-ref(arrs)])
															call(
																unsafe-to-int32
																[call(unsafe-to-int64, [call(code-ptrs-size, [])])])])])])
									seq(
										seq(
											seq(
												call(
													hard-assert
													[call(<=, [local-ref(n-code-ptrs), call(code-ptrs-size, [])])])
												call(
													fill-fun-ptrs-names-recur
													[
														0
														call(fun-ptrs, [local-ref(arrs)])
														call(fun-names, [local-ref(arrs)])]))
											call(
												sort-together
												[
													call(fun-ptrs, [local-ref(arrs)])
													call(fun-names, [local-ref(arrs)])
													call(funs-count, [])]))
										let(
											end-code-names
											call(+, [call(code-names, [local-ref(arrs)]), local-ref(n-code-ptrs)])
											seq(
												call(
													fill-code-names-recur
													[
														call(code-names, [local-ref(arrs)])
														local-ref(end-code-names)
														call(code-ptrs, [local-ref(arrs)])
														call(fun-ptrs, [local-ref(arrs)])
														call(fun-names, [local-ref(arrs)])])
												call(
													backtrace
													[
														call(
															arr
															[
																local-ref(n-code-ptrs)
																call(code-names, [local-ref(arrs)])])])))))))])))
		fun(
			true
			try-alloc-backtrace-arrs
			type(false, opt)
			none
			[]
			expr-body(
				match-union(
					call(try-alloc-uninitialized, [8])
					[
						case(none, to-union(0, call(none, [])))
						case(
							some("<<matched>>")
							let(
								code-ptrs
								get-field(local-ref("<<matched>>"), value)
								match-union(
									call(try-alloc-uninitialized, [8])
									[
										case(none, to-union(0, call(none, [])))
										case(
											some("<<matched>>")
											let(
												code-names
												get-field(local-ref("<<matched>>"), value)
												match-union(
													call(try-alloc-uninitialized, [call(funs-count, [])])
													[
														case(none, to-union(0, call(none, [])))
														case(
															some("<<matched>>")
															let(
																fun-ptrs
																get-field(local-ref("<<matched>>"), value)
																match-union(
																	call(
																		try-alloc-uninitialized
																		[call(funs-count, [])])
																	[
																		case(none, to-union(0, call(none, [])))
																		case(
																			some("<<matched>>")
																			let(
																				fun-names
																				get-field(
																					local-ref("<<matched>>")
																					value)
																				to-union(
																					1
																					call(
																						some
																						[
																							call(
																								backtrace-arrs
																								[
																									local-ref(code-ptrs)
																									local-ref(
																										code-names)
																									local-ref(fun-ptrs)
																									local-ref(fun-names)])]))))])))])))])))])))
		fun(
			true
			try-alloc-uninitialized
			type(false, opt)
			none
			[param(size, type(false, nat64))]
			expr-body(
				match-union(
					call(try-alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					[
						case(none, to-union(0, call(none, [])))
						case(
							some("<<matched>>")
							let(
								res
								get-field(local-ref("<<matched>>"), value)
								to-union(1, call(some, [call(ptr-cast, [local-ref(res)])]))))])))
		fun(
			true
			try-alloc
			type(false, opt)
			none
			[param(size-bytes, type(false, nat64))]
			expr-body(call(try-gc-alloc, [call(get-gc, []), param-ref(size-bytes)])))
		fun(
			false
			try-gc-alloc
			type(false, opt)
			none
			[param(gc, type(true, gc)), param(size-bytes, type(false, nat64))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gc)])])])
					let(
						res
						call(try-gc-alloc-recur, [param-ref(gc), param-ref(size-bytes)])
						seq(
							seq(
								call(maybe-set-needs-gc!, [param-ref(gc)])
								call(release!, [call(ref-of-val, [call(lk, [param-ref(gc)])])]))
							local-ref(res))))))
		fun(
			false
			acquire!
			type(false, void)
			none
			[param(a, type(true, lock))]
			expr-body(call(acquire-recur!, [param-ref(a), 0])))
		fun(
			false
			acquire-recur!
			type(false, void)
			none
			[param(a, type(true, lock)), param(n-tries, type(false, nat64))]
			expr-body(
				cond(
					call(!, [call(try-acquire!, [param-ref(a)])])
					cond(
						call(==, [param-ref(n-tries), 10000])
						call(todo, [])
						seq(
							call(yield-thread, [])
							call(acquire-recur!, [param-ref(a), call(wrap-add, [param-ref(n-tries), 1])])))
					void)))
		fun(
			false
			try-acquire!
			type(false, bool)
			none
			[param(a, type(true, lock))]
			expr-body(call(try-set!, [call(ref-of-val, [call(is-locked, [param-ref(a)])])])))
		fun(
			false
			try-set!
			type(false, bool)
			none
			[param(a, type(true, atomic-bool))]
			expr-body(call(try-change!, [param-ref(a), call(false, [])])))
		fun(
			false
			try-change!
			type(false, bool)
			none
			[param(a, type(true, atomic-bool)), param(old-value, type(false, bool))]
			expr-body(
				call(
					compare-exchange-strong
					[
						call(ptr-to, [call(value, [param-ref(a)])])
						call(ptr-to, [param-ref(old-value)])
						call(!, [param-ref(old-value)])])))
		fun(
			false
			compare-exchange-strong
			type(false, bool)
			none
			[
				param(value-ptr, type(false, ptr))
				param(expected-ptr, type(false, ptr))
				param(desired, type(false, bool))]
			builtin([]))
		fun(false, ptr-to, type(false, ptr), none, [param(t, type(false, bool))], builtin([type(false, bool)]))
		fun(false, value, type(false, bool), none, [param(a, type(true, atomic-bool))], field-get(0))
		fun(
			false
			ref-of-val
			type(true, atomic-bool)
			none
			[param(a, type(false, atomic-bool))]
			builtin([type(true, atomic-bool)]))
		fun(false, is-locked, type(false, atomic-bool), none, [param(a, type(true, lock))], field-get(0))
		fun(
			false
			yield-thread
			type(false, void)
			none
			[]
			expr-body(let(err, call(pthread_yield, []), call(hard-assert, [call(==, [local-ref(err), 0])]))))
		fun(false, pthread_yield, type(false, int32), none, [], extern(false))
		fun(false, ref-of-val, type(true, lock), none, [param(a, type(false, lock))], builtin([type(true, lock)]))
		fun(false, lk, type(false, lock), none, [param(a, type(true, gc))], field-get(0))
		fun(
			false
			try-gc-alloc-recur
			type(false, opt)
			none
			[param(gc, type(true, gc)), param(size-bytes, type(false, nat64))]
			expr-body(
				let(
					size-words
					call(words-of-bytes, [param-ref(size-bytes)])
					let(
						cur
						call(data-cur, [param-ref(gc)])
						let(
							next
							call(+, [local-ref(cur), local-ref(size-words)])
							cond(
								call(<, [local-ref(next), call(data-end, [param-ref(gc)])])
								cond(
									call(
										range-free?
										[
											call(mark-cur, [param-ref(gc)])
											call(+, [call(mark-cur, [param-ref(gc)]), local-ref(size-words)])])
									seq(
										seq(
											call(
												set-mark-cur
												[
													param-ref(gc)
													call(+, [call(mark-cur, [param-ref(gc)]), local-ref(size-words)])])
											call(set-data-cur, [param-ref(gc), local-ref(next)]))
										to-union(1, call(some, [call(ptr-cast, [local-ref(cur)])])))
									seq(
										seq(
											call(
												set-mark-cur
												[param-ref(gc), call(+, [call(mark-cur, [param-ref(gc)]), 1])])
											call(
												set-data-cur
												[param-ref(gc), call(+, [call(data-cur, [param-ref(gc)]), 1])]))
										call(try-gc-alloc-recur, [param-ref(gc), param-ref(size-bytes)])))
								to-union(0, call(none, []))))))))
		fun(false, data-cur, type(false, ptr), none, [param(a, type(true, gc))], field-get(9))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(false, nat64)]))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, nat64)]))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				cond(
					call(less?, [param-ref(a), param-ref(b)])
					to-union(0, call(less, []))
					cond(
						call(==, [param-ref(a), param-ref(b)])
						to-union(1, call(equal, []))
						to-union(2, call(greater, []))))))
		fun(
			false
			less?
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, nat64)]))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				match-union(
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(false, data-end, type(false, ptr), none, [param(a, type(true, gc))], field-get(10))
		fun(
			false
			range-free?
			type(false, bool)
			none
			[param(mark, type(false, ptr)), param(end, type(false, ptr))]
			expr-body(
				cond(
					call(==, [param-ref(mark), param-ref(end)])
					call(true, [])
					cond(
						call(subscript, [param-ref(mark)])
						call(false, [])
						call(range-free?, [call(+, [param-ref(mark), 1]), param-ref(end)])))))
		fun(false, mark-cur, type(false, ptr), none, [param(a, type(true, gc))], field-get(6))
		fun(
			false
			set-mark-cur
			type(false, void)
			none
			[param(a, type(true, gc)), param(mark-cur, type(false, ptr))]
			field-set(6))
		fun(
			false
			set-data-cur
			type(false, void)
			none
			[param(a, type(true, gc)), param(data-cur, type(false, ptr))]
			field-set(9))
		fun(false, some, type(false, some), none, [param(value, type(false, ptr))], new-record)
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat8), type(false, nat64)]))
		fun(
			false
			maybe-set-needs-gc!
			type(false, void)
			none
			[param(gc, type(true, gc))]
			expr-body(
				let(
					cur-word
					call(-, [call(mark-cur, [param-ref(gc)]), call(mark-begin, [param-ref(gc)])])
					cond(
						call(>, [local-ref(cur-word), call(unsafe-div, [call(size-words, [param-ref(gc)]), 2])])
						call(set-needs-gc?, [param-ref(gc), call(true, [])])
						void))))
		fun(
			false
			-
			type(false, nat64)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				call(
					unsafe-div
					[
						call(wrap-sub, [call(to-nat64, [param-ref(a)]), call(to-nat64, [param-ref(b)])])
						call(size-of, [])])))
		fun(false, to-nat64, type(false, nat64), none, [param(p, type(false, ptr))], builtin([type(false, bool)]))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, bool)]))
		fun(false, mark-begin, type(false, ptr), none, [param(a, type(true, gc))], field-get(5))
		fun(false, size-words, type(false, nat64), none, [param(a, type(true, gc))], field-get(4))
		fun(
			false
			set-needs-gc?
			type(false, void)
			none
			[param(a, type(true, gc)), param(needs-gc?, type(false, bool))]
			field-set(3))
		fun(
			false
			release!
			type(false, void)
			none
			[param(a, type(true, lock))]
			expr-body(call(must-unset!, [call(ref-of-val, [call(is-locked, [param-ref(a)])])])))
		fun(
			false
			must-unset!
			type(false, void)
			none
			[param(a, type(true, atomic-bool))]
			expr-body(let(did-unset, call(try-unset!, [param-ref(a)]), call(hard-assert, [local-ref(did-unset)]))))
		fun(
			false
			try-unset!
			type(false, bool)
			none
			[param(a, type(true, atomic-bool))]
			expr-body(call(try-change!, [param-ref(a), call(true, [])])))
		fun(true, get-gc, type(true, gc), none, [], expr-body(call(gc, [call(get-gc-ctx, [])])))
		fun(false, gc, type(true, gc), none, [param(a, type(true, gc-ctx))], field-get(0))
		fun(
			true
			get-gc-ctx
			type(true, gc-ctx)
			none
			[]
			expr-body(call(as-ref, [call(gc-ctx-ptr, [call(get-ctx, [])])])))
		fun(false, as-ref, type(true, gc-ctx), none, [param(a, type(false, ptr))], builtin([type(true, gc-ctx)]))
		fun(false, gc-ctx-ptr, type(false, ptr), none, [param(a, type(true, ctx))], field-get(3))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, ptr)]))
		fun(false, some, type(false, some), none, [param(value, type(false, ptr))], new-record)
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, ptr), type(false, nat8)]))
		fun(
			true
			try-alloc-uninitialized
			type(false, opt)
			none
			[param(size, type(false, nat64))]
			expr-body(
				match-union(
					call(try-alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					[
						case(none, to-union(0, call(none, [])))
						case(
							some("<<matched>>")
							let(
								res
								get-field(local-ref("<<matched>>"), value)
								to-union(1, call(some, [call(ptr-cast, [local-ref(res)])]))))])))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, str)]))
		fun(false, some, type(false, some), none, [param(value, type(false, ptr))], new-record)
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, str), type(false, nat8)]))
		fun(false, funs-count, type(false, nat64), none, [], builtin([]))
		fun(false, some, type(false, some), none, [param(value, type(true, backtrace-arrs))], new-record)
		fun(
			true
			backtrace-arrs
			type(true, backtrace-arrs)
			none
			[
				param(code-ptrs, type(false, ptr))
				param(code-names, type(false, ptr))
				param(fun-ptrs, type(false, ptr))
				param(fun-names, type(false, ptr))]
			new-record)
		fun(false, backtrace, type(false, backtrace), none, [param(return-stack, type(false, arr))], new-record)
		fun(false, as, type(false, arr), none, [param(value, type(false, arr))], builtin([type(false, arr)]))
		fun(false, unsafe-to-nat64, type(false, nat64), none, [param(a, type(false, int64))], builtin([]))
		fun(false, to-int64, type(false, int64), none, [param(i, type(false, int32))], builtin([]))
		fun(
			false
			backtrace
			type(false, int32)
			none
			[param(array, type(false, ptr)), param(size, type(false, int32))]
			extern(false))
		fun(false, code-ptrs, type(false, ptr), none, [param(a, type(true, backtrace-arrs))], field-get(0))
		fun(false, unsafe-to-int32, type(false, int32), none, [param(a, type(false, int64))], builtin([]))
		fun(true, code-ptrs-size, type(false, nat64), none, [], expr-body(8))
		fun(
			false
			fill-fun-ptrs-names-recur
			type(false, void)
			none
			[param(i, type(false, nat64)), param(fun-ptrs, type(false, ptr)), param(fun-names, type(false, ptr))]
			expr-body(
				cond(
					call(!=, [param-ref(i), call(funs-count, [])])
					seq(
						seq(
							call(set-subscript, [param-ref(fun-ptrs), param-ref(i), call(get-fun-ptr, [param-ref(i)])])
							call(
								set-subscript
								[param-ref(fun-names), param-ref(i), call(get-fun-name, [param-ref(i)])]))
						call(
							fill-fun-ptrs-names-recur
							[call(wrap-add, [param-ref(i), 1]), param-ref(fun-ptrs), param-ref(fun-names)]))
					void)))
		fun(
			false
			!=
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64)), param(value, type(false, ptr))]
			expr-body(call(set-subscript, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(value, type(false, ptr))]
			builtin([type(false, ptr)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(false, ptr)]))
		fun(false, get-fun-ptr, type(false, ptr), none, [param(fun-id, type(false, nat64))], builtin([]))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64)), param(value, type(false, str))]
			expr-body(call(set-subscript, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(value, type(false, str))]
			builtin([type(false, str)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(false, str)]))
		fun(false, get-fun-name, type(false, str), none, [param(fun-id, type(false, nat64))], builtin([]))
		fun(false, fun-ptrs, type(false, ptr), none, [param(a, type(true, backtrace-arrs))], field-get(2))
		fun(false, fun-names, type(false, ptr), none, [param(a, type(true, backtrace-arrs))], field-get(3))
		fun(
			true
			sort-together
			type(false, void)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr)), param(size, type(false, nat64))]
			expr-body(
				cond(
					call(>, [param-ref(size), 1])
					seq(
						seq(
							call(swap, [param-ref(a), 0, call(unsafe-div, [param-ref(size), 2])])
							call(swap, [param-ref(b), 0, call(unsafe-div, [param-ref(size), 2])]))
						let(
							after-pivot
							call(
								partition-recur-together
								[
									param-ref(a)
									param-ref(b)
									call(subscript, [param-ref(a)])
									1
									call(wrap-sub, [param-ref(size), 1])])
							let(
								new-pivot-index
								call(wrap-sub, [local-ref(after-pivot), 1])
								seq(
									seq(
										seq(
											call(swap, [param-ref(a), 0, local-ref(new-pivot-index)])
											call(swap, [param-ref(b), 0, local-ref(new-pivot-index)]))
										call(sort-together, [param-ref(a), param-ref(b), local-ref(new-pivot-index)]))
									call(
										sort-together
										[
											call(+, [param-ref(a), local-ref(after-pivot)])
											call(+, [param-ref(b), local-ref(after-pivot)])
											call(wrap-sub, [param-ref(size), local-ref(after-pivot)])])))))
					void)))
		fun(
			true
			swap
			type(false, void)
			none
			[param(a, type(false, ptr)), param(lo, type(false, nat64)), param(hi, type(false, nat64))]
			expr-body(
				let(
					temp
					call(subscript, [param-ref(a), param-ref(lo)])
					seq(
						call(
							set-subscript
							[param-ref(a), param-ref(lo), call(subscript, [param-ref(a), param-ref(hi)])])
						call(set-subscript, [param-ref(a), param-ref(hi), local-ref(temp)])))))
		fun(
			false
			subscript
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64))]
			expr-body(call(subscript, [call(+, [param-ref(a), param-ref(n)])])))
		fun(false, subscript, type(false, ptr), none, [param(a, type(false, ptr))], builtin([type(false, ptr)]))
		fun(
			true
			swap
			type(false, void)
			none
			[param(a, type(false, ptr)), param(lo, type(false, nat64)), param(hi, type(false, nat64))]
			expr-body(
				let(
					temp
					call(subscript, [param-ref(a), param-ref(lo)])
					seq(
						call(
							set-subscript
							[param-ref(a), param-ref(lo), call(subscript, [param-ref(a), param-ref(hi)])])
						call(set-subscript, [param-ref(a), param-ref(hi), local-ref(temp)])))))
		fun(
			false
			subscript
			type(false, str)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64))]
			expr-body(call(subscript, [call(+, [param-ref(a), param-ref(n)])])))
		fun(false, subscript, type(false, str), none, [param(a, type(false, ptr))], builtin([type(false, str)]))
		fun(
			true
			partition-recur-together
			type(false, nat64)
			none
			[
				param(a, type(false, ptr))
				param(b, type(false, ptr))
				param(pivot, type(false, ptr))
				param(l, type(false, nat64))
				param(r, type(false, nat64))]
			expr-body(
				cond(
					call(<=, [param-ref(l), param-ref(r)])
					cond(
						call(<, [call(subscript, [param-ref(a), param-ref(l)]), param-ref(pivot)])
						call(
							partition-recur-together
							[
								param-ref(a)
								param-ref(b)
								param-ref(pivot)
								call(wrap-add, [param-ref(l), 1])
								param-ref(r)])
						seq(
							seq(
								call(swap, [param-ref(a), param-ref(l), param-ref(r)])
								call(swap, [param-ref(b), param-ref(l), param-ref(r)]))
							call(
								partition-recur-together
								[
									param-ref(a)
									param-ref(b)
									param-ref(pivot)
									param-ref(l)
									call(wrap-sub, [param-ref(r), 1])])))
					param-ref(l))))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				cond(
					call(less?, [param-ref(a), param-ref(b)])
					to-union(0, call(less, []))
					cond(
						call(==, [param-ref(a), param-ref(b)])
						to-union(1, call(equal, []))
						to-union(2, call(greater, []))))))
		fun(
			false
			less?
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, nat8)]))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				match-union(
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(false, code-names, type(false, ptr), none, [param(a, type(true, backtrace-arrs))], field-get(1))
		fun(
			true
			fill-code-names-recur
			type(false, void)
			none
			[
				param(code-names, type(false, ptr))
				param(end-code-names, type(false, ptr))
				param(code-ptrs, type(false, ptr))
				param(fun-ptrs, type(false, ptr))
				param(fun-names, type(false, ptr))]
			expr-body(
				cond(
					call(<, [param-ref(code-names), param-ref(end-code-names)])
					seq(
						call(
							set-subscript
							[
								param-ref(code-names)
								call(
									get-fun-name
									[
										call(subscript, [param-ref(code-ptrs)])
										param-ref(fun-ptrs)
										param-ref(fun-names)
										call(funs-count, [])])])
						call(
							fill-code-names-recur
							[
								call(+, [param-ref(code-names), 1])
								param-ref(end-code-names)
								call(+, [param-ref(code-ptrs), 1])
								param-ref(fun-ptrs)
								param-ref(fun-names)]))
					void)))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, str)]))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				cond(
					call(less?, [param-ref(a), param-ref(b)])
					to-union(0, call(less, []))
					cond(
						call(==, [param-ref(a), param-ref(b)])
						to-union(1, call(equal, []))
						to-union(2, call(greater, []))))))
		fun(
			false
			less?
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, str)]))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				match-union(
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(
			false
			get-fun-name
			type(false, str)
			none
			[
				param(code-ptr, type(false, ptr))
				param(fun-ptrs, type(false, ptr))
				param(fun-names, type(false, ptr))
				param(size, type(false, nat64))]
			expr-body(
				cond(
					call(<, [param-ref(size), 2])
					record([arr(0, 2)])
					cond(
						call(<, [param-ref(code-ptr), call(subscript, [param-ref(fun-ptrs), 1])])
						call(subscript, [param-ref(fun-names)])
						call(
							get-fun-name
							[
								param-ref(code-ptr)
								call(+, [param-ref(fun-ptrs), 1])
								call(+, [param-ref(fun-names), 1])
								call(wrap-sub, [param-ref(size), 1])])))))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, ptr))]
			new-record)
		fun(
			false
			begin-ptr
			type(false, ptr)
			none
			[param(a, type(true, mut-list))]
			expr-body(call(begin-ptr, [call(backing, [param-ref(a)])])))
		fun(
			false
			begin-ptr
			type(false, ptr)
			none
			[param(a, type(false, mut-arr))]
			expr-body(call(begin-ptr, [call(inner, [param-ref(a)])])))
		fun(
			false
			set-backing
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(backing, type(false, mut-arr))]
			field-set(0))
		fun(
			true
			uninitialized-mut-arr
			type(false, mut-arr)
			none
			[param(size, type(false, nat64))]
			expr-body(call(mut-arr, [param-ref(size), call(alloc-uninitialized, [param-ref(size)])])))
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, ptr))]
			expr-body(call(mut-arr, [call(void, []), call(arr, [param-ref(size), param-ref(begin-ptr)])])))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, ptr))]
			new-record)
		fun(
			true
			alloc-uninitialized
			type(false, ptr)
			none
			[param(size, type(false, nat64))]
			expr-body(call(ptr-cast, [call(alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, char), type(false, nat8)]))
		fun(
			true
			alloc
			type(false, ptr)
			none
			[param(size-bytes, type(false, nat64))]
			expr-body(call(gc-alloc, [call(get-gc, []), param-ref(size-bytes)])))
		fun(
			true
			gc-alloc
			type(false, ptr)
			none
			[param(gc, type(true, gc)), param(size, type(false, nat64))]
			expr-body(
				match-union(
					call(try-gc-alloc, [param-ref(gc), param-ref(size)])
					[
						case(none, call(todo, []))
						case(some("<<matched>>"), let(res, get-field(local-ref("<<matched>>"), value), local-ref(res)))])))
		fun(false, todo, type(false, ptr), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(false, zeroed, type(false, ptr), none, [], builtin([type(false, ptr)]))
		fun(
			true
			copy-data-from
			type(false, void)
			none
			[param(to, type(false, ptr)), param(from, type(false, ptr)), param(len, type(false, nat64))]
			expr-body(
				call(
					drop
					[
						call(
							memcpy
							[
								call(as-any-ptr, [param-ref(to)])
								call(as-any-ptr, [param-ref(from)])
								call(wrap-mul, [param-ref(len), call(size-of, [])])])])))
		fun(
			false
			memcpy
			type(false, ptr)
			none
			[param(dest, type(false, ptr)), param(src, type(false, ptr)), param(size, type(false, nat64))]
			extern(false))
		fun(false, size, type(false, nat64), none, [param(a, type(true, mut-list))], field-get(1))
		fun(
			false
			set-zero-elements
			type(false, void)
			none
			[param(a, type(false, mut-arr))]
			expr-body(call(set-zero-range, [call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])))
		fun(
			false
			set-zero-range
			type(false, void)
			none
			[param(begin, type(false, ptr)), param(size, type(false, nat64))]
			expr-body(
				call(
					drop
					[
						call(
							memset
							[
								call(as-any-ptr, [param-ref(begin)])
								0
								call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(
			true
			subscript
			type(false, mut-arr)
			none
			[param(a, type(false, mut-arr)), param(range, type(false, arrow))]
			expr-body(
				seq(
					seq(
						call(assert, [call(<=, [call(from, [param-ref(range)]), call(to, [param-ref(range)])])])
						call(assert, [call(<=, [call(to, [param-ref(range)]), call(size, [param-ref(a)])])]))
					call(mut-arr, [call(void, []), call(subscript, [call(inner, [param-ref(a)]), param-ref(range)])]))))
		fun(false, from, type(false, nat64), none, [param(a, type(false, arrow))], field-get(0))
		fun(false, to, type(false, nat64), none, [param(a, type(false, arrow))], field-get(1))
		fun(
			true
			subscript
			type(false, arr)
			none
			[param(a, type(false, arr)), param(range, type(false, arrow))]
			expr-body(
				seq(
					seq(
						call(assert, [call(<=, [call(from, [param-ref(range)]), call(to, [param-ref(range)])])])
						call(assert, [call(<=, [call(to, [param-ref(range)]), call(size, [param-ref(a)])])]))
					call(
						arr
						[
							call(wrap-sub, [call(to, [param-ref(range)]), call(from, [param-ref(range)])])
							call(+, [call(begin-ptr, [param-ref(a)]), call(from, [param-ref(range)])])]))))
		fun(
			true
			->
			type(false, arrow)
			none
			[param(from, type(false, nat64)), param(to, type(false, nat64))]
			expr-body(call(arrow, [param-ref(from), param-ref(to)])))
		fun(
			false
			arrow
			type(false, arrow)
			none
			[param(from, type(false, nat64)), param(to, type(false, nat64))]
			new-record)
		fun(
			true
			+
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				let(
					res
					call(wrap-add, [param-ref(a), param-ref(b)])
					seq(
						call(
							assert
							[
								call(
									&&
									[call(>=, [local-ref(res), param-ref(a)]), call(>=, [local-ref(res), param-ref(b)])])])
						local-ref(res)))))
		fun(false, &&, type(false, bool), none, [param(a, type(false, bool)), param(b, type(false, bool))], builtin([]))
		fun(
			false
			>=
			type(false, bool)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(!, [call(<, [param-ref(a), param-ref(b)])])))
		fun(
			true
			round-up-to-power-of-two
			type(false, nat64)
			none
			[param(n, type(false, nat64))]
			expr-body(call(round-up-to-power-of-two-recur, [1, param-ref(n)])))
		fun(
			true
			round-up-to-power-of-two-recur
			type(false, nat64)
			none
			[param(acc, type(false, nat64)), param(n, type(false, nat64))]
			expr-body(
				cond(
					call(>=, [param-ref(acc), param-ref(n)])
					param-ref(acc)
					call(round-up-to-power-of-two-recur, [call(*, [param-ref(acc), 2]), param-ref(n)]))))
		fun(
			true
			*
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(
				cond(
					call(||, [call(==, [param-ref(a), 0]), call(==, [param-ref(b), 0])])
					0
					let(
						res
						call(wrap-mul, [param-ref(a), param-ref(b)])
						seq(
							seq(
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(b)]), param-ref(a)])])
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(a)]), param-ref(b)])]))
							local-ref(res))))))
		fun(
			true
			/
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(seq(call(forbid, [call(==, [param-ref(b), 0])]), call(unsafe-div, [param-ref(a), param-ref(b)]))))
		fun(
			true
			forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(cond(param-ref(condition), call(throw, [record([arr(0, 4)])]), void)))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64)), param(value, type(false, char))]
			expr-body(call(set-subscript, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(value, type(false, char))]
			builtin([type(false, char)]))
		fun(
			false
			set-size
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(size, type(false, nat64))]
			field-set(1))
		fun(
			true
			lambda(~=, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(~=, 0))))
			[param(x, type(false, char))]
			expr-body(call(~=, [get-field(param-ref("<<closure>>"), a), param-ref(x)])))
		fun(false, chars, type(true, mut-list), none, [param(a, type(false, writer))], field-get(0))
		fun(
			false
			?
			type(false, str)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, str)), param(if-false, type(false, str))]
			builtin([type(false, str)]))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, str))]
			expr-body(call(empty?, [call(chars, [param-ref(a)])])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body(call(==, [call(size, [param-ref(a)]), 0])))
		fun(false, message, type(false, str), none, [param(a, type(false, exception))], field-get(0))
		fun(
			true
			each
			type(false, void)
			none
			[param(a, type(false, arr)), param(f, type(false, fun-act1))]
			expr-body(call(each-recur, [call(begin-ptr, [param-ref(a)]), call(end-ptr, [param-ref(a)]), param-ref(f)])))
		fun(
			true
			each-recur
			type(false, void)
			none
			[param(cur, type(false, ptr)), param(end, type(false, ptr)), param(f, type(false, fun-act1))]
			expr-body(
				cond(
					call(!=, [param-ref(cur), param-ref(end)])
					seq(
						call(subscript, [param-ref(f), call(subscript, [param-ref(cur)])])
						call(each-recur, [call(+, [param-ref(cur), 1]), param-ref(end), param-ref(f)]))
					void)))
		fun(
			false
			!=
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			true
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, str))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, str))]
			builtin([type(false, void), type(false, str)]))
		fun(false, begin-ptr, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			false
			end-ptr
			type(false, ptr)
			none
			[param(a, type(false, arr))]
			expr-body(call(+, [call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])))
		fun(false, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(false, return-stack, type(false, arr), none, [param(a, type(false, backtrace))], field-get(0))
		fun(false, backtrace, type(false, backtrace), none, [param(a, type(false, exception))], field-get(1))
		fun(
			true
			lambda(to-str, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(to-str, 0))))
			[param(x, type(false, str))]
			expr-body(
				seq(
					call(~=, [get-field(param-ref("<<closure>>"), res), record([arr(0, 6)])])
					call(~=, [get-field(param-ref("<<closure>>"), res), param-ref(x)]))))
		fun(
			true
			move-to-str!
			type(false, str)
			none
			[param(a, type(false, writer))]
			expr-body(call(str, [call(move-to-arr!, [call(chars, [param-ref(a)])])])))
		fun(false, str, type(false, str), none, [param(chars, type(false, arr))], new-record)
		fun(
			false
			move-to-arr!
			type(false, arr)
			none
			[param(a, type(true, mut-list))]
			expr-body(
				let(
					res
					call(arr, [call(size, [param-ref(a)]), call(begin-ptr, [param-ref(a)])])
					seq(
						seq(call(set-backing, [param-ref(a), call(mut-arr, [])]), call(set-size, [param-ref(a), 0]))
						local-ref(res)))))
		fun(
			false
			set-any-unhandled-exceptions?
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(any-unhandled-exceptions?, type(false, bool))]
			field-set(8))
		fun(
			true
			get-global-ctx
			type(true, global-ctx)
			none
			[]
			expr-body(call(as-ref, [call(gctx-ptr, [call(get-ctx, [])])])))
		fun(
			false
			as-ref
			type(true, global-ctx)
			none
			[param(a, type(false, ptr))]
			builtin([type(true, global-ctx)]))
		fun(false, gctx-ptr, type(false, ptr), none, [param(a, type(true, ctx))], field-get(0))
		fun(
			true
			lambda(island, 0)
			type(false, void)
			some(param("<<closure>>", type(false, void)))
			[param(exn, type(false, exception))]
			expr-body(call(default-exception-handler, [param-ref(exn)])))
		fun(
			true
			default-log-handler
			type(false, void)
			none
			[param(a, type(true, logged))]
			expr-body(
				call(
					print
					[
						call(
							~
							[
								call(~, [call(to-str, [call(level, [param-ref(a)])]), record([arr(0, 10)])])
								call(message, [param-ref(a)])])])))
		fun(
			false
			print
			type(false, void)
			none
			[param(a, type(false, str))]
			expr-body(seq(call(print-no-newline, [param-ref(a)]), call(print-no-newline, [record([arr(0, 1)])]))))
		fun(
			false
			print-no-newline
			type(false, void)
			none
			[param(a, type(false, str))]
			expr-body(call(write-no-newline, [call(stdout, []), param-ref(a)])))
		fun(false, stdout, type(false, int32), none, [], expr-body(1))
		fun(
			true
			~
			type(false, str)
			none
			[param(a, type(false, str)), param(b, type(false, str))]
			expr-body(call(str, [call(~, [call(chars, [param-ref(a)]), call(chars, [param-ref(b)])])])))
		fun(
			true
			~
			type(false, arr)
			none
			[param(a, type(false, arr)), param(b, type(false, arr))]
			expr-body(
				let(
					res-size
					call(wrap-add, [call(size, [param-ref(a)]), call(size, [param-ref(b)])])
					let(
						res
						call(alloc-uninitialized, [local-ref(res-size)])
						seq(
							seq(
								call(
									copy-data-from
									[local-ref(res), call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)])])
								call(
									copy-data-from
									[
										call(+, [local-ref(res), call(size, [param-ref(a)])])
										call(begin-ptr, [param-ref(b)])
										call(size, [param-ref(b)])]))
							call(arr, [local-ref(res-size), local-ref(res)]))))))
		fun(
			true
			to-str
			type(false, str)
			none
			[param(a, type(false, log-level))]
			expr-body(
				match-union(
					param-ref(a)
					[case(none, record([arr(0, 7)])), case(none, record([arr(0, 8)])), case(none, record([arr(0, 9)]))])))
		fun(false, level, type(false, log-level), none, [param(a, type(true, logged))], field-get(0))
		fun(false, message, type(false, str), none, [param(a, type(true, logged))], field-get(1))
		fun(
			true
			lambda(island, 1)
			type(false, void)
			some(param("<<closure>>", type(false, void)))
			[param(log, type(true, logged))]
			expr-body(call(default-log-handler, [param-ref(log)])))
		fun(
			false
			island
			type(false, island)
			none
			[
				param(gctx, type(true, global-ctx))
				param(id, type(false, nat64))
				param(gc, type(false, gc))
				param(gc-root, type(false, island-gc-root))
				param(tasks-lock, type(false, lock))
				param(n-threads-running, type(false, nat64))
				param(next-exclusion, type(false, thread-safe-counter))]
			new-record)
		fun(
			false
			gc
			type(false, gc)
			none
			[]
			expr-body(
				let(
					mark
					call(ptr-cast, [call(malloc, [50331648])])
					let(
						mark-end
						call(+, [local-ref(mark), 50331648])
						let(
							data
							call(ptr-cast, [call(malloc, [call(wrap-mul, [50331648, call(size-of, [])])])])
							seq(
								call(hard-assert, [call(word-aligned?, [call(as-any-ptr, [local-ref(data)])])])
								let(
									data-end
									call(+, [local-ref(data), 50331648])
									seq(
										call(drop, [call(memset, [call(as-any-ptr, [local-ref(mark)]), 0, 50331648])])
										let(
											res
											call(
												as
												[
													call(
														gc
														[
															call(lock-by-val, [])
															0
															to-union(0, call(none, []))
															call(false, [])
															50331648
															local-ref(mark)
															local-ref(mark)
															local-ref(mark-end)
															local-ref(data)
															local-ref(data)
															local-ref(data-end)])])
											seq(call(validate-gc, [call(ref-of-val, [local-ref(res)])]), local-ref(res)))))))))))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, bool), type(false, nat8)]))
		fun(false, as-any-ptr, type(false, ptr), none, [param(ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(false, as, type(false, gc), none, [param(value, type(false, gc))], builtin([type(false, gc)]))
		fun(
			false
			gc
			type(false, gc)
			none
			[
				param(lk, type(false, lock))
				param(gc-count, type(false, nat64))
				param(context-head, type(false, opt))
				param(needs-gc?, type(false, bool))
				param(size-words, type(false, nat64))
				param(mark-begin, type(false, ptr))
				param(mark-cur, type(false, ptr))
				param(mark-end, type(false, ptr))
				param(data-begin, type(false, ptr))
				param(data-cur, type(false, ptr))
				param(data-end, type(false, ptr))]
			new-record)
		fun(
			false
			validate-gc
			type(false, void)
			none
			[param(gc, type(true, gc))]
			expr-body(
				seq(
					seq(
						seq(
							seq(
								seq(
									seq(
										seq(
											call(
												hard-assert
												[
													call(
														word-aligned?
														[call(as-any-ptr, [call(mark-begin, [param-ref(gc)])])])])
											call(
												hard-assert
												[
													call(
														word-aligned?
														[call(as-any-ptr, [call(data-begin, [param-ref(gc)])])])]))
										call(
											hard-assert
											[call(word-aligned?, [call(as-any-ptr, [call(data-cur, [param-ref(gc)])])])]))
									call(
										hard-assert
										[call(<=, [call(mark-begin, [param-ref(gc)]), call(mark-cur, [param-ref(gc)])])]))
								call(
									hard-assert
									[call(<=, [call(mark-cur, [param-ref(gc)]), call(mark-end, [param-ref(gc)])])]))
							call(
								hard-assert
								[call(<=, [call(data-begin, [param-ref(gc)]), call(data-cur, [param-ref(gc)])])]))
						call(
							hard-assert
							[call(<=, [call(data-cur, [param-ref(gc)]), call(data-end, [param-ref(gc)])])]))
					let(
						mark-idx
						call(-, [call(mark-cur, [param-ref(gc)]), call(mark-begin, [param-ref(gc)])])
						let(
							data-idx
							call(-, [call(data-cur, [param-ref(gc)]), call(data-begin, [param-ref(gc)])])
							seq(
								seq(
									call(
										hard-assert
										[
											call(
												==
												[
													call(
														-
														[
															call(mark-end, [param-ref(gc)])
															call(mark-begin, [param-ref(gc)])])
													call(size-words, [param-ref(gc)])])])
									call(
										hard-assert
										[
											call(
												==
												[
													call(
														-
														[
															call(data-end, [param-ref(gc)])
															call(data-begin, [param-ref(gc)])])
													call(size-words, [param-ref(gc)])])]))
								call(hard-assert, [call(==, [local-ref(mark-idx), local-ref(data-idx)])])))))))
		fun(false, data-begin, type(false, ptr), none, [param(a, type(true, gc))], field-get(8))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				cond(
					call(less?, [param-ref(a), param-ref(b)])
					to-union(0, call(less, []))
					cond(
						call(==, [param-ref(a), param-ref(b)])
						to-union(1, call(equal, []))
						to-union(2, call(greater, []))))))
		fun(
			false
			less?
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, bool)]))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				match-union(
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(false, mark-end, type(false, ptr), none, [param(a, type(true, gc))], field-get(7))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(false, ref-of-val, type(true, gc), none, [param(a, type(false, gc))], builtin([type(true, gc)]))
		fun(
			false
			thread-safe-counter
			type(false, thread-safe-counter)
			none
			[]
			expr-body(call(thread-safe-counter, [0])))
		fun(
			false
			thread-safe-counter
			type(false, thread-safe-counter)
			none
			[param(init, type(false, nat64))]
			expr-body(call(thread-safe-counter, [call(lock-by-val, []), param-ref(init)])))
		fun(
			false
			thread-safe-counter
			type(false, thread-safe-counter)
			none
			[param(lk, type(false, lock)), param(value, type(false, nat64))]
			new-record)
		fun(false, ref-of-val, type(true, island), none, [param(a, type(false, island))], builtin([type(true, island)]))
		fun(
			false
			set-islands
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(islands, type(false, arr))]
			field-set(4))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, ptr))]
			new-record)
		fun(false, ptr-to, type(false, ptr), none, [param(t, type(true, island))], builtin([type(true, island)]))
		fun(
			false
			add-main-task
			type(true, fut)
			none
			[
				param(gctx, type(true, global-ctx))
				param(thread-id, type(false, nat64))
				param(island, type(true, island))
				param(argc, type(false, int32))
				param(argv, type(false, ptr))
				param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				let(
					ectx
					call(exception-ctx, [])
					let(
						log-ctx
						call(log-ctx, [])
						let(
							perf-ctx
							call(perf-ctx, [])
							let(
								ectx-ptr
								call(as-any-ptr, [call(ref-of-val, [local-ref(ectx)])])
								let(
									log-ctx-ptr
									call(as-any-ptr, [call(ref-of-val, [local-ref(log-ctx)])])
									let(
										perf-ptr
										call(as-any-ptr, [call(ref-of-val, [local-ref(perf-ctx)])])
										let(
											print-lock
											call(ref-of-val, [call(print-lock, [param-ref(gctx)])])
											let(
												tls
												call(
													as
													[
														call(
															thread-local-stuff
															[
																param-ref(thread-id)
																local-ref(print-lock)
																local-ref(ectx-ptr)
																local-ref(log-ctx-ptr)
																local-ref(perf-ptr)])])
												let(
													ctx-by-val
													call(
														ctx
														[
															param-ref(gctx)
															call(ref-of-val, [local-ref(tls)])
															param-ref(island)
															0])
													let(
														ctx
														call(ref-of-val, [local-ref(ctx-by-val)])
														let(
															add
															call(as, [lambda(0, void)])
															let(
																all-args
																call(
																	arr
																	[
																		call(
																			unsafe-to-nat64
																			[call(to-int64, [param-ref(argc)])])
																		param-ref(argv)])
																call(
																	call-with-ctx
																	[
																		local-ref(add)
																		local-ref(ctx)
																		local-ref(all-args)
																		param-ref(main-ptr)])))))))))))))))
		fun(
			false
			exception-ctx
			type(false, exception-ctx)
			none
			[]
			expr-body(
				call(
					exception-ctx
					[
						call(null, [])
						call(exception, [record([record([0, null])]), call(backtrace, [call(as, [record([0, null])])])])])))
		fun(
			false
			exception-ctx
			type(false, exception-ctx)
			none
			[param(jmp-buf-ptr, type(false, ptr)), param(thrown-exception, type(false, exception))]
			new-record)
		fun(false, log-ctx, type(false, log-ctx), none, [], expr-body(call(log-ctx, [call(zeroed, [])])))
		fun(false, log-ctx, type(false, log-ctx), none, [param(handler, type(false, fun1))], new-record)
		fun(false, zeroed, type(false, fun1), none, [], builtin([type(false, fun1)]))
		fun(
			false
			perf-ctx
			type(false, perf-ctx)
			none
			[]
			expr-body(call(perf-ctx, [record([0, null]), call(mut-arr, [])])))
		fun(
			false
			perf-ctx
			type(false, perf-ctx)
			none
			[param(measure-names, type(false, arr)), param(measure-values, type(false, mut-arr))]
			new-record)
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[]
			expr-body(call(mut-arr, [call(void, []), record([0, null])])))
		fun(
			false
			mut-arr
			type(false, mut-arr)
			none
			[param(ignore, type(false, void)), param(inner, type(false, arr))]
			new-record)
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(ref, type(true, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			false
			ref-of-val
			type(true, exception-ctx)
			none
			[param(a, type(false, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(ref, type(true, log-ctx))]
			builtin([type(true, log-ctx)]))
		fun(
			false
			ref-of-val
			type(true, log-ctx)
			none
			[param(a, type(false, log-ctx))]
			builtin([type(true, log-ctx)]))
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(ref, type(true, perf-ctx))]
			builtin([type(true, perf-ctx)]))
		fun(
			false
			ref-of-val
			type(true, perf-ctx)
			none
			[param(a, type(false, perf-ctx))]
			builtin([type(true, perf-ctx)]))
		fun(false, print-lock, type(false, lock), none, [param(a, type(true, global-ctx))], field-get(1))
		fun(
			false
			as
			type(false, thread-local-stuff)
			none
			[param(value, type(false, thread-local-stuff))]
			builtin([type(false, thread-local-stuff)]))
		fun(
			false
			thread-local-stuff
			type(false, thread-local-stuff)
			none
			[
				param(thread-id, type(false, nat64))
				param(print-lock, type(true, lock))
				param(exception-ctx-ptr, type(false, ptr))
				param(log-ctx-ptr, type(false, ptr))
				param(perf-ctx-ptr, type(false, ptr))]
			new-record)
		fun(
			false
			ctx
			type(false, ctx)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(island, type(true, island))
				param(exclusion, type(false, nat64))]
			expr-body(
				let(
					gc-ctx
					call(get-gc-ctx, [call(ref-of-val, [call(gc, [param-ref(island)])])])
					seq(
						call(
							set-handler
							[
								call(as-ref, [call(log-ctx-ptr, [param-ref(tls)])])
								call(log-handler, [call(ref-of-val, [call(gc-root, [param-ref(island)])])])])
						call(
							ctx
							[
								call(as-any-ptr, [param-ref(gctx)])
								call(id, [param-ref(island)])
								param-ref(exclusion)
								call(as-any-ptr, [local-ref(gc-ctx)])
								param-ref(tls)])))))
		fun(
			false
			get-gc-ctx
			type(true, gc-ctx)
			none
			[param(gc, type(true, gc))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gc)])])])
					let(
						res
						match-union(
							call(context-head, [param-ref(gc)])
							[
								case(
									none
									let(
										c
										call(as-ref, [call(malloc, [call(size-of, [])])])
										seq(
											seq(
												call(set-gc, [local-ref(c), param-ref(gc)])
												call(set-next-ctx, [local-ref(c), to-union(0, call(none, []))]))
											local-ref(c))))
								case(
									some("<<matched>>")
									let(
										c
										get-field(local-ref("<<matched>>"), value)
										seq(
											seq(
												call(set-context-head, [param-ref(gc), call(next-ctx, [local-ref(c)])])
												call(set-next-ctx, [local-ref(c), to-union(0, call(none, []))]))
											local-ref(c))))])
						seq(call(release!, [call(ref-of-val, [call(lk, [param-ref(gc)])])]), local-ref(res))))))
		fun(false, context-head, type(false, opt), none, [param(a, type(true, gc))], field-get(2))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, gc-ctx)]))
		fun(
			false
			set-gc
			type(false, void)
			none
			[param(a, type(true, gc-ctx)), param(gc, type(true, gc))]
			field-set(0))
		fun(
			false
			set-next-ctx
			type(false, void)
			none
			[param(a, type(true, gc-ctx)), param(next-ctx, type(false, opt))]
			field-set(1))
		fun(
			false
			set-context-head
			type(false, void)
			none
			[param(a, type(true, gc)), param(context-head, type(false, opt))]
			field-set(2))
		fun(false, next-ctx, type(false, opt), none, [param(a, type(true, gc-ctx))], field-get(1))
		fun(false, gc, type(false, gc), none, [param(a, type(true, island))], field-get(2))
		fun(
			false
			set-handler
			type(false, void)
			none
			[param(a, type(true, log-ctx)), param(handler, type(false, fun1))]
			field-set(0))
		fun(false, as-ref, type(true, log-ctx), none, [param(a, type(false, ptr))], builtin([type(true, log-ctx)]))
		fun(false, log-ctx-ptr, type(false, ptr), none, [param(a, type(true, thread-local-stuff))], field-get(3))
		fun(false, log-handler, type(false, fun1), none, [param(a, type(true, island-gc-root))], field-get(2))
		fun(
			false
			ref-of-val
			type(true, island-gc-root)
			none
			[param(a, type(false, island-gc-root))]
			builtin([type(true, island-gc-root)]))
		fun(false, gc-root, type(false, island-gc-root), none, [param(a, type(true, island))], field-get(3))
		fun(
			false
			ctx
			type(false, ctx)
			none
			[
				param(gctx-ptr, type(false, ptr))
				param(island-id, type(false, nat64))
				param(exclusion, type(false, nat64))
				param(gc-ctx-ptr, type(false, ptr))
				param(thread-local-stuff, type(true, thread-local-stuff))]
			new-record)
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(ref, type(true, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(false, id, type(false, nat64), none, [param(a, type(true, island))], field-get(1))
		fun(false, as-any-ptr, type(false, ptr), none, [param(ref, type(true, gc-ctx))], builtin([type(true, gc-ctx)]))
		fun(
			false
			ref-of-val
			type(true, thread-local-stuff)
			none
			[param(a, type(false, thread-local-stuff))]
			builtin([type(true, thread-local-stuff)]))
		fun(false, ref-of-val, type(true, ctx), none, [param(a, type(false, ctx))], builtin([type(true, ctx)]))
		fun(
			false
			as
			type(false, fun-act2)
			none
			[param(value, type(false, fun-act2))]
			builtin([type(false, fun-act2)]))
		fun(
			true
			add-first-task
			type(true, fut)
			none
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				let(
					res
					call(
						then-void
						[
							call(delay, [])
							record(
								[
									call(cur-island-and-exclusion, [])
									lambda(0, alloc(record([param-ref(all-args), param-ref(main-ptr)])))])])
					seq(call(handle-exceptions, [local-ref(res)]), local-ref(res)))))
		fun(
			true
			then-void
			type(true, fut)
			none
			[param(a, type(true, fut)), param(cb, type(false, fun-ref0))]
			expr-body(
				call(
					then
					[
						param-ref(a)
						record([call(cur-island-and-exclusion, []), lambda(0, alloc(record([param-ref(cb)])))])])))
		fun(
			true
			then
			type(true, fut)
			none
			[param(a, type(true, fut)), param(cb, type(false, fun-ref1))]
			expr-body(
				let(
					res
					call(unresolved, [])
					seq(
						call(callback!, [param-ref(a), lambda(0, alloc(record([param-ref(cb), local-ref(res)])))])
						local-ref(res)))))
		fun(
			true
			unresolved
			type(true, fut)
			none
			[]
			expr-body(call(fut, [call(lock-by-val, []), to-union(0, call(fut-state-no-callbacks, []))])))
		fun(
			true
			fut
			type(true, fut)
			none
			[param(lk, type(false, lock)), param(state, type(false, fut-state))]
			new-record)
		fun(false, fut-state-no-callbacks, type(false, fut-state-no-callbacks), none, [], new-record)
		fun(
			true
			callback!
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-act1))]
			expr-body(
				call(
					with-lock
					[
						call(ref-of-val, [call(lk, [param-ref(f)])])
						lambda(0, alloc(record([param-ref(f), param-ref(cb)])))])))
		fun(
			true
			with-lock
			type(false, void)
			none
			[param(a, type(true, lock)), param(f, type(false, fun-act0))]
			expr-body(
				seq(
					call(acquire!, [param-ref(a)])
					let(res, call(subscript, [param-ref(f)]), seq(call(release!, [param-ref(a)]), local-ref(res))))))
		fun(
			true
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act0))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, [])])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act0)), param(c, type(true, ctx))]
			builtin([type(false, void)]))
		fun(false, lk, type(false, lock), none, [param(a, type(true, fut))], field-get(0))
		fun(false, state, type(false, fut-state), none, [param(a, type(true, fut))], field-get(1))
		fun(
			false
			set-state
			type(false, void)
			none
			[param(a, type(true, fut)), param(state, type(false, fut-state))]
			field-set(1))
		fun(
			true
			fut-state-callbacks
			type(true, fut-state-callbacks)
			none
			[param(cb, type(false, fun-act1)), param(next, type(false, opt))]
			new-record)
		fun(false, some, type(false, some), none, [param(value, type(true, fut-state-callbacks))], new-record)
		fun(
			true
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, result))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, result))]
			builtin([type(false, void), type(false, result)]))
		fun(false, ok, type(false, ok), none, [param(value, type(false, void))], new-record)
		fun(false, value, type(false, void), none, [param(a, type(false, fut-state-resolved))], field-get(0))
		fun(false, err, type(false, err), none, [param(value, type(false, exception))], new-record)
		fun(
			true
			lambda(callback!, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(callback!, 0))))
			[]
			expr-body(
				match-union(
					call(state, [get-field(param-ref("<<closure>>"), f)])
					[
						case(
							none
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									to-union(
										1
										call(
											fut-state-callbacks
											[get-field(param-ref("<<closure>>"), cb), to-union(0, call(none, []))]))]))
						case(
							some(cbs)
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									to-union(
										1
										call(
											fut-state-callbacks
											[
												get-field(param-ref("<<closure>>"), cb)
												to-union(1, call(some, [local-ref(cbs)]))]))]))
						case(
							some(r)
							call(
								subscript
								[
									get-field(param-ref("<<closure>>"), cb)
									to-union(0, call(ok, [call(value, [local-ref(r)])]))]))
						case(
							some(e)
							call(
								subscript
								[get-field(param-ref("<<closure>>"), cb), to-union(1, call(err, [local-ref(e)]))]))])))
		fun(
			true
			forward-to!
			type(false, void)
			none
			[param(from, type(true, fut)), param(to, type(true, fut))]
			expr-body(call(callback!, [param-ref(from), lambda(0, alloc(record([param-ref(to)])))])))
		fun(
			true
			callback!
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-act1))]
			expr-body(
				call(
					with-lock
					[
						call(ref-of-val, [call(lk, [param-ref(f)])])
						lambda(1, alloc(record([param-ref(f), param-ref(cb)])))])))
		fun(false, lk, type(false, lock), none, [param(a, type(true, fut))], field-get(0))
		fun(false, state, type(false, fut-state), none, [param(a, type(true, fut))], field-get(1))
		fun(
			false
			set-state
			type(false, void)
			none
			[param(a, type(true, fut)), param(state, type(false, fut-state))]
			field-set(1))
		fun(
			true
			fut-state-callbacks
			type(true, fut-state-callbacks)
			none
			[param(cb, type(false, fun-act1)), param(next, type(false, opt))]
			new-record)
		fun(false, some, type(false, some), none, [param(value, type(true, fut-state-callbacks))], new-record)
		fun(
			true
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, result))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, result))]
			builtin([type(false, void), type(false, result)]))
		fun(false, ok, type(false, ok), none, [param(value, type(false, nat64))], new-record)
		fun(false, value, type(false, nat64), none, [param(a, type(false, fut-state-resolved))], field-get(0))
		fun(
			true
			lambda(callback!, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(callback!, 0))))
			[]
			expr-body(
				match-union(
					call(state, [get-field(param-ref("<<closure>>"), f)])
					[
						case(
							none
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									to-union(
										1
										call(
											fut-state-callbacks
											[get-field(param-ref("<<closure>>"), cb), to-union(0, call(none, []))]))]))
						case(
							some(cbs)
							call(
								set-state
								[
									get-field(param-ref("<<closure>>"), f)
									to-union(
										1
										call(
											fut-state-callbacks
											[
												get-field(param-ref("<<closure>>"), cb)
												to-union(1, call(some, [local-ref(cbs)]))]))]))
						case(
							some(r)
							call(
								subscript
								[
									get-field(param-ref("<<closure>>"), cb)
									to-union(0, call(ok, [call(value, [local-ref(r)])]))]))
						case(
							some(e)
							call(
								subscript
								[get-field(param-ref("<<closure>>"), cb), to-union(1, call(err, [local-ref(e)]))]))])))
		fun(
			true
			resolve-or-reject!
			type(false, void)
			none
			[param(f, type(true, fut)), param(result, type(false, result))]
			expr-body(
				let(
					old-state
					call(
						with-lock
						[
							call(ref-of-val, [call(lk, [param-ref(f)])])
							lambda(0, alloc(record([param-ref(f), param-ref(result)])))])
					match-union(
						local-ref(old-state)
						[
							case(none, call(void, []))
							case(some(cbs), call(call-callbacks!, [local-ref(cbs), param-ref(result)]))
							case(none, call(hard-unreachable, []))
							case(none, call(hard-unreachable, []))]))))
		fun(
			true
			with-lock
			type(false, fut-state)
			none
			[param(a, type(true, lock)), param(f, type(false, fun-act0))]
			expr-body(
				seq(
					call(acquire!, [param-ref(a)])
					let(res, call(subscript, [param-ref(f)]), seq(call(release!, [param-ref(a)]), local-ref(res))))))
		fun(
			true
			subscript
			type(false, fut-state)
			none
			[param(a, type(false, fun-act0))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, [])])))
		fun(
			false
			call-with-ctx
			type(false, fut-state)
			none
			[param(f, type(false, fun-act0)), param(c, type(true, ctx))]
			builtin([type(false, fut-state)]))
		fun(
			true
			fut-state-resolved
			type(false, fut-state-resolved)
			none
			[param(value, type(false, nat64))]
			new-record)
		fun(false, value, type(false, nat64), none, [param(a, type(false, ok))], field-get(0))
		fun(false, value, type(false, exception), none, [param(a, type(false, err))], field-get(0))
		fun(
			true
			lambda(resolve-or-reject!, 0)
			type(false, fut-state)
			some(param("<<closure>>", type(true, lambda(resolve-or-reject!, 0))))
			[]
			expr-body(
				let(
					old
					call(state, [get-field(param-ref("<<closure>>"), f)])
					seq(
						call(
							set-state
							[
								get-field(param-ref("<<closure>>"), f)
								match-union(
									get-field(param-ref("<<closure>>"), result)
									[
										case(
											some(o)
											to-union(2, call(fut-state-resolved, [call(value, [local-ref(o)])])))
										case(some(e), let(ex, call(value, [local-ref(e)]), to-union(3, local-ref(ex))))])])
						local-ref(old)))))
		fun(
			true
			call-callbacks!
			type(false, void)
			none
			[param(cbs, type(true, fut-state-callbacks)), param(value, type(false, result))]
			expr-body(
				seq(
					call(subscript, [call(cb, [param-ref(cbs)]), param-ref(value)])
					match-union(
						call(next, [param-ref(cbs)])
						[
							case(none, void)
							case(
								some("<<matched>>")
								let(
									next
									get-field(local-ref("<<matched>>"), value)
									call(call-callbacks!, [local-ref(next), param-ref(value)])))]))))
		fun(false, cb, type(false, fun-act1), none, [param(a, type(true, fut-state-callbacks))], field-get(0))
		fun(false, next, type(false, opt), none, [param(a, type(true, fut-state-callbacks))], field-get(1))
		fun(
			true
			lambda(forward-to!, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(forward-to!, 0))))
			[param(it, type(false, result))]
			expr-body(call(resolve-or-reject!, [get-field(param-ref("<<closure>>"), to), param-ref(it)])))
		fun(
			true
			subscript
			type(true, fut)
			none
			[param(f, type(false, fun-ref1)), param(p0, type(false, void))]
			expr-body(
				let(
					island
					call(get-island, [call(island, [call(island-and-exclusion, [param-ref(f)])])])
					let(
						res
						call(unresolved, [])
						seq(
							call(
								add-task
								[
									local-ref(island)
									call(exclusion, [call(island-and-exclusion, [param-ref(f)])])
									lambda(3, alloc(record([param-ref(f), param-ref(p0), local-ref(res)])))])
							local-ref(res))))))
		fun(
			true
			get-island
			type(true, island)
			none
			[param(island-id, type(false, nat64))]
			expr-body(call(subscript, [call(islands, [call(get-global-ctx, [])]), param-ref(island-id)])))
		fun(
			true
			subscript
			type(true, island)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(false, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			false
			unsafe-at
			type(true, island)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])))
		fun(
			false
			subscript
			type(true, island)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64))]
			expr-body(call(subscript, [call(+, [param-ref(a), param-ref(n)])])))
		fun(false, subscript, type(true, island), none, [param(a, type(false, ptr))], builtin([type(true, island)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(true, island)]))
		fun(false, begin-ptr, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(false, islands, type(false, arr), none, [param(a, type(true, global-ctx))], field-get(4))
		fun(false, island, type(false, nat64), none, [param(a, type(false, island-and-exclusion))], field-get(0))
		fun(
			false
			island-and-exclusion
			type(false, island-and-exclusion)
			none
			[param(a, type(false, fun-ref1))]
			field-get(0))
		fun(
			true
			add-task
			type(false, void)
			none
			[param(a, type(true, island)), param(exclusion, type(false, nat64)), param(action, type(false, fun-act0))]
			expr-body(call(add-task, [param-ref(a), call(no-timestamp, []), param-ref(exclusion), param-ref(action)])))
		fun(
			true
			add-task
			type(false, void)
			none
			[
				param(a, type(true, island))
				param(timestamp, type(false, nat64))
				param(exclusion, type(false, nat64))
				param(action, type(false, fun-act0))]
			expr-body(
				let(
					node
					call(task-queue-node, [call(task, [param-ref(timestamp), param-ref(exclusion), param-ref(action)])])
					seq(
						seq(
							seq(
								call(acquire!, [call(ref-of-val, [call(tasks-lock, [param-ref(a)])])])
								call(insert-task!, [call(tasks, [param-ref(a)]), local-ref(node)]))
							call(release!, [call(ref-of-val, [call(tasks-lock, [param-ref(a)])])]))
						call(broadcast!, [call(ref-of-val, [call(may-be-work-to-do, [call(gctx, [param-ref(a)])])])])))))
		fun(
			true
			task-queue-node
			type(true, task-queue-node)
			none
			[param(task, type(false, task))]
			expr-body(call(task-queue-node, [param-ref(task), to-union(0, call(none, []))])))
		fun(
			true
			task-queue-node
			type(true, task-queue-node)
			none
			[param(task, type(false, task)), param(next, type(false, opt))]
			new-record)
		fun(
			false
			task
			type(false, task)
			none
			[
				param(time, type(false, nat64))
				param(exclusion, type(false, nat64))
				param(action, type(false, fun-act0))]
			new-record)
		fun(false, tasks-lock, type(false, lock), none, [param(a, type(true, island))], field-get(4))
		fun(
			false
			insert-task!
			type(false, void)
			none
			[param(a, type(true, task-queue)), param(inserted, type(true, task-queue-node))]
			expr-body(
				let(
					size-before
					call(size, [param-ref(a)])
					seq(
						match-union(
							call(head, [param-ref(a)])
							[
								case(
									none
									call(set-head, [param-ref(a), to-union(1, call(some, [param-ref(inserted)]))]))
								case(
									some("<<matched>>")
									let(
										head
										get-field(local-ref("<<matched>>"), value)
										cond(
											call(
												<=
												[
													call(time, [call(task, [local-ref(head)])])
													call(time, [call(task, [param-ref(inserted)])])])
											call(insert-recur, [local-ref(head), param-ref(inserted)])
											seq(
												call(
													set-next
													[param-ref(inserted), to-union(1, call(some, [local-ref(head)]))])
												call(
													set-head
													[param-ref(a), to-union(1, call(some, [param-ref(inserted)]))])))))])
						let(
							size-after
							call(size, [param-ref(a)])
							call(
								hard-assert
								[call(==, [call(wrap-add, [local-ref(size-before), 1]), local-ref(size-after)])]))))))
		fun(
			false
			size
			type(false, nat64)
			none
			[param(a, type(true, task-queue))]
			expr-body(call(size-recur, [call(head, [param-ref(a)]), 0])))
		fun(
			false
			size-recur
			type(false, nat64)
			none
			[param(node, type(false, opt)), param(acc, type(false, nat64))]
			expr-body(
				match-union(
					param-ref(node)
					[
						case(none, param-ref(acc))
						case(
							some("<<matched>>")
							let(
								n
								get-field(local-ref("<<matched>>"), value)
								call(size-recur, [call(next, [local-ref(n)]), call(wrap-add, [param-ref(acc), 1])])))])))
		fun(false, next, type(false, opt), none, [param(a, type(true, task-queue-node))], field-get(1))
		fun(false, head, type(false, opt), none, [param(a, type(true, task-queue))], field-get(0))
		fun(
			false
			set-head
			type(false, void)
			none
			[param(a, type(true, task-queue)), param(head, type(false, opt))]
			field-set(0))
		fun(false, some, type(false, some), none, [param(value, type(true, task-queue-node))], new-record)
		fun(false, time, type(false, nat64), none, [param(a, type(false, task))], field-get(0))
		fun(false, task, type(false, task), none, [param(a, type(true, task-queue-node))], field-get(0))
		fun(
			false
			insert-recur
			type(false, void)
			none
			[param(prev, type(true, task-queue-node)), param(inserted, type(true, task-queue-node))]
			expr-body(
				match-union(
					call(next, [param-ref(prev)])
					[
						case(none, call(set-next, [param-ref(prev), to-union(1, call(some, [param-ref(inserted)]))]))
						case(
							some("<<matched>>")
							let(
								cur
								get-field(local-ref("<<matched>>"), value)
								cond(
									call(
										<=
										[
											call(time, [call(task, [local-ref(cur)])])
											call(time, [call(task, [param-ref(inserted)])])])
									call(insert-recur, [local-ref(cur), param-ref(inserted)])
									seq(
										call(set-next, [param-ref(inserted), to-union(1, call(some, [local-ref(cur)]))])
										call(set-next, [param-ref(prev), to-union(1, call(some, [param-ref(inserted)]))])))))])))
		fun(
			false
			set-next
			type(false, void)
			none
			[param(a, type(true, task-queue-node)), param(next, type(false, opt))]
			field-set(1))
		fun(
			false
			tasks
			type(true, task-queue)
			none
			[param(a, type(true, island))]
			expr-body(call(ref-of-val, [call(tasks, [call(ref-of-val, [call(gc-root, [param-ref(a)])])])])))
		fun(
			false
			ref-of-val
			type(true, task-queue)
			none
			[param(a, type(false, task-queue))]
			builtin([type(true, task-queue)]))
		fun(false, tasks, type(false, task-queue), none, [param(a, type(true, island-gc-root))], field-get(0))
		fun(
			false
			broadcast!
			type(false, void)
			none
			[param(a, type(true, condition))]
			expr-body(
				seq(
					seq(
						seq(
							call(
								hard-assert-posix-error
								[call(pthread_mutex_lock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
							call(
								hard-assert-posix-error
								[call(pthread_cond_broadcast, [call(ref-of-val, [call(cond, [param-ref(a)])])])]))
						call(set-sequence, [param-ref(a), call(wrap-add, [call(sequence, [param-ref(a)]), 1])]))
					call(
						hard-assert-posix-error
						[call(pthread_mutex_unlock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])]))))
		fun(
			false
			pthread_mutex_lock
			type(false, int32)
			none
			[param(mutex, type(true, pthread_mutex_t))]
			extern(false))
		fun(
			false
			pthread_cond_broadcast
			type(false, int32)
			none
			[param(cond, type(true, pthread_cond_t))]
			extern(false))
		fun(
			false
			set-sequence
			type(false, void)
			none
			[param(a, type(true, condition)), param(sequence, type(false, nat64))]
			field-set(4))
		fun(false, sequence, type(false, nat64), none, [param(a, type(true, condition))], field-get(4))
		fun(
			false
			pthread_mutex_unlock
			type(false, int32)
			none
			[param(mutex, type(true, pthread_mutex_t))]
			extern(false))
		fun(false, may-be-work-to-do, type(false, condition), none, [param(a, type(true, global-ctx))], field-get(6))
		fun(false, gctx, type(true, global-ctx), none, [param(a, type(true, island))], field-get(0))
		fun(false, no-timestamp, type(false, nat64), none, [], expr-body(0))
		fun(false, exclusion, type(false, nat64), none, [param(a, type(false, island-and-exclusion))], field-get(1))
		fun(
			true
			catch
			type(false, void)
			none
			[param(try, type(false, fun-act0)), param(catcher, type(false, fun-act1))]
			expr-body(call(catch-with-exception-ctx, [call(get-exception-ctx, []), param-ref(try), param-ref(catcher)])))
		fun(
			true
			catch-with-exception-ctx
			type(false, void)
			none
			[
				param(ec, type(true, exception-ctx))
				param(try, type(false, fun-act0))
				param(catcher, type(false, fun-act1))]
			expr-body(
				let(
					old-thrown-exception
					call(thrown-exception, [param-ref(ec)])
					let(
						old-jmp-buf
						call(jmp-buf-ptr, [param-ref(ec)])
						let(
							store
							call(__jmp_buf_tag, [call(zero, []), 0, call(zero, [])])
							seq(
								call(set-jmp-buf-ptr, [param-ref(ec), call(ptr-to, [local-ref(store)])])
								let(
									setjmp-result
									call(setjmp, [call(jmp-buf-ptr, [param-ref(ec)])])
									cond(
										call(==, [local-ref(setjmp-result), 0])
										let(
											res
											call(subscript, [param-ref(try)])
											seq(
												seq(
													call(set-jmp-buf-ptr, [param-ref(ec), local-ref(old-jmp-buf)])
													call(
														set-thrown-exception
														[param-ref(ec), local-ref(old-thrown-exception)]))
												local-ref(res)))
										seq(
											call(
												hard-assert
												[call(==, [local-ref(setjmp-result), call(number-to-throw, [])])])
											let(
												thrown-exception
												call(thrown-exception, [param-ref(ec)])
												seq(
													seq(
														call(set-jmp-buf-ptr, [param-ref(ec), local-ref(old-jmp-buf)])
														call(
															set-thrown-exception
															[param-ref(ec), local-ref(old-thrown-exception)]))
													call(subscript, [param-ref(catcher), local-ref(thrown-exception)]))))))))))))
		fun(false, thrown-exception, type(false, exception), none, [param(a, type(true, exception-ctx))], field-get(1))
		fun(
			false
			__jmp_buf_tag
			type(false, __jmp_buf_tag)
			none
			[
				param(__jmpbuf, type(false, bytes64))
				param(__mask_was_saved, type(false, int32))
				param(__saved_mask, type(false, bytes128))]
			new-record)
		fun(false, zero, type(false, bytes64), none, [], expr-body(call(bytes64, [call(zero, []), call(zero, [])])))
		fun(
			false
			bytes64
			type(false, bytes64)
			none
			[param(n0, type(false, bytes32)), param(n1, type(false, bytes32))]
			new-record)
		fun(false, zero, type(false, bytes32), none, [], expr-body(call(bytes32, [call(zero, []), call(zero, [])])))
		fun(
			false
			bytes32
			type(false, bytes32)
			none
			[param(n0, type(false, bytes16)), param(n1, type(false, bytes16))]
			new-record)
		fun(false, zero, type(false, bytes16), none, [], expr-body(call(bytes16, [0, 0])))
		fun(
			false
			bytes16
			type(false, bytes16)
			none
			[param(n0, type(false, nat64)), param(n1, type(false, nat64))]
			new-record)
		fun(false, zero, type(false, bytes128), none, [], expr-body(call(bytes128, [call(zero, []), call(zero, [])])))
		fun(
			false
			bytes128
			type(false, bytes128)
			none
			[param(n0, type(false, bytes64)), param(n1, type(false, bytes64))]
			new-record)
		fun(
			false
			set-jmp-buf-ptr
			type(false, void)
			none
			[param(a, type(true, exception-ctx)), param(jmp-buf-ptr, type(false, ptr))]
			field-set(0))
		fun(
			false
			ptr-to
			type(false, ptr)
			none
			[param(t, type(false, __jmp_buf_tag))]
			builtin([type(false, __jmp_buf_tag)]))
		fun(false, setjmp, type(false, int32), none, [param(env, type(false, ptr))], extern(false))
		fun(
			true
			subscript
			type(false, void)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, exception))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, exception))]
			builtin([type(false, void), type(false, exception)]))
		fun(
			true
			subscript
			type(true, fut)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, void))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, void))]
			builtin([type(true, fut), type(false, void)]))
		fun(false, fun, type(false, fun-act1), none, [param(a, type(false, fun-ref1))], field-get(1))
		fun(
			true
			lambda(lambda(subscript, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 0))))
			[]
			expr-body(
				call(
					forward-to!
					[
						call(
							subscript
							[
								call(fun, [get-field(param-ref("<<closure>>"), f)])
								get-field(param-ref("<<closure>>"), p0)])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			true
			reject!
			type(false, void)
			none
			[param(f, type(true, fut)), param(e, type(false, exception))]
			expr-body(call(resolve-or-reject!, [param-ref(f), to-union(1, call(err, [param-ref(e)]))])))
		fun(
			true
			lambda(lambda(subscript, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 1))))
			[param(err, type(false, exception))]
			expr-body(call(reject!, [get-field(param-ref("<<closure>>"), res), param-ref(err)])))
		fun(
			true
			lambda(subscript, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(subscript, 0))))
			[]
			expr-body(
				call(
					catch
					[
						lambda(
							2
							alloc(
								record(
									[
										get-field(param-ref("<<closure>>"), f)
										get-field(param-ref("<<closure>>"), p0)
										get-field(param-ref("<<closure>>"), res)])))
						lambda(0, alloc(record([get-field(param-ref("<<closure>>"), res)])))])))
		fun(false, value, type(false, void), none, [param(a, type(false, ok))], field-get(0))
		fun(
			true
			lambda(then, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(then, 0))))
			[param(result, type(false, result))]
			expr-body(
				match-union(
					param-ref(result)
					[
						case(
							some(o)
							call(
								forward-to!
								[
									call(
										subscript
										[get-field(param-ref("<<closure>>"), cb), call(value, [local-ref(o)])])
									get-field(param-ref("<<closure>>"), res)]))
						case(
							some(e)
							call(reject!, [get-field(param-ref("<<closure>>"), res), call(value, [local-ref(e)])]))])))
		fun(
			true
			subscript
			type(true, fut)
			none
			[param(f, type(false, fun-ref0))]
			expr-body(
				let(
					res
					call(unresolved, [])
					seq(
						call(
							add-task
							[
								call(get-island, [call(island, [call(island-and-exclusion, [param-ref(f)])])])
								call(exclusion, [call(island-and-exclusion, [param-ref(f)])])
								lambda(5, alloc(record([param-ref(f), local-ref(res)])))])
						local-ref(res)))))
		fun(
			false
			island-and-exclusion
			type(false, island-and-exclusion)
			none
			[param(a, type(false, fun-ref0))]
			field-get(0))
		fun(
			true
			subscript
			type(true, fut)
			none
			[param(a, type(false, fun-act0))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, [])])))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[param(f, type(false, fun-act0)), param(c, type(true, ctx))]
			builtin([type(true, fut)]))
		fun(false, fun, type(false, fun-act0), none, [param(a, type(false, fun-ref0))], field-get(1))
		fun(
			true
			lambda(lambda(subscript, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 0))))
			[]
			expr-body(
				call(
					forward-to!
					[
						call(subscript, [call(fun, [get-field(param-ref("<<closure>>"), f)])])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			true
			lambda(lambda(subscript, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(subscript, 0), 1))))
			[param(err, type(false, exception))]
			expr-body(call(reject!, [get-field(param-ref("<<closure>>"), res), param-ref(err)])))
		fun(
			true
			lambda(subscript, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(subscript, 0))))
			[]
			expr-body(
				call(
					catch
					[
						lambda(
							4
							alloc(
								record(
									[get-field(param-ref("<<closure>>"), f), get-field(param-ref("<<closure>>"), res)])))
						lambda(1, alloc(record([get-field(param-ref("<<closure>>"), res)])))])))
		fun(
			true
			lambda(then-void, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(then-void, 0))))
			[param(ignore, type(false, void))]
			expr-body(call(subscript, [get-field(param-ref("<<closure>>"), cb)])))
		fun(
			true
			cur-island-and-exclusion
			type(false, island-and-exclusion)
			none
			[]
			expr-body(
				let(
					c
					call(get-ctx, [])
					call(island-and-exclusion, [call(island-id, [local-ref(c)]), call(exclusion, [local-ref(c)])]))))
		fun(
			false
			island-and-exclusion
			type(false, island-and-exclusion)
			none
			[param(island, type(false, nat64)), param(exclusion, type(false, nat64))]
			new-record)
		fun(false, island-id, type(false, nat64), none, [param(a, type(true, ctx))], field-get(1))
		fun(false, exclusion, type(false, nat64), none, [param(a, type(true, ctx))], field-get(2))
		fun(true, delay, type(true, fut), none, [], expr-body(call(resolved, [call(void, [])])))
		fun(
			true
			resolved
			type(true, fut)
			none
			[param(value, type(false, void))]
			expr-body(call(fut, [call(lock-by-val, []), to-union(2, call(fut-state-resolved, [param-ref(value)]))])))
		fun(
			true
			fut
			type(true, fut)
			none
			[param(lk, type(false, lock)), param(state, type(false, fut-state))]
			new-record)
		fun(
			true
			fut-state-resolved
			type(false, fut-state-resolved)
			none
			[param(value, type(false, void))]
			new-record)
		fun(
			true
			tail
			type(false, arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(subscript, [param-ref(a), call(->, [1, call(size, [param-ref(a)])])]))))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body(call(==, [call(size, [param-ref(a)]), 0])))
		fun(false, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			true
			subscript
			type(false, arr)
			none
			[param(a, type(false, arr)), param(range, type(false, arrow))]
			expr-body(
				seq(
					seq(
						call(assert, [call(<=, [call(from, [param-ref(range)]), call(to, [param-ref(range)])])])
						call(assert, [call(<=, [call(to, [param-ref(range)]), call(size, [param-ref(a)])])]))
					call(
						arr
						[
							call(wrap-sub, [call(to, [param-ref(range)]), call(from, [param-ref(range)])])
							call(+, [call(begin-ptr, [param-ref(a)]), call(from, [param-ref(range)])])]))))
		fun(
			false
			arr
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(begin-ptr, type(false, ptr))]
			new-record)
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(false, ptr)]))
		fun(false, begin-ptr, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			false
			subscript
			type(true, fut)
			none
			[param(a, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, arr))]
			builtin([type(true, fut), type(true, ctx), type(false, arr)]))
		fun(
			true
			map
			type(false, arr)
			none
			[param(a, type(false, arr)), param(f, type(false, fun-act1))]
			expr-body(
				call(make-arr, [call(size, [param-ref(a)]), lambda(0, alloc(record([param-ref(f), param-ref(a)])))])))
		fun(
			true
			make-arr
			type(false, arr)
			none
			[param(size, type(false, nat64)), param(f, type(false, fun-act1))]
			expr-body(
				let(
					res
					call(alloc-uninitialized, [param-ref(size)])
					seq(
						call(fill-ptr-range, [local-ref(res), param-ref(size), param-ref(f)])
						call(arr, [param-ref(size), local-ref(res)])))))
		fun(
			true
			alloc-uninitialized
			type(false, ptr)
			none
			[param(size, type(false, nat64))]
			expr-body(call(ptr-cast, [call(alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])])))
		fun(
			true
			fill-ptr-range
			type(false, void)
			none
			[param(begin, type(false, ptr)), param(size, type(false, nat64)), param(f, type(false, fun-act1))]
			expr-body(call(fill-ptr-range-recur, [param-ref(begin), 0, param-ref(size), param-ref(f)])))
		fun(
			true
			fill-ptr-range-recur
			type(false, void)
			none
			[
				param(begin, type(false, ptr))
				param(i, type(false, nat64))
				param(size, type(false, nat64))
				param(f, type(false, fun-act1))]
			expr-body(
				cond(
					call(!=, [param-ref(i), param-ref(size)])
					seq(
						call(
							set-subscript
							[param-ref(begin), param-ref(i), call(subscript, [param-ref(f), param-ref(i)])])
						call(
							fill-ptr-range-recur
							[param-ref(begin), call(wrap-add, [param-ref(i), 1]), param-ref(size), param-ref(f)]))
					void)))
		fun(
			true
			subscript
			type(false, str)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, nat64))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, str)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, nat64))]
			builtin([type(false, str), type(false, nat64)]))
		fun(
			true
			subscript
			type(false, str)
			none
			[param(a, type(false, fun-act1)), param(p0, type(false, ptr))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, str)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(false, ptr))]
			builtin([type(false, str), type(false, ptr)]))
		fun(
			true
			subscript
			type(false, ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(
			false
			unsafe-at
			type(false, ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])))
		fun(
			false
			subscript
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64))]
			expr-body(call(subscript, [call(+, [param-ref(a), param-ref(n)])])))
		fun(false, subscript, type(false, ptr), none, [param(a, type(false, ptr))], builtin([type(false, ptr)]))
		fun(
			true
			lambda(map, 0)
			type(false, str)
			some(param("<<closure>>", type(true, lambda(map, 0))))
			[param(i, type(false, nat64))]
			expr-body(
				call(
					subscript
					[
						get-field(param-ref("<<closure>>"), f)
						call(subscript, [get-field(param-ref("<<closure>>"), a), param-ref(i)])])))
		fun(
			false
			to-str
			type(false, str)
			none
			[param(a, type(false, ptr))]
			expr-body(call(str, [call(arr-from-begin-end, [param-ref(a), call(find-cstr-end, [param-ref(a)])])])))
		fun(
			false
			arr-from-begin-end
			type(false, arr)
			none
			[param(begin, type(false, ptr)), param(end, type(false, ptr))]
			expr-body(
				seq(
					call(hard-assert, [call(<=, [param-ref(begin), param-ref(end)])])
					call(arr, [call(-, [param-ref(end), param-ref(begin)]), param-ref(begin)]))))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				cond(
					call(less?, [param-ref(a), param-ref(b)])
					to-union(0, call(less, []))
					cond(
						call(==, [param-ref(a), param-ref(b)])
						to-union(1, call(equal, []))
						to-union(2, call(greater, []))))))
		fun(
			false
			less?
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			builtin([type(false, char)]))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(call(!, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				match-union(
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(
			false
			-
			type(false, nat64)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(
				call(
					unsafe-div
					[
						call(wrap-sub, [call(to-nat64, [param-ref(a)]), call(to-nat64, [param-ref(b)])])
						call(size-of, [])])))
		fun(false, to-nat64, type(false, nat64), none, [param(p, type(false, ptr))], builtin([type(false, char)]))
		fun(
			false
			find-cstr-end
			type(false, ptr)
			none
			[param(a, type(false, ptr))]
			expr-body(
				match-union(
					call(find-char-in-cstr, [param-ref(a), 0])
					[
						case(none, call(hard-unreachable, []))
						case(some("<<matched>>"), let(v, get-field(local-ref("<<matched>>"), value), local-ref(v)))])))
		fun(
			false
			find-char-in-cstr
			type(false, opt)
			none
			[param(a, type(false, ptr)), param(c, type(false, char))]
			expr-body(
				cond(
					call(==, [call(subscript, [param-ref(a)]), param-ref(c)])
					to-union(1, call(some, [param-ref(a)]))
					cond(
						call(==, [call(subscript, [param-ref(a)]), 0])
						to-union(0, call(none, []))
						call(find-char-in-cstr, [call(+, [param-ref(a), 1]), param-ref(c)])))))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, char)), param(b, type(false, char))]
			expr-body(call(==, [call(to-nat8, [param-ref(a)]), call(to-nat8, [param-ref(b)])])))
		fun(false, ==, type(false, bool), none, [param(a, type(false, nat8)), param(b, type(false, nat8))], builtin([]))
		fun(false, to-nat8, type(false, nat8), none, [param(c, type(false, char))], builtin([]))
		fun(false, some, type(false, some), none, [param(value, type(false, ptr))], new-record)
		fun(false, hard-unreachable, type(false, ptr), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(false, zeroed, type(false, ptr), none, [], builtin([type(false, ptr)]))
		fun(
			true
			lambda(lambda(add-first-task, 0), 0)
			type(false, str)
			some(param("<<closure>>", type(false, void)))
			[param(arg, type(false, ptr))]
			expr-body(call(to-str, [param-ref(arg)])))
		fun(
			true
			lambda(add-first-task, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(add-first-task, 0))))
			[]
			expr-body(
				let(
					args
					call(tail, [get-field(param-ref("<<closure>>"), all-args)])
					call(
						subscript
						[
							get-field(param-ref("<<closure>>"), main-ptr)
							call(get-ctx, [])
							call(map, [local-ref(args), lambda(0, void)])]))))
		fun(
			true
			handle-exceptions
			type(false, void)
			none
			[param(a, type(true, fut))]
			expr-body(call(callback!, [param-ref(a), lambda(1, void)])))
		fun(
			true
			subscript
			type(false, void)
			none
			[param(a, type(false, fun1)), param(p0, type(false, exception))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(f, type(false, fun1)), param(c, type(true, ctx)), param(p0, type(false, exception))]
			builtin([type(false, void), type(false, exception)]))
		fun(
			true
			exception-handler
			type(false, fun1)
			none
			[param(a, type(true, island))]
			expr-body(call(exception-handler, [call(ref-of-val, [call(gc-root, [param-ref(a)])])])))
		fun(false, exception-handler, type(false, fun1), none, [param(a, type(true, island-gc-root))], field-get(1))
		fun(
			true
			get-cur-island
			type(true, island)
			none
			[]
			expr-body(call(get-island, [call(island-id, [call(get-ctx, [])])])))
		fun(
			true
			lambda(handle-exceptions, 0)
			type(false, void)
			some(param("<<closure>>", type(false, void)))
			[param(result, type(false, result))]
			expr-body(
				match-union(
					param-ref(result)
					[
						case(none, call(void, []))
						case(
							some(e)
							call(
								subscript
								[call(exception-handler, [call(get-cur-island, [])]), call(value, [local-ref(e)])]))])))
		fun(
			true
			lambda(add-main-task, 0)
			type(true, fut)
			some(param("<<closure>>", type(false, void)))
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(call(add-first-task, [param-ref(all-args), param-ref(main-ptr)])))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[
				param(f, type(false, fun-act2))
				param(c, type(true, ctx))
				param(p0, type(false, arr))
				param(p1, type(false, fun-ptr2))]
			builtin([type(true, fut), type(false, arr), type(false, fun-ptr2)]))
		fun(
			false
			run-threads
			type(false, void)
			none
			[param(n-threads, type(false, nat64)), param(gctx, type(true, global-ctx))]
			expr-body(
				let(
					threads
					call(unmanaged-alloc-elements, [param-ref(n-threads)])
					let(
						thread-args
						call(unmanaged-alloc-elements, [param-ref(n-threads)])
						let(
							actual-n-threads
							call(wrap-sub, [param-ref(n-threads), 1])
							seq(
								seq(
									seq(
										seq(
											call(
												start-threads-recur
												[
													0
													local-ref(actual-n-threads)
													local-ref(threads)
													local-ref(thread-args)
													param-ref(gctx)])
											call(thread-function, [local-ref(actual-n-threads), param-ref(gctx)]))
										call(join-threads-recur, [0, local-ref(actual-n-threads), local-ref(threads)]))
									call(unmanaged-free, [local-ref(threads)]))
								call(unmanaged-free, [local-ref(thread-args)])))))))
		fun(
			false
			unmanaged-alloc-elements
			type(false, ptr)
			none
			[param(size-elements, type(false, nat64))]
			expr-body(
				call(
					ptr-cast
					[call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])])))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, thread-args), type(false, nat8)]))
		fun(false, size-of, type(false, nat64), none, [], builtin([type(false, thread-args)]))
		fun(
			false
			start-threads-recur
			type(false, void)
			none
			[
				param(i, type(false, nat64))
				param(n-threads, type(false, nat64))
				param(threads, type(false, ptr))
				param(thread-args-begin, type(false, ptr))
				param(gctx, type(true, global-ctx))]
			expr-body(
				cond(
					call(!=, [param-ref(i), param-ref(n-threads)])
					let(
						thread-arg-ptr
						call(+, [param-ref(thread-args-begin), param-ref(i)])
						seq(
							call(
								set-subscript
								[local-ref(thread-arg-ptr), call(thread-args, [param-ref(i), param-ref(gctx)])])
							let(
								thread-ptr
								call(+, [param-ref(threads), param-ref(i)])
								seq(
									call(
										create-one-thread
										[
											call(as-cell, [local-ref(thread-ptr)])
											call(as-any-ptr, [local-ref(thread-arg-ptr)])
											fun-ptr(thread-fun)])
									call(
										start-threads-recur
										[
											call(wrap-add, [param-ref(i), 1])
											param-ref(n-threads)
											param-ref(threads)
											param-ref(thread-args-begin)
											param-ref(gctx)])))))
					void)))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(offset, type(false, nat64))]
			builtin([type(false, thread-args)]))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(value, type(false, thread-args))]
			builtin([type(false, thread-args)]))
		fun(
			false
			thread-args
			type(false, thread-args)
			none
			[param(thread-id, type(false, nat64)), param(gctx, type(true, global-ctx))]
			new-record)
		fun(
			false
			create-one-thread
			type(false, void)
			none
			[
				param(tid, type(true, cell))
				param(thread-arg, type(false, ptr))
				param(thread-fun, type(false, fun-ptr1))]
			expr-body(
				let(
					err
					call(pthread_create, [param-ref(tid), call(null, []), param-ref(thread-fun), param-ref(thread-arg)])
					cond(
						call(!=, [local-ref(err), 0])
						cond(call(==, [local-ref(err), call(EAGAIN, [])]), call(todo, []), call(todo, []))
						void))))
		fun(
			false
			pthread_create
			type(false, int32)
			none
			[
				param(thread, type(true, cell))
				param(attr, type(false, ptr))
				param(start-routine, type(false, fun-ptr1))
				param(arg, type(false, ptr))]
			extern(false))
		fun(
			false
			!=
			type(false, bool)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(false, EAGAIN, type(false, int32), none, [], expr-body(11))
		fun(
			false
			as-cell
			type(true, cell)
			none
			[param(a, type(false, ptr))]
			expr-body(call(as-ref, [call(as-any-ptr, [param-ref(a)])])))
		fun(false, as-ref, type(true, cell), none, [param(a, type(false, ptr))], builtin([type(true, cell)]))
		fun(false, as-any-ptr, type(false, ptr), none, [param(ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(
			false
			thread-fun
			type(false, ptr)
			none
			[param(args-ptr, type(false, ptr))]
			expr-body(
				let(
					args
					call(as-ref, [param-ref(args-ptr)])
					seq(
						call(thread-function, [call(thread-id, [local-ref(args)]), call(gctx, [local-ref(args)])])
						call(null, [])))))
		fun(
			false
			as-ref
			type(true, thread-args)
			none
			[param(a, type(false, ptr))]
			builtin([type(true, thread-args)]))
		fun(
			false
			thread-function
			type(false, void)
			none
			[param(thread-id, type(false, nat64)), param(gctx, type(true, global-ctx))]
			expr-body(
				let(
					ectx
					call(exception-ctx, [])
					let(
						log-ctx
						call(log-ctx, [])
						let(
							perf-ctx
							call(perf-ctx, [])
							let(
								print-lock
								call(ref-of-val, [call(print-lock, [param-ref(gctx)])])
								let(
									ectx-ptr
									call(as-any-ptr, [call(ref-of-val, [local-ref(ectx)])])
									let(
										log-ctx-ptr
										call(as-any-ptr, [call(ref-of-val, [local-ref(log-ctx)])])
										let(
											perf-ptr
											call(as-any-ptr, [call(ref-of-val, [local-ref(perf-ctx)])])
											let(
												tls
												call(
													as
													[
														call(
															thread-local-stuff
															[
																param-ref(thread-id)
																local-ref(print-lock)
																local-ref(ectx-ptr)
																local-ref(log-ctx-ptr)
																local-ref(perf-ptr)])])
												call(
													thread-function-recur
													[param-ref(gctx), call(ref-of-val, [local-ref(tls)])])))))))))))
		fun(
			false
			thread-function-recur
			type(false, void)
			none
			[param(gctx, type(true, global-ctx)), param(tls, type(true, thread-local-stuff))]
			expr-body(
				cond(
					call(shut-down?, [param-ref(gctx)])
					seq(
						seq(
							seq(
								call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])
								call(
									set-n-live-threads
									[param-ref(gctx), call(wrap-sub, [call(n-live-threads, [param-ref(gctx)]), 1])]))
							call(assert-islands-are-shut-down, [0, call(islands, [param-ref(gctx)])]))
						call(release!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])]))
					seq(
						call(hard-assert, [call(>, [call(n-live-threads, [param-ref(gctx)]), 0])])
						let(
							last-checked
							call(get-sequence, [call(ref-of-val, [call(may-be-work-to-do, [param-ref(gctx)])])])
							seq(
								match-union(
									call(choose-task, [param-ref(gctx)])
									[
										case(some(t), call(do-task, [param-ref(gctx), param-ref(tls), local-ref(t)]))
										case(
											some(n)
											seq(
												seq(
													seq(
														cond(
															call(no-tasks-and-last-thread-out?, [local-ref(n)])
															seq(
																seq(
																	call(
																		hard-forbid
																		[call(shut-down?, [param-ref(gctx)])])
																	call(
																		set-shut-down?
																		[param-ref(gctx), call(true, [])]))
																call(
																	broadcast!
																	[
																		call(
																			ref-of-val
																			[call(may-be-work-to-do, [param-ref(gctx)])])]))
															call(
																wait-on
																[
																	call(
																		ref-of-val
																		[call(may-be-work-to-do, [param-ref(gctx)])])
																	call(first-task-time, [local-ref(n)])
																	local-ref(last-checked)]))
														call(
															acquire!
															[call(ref-of-val, [call(lk, [param-ref(gctx)])])]))
													call(
														set-n-live-threads
														[
															param-ref(gctx)
															call(wrap-add, [call(n-live-threads, [param-ref(gctx)]), 1])]))
												call(release!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])))])
								call(thread-function-recur, [param-ref(gctx), param-ref(tls)])))))))
		fun(false, shut-down?, type(false, bool), none, [param(a, type(true, global-ctx))], field-get(7))
		fun(false, lk, type(false, lock), none, [param(a, type(true, global-ctx))], field-get(0))
		fun(
			false
			set-n-live-threads
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(n-live-threads, type(false, nat64))]
			field-set(5))
		fun(false, n-live-threads, type(false, nat64), none, [param(a, type(true, global-ctx))], field-get(5))
		fun(
			false
			assert-islands-are-shut-down
			type(false, void)
			none
			[param(i, type(false, nat64)), param(islands, type(false, arr))]
			expr-body(
				cond(
					call(!=, [param-ref(i), call(size, [param-ref(islands)])])
					let(
						island
						call(noctx-at, [param-ref(islands), param-ref(i)])
						seq(
							seq(
								seq(
									seq(
										seq(
											call(acquire!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])])
											call(
												hard-forbid
												[call(needs-gc?, [call(ref-of-val, [call(gc, [local-ref(island)])])])]))
										call(hard-assert, [call(==, [call(n-threads-running, [local-ref(island)]), 0])]))
									call(hard-assert, [call(empty?, [call(tasks, [local-ref(island)])])]))
								call(release!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])]))
							call(assert-islands-are-shut-down, [call(wrap-add, [param-ref(i), 1]), param-ref(islands)])))
					void)))
		fun(
			false
			noctx-at
			type(true, island)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(false, needs-gc?, type(false, bool), none, [param(a, type(true, gc))], field-get(3))
		fun(false, n-threads-running, type(false, nat64), none, [param(a, type(true, island))], field-get(5))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(true, task-queue))]
			expr-body(call(empty?, [call(head, [param-ref(a)])])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(match-union(param-ref(a), [case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			get-sequence
			type(false, nat64)
			none
			[param(a, type(true, condition))]
			expr-body(
				seq(
					call(
						hard-assert-posix-error
						[call(pthread_mutex_lock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
					let(
						res
						call(sequence, [param-ref(a)])
						seq(
							call(
								hard-assert-posix-error
								[call(pthread_mutex_unlock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
							local-ref(res))))))
		fun(
			false
			choose-task
			type(false, choose-task-result)
			none
			[param(gctx, type(true, global-ctx))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])])
					let(
						cur-time
						call(get-monotime-nsec, [])
						let(
							res
							call(
								as
								[
									match-union(
										call(
											choose-task-recur
											[
												call(islands, [param-ref(gctx)])
												0
												local-ref(cur-time)
												call(false, [])
												to-union(0, call(none, []))])
										[
											case(some(c), to-union(0, local-ref(c)))
											case(
												some(n)
												seq(
													call(
														set-n-live-threads
														[
															param-ref(gctx)
															call(wrap-sub, [call(n-live-threads, [param-ref(gctx)]), 1])])
													let(
														no-task-and-last-thread-out?
														call(
															&&
															[
																call(no-tasks-and-last-thread-out?, [local-ref(n)])
																call(==, [call(n-live-threads, [param-ref(gctx)]), 0])])
														to-union(
															1
															call(
																no-chosen-task
																[
																	local-ref(no-task-and-last-thread-out?)
																	call(first-task-time, [local-ref(n)])])))))])])
							seq(call(release!, [call(ref-of-val, [call(lk, [param-ref(gctx)])])]), local-ref(res)))))))
		fun(
			false
			get-monotime-nsec
			type(false, nat64)
			none
			[]
			expr-body(
				let(
					time-cell
					call(as, [call(cell, [call(timespec, [0, 0])])])
					let(
						err
						call(clock_gettime, [call(CLOCK_MONOTONIC, []), call(ref-of-val, [local-ref(time-cell)])])
						cond(
							call(==, [local-ref(err), 0])
							let(
								time
								call(subscript, [call(ref-of-val, [local-ref(time-cell)])])
								call(
									unsafe-to-nat64
									[
										call(
											wrap-add
											[
												call(wrap-mul, [call(tv-sec, [local-ref(time)]), 1000000000])
												call(tv-nsec, [local-ref(time)])])]))
							call(todo, []))))))
		fun(false, as, type(false, cell), none, [param(value, type(false, cell))], builtin([type(false, cell)]))
		fun(false, cell, type(false, cell), none, [param(subscript, type(false, timespec))], new-record)
		fun(
			false
			timespec
			type(false, timespec)
			none
			[param(tv-sec, type(false, int64)), param(tv-nsec, type(false, int64))]
			new-record)
		fun(
			false
			clock_gettime
			type(false, int32)
			none
			[param(clock-id, type(false, int32)), param(timespec, type(true, cell))]
			extern(false))
		fun(false, ref-of-val, type(true, cell), none, [param(a, type(false, cell))], builtin([type(true, cell)]))
		fun(false, subscript, type(false, timespec), none, [param(a, type(true, cell))], field-get(0))
		fun(
			false
			wrap-add
			type(false, int64)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			builtin([]))
		fun(
			false
			wrap-mul
			type(false, int64)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			builtin([]))
		fun(false, tv-sec, type(false, int64), none, [param(a, type(false, timespec))], field-get(0))
		fun(false, tv-nsec, type(false, int64), none, [param(a, type(false, timespec))], field-get(1))
		fun(false, todo, type(false, nat64), none, [], expr-body(seq(call(abort, []), call(zeroed, []))))
		fun(false, zeroed, type(false, nat64), none, [], builtin([type(false, nat64)]))
		fun(
			false
			as
			type(false, choose-task-result)
			none
			[param(value, type(false, choose-task-result))]
			builtin([type(false, choose-task-result)]))
		fun(
			false
			choose-task-recur
			type(false, choose-task-result)
			none
			[
				param(islands, type(false, arr))
				param(i, type(false, nat64))
				param(cur-time, type(false, nat64))
				param(any-tasks?, type(false, bool))
				param(first-task-time, type(false, opt))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(islands)])])
					to-union(1, call(no-chosen-task, [call(!, [param-ref(any-tasks?)]), param-ref(first-task-time)]))
					let(
						island
						call(noctx-at, [param-ref(islands), param-ref(i)])
						match-union(
							call(choose-task-in-island, [local-ref(island), param-ref(cur-time)])
							[
								case(
									some(t)
									to-union(0, call(chosen-task, [local-ref(island), to-union(0, local-ref(t))])))
								case(
									some(g)
									to-union(0, call(chosen-task, [local-ref(island), to-union(1, local-ref(g))])))
								case(
									some(n)
									let(
										new-any-tasks?
										call(||, [param-ref(any-tasks?), call(any-tasks?, [local-ref(n)])])
										let(
											new-first-task-time
											call(
												min-time
												[param-ref(first-task-time), call(first-task-time, [local-ref(n)])])
											call(
												choose-task-recur
												[
													param-ref(islands)
													call(wrap-add, [param-ref(i), 1])
													param-ref(cur-time)
													local-ref(new-any-tasks?)
													local-ref(new-first-task-time)]))))])))))
		fun(
			false
			no-chosen-task
			type(false, no-chosen-task)
			none
			[param(no-tasks-and-last-thread-out?, type(false, bool)), param(first-task-time, type(false, opt))]
			new-record)
		fun(
			false
			choose-task-in-island
			type(false, choose-task-in-island-result)
			none
			[param(island, type(true, island)), param(cur-time, type(false, nat64))]
			expr-body(
				seq(
					call(acquire!, [call(ref-of-val, [call(tasks-lock, [param-ref(island)])])])
					let(
						res
						call(
							as
							[
								cond(
									call(needs-gc?, [call(ref-of-val, [call(gc, [param-ref(island)])])])
									cond(
										call(==, [call(n-threads-running, [param-ref(island)]), 0])
										to-union(1, call(do-a-gc, []))
										to-union(2, call(no-task, [call(true, []), to-union(0, call(none, []))])))
									match-union(
										call(pop-task!, [call(tasks, [param-ref(island)]), param-ref(cur-time)])
										[
											case(some(t), to-union(0, local-ref(t)))
											case(some(n), to-union(2, local-ref(n)))]))])
						seq(
							seq(
								cond(
									call(!, [call(is-no-task?, [local-ref(res)])])
									call(
										set-n-threads-running
										[
											param-ref(island)
											call(wrap-add, [call(n-threads-running, [param-ref(island)]), 1])])
									void)
								call(release!, [call(ref-of-val, [call(tasks-lock, [param-ref(island)])])]))
							local-ref(res))))))
		fun(
			false
			as
			type(false, choose-task-in-island-result)
			none
			[param(value, type(false, choose-task-in-island-result))]
			builtin([type(false, choose-task-in-island-result)]))
		fun(false, do-a-gc, type(false, do-a-gc), none, [], new-record)
		fun(
			false
			no-task
			type(false, no-task)
			none
			[param(any-tasks?, type(false, bool)), param(first-task-time, type(false, opt))]
			new-record)
		fun(
			false
			pop-task!
			type(false, pop-task-result)
			none
			[param(a, type(true, task-queue)), param(cur-time, type(false, nat64))]
			expr-body(
				let(
					exclusions
					call(ref-of-val, [call(currently-running-exclusions, [param-ref(a)])])
					let(
						res
						call(
							as
							[
								match-union(
									call(head, [param-ref(a)])
									[
										case(
											none
											to-union(1, call(no-task, [call(false, []), to-union(0, call(none, []))])))
										case(
											some("<<matched>>")
											let(
												head
												get-field(local-ref("<<matched>>"), value)
												let(
													task
													call(task, [local-ref(head)])
													cond(
														call(<=, [call(time, [local-ref(task)]), param-ref(cur-time)])
														cond(
															call(
																contains?
																[
																	local-ref(exclusions)
																	call(exclusion, [local-ref(task)])])
															call(
																pop-recur!
																[
																	local-ref(head)
																	local-ref(exclusions)
																	param-ref(cur-time)
																	call(to-opt-time, [call(time, [local-ref(task)])])])
															seq(
																call(
																	set-head
																	[param-ref(a), call(next, [local-ref(head)])])
																to-union(0, call(task, [local-ref(head)]))))
														to-union(
															1
															call(
																no-task
																[
																	call(true, [])
																	to-union(
																		1
																		call(some, [call(time, [local-ref(task)])]))]))))))])])
						seq(
							match-union(
								local-ref(res)
								[
									case(
										some(t)
										call(
											push-capacity-must-be-sufficient!
											[local-ref(exclusions), call(exclusion, [local-ref(t)])]))
									case(none, call(void, []))])
							local-ref(res))))))
		fun(
			false
			ref-of-val
			type(true, mut-list)
			none
			[param(a, type(false, mut-list))]
			builtin([type(true, mut-list)]))
		fun(
			false
			currently-running-exclusions
			type(false, mut-list)
			none
			[param(a, type(true, task-queue))]
			field-get(1))
		fun(
			false
			as
			type(false, pop-task-result)
			none
			[param(value, type(false, pop-task-result))]
			builtin([type(false, pop-task-result)]))
		fun(
			false
			contains?
			type(false, bool)
			none
			[param(a, type(true, mut-list)), param(value, type(false, nat64))]
			expr-body(call(contains?, [call(temp-as-arr, [param-ref(a)]), param-ref(value)])))
		fun(
			false
			contains?
			type(false, bool)
			none
			[param(a, type(false, arr)), param(value, type(false, nat64))]
			expr-body(call(contains-recur?, [param-ref(a), param-ref(value), 0])))
		fun(
			false
			contains-recur?
			type(false, bool)
			none
			[param(a, type(false, arr)), param(value, type(false, nat64)), param(i, type(false, nat64))]
			expr-body(
				cond(
					call(==, [param-ref(i), call(size, [param-ref(a)])])
					call(false, [])
					cond(
						call(==, [call(noctx-at, [param-ref(a), param-ref(i)]), param-ref(value)])
						call(true, [])
						call(contains-recur?, [param-ref(a), param-ref(value), call(wrap-add, [param-ref(i), 1])])))))
		fun(false, size, type(false, nat64), none, [param(a, type(false, arr))], field-get(0))
		fun(
			false
			noctx-at
			type(false, nat64)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					call(unsafe-at, [param-ref(a), param-ref(index)]))))
		fun(
			false
			unsafe-at
			type(false, nat64)
			none
			[param(a, type(false, arr)), param(index, type(false, nat64))]
			expr-body(call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])))
		fun(
			false
			subscript
			type(false, nat64)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64))]
			expr-body(call(subscript, [call(+, [param-ref(a), param-ref(n)])])))
		fun(false, subscript, type(false, nat64), none, [param(a, type(false, ptr))], builtin([type(false, nat64)]))
		fun(false, begin-ptr, type(false, ptr), none, [param(a, type(false, arr))], field-get(1))
		fun(
			false
			temp-as-arr
			type(false, arr)
			none
			[param(a, type(true, mut-list))]
			expr-body(call(temp-as-arr, [call(temp-as-mut-arr, [param-ref(a)])])))
		fun(
			false
			temp-as-arr
			type(false, arr)
			none
			[param(a, type(false, mut-arr))]
			expr-body(call(inner, [param-ref(a)])))
		fun(false, inner, type(false, arr), none, [param(a, type(false, mut-arr))], field-get(1))
		fun(
			false
			temp-as-mut-arr
			type(false, mut-arr)
			none
			[param(a, type(true, mut-list))]
			expr-body(call(mut-arr, [call(size, [param-ref(a)]), call(begin-ptr, [param-ref(a)])])))
		fun(false, size, type(false, nat64), none, [param(a, type(true, mut-list))], field-get(1))
		fun(
			false
			begin-ptr
			type(false, ptr)
			none
			[param(a, type(true, mut-list))]
			expr-body(call(begin-ptr, [call(backing, [param-ref(a)])])))
		fun(
			false
			begin-ptr
			type(false, ptr)
			none
			[param(a, type(false, mut-arr))]
			expr-body(call(begin-ptr, [call(inner, [param-ref(a)])])))
		fun(false, backing, type(false, mut-arr), none, [param(a, type(true, mut-list))], field-get(0))
		fun(false, exclusion, type(false, nat64), none, [param(a, type(false, task))], field-get(1))
		fun(
			false
			pop-recur!
			type(false, pop-task-result)
			none
			[
				param(prev, type(true, task-queue-node))
				param(exclusions, type(true, mut-list))
				param(cur-time, type(false, nat64))
				param(first-task-time, type(false, opt))]
			expr-body(
				match-union(
					call(next, [param-ref(prev)])
					[
						case(none, to-union(1, call(no-task, [call(true, []), param-ref(first-task-time)])))
						case(
							some("<<matched>>")
							let(
								cur
								get-field(local-ref("<<matched>>"), value)
								let(
									task
									call(task, [local-ref(cur)])
									cond(
										call(<=, [call(time, [local-ref(task)]), param-ref(cur-time)])
										cond(
											call(contains?, [param-ref(exclusions), call(exclusion, [local-ref(task)])])
											call(
												pop-recur!
												[
													local-ref(cur)
													param-ref(exclusions)
													param-ref(cur-time)
													match-union(
														param-ref(first-task-time)
														[
															case(
																none
																call(to-opt-time, [call(time, [local-ref(task)])]))
															case(
																some("<<matched>>")
																let(
																	t
																	get-field(local-ref("<<matched>>"), value)
																	to-union(1, call(some, [local-ref(t)]))))])])
											seq(
												call(set-next, [param-ref(prev), call(next, [local-ref(cur)])])
												to-union(0, local-ref(task))))
										to-union(
											1
											call(
												no-task
												[
													call(true, [])
													to-union(1, call(some, [call(time, [local-ref(task)])]))]))))))])))
		fun(
			false
			to-opt-time
			type(false, opt)
			none
			[param(a, type(false, nat64))]
			expr-body(
				cond(
					call(!=, [param-ref(a), call(no-timestamp, [])])
					to-union(1, call(some, [param-ref(a)]))
					to-union(0, call(none, [])))))
		fun(false, some, type(false, some), none, [param(value, type(false, nat64))], new-record)
		fun(
			false
			push-capacity-must-be-sufficient!
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(value, type(false, nat64))]
			expr-body(
				seq(
					seq(
						call(hard-assert, [call(<, [call(size, [param-ref(a)]), call(capacity, [param-ref(a)])])])
						call(
							set-subscript
							[call(begin-ptr, [param-ref(a)]), call(size, [param-ref(a)]), param-ref(value)]))
					call(set-size, [param-ref(a), call(wrap-add, [call(size, [param-ref(a)]), 1])]))))
		fun(
			false
			capacity
			type(false, nat64)
			none
			[param(a, type(true, mut-list))]
			expr-body(call(size, [call(backing, [param-ref(a)])])))
		fun(
			false
			size
			type(false, nat64)
			none
			[param(a, type(false, mut-arr))]
			expr-body(call(size, [call(inner, [param-ref(a)])])))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(n, type(false, nat64)), param(value, type(false, nat64))]
			expr-body(call(set-subscript, [call(+, [param-ref(a), param-ref(n)]), param-ref(value)])))
		fun(
			false
			set-subscript
			type(false, void)
			none
			[param(a, type(false, ptr)), param(value, type(false, nat64))]
			builtin([type(false, nat64)]))
		fun(
			false
			set-size
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(size, type(false, nat64))]
			field-set(1))
		fun(
			false
			is-no-task?
			type(false, bool)
			none
			[param(a, type(false, choose-task-in-island-result))]
			expr-body(
				match-union(
					param-ref(a)
					[case(none, call(false, [])), case(none, call(false, [])), case(none, call(true, []))])))
		fun(
			false
			set-n-threads-running
			type(false, void)
			none
			[param(a, type(true, island)), param(n-threads-running, type(false, nat64))]
			field-set(5))
		fun(
			false
			chosen-task
			type(false, chosen-task)
			none
			[param(task-island, type(true, island)), param(task-or-gc, type(false, task-or-gc))]
			new-record)
		fun(false, any-tasks?, type(false, bool), none, [param(a, type(false, no-task))], field-get(0))
		fun(
			false
			min-time
			type(false, opt)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(
				match-union(
					param-ref(a)
					[
						case(none, param-ref(b))
						case(
							some("<<matched>>")
							let(
								ta
								get-field(local-ref("<<matched>>"), value)
								match-union(
									param-ref(b)
									[
										case(none, to-union(0, call(none, [])))
										case(
											some("<<matched>>")
											let(
												tb
												get-field(local-ref("<<matched>>"), value)
												to-union(1, call(some, [call(min, [local-ref(ta), local-ref(tb)])]))))])))])))
		fun(
			false
			min
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(call(?, [call(<, [param-ref(a), param-ref(b)]), param-ref(a), param-ref(b)])))
		fun(
			false
			?
			type(false, nat64)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, nat64)), param(if-false, type(false, nat64))]
			builtin([type(false, nat64)]))
		fun(false, first-task-time, type(false, opt), none, [param(a, type(false, no-task))], field-get(1))
		fun(
			false
			no-tasks-and-last-thread-out?
			type(false, bool)
			none
			[param(a, type(false, no-chosen-task))]
			field-get(0))
		fun(false, first-task-time, type(false, opt), none, [param(a, type(false, no-chosen-task))], field-get(1))
		fun(
			false
			do-task
			type(false, void)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(chosen-task, type(false, chosen-task))]
			expr-body(
				let(
					island
					call(task-island, [param-ref(chosen-task)])
					seq(
						seq(
							seq(
								match-union(
									call(task-or-gc, [param-ref(chosen-task)])
									[
										case(
											some(task)
											let(
												ctx
												call(
													ctx
													[
														param-ref(gctx)
														param-ref(tls)
														local-ref(island)
														call(exclusion, [local-ref(task)])])
												seq(
													seq(
														seq(
															seq(
																call(
																	call-with-ctx
																	[
																		call(action, [local-ref(task)])
																		call(ref-of-val, [local-ref(ctx)])])
																call(
																	acquire!
																	[
																		call(
																			ref-of-val
																			[call(tasks-lock, [local-ref(island)])])]))
															call(
																return-task!
																[call(tasks, [local-ref(island)]), local-ref(task)]))
														call(
															release!
															[call(ref-of-val, [call(tasks-lock, [local-ref(island)])])]))
													call(return-ctx, [call(ref-of-val, [local-ref(ctx)])]))))
										case(
											none
											seq(
												call(
													run-garbage-collection
													[
														call(ref-of-val, [call(gc, [local-ref(island)])])
														call(gc-root, [local-ref(island)])])
												call(
													broadcast!
													[call(ref-of-val, [call(may-be-work-to-do, [param-ref(gctx)])])])))])
								call(acquire!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])]))
							call(
								set-n-threads-running
								[local-ref(island), call(wrap-sub, [call(n-threads-running, [local-ref(island)]), 1])]))
						call(release!, [call(ref-of-val, [call(tasks-lock, [local-ref(island)])])])))))
		fun(false, task-island, type(true, island), none, [param(a, type(false, chosen-task))], field-get(0))
		fun(false, task-or-gc, type(false, task-or-gc), none, [param(a, type(false, chosen-task))], field-get(1))
		fun(false, action, type(false, fun-act0), none, [param(a, type(false, task))], field-get(2))
		fun(
			false
			return-task!
			type(false, void)
			none
			[param(a, type(true, task-queue)), param(task, type(false, task))]
			expr-body(
				call(
					noctx-must-remove-unordered!
					[
						call(ref-of-val, [call(currently-running-exclusions, [param-ref(a)])])
						call(exclusion, [param-ref(task)])])))
		fun(
			false
			noctx-must-remove-unordered!
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(value, type(false, nat64))]
			expr-body(call(noctx-must-remove-unordered-recur!, [param-ref(a), 0, param-ref(value)])))
		fun(
			false
			noctx-must-remove-unordered-recur!
			type(false, void)
			none
			[param(a, type(true, mut-list)), param(index, type(false, nat64)), param(value, type(false, nat64))]
			expr-body(
				cond(
					call(==, [param-ref(index), call(size, [param-ref(a)])])
					call(todo, [])
					cond(
						call(
							==
							[call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)]), param-ref(value)])
						call(drop, [call(noctx-remove-unordered-at!, [param-ref(a), param-ref(index)])])
						call(
							noctx-must-remove-unordered-recur!
							[param-ref(a), call(wrap-add, [param-ref(index), 1]), param-ref(value)])))))
		fun(false, drop, type(false, void), none, [param("_", type(false, nat64))], expr-body(call(void, [])))
		fun(
			false
			noctx-remove-unordered-at!
			type(false, nat64)
			none
			[param(a, type(true, mut-list)), param(index, type(false, nat64))]
			expr-body(
				seq(
					call(hard-assert, [call(<, [param-ref(index), call(size, [param-ref(a)])])])
					let(
						res
						call(subscript, [call(begin-ptr, [param-ref(a)]), param-ref(index)])
						let(
							new-size
							call(wrap-sub, [call(size, [param-ref(a)]), 1])
							seq(
								seq(
									call(
										set-subscript
										[
											call(begin-ptr, [param-ref(a)])
											param-ref(index)
											call(subscript, [call(begin-ptr, [param-ref(a)]), local-ref(new-size)])])
									call(set-size, [param-ref(a), local-ref(new-size)]))
								local-ref(res)))))))
		fun(
			false
			return-ctx
			type(false, void)
			none
			[param(c, type(true, ctx))]
			expr-body(call(return-gc-ctx, [call(as-ref, [call(gc-ctx-ptr, [param-ref(c)])])])))
		fun(
			false
			return-gc-ctx
			type(false, void)
			none
			[param(gc-ctx, type(true, gc-ctx))]
			expr-body(
				let(
					gc
					call(gc, [param-ref(gc-ctx)])
					seq(
						seq(
							seq(
								call(acquire!, [call(ref-of-val, [call(lk, [local-ref(gc)])])])
								call(set-next-ctx, [param-ref(gc-ctx), call(context-head, [local-ref(gc)])]))
							call(set-context-head, [local-ref(gc), to-union(1, call(some, [param-ref(gc-ctx)]))]))
						call(release!, [call(ref-of-val, [call(lk, [local-ref(gc)])])])))))
		fun(false, some, type(false, some), none, [param(value, type(true, gc-ctx))], new-record)
		fun(
			false
			run-garbage-collection
			type(false, void)
			none
			[param(gc, type(true, gc)), param(gc-root, type(false, island-gc-root))]
			expr-body(
				seq(
					seq(
						seq(
							call(hard-assert, [call(needs-gc?, [param-ref(gc)])])
							call(set-gc-count, [param-ref(gc), call(wrap-add, [call(gc-count, [param-ref(gc)]), 1])]))
						call(
							drop
							[
								call(
									memset
									[
										call(as-any-ptr, [call(mark-begin, [param-ref(gc)])])
										0
										call(size-words, [param-ref(gc)])])]))
					let(
						mark-ctx
						call(
							as
							[
								call(
									mark-ctx
									[
										call(size-words, [param-ref(gc)])
										call(mark-begin, [param-ref(gc)])
										call(data-begin, [param-ref(gc)])])])
						seq(
							seq(
								seq(
									seq(
										seq(
											call(
												mark-visit
												[call(ref-of-val, [local-ref(mark-ctx)]), param-ref(gc-root)])
											call(set-mark-cur, [param-ref(gc), call(mark-begin, [param-ref(gc)])]))
										call(set-data-cur, [param-ref(gc), call(data-begin, [param-ref(gc)])]))
									call(
										clear-free-mem
										[
											call(mark-begin, [param-ref(gc)])
											call(mark-end, [param-ref(gc)])
											call(data-begin, [param-ref(gc)])]))
								call(validate-gc, [param-ref(gc)]))
							call(set-needs-gc?, [param-ref(gc), call(false, [])]))))))
		fun(
			false
			set-gc-count
			type(false, void)
			none
			[param(a, type(true, gc)), param(gc-count, type(false, nat64))]
			field-set(1))
		fun(false, gc-count, type(false, nat64), none, [param(a, type(true, gc))], field-get(1))
		fun(
			false
			as
			type(false, mark-ctx)
			none
			[param(value, type(false, mark-ctx))]
			builtin([type(false, mark-ctx)]))
		fun(
			false
			mark-ctx
			type(false, mark-ctx)
			none
			[
				param(memory-size-words, type(false, nat64))
				param(marks, type(false, ptr))
				param(memory-start, type(false, ptr))]
			new-record)
		fun(
			false
			mark-visit
			type(false, void)
			none
			[param(mark-ctx, type(true, mark-ctx)), param(value, type(false, island-gc-root))]
			builtin([type(false, island-gc-root)]))
		fun(
			false
			ref-of-val
			type(true, mark-ctx)
			none
			[param(a, type(false, mark-ctx))]
			builtin([type(true, mark-ctx)]))
		fun(
			false
			clear-free-mem
			type(false, void)
			none
			[param(mark-ptr, type(false, ptr)), param(mark-end, type(false, ptr)), param(data-ptr, type(false, ptr))]
			expr-body(
				cond(
					call(!=, [param-ref(mark-ptr), param-ref(mark-end)])
					seq(
						cond(
							call(!, [call(subscript, [param-ref(mark-ptr)])])
							call(set-subscript, [param-ref(data-ptr), -369582283799201058])
							void)
						call(
							clear-free-mem
							[call(+, [param-ref(mark-ptr), 1]), param-ref(mark-end), param-ref(data-ptr)]))
					void)))
		fun(
			false
			!=
			type(false, bool)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body(call(!, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			false
			set-shut-down?
			type(false, void)
			none
			[param(a, type(true, global-ctx)), param(shut-down?, type(false, bool))]
			field-set(7))
		fun(
			false
			wait-on
			type(false, void)
			none
			[
				param(a, type(true, condition))
				param(until-time, type(false, opt))
				param(last-sequence, type(false, nat64))]
			expr-body(
				seq(
					seq(
						call(
							hard-assert-posix-error
							[call(pthread_mutex_lock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])])
						cond(
							call(==, [call(sequence, [param-ref(a)]), param-ref(last-sequence)])
							call(
								hard-assert-posix-error
								[
									match-union(
										param-ref(until-time)
										[
											case(
												none
												call(
													pthread_cond_wait
													[
														call(ref-of-val, [call(cond, [param-ref(a)])])
														call(ref-of-val, [call(mutex, [param-ref(a)])])]))
											case(
												some("<<matched>>")
												let(
													t
													get-field(local-ref("<<matched>>"), value)
													let(
														abstime
														call(to-timespec, [local-ref(t)])
														let(
															err
															call(
																pthread_cond_timedwait
																[
																	call(ref-of-val, [call(cond, [param-ref(a)])])
																	call(ref-of-val, [call(mutex, [param-ref(a)])])
																	call(ptr-to, [local-ref(abstime)])])
															call(
																?
																[
																	call(==, [local-ref(err), call(ETIMEDOUT, [])])
																	0
																	local-ref(err)])))))])])
							void))
					call(
						hard-assert-posix-error
						[call(pthread_mutex_unlock, [call(ref-of-val, [call(mutex, [param-ref(a)])])])]))))
		fun(
			false
			pthread_cond_wait
			type(false, int32)
			none
			[param(cond, type(true, pthread_cond_t)), param(mutex, type(true, pthread_mutex_t))]
			extern(false))
		fun(
			false
			to-timespec
			type(false, timespec)
			none
			[param(a, type(false, nat64))]
			expr-body(
				let(
					seconds
					call(unsafe-to-int64, [call(unsafe-div, [param-ref(a), 1000000000])])
					let(
						ns
						call(unsafe-to-int64, [call(unsafe-mod, [param-ref(a), 1000000000])])
						call(timespec, [local-ref(seconds), local-ref(ns)])))))
		fun(
			false
			unsafe-mod
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			builtin([]))
		fun(
			false
			pthread_cond_timedwait
			type(false, int32)
			none
			[
				param(cond, type(true, pthread_cond_t))
				param(mutex, type(true, pthread_mutex_t))
				param(abstime, type(false, ptr))]
			extern(false))
		fun(false, ptr-to, type(false, ptr), none, [param(t, type(false, timespec))], builtin([type(false, timespec)]))
		fun(
			false
			?
			type(false, int32)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, int32)), param(if-false, type(false, int32))]
			builtin([type(false, int32)]))
		fun(false, ETIMEDOUT, type(false, int32), none, [], expr-body(110))
		fun(false, thread-id, type(false, nat64), none, [param(a, type(true, thread-args))], field-get(0))
		fun(false, gctx, type(true, global-ctx), none, [param(a, type(true, thread-args))], field-get(1))
		fun(
			false
			join-threads-recur
			type(false, void)
			none
			[param(i, type(false, nat64)), param(n-threads, type(false, nat64)), param(threads, type(false, ptr))]
			expr-body(
				cond(
					call(!=, [param-ref(i), param-ref(n-threads)])
					seq(
						call(join-one-thread, [call(subscript, [param-ref(threads), param-ref(i)])])
						call(
							join-threads-recur
							[call(wrap-add, [param-ref(i), 1]), param-ref(n-threads), param-ref(threads)]))
					void)))
		fun(
			false
			join-one-thread
			type(false, void)
			none
			[param(tid, type(false, nat64))]
			expr-body(
				let(
					thread-return
					call(as, [call(cell, [call(null, [])])])
					let(
						err
						call(pthread_join, [param-ref(tid), call(ref-of-val, [local-ref(thread-return)])])
						seq(
							cond(
								call(!=, [local-ref(err), 0])
								cond(
									call(==, [local-ref(err), call(EINVAL, [])])
									call(todo, [])
									cond(call(==, [local-ref(err), call(ESRCH, [])]), call(todo, []), call(todo, [])))
								void)
							call(
								hard-assert
								[call(null?, [call(subscript, [call(ref-of-val, [local-ref(thread-return)])])])]))))))
		fun(false, as, type(false, cell), none, [param(value, type(false, cell))], builtin([type(false, cell)]))
		fun(false, cell, type(false, cell), none, [param(subscript, type(false, ptr))], new-record)
		fun(
			false
			pthread_join
			type(false, int32)
			none
			[param(thread, type(false, nat64)), param(thread-return, type(true, cell))]
			extern(false))
		fun(false, ref-of-val, type(true, cell), none, [param(a, type(false, cell))], builtin([type(true, cell)]))
		fun(false, EINVAL, type(false, int32), none, [], expr-body(22))
		fun(false, ESRCH, type(false, int32), none, [], expr-body(3))
		fun(false, subscript, type(false, ptr), none, [param(a, type(true, cell))], field-get(0))
		fun(
			false
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, ptr))]
			expr-body(call(free, [call(ptr-cast, [param-ref(p)])])))
		fun(false, free, type(false, void), none, [param(p, type(false, ptr))], extern(false))
		fun(
			false
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, ptr))]
			expr-body(call(free, [call(ptr-cast, [param-ref(p)])])))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat8), type(false, thread-args)]))
		fun(
			false
			destroy-condition
			type(false, void)
			none
			[param(a, type(true, condition))]
			expr-body(
				seq(
					seq(
						seq(
							call(
								hard-assert-posix-error
								[
									call(
										pthread_mutexattr_destroy
										[call(ref-of-val, [call(mutex-attr, [param-ref(a)])])])])
							call(
								hard-assert-posix-error
								[call(pthread_mutex_destroy, [call(ref-of-val, [call(mutex, [param-ref(a)])])])]))
						call(
							hard-assert-posix-error
							[call(pthread_condattr_destroy, [call(ref-of-val, [call(cond-attr, [param-ref(a)])])])]))
					call(
						hard-assert-posix-error
						[call(pthread_cond_destroy, [call(ref-of-val, [call(cond, [param-ref(a)])])])]))))
		fun(
			false
			pthread_mutexattr_destroy
			type(false, int32)
			none
			[param(attr, type(true, pthread_mutexattr_t))]
			extern(false))
		fun(
			false
			pthread_mutex_destroy
			type(false, int32)
			none
			[param(mutex, type(true, pthread_mutex_t))]
			extern(false))
		fun(
			false
			pthread_condattr_destroy
			type(false, int32)
			none
			[param(attr, type(true, pthread_condattr_t))]
			extern(false))
		fun(
			false
			pthread_cond_destroy
			type(false, int32)
			none
			[param(cond, type(true, pthread_cond_t))]
			extern(false))
		fun(false, any-unhandled-exceptions?, type(false, bool), none, [param(a, type(true, global-ctx))], field-get(8))
		fun(
			true
			main
			type(true, fut)
			none
			[param("_", type(false, arr))]
			expr-body(
				seq(
					seq(
						seq(
							seq(
								seq(
									seq(
										seq(
											seq(
												seq(
													call(
														is
														[
															call(parse-nat, [record([record([0, null])])])
															to-union(0, call(none, []))])
													call(
														is
														[
															call(parse-nat, [record([arr(0, 11)])])
															to-union(1, call(some, [1]))]))
												call(
													is
													[call(parse-nat, [record([arr(0, 12)])]), to-union(0, call(none, []))]))
											call(is, [call(parse-nat, [record([arr(0, 13)])]), to-union(0, call(none, []))]))
										call(is, [call(parse-int, [record([arr(0, 14)])]), to-union(1, call(some, [123]))]))
									call(is, [call(parse-int, [record([arr(0, 15)])]), to-union(1, call(some, [-123]))]))
								call(is, [call(parse-int, [record([arr(0, 16)])]), to-union(1, call(some, [123]))]))
							call(is, [call(parse-int, [record([arr(0, 17)])]), to-union(0, call(none, []))]))
						call(print, [call(to-str, [call(parse-nat, [record([arr(0, 11)])])])]))
					call(resolved, [0]))))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(call(opt-equal?, [param-ref(a), param-ref(b)])))
		fun(
			false
			opt-equal?
			type(false, bool)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(
				match-union(
					param-ref(a)
					[
						case(none, call(!, [call(has?, [param-ref(b)])]))
						case(
							some("<<matched>>")
							let(
								va
								get-field(local-ref("<<matched>>"), value)
								match-union(
									param-ref(b)
									[
										case(none, call(false, []))
										case(
											some("<<matched>>")
											let(
												vb
												get-field(local-ref("<<matched>>"), value)
												call(==, [local-ref(va), local-ref(vb)])))])))])))
		fun(
			false
			has?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(call(!, [call(empty?, [param-ref(a)])])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(match-union(param-ref(a), [case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			true
			is
			type(false, void)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(call(assert, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			true
			parse-nat
			type(false, opt)
			none
			[param(a, type(false, str))]
			expr-body(call(with-reader, [param-ref(a), lambda(0, void)])))
		fun(
			true
			with-reader
			type(false, opt)
			none
			[param(a, type(false, str)), param(f, type(false, fun-act1))]
			expr-body(
				let(
					reader
					call(reader, [param-ref(a)])
					let(
						res
						call(subscript, [param-ref(f), local-ref(reader)])
						cond(
							call(&&, [call(has?, [local-ref(res)]), call(empty?, [local-ref(reader)])])
							local-ref(res)
							to-union(0, call(none, [])))))))
		fun(
			true
			reader
			type(true, reader)
			none
			[param(a, type(false, str))]
			expr-body(
				call(
					reader
					[call(begin-ptr, [call(chars, [param-ref(a)])]), call(end-ptr, [call(chars, [param-ref(a)])])])))
		fun(
			true
			reader
			type(true, reader)
			none
			[param(cur, type(false, ptr)), param(end, type(false, ptr))]
			new-record)
		fun(
			true
			subscript
			type(false, opt)
			none
			[param(a, type(false, fun-act1)), param(p0, type(true, reader))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, opt)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(true, reader))]
			builtin([type(false, opt), type(true, reader)]))
		fun(
			true
			empty?
			type(false, bool)
			none
			[param(a, type(true, reader))]
			expr-body(
				seq(
					call(assert, [call(<=, [call(cur, [param-ref(a)]), call(end, [param-ref(a)])])])
					call(==, [call(cur, [param-ref(a)]), call(end, [param-ref(a)])]))))
		fun(false, cur, type(false, ptr), none, [param(a, type(true, reader))], field-get(0))
		fun(false, end, type(false, ptr), none, [param(a, type(true, reader))], field-get(1))
		fun(
			true
			take-nat!
			type(false, opt)
			none
			[param(a, type(true, reader))]
			expr-body(
				cond(
					call(has?, [param-ref(a)])
					match-union(
						call(char-to-nat64, [call(peek, [param-ref(a)])])
						[
							case(none, to-union(0, call(none, [])))
							case(
								some("<<matched>>")
								let(
									first-digit
									get-field(local-ref("<<matched>>"), value)
									seq(
										call(drop, [call(next!, [param-ref(a)])])
										to-union(
											1
											call(some, [call(take-nat-recur!, [local-ref(first-digit), param-ref(a)])])))))])
					to-union(0, call(none, [])))))
		fun(
			true
			has?
			type(false, bool)
			none
			[param(a, type(true, reader))]
			expr-body(call(!, [call(empty?, [param-ref(a)])])))
		fun(
			true
			char-to-nat64
			type(false, opt)
			none
			[param(c, type(false, char))]
			expr-body(
				cond(
					call(==, [param-ref(c), 48])
					to-union(1, call(some, [0]))
					cond(
						call(==, [param-ref(c), 49])
						to-union(1, call(some, [1]))
						cond(
							call(==, [param-ref(c), 50])
							to-union(1, call(some, [2]))
							cond(
								call(==, [param-ref(c), 51])
								to-union(1, call(some, [3]))
								cond(
									call(==, [param-ref(c), 52])
									to-union(1, call(some, [4]))
									cond(
										call(==, [param-ref(c), 53])
										to-union(1, call(some, [5]))
										cond(
											call(==, [param-ref(c), 54])
											to-union(1, call(some, [6]))
											cond(
												call(==, [param-ref(c), 55])
												to-union(1, call(some, [7]))
												cond(
													call(==, [param-ref(c), 56])
													to-union(1, call(some, [8]))
													cond(
														call(==, [param-ref(c), 57])
														to-union(1, call(some, [9]))
														to-union(0, call(none, []))))))))))))))
		fun(
			true
			peek
			type(false, char)
			none
			[param(a, type(true, reader))]
			expr-body(seq(call(assert, [call(has?, [param-ref(a)])]), call(subscript, [call(cur, [param-ref(a)])]))))
		fun(false, drop, type(false, void), none, [param("_", type(false, char))], expr-body(call(void, [])))
		fun(
			true
			next!
			type(false, char)
			none
			[param(a, type(true, reader))]
			expr-body(
				seq(
					call(assert, [call(has?, [param-ref(a)])])
					let(
						res
						call(subscript, [call(cur, [param-ref(a)])])
						seq(call(set-cur, [param-ref(a), call(+, [call(cur, [param-ref(a)]), 1])]), local-ref(res))))))
		fun(
			false
			set-cur
			type(false, void)
			none
			[param(a, type(true, reader)), param(cur, type(false, ptr))]
			field-set(0))
		fun(
			true
			take-nat-recur!
			type(false, nat64)
			none
			[param(acc, type(false, nat64)), param(a, type(true, reader))]
			expr-body(
				cond(
					call(empty?, [param-ref(a)])
					param-ref(acc)
					match-union(
						call(char-to-nat64, [call(peek, [param-ref(a)])])
						[
							case(none, param-ref(acc))
							case(
								some("<<matched>>")
								let(
									v
									get-field(local-ref("<<matched>>"), value)
									seq(
										call(drop, [call(next!, [param-ref(a)])])
										call(
											take-nat-recur!
											[call(+, [call(*, [param-ref(acc), 10]), local-ref(v)]), param-ref(a)]))))]))))
		fun(
			true
			lambda(parse-nat, 0)
			type(false, opt)
			some(param("<<closure>>", type(false, void)))
			[param(r, type(true, reader))]
			expr-body(call(take-nat!, [param-ref(r)])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(call(opt-equal?, [param-ref(a), param-ref(b)])))
		fun(
			false
			opt-equal?
			type(false, bool)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(
				match-union(
					param-ref(a)
					[
						case(none, call(!, [call(has?, [param-ref(b)])]))
						case(
							some("<<matched>>")
							let(
								va
								get-field(local-ref("<<matched>>"), value)
								match-union(
									param-ref(b)
									[
										case(none, call(false, []))
										case(
											some("<<matched>>")
											let(
												vb
												get-field(local-ref("<<matched>>"), value)
												call(==, [local-ref(va), local-ref(vb)])))])))])))
		fun(
			false
			has?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(call(!, [call(empty?, [param-ref(a)])])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(match-union(param-ref(a), [case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			true
			is
			type(false, void)
			none
			[param(a, type(false, opt)), param(b, type(false, opt))]
			expr-body(call(assert, [call(==, [param-ref(a), param-ref(b)])])))
		fun(
			true
			parse-int
			type(false, opt)
			none
			[param(a, type(false, str))]
			expr-body(call(with-reader, [param-ref(a), lambda(0, void)])))
		fun(
			true
			with-reader
			type(false, opt)
			none
			[param(a, type(false, str)), param(f, type(false, fun-act1))]
			expr-body(
				let(
					reader
					call(reader, [param-ref(a)])
					let(
						res
						call(subscript, [param-ref(f), local-ref(reader)])
						cond(
							call(&&, [call(has?, [local-ref(res)]), call(empty?, [local-ref(reader)])])
							local-ref(res)
							to-union(0, call(none, [])))))))
		fun(
			true
			subscript
			type(false, opt)
			none
			[param(a, type(false, fun-act1)), param(p0, type(true, reader))]
			expr-body(call(call-with-ctx, [param-ref(a), call(get-ctx, []), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, opt)
			none
			[param(f, type(false, fun-act1)), param(c, type(true, ctx)), param(p0, type(true, reader))]
			builtin([type(false, opt), type(true, reader)]))
		fun(
			true
			take-int!
			type(false, opt)
			none
			[param(a, type(true, reader))]
			expr-body(
				let(
					start
					call(cur, [param-ref(a)])
					let(
						sign
						call(?, [call(take-sign?, [param-ref(a)]), 1, -1])
						match-union(
							call(take-nat!, [param-ref(a)])
							[
								case(
									none
									seq(call(set-cur, [param-ref(a), local-ref(start)]), to-union(0, call(none, []))))
								case(
									some("<<matched>>")
									let(
										n
										get-field(local-ref("<<matched>>"), value)
										to-union(
											1
											call(some, [call(*, [call(to-int64, [local-ref(n)]), local-ref(sign)])]))))])))))
		fun(
			false
			?
			type(false, int64)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, int64)), param(if-false, type(false, int64))]
			builtin([type(false, int64)]))
		fun(
			true
			take-sign?
			type(false, bool)
			none
			[param(a, type(true, reader))]
			expr-body(
				cond(
					call(take-char?, [param-ref(a), 45])
					call(false, [])
					seq(call(drop, [call(take-char?, [param-ref(a), 43])]), call(true, [])))))
		fun(
			true
			take-char?
			type(false, bool)
			none
			[param(a, type(true, reader)), param(c, type(false, char))]
			expr-body(
				cond(
					call(&&, [call(has?, [param-ref(a)]), call(==, [call(peek, [param-ref(a)]), param-ref(c)])])
					seq(call(drop, [call(next!, [param-ref(a)])]), call(true, []))
					call(false, []))))
		fun(false, drop, type(false, void), none, [param("_", type(false, bool))], expr-body(call(void, [])))
		fun(false, some, type(false, some), none, [param(value, type(false, int64))], new-record)
		fun(
			true
			*
			type(false, int64)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			expr-body(call(wrap-mul, [param-ref(a), param-ref(b)])))
		fun(
			true
			to-int64
			type(false, int64)
			none
			[param(a, type(false, nat64))]
			expr-body(
				seq(
					call(assert, [call(<, [param-ref(a), call(to-nat64, [call(max-int64, [])])])])
					call(unsafe-to-int64, [param-ref(a)]))))
		fun(
			true
			to-nat64
			type(false, nat64)
			none
			[param(a, type(false, int64))]
			expr-body(seq(call(forbid, [call(<, [param-ref(a), 0])]), call(unsafe-to-nat64, [param-ref(a)]))))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			expr-body(
				call(
					?
					[
						call(less?, [param-ref(a), param-ref(b)])
						to-union(0, call(less, []))
						call(
							?
							[
								call(==, [param-ref(a), param-ref(b)])
								to-union(1, call(equal, []))
								to-union(2, call(greater, []))])])))
		fun(
			false
			less?
			type(false, bool)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			builtin([]))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, int64)), param(b, type(false, int64))]
			expr-body(
				match-union(
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(false, max-int64, type(false, int64), none, [], expr-body(9223372036854775807))
		fun(
			true
			lambda(parse-int, 0)
			type(false, opt)
			some(param("<<closure>>", type(false, void)))
			[param(r, type(true, reader))]
			expr-body(call(take-int!, [param-ref(r)])))
		fun(
			true
			to-str
			type(false, str)
			none
			[param(a, type(false, nat64))]
			expr-body(call(to-base, [param-ref(a), 10])))
		fun(
			true
			to-base
			type(false, str)
			none
			[param(a, type(false, nat64)), param(base, type(false, nat64))]
			expr-body(
				cond(
					call(<, [param-ref(a), param-ref(base)])
					call(digit-to-str, [param-ref(a)])
					call(
						~
						[
							call(to-base, [call(/, [param-ref(a), param-ref(base)]), param-ref(base)])
							call(digit-to-str, [call(mod, [param-ref(a), param-ref(base)])])]))))
		fun(
			true
			digit-to-str
			type(false, str)
			none
			[param(a, type(false, nat64))]
			expr-body(
				cond(
					call(==, [param-ref(a), 0])
					record([arr(0, 18)])
					cond(
						call(==, [param-ref(a), 1])
						record([arr(0, 11)])
						cond(
							call(==, [param-ref(a), 2])
							record([arr(0, 19)])
							cond(
								call(==, [param-ref(a), 3])
								record([arr(0, 20)])
								cond(
									call(==, [param-ref(a), 4])
									record([arr(0, 21)])
									cond(
										call(==, [param-ref(a), 5])
										record([arr(0, 22)])
										cond(
											call(==, [param-ref(a), 6])
											record([arr(0, 23)])
											cond(
												call(==, [param-ref(a), 7])
												record([arr(0, 24)])
												cond(
													call(==, [param-ref(a), 8])
													record([arr(0, 25)])
													cond(
														call(==, [param-ref(a), 9])
														record([arr(0, 26)])
														cond(
															call(==, [param-ref(a), 10])
															record([arr(0, 27)])
															cond(
																call(==, [param-ref(a), 11])
																record([arr(0, 28)])
																cond(
																	call(==, [param-ref(a), 12])
																	record([arr(0, 29)])
																	cond(
																		call(==, [param-ref(a), 13])
																		record([arr(0, 30)])
																		cond(
																			call(==, [param-ref(a), 14])
																			record([arr(0, 31)])
																			cond(
																				call(==, [param-ref(a), 15])
																				record([arr(0, 32)])
																				record([arr(0, 33)])))))))))))))))))))
		fun(
			true
			mod
			type(false, nat64)
			none
			[param(a, type(false, nat64)), param(b, type(false, nat64))]
			expr-body(seq(call(forbid, [call(==, [param-ref(b), 0])]), call(unsafe-mod, [param-ref(a), param-ref(b)]))))
		fun(
			true
			to-str
			type(false, str)
			none
			[param(a, type(false, opt))]
			expr-body(
				match-union(
					param-ref(a)
					[
						case(none, record([arr(0, 34)]))
						case(
							some("<<matched>>")
							let(
								v
								get-field(local-ref("<<matched>>"), value)
								call(
									finish
									[
										call(
											with-str
											[
												call(
													with-value
													[
														call(with-str, [call(interp, []), record([arr(0, 35)])])
														local-ref(v)])
												record([arr(0, 36)])])])))])))
		fun(
			true
			finish
			type(false, str)
			none
			[param(a, type(false, interp))]
			expr-body(call(str, [call(move-to-arr!, [call(inner, [param-ref(a)])])])))
		fun(false, inner, type(true, mut-list), none, [param(a, type(false, interp))], field-get(0))
		fun(
			true
			with-str
			type(false, interp)
			none
			[param(a, type(false, interp)), param(b, type(false, str))]
			expr-body(seq(call(~=, [call(inner, [param-ref(a)]), call(chars, [param-ref(b)])]), param-ref(a))))
		fun(
			true
			with-value
			type(false, interp)
			none
			[param(a, type(false, interp)), param(b, type(false, nat64))]
			expr-body(call(with-str, [param-ref(a), call(to-str, [param-ref(b)])])))
		fun(true, interp, type(false, interp), none, [], expr-body(call(interp, [call(mut-list, [])])))
		fun(true, interp, type(false, interp), none, [param(inner, type(true, mut-list))], new-record)
		fun(
			true
			resolved
			type(true, fut)
			none
			[param(value, type(false, nat64))]
			expr-body(call(fut, [call(lock-by-val, []), to-union(2, call(fut-state-resolved, [param-ref(value)]))])))
		fun(false, static-syms, type(false, arr), none, [], builtin([]))]
	rt-main
	main
	ctx)
