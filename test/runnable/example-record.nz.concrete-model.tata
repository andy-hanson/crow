program(
	[
		struct(
			name: ctx
			ptr?: true
			body: record(
				[
					field(gctx-ptr, false, type(false, ptr))
					field(vat-id, false, type(false, nat))
					field(actor-id, false, type(false, nat))
					field(gc-ctx-ptr, false, type(false, ptr))
					field(exception-ctx-ptr, false, type(false, ptr))]))
		struct(name: nat8, body: builtin(nat-8, []))
		struct(name: ptr, body: builtin(ptr, [type(false, nat8)]))
		struct(name: nat, body: builtin(nat-64, []))
		struct(name: int32, body: builtin(int-32, []))
		struct(name: char, body: builtin(char, []))
		struct(name: ptr, body: builtin(ptr, [type(false, char)]))
		struct(name: ptr, body: builtin(ptr, [type(false, ptr)]))
		struct(
			name: fut
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(state, true, type(false, fut-state))]))
		struct(name: lock, ptr?: true, body: record([field(is-locked, false, type(false, atomic-bool))]))
		struct(name: atomic-bool, mut?: true, ptr?: true, body: record([field(value, true, type(false, bool))]))
		struct(name: bool, body: builtin(bool, []))
		struct(
			name: fut-state
			body: union([type(false, fut-state-callbacks), type(false, fut-state-resolved), type(false, exception)]))
		struct(name: fut-state-callbacks, body: record([field(head, false, type(false, opt))]))
		struct(
			name: fut-callback-node
			ptr?: true
			body: record([field(cb, false, type(false, fun-mut1)), field(next-node, false, type(false, opt))]))
		struct(name: void, body: builtin(void, []))
		struct(name: exception, body: record([field(message, false, type(false, arr))]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, int32))]))
		struct(name: err, body: record([field(value, false, type(false, exception))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: none, body: record([]))
		struct(name: some, body: record([field(value, false, type(true, fut-callback-node))]))
		struct(name: fut-state-resolved, body: record([field(value, false, type(false, int32))]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, arr)]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, arr)]))
		struct(
			name: global-ctx
			mut?: true
			ptr?: true
			body: record(
				[
					field(lk, false, type(false, lock))
					field(vats, true, type(false, arr))
					field(n-live-threads, true, type(false, nat))
					field(may-be-work-to-do, false, type(false, condition))
					field(is-shut-down, true, type(false, bool))
					field(any-unhandled-exceptions?, true, type(false, bool))]))
		struct(
			name: vat
			mut?: true
			ptr?: true
			body: record(
				[
					field(gctx, false, type(true, global-ctx))
					field(id, false, type(false, nat))
					field(gc, false, type(false, gc))
					field(tasks-lock, false, type(false, lock))
					field(tasks, false, type(false, mut-bag))
					field(currently-running-actors, false, type(false, mut-arr))
					field(n-threads-running, true, type(false, nat))
					field(next-actor-id, false, type(false, thread-safe-counter))
					field(exception-handler, true, type(false, fun-mut1))]))
		struct(
			name: gc
			mut?: true
			ptr?: true
			body: record(
				[
					field(lk, false, type(false, lock))
					field(context-head, true, type(false, opt))
					field(needs-gc, true, type(false, bool))
					field(is-doing-gc, true, type(false, bool))
					field(begin, false, type(false, ptr))
					field(next-byte, false, type(false, ptr))]))
		struct(
			name: gc-ctx
			mut?: true
			ptr?: true
			body: record([field(gc, true, type(true, gc)), field(next-ctx, true, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, gc-ctx))]))
		struct(
			name: task
			body: record([field(actor-id, false, type(false, nat)), field(fun, false, type(false, fun-mut0))]))
		struct(
			name: fun-mut0
			body: record([field(fun-ptr, false, type(false, fun-ptr2)), field(closure, false, type(false, ptr))]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr)]))
		struct(name: mut-bag, mut?: true, ptr?: true, body: record([field(head, true, type(false, opt))]))
		struct(
			name: mut-bag-node
			mut?: true
			ptr?: true
			body: record([field(value, false, type(false, task)), field(next-node, true, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, mut-bag-node))]))
		struct(
			name: mut-arr
			mut?: true
			ptr?: true
			body: record(
				[
					field(frozen?, true, type(false, bool))
					field(size, true, type(false, nat))
					field(capacity, true, type(false, nat))
					field(data, true, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(false, nat)]))
		struct(
			name: thread-safe-counter
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(value, true, type(false, nat))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr), type(false, exception)]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: ptr, body: builtin(ptr, [type(true, vat)]))
		struct(
			name: condition
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(value, true, type(false, nat))]))
		struct(name: comparison, body: union([type(false, less), type(false, equal), type(false, greater)]))
		struct(name: less, body: record([]))
		struct(name: equal, body: record([]))
		struct(name: greater, body: record([]))
		struct(name: ptr, body: builtin(ptr, [type(false, bool)]))
		struct(name: int, body: builtin(int-64, []))
		struct(
			name: exception-ctx
			mut?: true
			ptr?: true
			body: record([field(jmp-buf-ptr, true, type(false, ptr)), field(thrown-exception, true, type(false, exception))]))
		struct(
			name: jmp-buf-tag
			body: record(
				[
					field(jmp-buf, false, type(false, bytes64))
					field(mask-was-saved, false, type(false, int32))
					field(saved-mask, false, type(false, bytes128))]))
		struct(
			name: bytes64
			body: record([field(n0, false, type(false, bytes32)), field(n1, false, type(false, bytes32))]))
		struct(
			name: bytes32
			body: record([field(n0, false, type(false, bytes16)), field(n1, false, type(false, bytes16))]))
		struct(name: bytes16, body: record([field(n0, false, type(false, nat)), field(n1, false, type(false, nat))]))
		struct(
			name: bytes128
			body: record([field(n0, false, type(false, bytes64)), field(n1, false, type(false, bytes64))]))
		struct(name: ptr, body: builtin(ptr, [type(false, jmp-buf-tag)]))
		struct(
			name: thread-local-stuff
			ptr?: true
			body: record([field(exception-ctx, false, type(true, exception-ctx))]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(
			name: fun2
			body: record([field(fun-ptr, false, type(false, fun-ptr4)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr4
			body: builtin(
				fun-ptr
				[type(true, fut), type(true, ctx), type(false, ptr), type(false, arr), type(false, fun-ptr2)]))
		struct(
			name: fut
			mut?: true
			ptr?: true
			body: record([field(lk, false, type(false, lock)), field(state, true, type(false, fut-state))]))
		struct(
			name: fut-state
			body: union([type(false, fut-state-callbacks), type(false, fut-state-resolved), type(false, exception)]))
		struct(name: fut-state-callbacks, body: record([field(head, false, type(false, opt))]))
		struct(
			name: fut-callback-node
			ptr?: true
			body: record([field(cb, false, type(false, fun-mut1)), field(next-node, false, type(false, opt))]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, void))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(true, fut-callback-node))]))
		struct(name: fut-state-resolved, body: record([field(value, false, type(false, void))]))
		struct(
			name: fun-ref0
			body: record(
				[field(vat-and-actor, false, type(false, vat-and-actor-id)), field(fun, false, type(false, fun-mut0))]))
		struct(
			name: vat-and-actor-id
			body: record([field(vat, false, type(false, nat)), field(actor, false, type(false, nat))]))
		struct(
			name: fun-mut0
			body: record([field(fun-ptr, false, type(false, fun-ptr2)), field(closure, false, type(false, ptr))]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, ptr)]))
		struct(
			name: fun-ref1
			body: record(
				[field(vat-and-actor, false, type(false, vat-and-actor-id)), field(fun, false, type(false, fun-mut1))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(true, fut), type(true, ctx), type(false, ptr), type(false, void)]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, ptr))]))
		struct(
			name: lambda(then, 0)
			ptr?: true
			body: record([field(cb, false, type(false, fun-ref1)), field(res, false, type(true, fut))]))
		struct(name: lambda(forward-to, 0), body: record([field(to, false, type(true, fut))]))
		struct(
			name: lambda(call, 0)
			ptr?: true
			body: record(
				[
					field(f, false, type(false, fun-ref1))
					field(p0, false, type(false, void))
					field(res, false, type(true, fut))]))
		struct(
			name: lambda(lambda(call, 0), 0)
			ptr?: true
			body: record(
				[
					field(f, false, type(false, fun-ref1))
					field(p0, false, type(false, void))
					field(res, false, type(true, fut))]))
		struct(name: lambda(lambda(call, 0), 1), body: record([field(res, false, type(true, fut))]))
		struct(name: lambda(then2, 0), ptr?: true, body: record([field(cb, false, type(false, fun-ref0))]))
		struct(
			name: lambda(call, 0)
			ptr?: true
			body: record([field(f, false, type(false, fun-ref0)), field(res, false, type(true, fut))]))
		struct(
			name: lambda(lambda(call, 0), 0)
			ptr?: true
			body: record([field(f, false, type(false, fun-ref0)), field(res, false, type(true, fut))]))
		struct(name: lambda(lambda(call, 0), 1), body: record([field(res, false, type(true, fut))]))
		struct(
			name: lambda(add-first-task, 0)
			ptr?: true
			body: record([field(all-args, false, type(false, arr)), field(main-ptr, false, type(false, fun-ptr2))]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, arr), type(true, ctx), type(false, ptr), type(false, ptr)]))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, arr), type(true, ctx), type(false, ptr), type(false, nat)]))
		struct(
			name: mut-arr
			mut?: true
			ptr?: true
			body: record(
				[
					field(frozen?, true, type(false, bool))
					field(size, true, type(false, nat))
					field(capacity, true, type(false, nat))
					field(data, true, type(false, ptr))]))
		struct(
			name: lambda(map, 0)
			ptr?: true
			body: record([field(mapper, false, type(false, fun-mut1)), field(a, false, type(false, arr))]))
		struct(name: fun-ptr2, body: builtin(fun-ptr, [type(false, void), type(false, nat), type(true, global-ctx)]))
		struct(
			name: thread-args
			ptr?: true
			body: record(
				[
					field(fun, false, type(false, fun-ptr2))
					field(thread-id, false, type(false, nat))
					field(arg, false, type(true, global-ctx))]))
		struct(name: ptr, body: builtin(ptr, [type(false, thread-args)]))
		struct(name: fun-ptr1, body: builtin(fun-ptr, [type(false, ptr), type(false, ptr)]))
		struct(name: cell, mut?: true, ptr?: true, body: record([field(value, true, type(false, nat))]))
		struct(name: cell, mut?: true, ptr?: true, body: record([field(value, true, type(false, ptr))]))
		struct(
			name: chosen-task
			body: record([field(vat, false, type(true, vat)), field(task-or-gc, false, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, task))]))
		struct(name: no-chosen-task, body: record([field(last-thread-out, false, type(false, bool))]))
		struct(name: result, body: union([type(false, ok), type(false, err)]))
		struct(name: ok, body: record([field(value, false, type(false, chosen-task))]))
		struct(name: err, body: record([field(value, false, type(false, no-chosen-task))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, chosen-task))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, opt))]))
		struct(
			name: task-and-nodes
			body: record([field(task, false, type(false, task)), field(nodes, false, type(false, opt))]))
		struct(name: opt, body: union([type(false, none), type(false, some)]))
		struct(name: some, body: record([field(value, false, type(false, task-and-nodes))]))
		struct(name: arr, body: record([field(size, false, type(false, nat)), field(data, false, type(false, ptr))]))
		struct(name: point, body: record([field(x, false, type(false, float)), field(y, false, type(false, float))]))
		struct(name: float, body: builtin(float-64, []))
		struct(
			name: fun-mut1
			body: record([field(fun-ptr, false, type(false, fun-ptr3)), field(closure, false, type(false, ptr))]))
		struct(
			name: fun-ptr3
			body: builtin(fun-ptr, [type(false, char), type(true, ctx), type(false, ptr), type(false, nat)]))
		struct(
			name: mut-arr
			mut?: true
			ptr?: true
			body: record(
				[
					field(frozen?, true, type(false, bool))
					field(size, true, type(false, nat))
					field(capacity, true, type(false, nat))
					field(data, true, type(false, ptr))]))
		struct(
			name: lambda(+, 0)
			ptr?: true
			body: record([field(a, false, type(false, arr)), field(b, false, type(false, arr))]))]
	[
		fun(
			false
			rt-main
			type(false, int32)
			none
			[param(argc, type(false, int32)), param(argv, type(false, ptr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				[
					local(n-threads, type(false, nat))
					local(gctx-by-val, type(false, global-ctx))
					local(gctx, type(true, global-ctx))
					local(vat-by-val, type(false, vat))
					local(vat, type(true, vat))
					local(main-fut, type(true, fut))
					local(o, type(false, ok))
					local(e, type(false, err))
					local("<<matched>>", type(false, result))]
				let(
					n-threads
					call(as, [call(two, [])])
					let(
						gctx-by-val
						record(
							[
								call(new-lock, [])
								call(empty-arr, [])
								local-ref(n-threads)
								call(new-condition, [])
								call(false, [])
								call(false, [])])
						let(
							gctx
							call(ref-of-val, [local-ref(gctx-by-val)])
							let(
								vat-by-val
								call(new-vat, [local-ref(gctx), call(zero, []), local-ref(n-threads)])
								let(
									vat
									call(ref-of-val, [local-ref(vat-by-val)])
									seq(
										set-field(
											local-ref(gctx)
											vats
											record([call(one, []), call(ptr-to, [local-ref(vat)])]))
										let(
											main-fut
											call(
												do-main
												[
													local-ref(gctx)
													local-ref(vat)
													param-ref(argc)
													param-ref(argv)
													param-ref(main-ptr)])
											seq(
												call(
													run-threads
													[
														local-ref(n-threads)
														local-ref(gctx)
														lambda(lambda(rt-main, 0), none)])
												cond(
													get-field(local-ref(gctx), any-unhandled-exceptions?)
													call(one, [])
													match(
														"<<matched>>"
														call(must-be-resolved, [local-ref(main-fut)])
														[
															case(some(o), get-field(local-ref(o), value))
															case(
																some(e)
																seq(
																	seq(
																		call(
																			print-err-sync-no-newline
																			[str-lit("main failed: ")])
																		call(
																			print-err-sync
																			[
																				get-field(
																					get-field(local-ref(e), value)
																					message)]))
																	call(one, [])))]))))))))))))
		fun(false, as, type(false, nat), none, [param(value, type(false, nat))], builtin([type(false, nat)]))
		fun(false, two, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(one, [])])))
		fun(
			false
			wrap-incr
			type(false, nat)
			none
			[param(a, type(false, nat))]
			expr-body([], call(wrap-add, [param-ref(a), call(one, [])])))
		fun(
			false
			wrap-add
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(false, one, type(false, nat), none, [], builtin([]))
		fun(false, new-lock, type(false, lock), none, [], expr-body([], record([call(new-atomic-bool, [])])))
		fun(false, new-atomic-bool, type(false, atomic-bool), none, [], expr-body([], record([call(false, [])])))
		fun(false, false, type(false, bool), none, [], builtin([]))
		fun(false, empty-arr, type(false, arr), none, [], expr-body([], record([call(zero, []), call(null, [])])))
		fun(false, zero, type(false, nat), none, [], builtin([]))
		fun(false, null, type(false, ptr), none, [], builtin([type(true, vat)]))
		fun(
			false
			new-condition
			type(false, condition)
			none
			[]
			expr-body([], record([call(new-lock, []), call(zero, [])])))
		fun(
			false
			ref-of-val
			type(true, global-ctx)
			none
			[param(b, type(false, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(
			false
			new-vat
			type(false, vat)
			none
			[param(gctx, type(true, global-ctx)), param(id, type(false, nat)), param(max-threads, type(false, nat))]
			expr-body(
				[local(actors, type(false, mut-arr))]
				let(
					actors
					call(new-mut-arr-by-val-with-capacity-from-unmanaged-memory, [param-ref(max-threads)])
					record(
						[
							param-ref(gctx)
							param-ref(id)
							call(new-gc, [])
							call(new-lock, [])
							call(new-mut-bag, [])
							local-ref(actors)
							call(zero, [])
							call(new-thread-safe-counter, [])
							lambda(lambda(new-vat, 0), some(call(null-any, [])))]))))
		fun(
			false
			new-mut-arr-by-val-with-capacity-from-unmanaged-memory
			type(false, mut-arr)
			none
			[param(capacity, type(false, nat))]
			expr-body(
				[]
				record(
					[
						call(false, [])
						call(zero, [])
						param-ref(capacity)
						call(unmanaged-alloc-elements, [param-ref(capacity)])])))
		fun(
			false
			unmanaged-alloc-elements
			type(false, ptr)
			none
			[param(size-elements, type(false, nat))]
			expr-body(
				[local(bytes, type(false, ptr))]
				let(
					bytes
					call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])
					call(ptr-cast, [local-ref(bytes)]))))
		fun(
			false
			unmanaged-alloc-bytes
			type(false, ptr)
			none
			[param(size, type(false, nat))]
			expr-body(
				[local(res, type(false, ptr))]
				let(
					res
					call(malloc, [param-ref(size)])
					seq(call(hard-forbid, [call(null?, [local-ref(res)])]), local-ref(res)))))
		fun(false, malloc, type(false, ptr), none, [param(size, type(false, nat))], extern(false))
		fun(
			false
			hard-forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body([], call(hard-assert, [call(not, [param-ref(condition)])])))
		fun(
			false
			hard-assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body(
				[]
				call(if, [param-ref(condition), call(pass, []), call(hard-fail, [str-lit("Assertion failed!")])])))
		fun(
			false
			if
			type(false, void)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, void)), param(if-false, type(false, void))]
			builtin([type(false, void)]))
		fun(false, pass, type(false, void), none, [], builtin([]))
		fun(false, hard-fail, type(false, void), none, [param(reason, type(false, arr))], builtin([type(false, void)]))
		fun(false, not, type(false, bool), none, [param(a, type(false, bool))], builtin([]))
		fun(
			false
			null?
			type(false, bool)
			none
			[param(a, type(false, ptr))]
			expr-body([], call(==, [call(to-nat, [param-ref(a)]), call(to-nat, [call(null, [])])])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				[local("<<matched>>", type(false, comparison))]
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([type(false, nat)]))
		fun(false, true, type(false, bool), none, [], builtin([]))
		fun(false, to-nat, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, nat8)]))
		fun(false, null, type(false, ptr), none, [], builtin([type(false, nat8)]))
		fun(
			false
			wrap-mul
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, nat)]))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat), type(false, nat8)]))
		fun(
			false
			new-gc
			type(false, gc)
			none
			[]
			expr-body(
				[]
				record(
					[
						call(new-lock, [])
						to-union(0, call(none, []))
						call(false, [])
						call(false, [])
						call(null, [])
						call(null, [])])))
		fun(false, none, type(false, none), none, [], expr-body([], record([])))
		fun(false, new-mut-bag, type(false, mut-bag), none, [], expr-body([], record([to-union(0, call(none, []))])))
		fun(
			false
			new-thread-safe-counter
			type(false, thread-safe-counter)
			none
			[]
			expr-body([], call(new-thread-safe-counter, [call(zero, [])])))
		fun(
			false
			new-thread-safe-counter
			type(false, thread-safe-counter)
			none
			[param(init, type(false, nat))]
			expr-body([], record([call(new-lock, []), param-ref(init)])))
		fun(false, null-any, type(false, ptr), none, [], expr-body([], call(null, [])))
		fun(false, null, type(false, ptr), none, [], builtin([type(false, bool)]))
		fun(
			true
			default-exception-handler
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				[]
				seq(
					seq(
						call(print-err-sync-no-newline, [str-lit("uncaught exception: ")])
						call(
							print-err-sync
							[
								call(
									if
									[
										call(empty?, [get-field(param-ref(e), message)])
										str-lit("<<empty message>>")
										get-field(param-ref(e), message)])]))
					set-field(call(get-gctx, []), any-unhandled-exceptions?, call(true, [])))))
		fun(
			false
			print-err-sync-no-newline
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body([], call(write-sync-no-newline, [call(stderr-fd, []), param-ref(s)])))
		fun(
			false
			write-sync-no-newline
			type(false, void)
			none
			[param(fd, type(false, int32)), param(s, type(false, arr))]
			expr-body(
				[local(res, type(false, int))]
				seq(
					call(hard-assert, [call(==, [call(size-of, []), call(size-of, [])])])
					let(
						res
						call(
							write
							[
								param-ref(fd)
								call(as-any-ptr, [get-field(param-ref(s), data)])
								get-field(param-ref(s), size)])
						cond(
							call(==, [local-ref(res), call(unsafe-to-int, [get-field(param-ref(s), size)])])
							call(pass, [])
							call(todo, []))))))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, char)]))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, nat8)]))
		fun(
			false
			write
			type(false, int)
			none
			[param(fd, type(false, int32)), param(buff, type(false, ptr)), param(n-bytes, type(false, nat))]
			extern(false))
		fun(false, as-any-ptr, type(false, ptr), none, [param(some-ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(
				[local("<<matched>>", type(false, comparison))]
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([type(false, int)]))
		fun(false, unsafe-to-int, type(false, int), none, [param(a, type(false, nat))], builtin([]))
		fun(false, todo, type(false, void), none, [], expr-body([], call(hard-fail, [str-lit("TODO")])))
		fun(false, stderr-fd, type(false, int32), none, [], expr-body([], call(two, [])))
		fun(false, two, type(false, int32), none, [], expr-body([], call(wrap-incr, [call(one, [])])))
		fun(
			false
			wrap-incr
			type(false, int32)
			none
			[param(a, type(false, int32))]
			expr-body([], call(wrap-add, [param-ref(a), call(one, [])])))
		fun(
			false
			wrap-add
			type(false, int32)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			builtin([]))
		fun(false, one, type(false, int32), none, [], builtin([]))
		fun(
			false
			print-err-sync
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body(
				[]
				seq(call(print-err-sync-no-newline, [param-ref(s)]), call(print-err-sync-no-newline, [str-lit("\n")]))))
		fun(
			false
			if
			type(false, arr)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, arr)), param(if-false, type(false, arr))]
			builtin([type(false, arr)]))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body([], call(zero?, [get-field(param-ref(a), size)])))
		fun(
			false
			zero?
			type(false, bool)
			none
			[param(n, type(false, nat))]
			expr-body([], call(==, [param-ref(n), call(zero, [])])))
		fun(
			true
			get-gctx
			type(true, global-ctx)
			none
			[]
			expr-body([], call(as-ref, [get-field(call(get-ctx, []), gctx-ptr)])))
		fun(
			false
			as-ref
			type(true, global-ctx)
			none
			[param(p, type(false, ptr))]
			builtin([type(true, global-ctx)]))
		fun(true, get-ctx, type(true, ctx), none, [], builtin([]))
		fun(
			true
			lambda(new-vat, 0)
			type(false, void)
			some(param("<<closure>>", type(false, ptr)))
			[param(it, type(false, exception))]
			expr-body([], call(default-exception-handler, [param-ref(it)])))
		fun(false, ref-of-val, type(true, vat), none, [param(b, type(false, vat))], builtin([type(true, vat)]))
		fun(false, ptr-to, type(false, ptr), none, [param(t, type(true, vat))], builtin([type(true, vat)]))
		fun(
			false
			do-main
			type(true, fut)
			none
			[
				param(gctx, type(true, global-ctx))
				param(vat, type(true, vat))
				param(argc, type(false, int32))
				param(argv, type(false, ptr))
				param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				[
					local(ectx, type(false, exception-ctx))
					local(tls, type(false, thread-local-stuff))
					local(ctx-by-val, type(false, ctx))
					local(ctx, type(true, ctx))
					local(add, type(false, fun2))
					local(all-args, type(false, arr))]
				let(
					ectx
					call(new-exception-ctx, [])
					let(
						tls
						record([call(ref-of-val, [local-ref(ectx)])])
						let(
							ctx-by-val
							call(
								new-ctx
								[param-ref(gctx), call(ref-of-val, [local-ref(tls)]), param-ref(vat), call(zero, [])])
							let(
								ctx
								call(ref-of-val, [local-ref(ctx-by-val)])
								let(
									add
									call(as, [lambda(lambda(do-main, 0), some(call(null-any, [])))])
									let(
										all-args
										record(
											[call(unsafe-to-nat, [call(to-int, [param-ref(argc)])]), param-ref(argv)])
										call(
											call-with-ctx
											[local-ref(ctx), local-ref(add), local-ref(all-args), param-ref(main-ptr)])))))))))
		fun(
			false
			new-exception-ctx
			type(false, exception-ctx)
			none
			[]
			expr-body([], record([call(null, []), record([str-lit("")])])))
		fun(false, null, type(false, ptr), none, [], builtin([type(false, jmp-buf-tag)]))
		fun(
			false
			ref-of-val
			type(true, exception-ctx)
			none
			[param(b, type(false, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			false
			new-ctx
			type(false, ctx)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(vat, type(true, vat))
				param(actor-id, type(false, nat))]
			expr-body(
				[]
				record(
					[
						call(as-any-ptr, [param-ref(gctx)])
						get-field(param-ref(vat), id)
						param-ref(actor-id)
						call(as-any-ptr, [call(get-gc-ctx, [call(ref-of-val, [get-field(param-ref(vat), gc)])])])
						call(as-any-ptr, [get-field(param-ref(tls), exception-ctx)])])))
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(some-ref, type(true, global-ctx))]
			builtin([type(true, global-ctx)]))
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(some-ref, type(true, gc-ctx))]
			builtin([type(true, gc-ctx)]))
		fun(
			false
			get-gc-ctx
			type(true, gc-ctx)
			none
			[param(gc, type(true, gc))]
			expr-body(
				[
					local(c, type(true, gc-ctx))
					local(s, type(false, some))
					local(c, type(true, gc-ctx))
					local("<<matched>>", type(false, opt))
					local(res, type(true, gc-ctx))]
				seq(
					call(acquire-lock, [call(ref-of-val, [get-field(param-ref(gc), lk)])])
					let(
						res
						match(
							"<<matched>>"
							get-field(param-ref(gc), context-head)
							[
								case(
									none
									let(
										c
										call(as-ref, [call(malloc, [call(size-of, [])])])
										seq(
											seq(
												set-field(local-ref(c), gc, param-ref(gc))
												set-field(local-ref(c), next-ctx, to-union(0, call(none, []))))
											local-ref(c))))
								case(
									some(s)
									let(
										c
										get-field(local-ref(s), value)
										seq(
											seq(
												set-field(
													param-ref(gc)
													context-head
													get-field(local-ref(c), next-ctx))
												set-field(local-ref(c), next-ctx, to-union(0, call(none, []))))
											local-ref(c))))])
						seq(call(release-lock, [call(ref-of-val, [get-field(param-ref(gc), lk)])]), local-ref(res))))))
		fun(
			false
			acquire-lock
			type(false, void)
			none
			[param(a, type(true, lock))]
			expr-body([], call(acquire-lock-recur, [param-ref(a), call(zero, [])])))
		fun(
			false
			acquire-lock-recur
			type(false, void)
			none
			[param(a, type(true, lock)), param(n-tries, type(false, nat))]
			expr-body(
				[]
				cond(
					call(try-acquire-lock, [param-ref(a)])
					call(pass, [])
					cond(
						call(==, [param-ref(n-tries), call(thousand, [])])
						call(hard-fail, [str-lit("Couldn't acquire lock after 1000 tries")])
						seq(
							call(yield-thread, [])
							call(acquire-lock-recur, [param-ref(a), call(noctx-incr, [param-ref(n-tries)])]))))))
		fun(
			false
			try-acquire-lock
			type(false, bool)
			none
			[param(a, type(true, lock))]
			expr-body([], call(try-set, [call(ref-of-val, [get-field(param-ref(a), is-locked)])])))
		fun(
			false
			try-set
			type(false, bool)
			none
			[param(a, type(true, atomic-bool))]
			expr-body([], call(try-change, [param-ref(a), call(false, [])])))
		fun(
			false
			try-change
			type(false, bool)
			none
			[param(a, type(true, atomic-bool)), param(old-value, type(false, bool))]
			expr-body(
				[]
				call(
					compare-exchange-strong
					[
						call(ptr-to, [get-field(param-ref(a), value)])
						call(ptr-to, [param-ref(old-value)])
						call(not, [param-ref(old-value)])])))
		fun(
			false
			compare-exchange-strong
			type(false, bool)
			none
			[
				param(value-ptr, type(false, ptr))
				param(expected-ptr, type(false, ptr))
				param(desired, type(false, bool))]
			builtin([]))
		fun(false, ptr-to, type(false, ptr), none, [param(t, type(false, bool))], builtin([type(false, bool)]))
		fun(
			false
			ref-of-val
			type(true, atomic-bool)
			none
			[param(b, type(false, atomic-bool))]
			builtin([type(true, atomic-bool)]))
		fun(
			false
			thousand
			type(false, nat)
			none
			[]
			expr-body([], call(wrap-mul, [call(hundred, []), call(ten, [])])))
		fun(false, hundred, type(false, nat), none, [], expr-body([], call(wrap-mul, [call(ten, []), call(ten, [])])))
		fun(false, ten, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(nine, [])])))
		fun(false, nine, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(eight, [])])))
		fun(false, eight, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(seven, [])])))
		fun(false, seven, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(six, [])])))
		fun(false, six, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(five, [])])))
		fun(false, five, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(four, [])])))
		fun(false, four, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(three, [])])))
		fun(false, three, type(false, nat), none, [], expr-body([], call(wrap-incr, [call(two, [])])))
		fun(
			false
			yield-thread
			type(false, void)
			none
			[]
			expr-body(
				[local(err, type(false, int32))]
				let(
					err
					call(pthread-yield, [])
					seq(call(usleep, [call(thousand, [])]), call(hard-assert, [call(zero?, [local-ref(err)])])))))
		fun(false, pthread-yield, type(false, int32), none, [], extern(false))
		fun(false, usleep, type(false, void), none, [param(micro-seconds, type(false, nat))], extern(false))
		fun(
			false
			zero?
			type(false, bool)
			none
			[param(i, type(false, int32))]
			expr-body([], call(==, [param-ref(i), call(zero, [])])))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			expr-body(
				[local("<<matched>>", type(false, comparison))]
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, int32)), param(b, type(false, int32))]
			builtin([type(false, int32)]))
		fun(false, zero, type(false, int32), none, [], builtin([]))
		fun(
			false
			noctx-incr
			type(false, nat)
			none
			[param(n, type(false, nat))]
			expr-body(
				[]
				seq(call(hard-assert, [call(<, [param-ref(n), call(billion, [])])]), call(wrap-incr, [param-ref(n)]))))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				[local("<<matched>>", type(false, comparison))]
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(
			false
			billion
			type(false, nat)
			none
			[]
			expr-body([], call(wrap-mul, [call(million, []), call(thousand, [])])))
		fun(
			false
			million
			type(false, nat)
			none
			[]
			expr-body([], call(wrap-mul, [call(thousand, []), call(thousand, [])])))
		fun(false, ref-of-val, type(true, lock), none, [param(b, type(false, lock))], builtin([type(true, lock)]))
		fun(false, as-ref, type(true, gc-ctx), none, [param(p, type(false, ptr))], builtin([type(true, gc-ctx)]))
		fun(false, size-of, type(false, nat), none, [], builtin([type(true, gc-ctx)]))
		fun(
			false
			release-lock
			type(false, void)
			none
			[param(l, type(true, lock))]
			expr-body([], call(must-unset, [call(ref-of-val, [get-field(param-ref(l), is-locked)])])))
		fun(
			false
			must-unset
			type(false, void)
			none
			[param(a, type(true, atomic-bool))]
			expr-body(
				[local(did-unset, type(false, bool))]
				let(did-unset, call(try-unset, [param-ref(a)]), call(hard-assert, [local-ref(did-unset)]))))
		fun(
			false
			try-unset
			type(false, bool)
			none
			[param(a, type(true, atomic-bool))]
			expr-body([], call(try-change, [param-ref(a), call(true, [])])))
		fun(false, ref-of-val, type(true, gc), none, [param(b, type(false, gc))], builtin([type(true, gc)]))
		fun(
			false
			as-any-ptr
			type(false, ptr)
			none
			[param(some-ref, type(true, exception-ctx))]
			builtin([type(true, exception-ctx)]))
		fun(
			false
			ref-of-val
			type(true, thread-local-stuff)
			none
			[param(b, type(false, thread-local-stuff))]
			builtin([type(true, thread-local-stuff)]))
		fun(false, ref-of-val, type(true, ctx), none, [param(b, type(false, ctx))], builtin([type(true, ctx)]))
		fun(false, as, type(false, fun2), none, [param(value, type(false, fun2))], builtin([type(false, fun2)]))
		fun(
			true
			add-first-task
			type(true, fut)
			none
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body(
				[]
				call(
					then2
					[
						call(as, [call(resolved, [call(pass, [])])])
						record(
							[
								call(cur-actor, [])
								lambda(
									lambda(add-first-task, 0)
									some(alloc(alloc, record([param-ref(all-args), param-ref(main-ptr)]))))])])))
		fun(
			true
			then2
			type(true, fut)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-ref0))]
			expr-body(
				[]
				call(
					then
					[
						param-ref(f)
						record(
							[call(cur-actor, []), lambda(lambda(then2, 0), some(alloc(alloc, record([param-ref(cb)]))))])])))
		fun(
			true
			then
			type(true, fut)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-ref1))]
			expr-body(
				[local(res, type(true, fut))]
				let(
					res
					call(new-unresolved-fut, [])
					seq(
						call(
							then-void
							[
								param-ref(f)
								lambda(lambda(then, 0), some(alloc(alloc, record([param-ref(cb), local-ref(res)]))))])
						local-ref(res)))))
		fun(
			true
			new-unresolved-fut
			type(true, fut)
			none
			[]
			expr-body([], alloc(alloc, record([call(new-lock, []), to-union(0, record([to-union(0, call(none, []))]))]))))
		fun(
			true
			alloc
			type(false, ptr)
			none
			[param(size, type(false, nat))]
			expr-body([], call(gc-alloc, [call(get-gc, []), param-ref(size)])))
		fun(
			true
			gc-alloc
			type(false, ptr)
			none
			[param(gc, type(true, gc)), param(size, type(false, nat))]
			expr-body(
				[local(s, type(false, some)), local("<<matched>>", type(false, opt))]
				match(
					"<<matched>>"
					call(try-gc-alloc, [param-ref(gc), param-ref(size)])
					[case(none, call(todo, [])), case(some(s), get-field(local-ref(s), value))])))
		fun(
			false
			try-gc-alloc
			type(false, opt)
			none
			[param(gc, type(true, gc)), param(size, type(false, nat))]
			expr-body([], to-union(1, call(some, [call(unmanaged-alloc-bytes, [param-ref(size)])]))))
		fun(false, some, type(false, some), none, [param(t, type(false, ptr))], expr-body([], record([param-ref(t)])))
		fun(false, todo, type(false, ptr), none, [], expr-body([], call(hard-fail, [str-lit("TODO")])))
		fun(false, hard-fail, type(false, ptr), none, [param(reason, type(false, arr))], builtin([type(false, ptr)]))
		fun(true, get-gc, type(true, gc), none, [], expr-body([], get-field(call(get-gc-ctx, []), gc)))
		fun(
			true
			get-gc-ctx
			type(true, gc-ctx)
			none
			[]
			expr-body([], call(as-ref, [get-field(call(get-ctx, []), gc-ctx-ptr)])))
		fun(
			true
			then-void
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-mut1))]
			expr-body(
				[
					local(cbs, type(false, fut-state-callbacks))
					local(r, type(false, fut-state-resolved))
					local(e, type(false, exception))
					local("<<matched>>", type(false, fut-state))]
				seq(
					seq(
						call(acquire-lock, [call(ref-of-val, [get-field(param-ref(f), lk)])])
						match(
							"<<matched>>"
							get-field(param-ref(f), state)
							[
								case(
									some(cbs)
									set-field(
										param-ref(f)
										state
										to-union(
											0
											record(
												[
													to-union(
														1
														call(
															some
															[
																alloc(
																	alloc
																	record(
																		[param-ref(cb), get-field(local-ref(cbs), head)]))]))]))))
								case(
									some(r)
									call(call, [param-ref(cb), to-union(0, call(ok, [get-field(local-ref(r), value)]))]))
								case(some(e), call(call, [param-ref(cb), to-union(1, call(err, [local-ref(e)]))]))]))
					call(release-lock, [call(ref-of-val, [get-field(param-ref(f), lk)])]))))
		fun(
			false
			some
			type(false, some)
			none
			[param(t, type(true, fut-callback-node))]
			expr-body([], record([param-ref(t)])))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body(
				[]
				call(
					call
					[get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure), param-ref(p0)])))
		fun(
			false
			call
			type(false, void)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, result))]
			builtin([type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		fun(false, ok, type(false, ok), none, [param(t, type(false, void))], expr-body([], record([param-ref(t)])))
		fun(
			false
			err
			type(false, err)
			none
			[param(t, type(false, exception))]
			expr-body([], record([param-ref(t)])))
		fun(
			true
			forward-to
			type(false, void)
			none
			[param(from, type(true, fut)), param(to, type(true, fut))]
			expr-body(
				[]
				call(
					then-void
					[param-ref(from), lambda(lambda(forward-to, 0), some(alloc(alloc, record([param-ref(to)]))))])))
		fun(
			true
			then-void
			type(false, void)
			none
			[param(f, type(true, fut)), param(cb, type(false, fun-mut1))]
			expr-body(
				[
					local(cbs, type(false, fut-state-callbacks))
					local(r, type(false, fut-state-resolved))
					local(e, type(false, exception))
					local("<<matched>>", type(false, fut-state))]
				seq(
					seq(
						call(acquire-lock, [call(ref-of-val, [get-field(param-ref(f), lk)])])
						match(
							"<<matched>>"
							get-field(param-ref(f), state)
							[
								case(
									some(cbs)
									set-field(
										param-ref(f)
										state
										to-union(
											0
											record(
												[
													to-union(
														1
														call(
															some
															[
																alloc(
																	alloc
																	record(
																		[param-ref(cb), get-field(local-ref(cbs), head)]))]))]))))
								case(
									some(r)
									call(call, [param-ref(cb), to-union(0, call(ok, [get-field(local-ref(r), value)]))]))
								case(some(e), call(call, [param-ref(cb), to-union(1, call(err, [local-ref(e)]))]))]))
					call(release-lock, [call(ref-of-val, [get-field(param-ref(f), lk)])]))))
		fun(
			false
			some
			type(false, some)
			none
			[param(t, type(true, fut-callback-node))]
			expr-body([], record([param-ref(t)])))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, result))]
			expr-body(
				[]
				call(
					call
					[get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure), param-ref(p0)])))
		fun(
			false
			call
			type(false, void)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, result))]
			builtin([type(false, void), type(true, ctx), type(false, ptr), type(false, result)]))
		fun(false, ok, type(false, ok), none, [param(t, type(false, int32))], expr-body([], record([param-ref(t)])))
		fun(
			true
			resolve-or-reject
			type(false, void)
			none
			[param(f, type(true, fut)), param(result, type(false, result))]
			expr-body(
				[
					local(cbs, type(false, fut-state-callbacks))
					local("<<matched>>", type(false, fut-state))
					local(o, type(false, ok))
					local(e, type(false, err))
					local("<<matched>>", type(false, result))]
				seq(
					seq(
						seq(
							call(acquire-lock, [call(ref-of-val, [get-field(param-ref(f), lk)])])
							match(
								"<<matched>>"
								get-field(param-ref(f), state)
								[
									case(
										some(cbs)
										call(
											resolve-or-reject-recur
											[get-field(local-ref(cbs), head), param-ref(result)]))
									case(none, call(hard-fail, [str-lit("resolving an already-resolved fut")]))
									case(none, call(hard-fail, [str-lit("resolving an already-resolved fut")]))]))
						set-field(
							param-ref(f)
							state
							match(
								"<<matched>>"
								param-ref(result)
								[
									case(some(o), to-union(1, record([get-field(local-ref(o), value)])))
									case(some(e), to-union(2, get-field(local-ref(e), value)))])))
					call(release-lock, [call(ref-of-val, [get-field(param-ref(f), lk)])]))))
		fun(
			true
			resolve-or-reject-recur
			type(false, void)
			none
			[param(node, type(false, opt)), param(value, type(false, result))]
			expr-body(
				[local(s, type(false, some)), local("<<matched>>", type(false, opt))]
				match(
					"<<matched>>"
					param-ref(node)
					[
						case(none, call(pass, []))
						case(
							some(s)
							seq(
								call(
									drop
									[call(call, [get-field(get-field(local-ref(s), value), cb), param-ref(value)])])
								call(
									resolve-or-reject-recur
									[get-field(get-field(local-ref(s), value), next-node), param-ref(value)])))])))
		fun(false, drop, type(false, void), none, [param(t, type(false, void))], expr-body([], call(pass, [])))
		fun(
			true
			lambda(forward-to, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(forward-to, 0))))
			[param(it, type(false, result))]
			expr-body([], call(resolve-or-reject, [get-field(param-ref("<<closure>>"), to), param-ref(it)])))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ref1)), param(p0, type(false, void))]
			expr-body(
				[local(vat, type(true, vat)), local(res, type(true, fut))]
				let(
					vat
					call(get-vat, [get-field(get-field(param-ref(f), vat-and-actor), vat)])
					let(
						res
						call(new-unresolved-fut, [])
						seq(
							call(
								add-task
								[
									local-ref(vat)
									record(
										[
											get-field(get-field(param-ref(f), vat-and-actor), actor)
											lambda(
												lambda(call, 0)
												some(alloc(alloc, record([param-ref(f), param-ref(p0), local-ref(res)]))))])])
							local-ref(res))))))
		fun(
			true
			get-vat
			type(true, vat)
			none
			[param(vat-id, type(false, nat))]
			expr-body([], call(at, [get-field(call(get-gctx, []), vats), param-ref(vat-id)])))
		fun(
			true
			at
			type(true, vat)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(noctx-at, [param-ref(a), param-ref(index)]))))
		fun(
			true
			assert
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body([], call(assert, [param-ref(condition), str-lit("assert failed")])))
		fun(
			true
			assert
			type(false, void)
			none
			[param(condition, type(false, bool)), param(message, type(false, arr))]
			expr-body([], call(if, [param-ref(condition), call(pass, []), call(fail, [param-ref(message)])])))
		fun(
			true
			fail
			type(false, void)
			none
			[param(reason, type(false, arr))]
			expr-body([], call(throw, [record([param-ref(reason)])])))
		fun(
			true
			throw
			type(false, void)
			none
			[param(e, type(false, exception))]
			expr-body(
				[local(exn-ctx, type(true, exception-ctx))]
				let(
					exn-ctx
					call(get-exception-ctx, [])
					seq(
						seq(
							seq(
								call(hard-forbid, [call(null?, [get-field(local-ref(exn-ctx), jmp-buf-ptr)])])
								set-field(local-ref(exn-ctx), thrown-exception, param-ref(e)))
							call(longjmp, [get-field(local-ref(exn-ctx), jmp-buf-ptr), call(number-to-throw, [])]))
						call(todo, [])))))
		fun(
			true
			get-exception-ctx
			type(true, exception-ctx)
			none
			[]
			expr-body([], call(as-ref, [get-field(call(get-ctx, []), exception-ctx-ptr)])))
		fun(
			false
			as-ref
			type(true, exception-ctx)
			none
			[param(p, type(false, ptr))]
			builtin([type(true, exception-ctx)]))
		fun(
			false
			null?
			type(false, bool)
			none
			[param(a, type(false, ptr))]
			expr-body([], call(==, [call(to-nat, [param-ref(a)]), call(to-nat, [call(null, [])])])))
		fun(false, to-nat, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, jmp-buf-tag)]))
		fun(
			false
			longjmp
			type(false, void)
			none
			[param(env, type(false, ptr)), param(val, type(false, int32))]
			extern(false))
		fun(true, number-to-throw, type(false, int32), none, [], expr-body([], call(seven, [])))
		fun(false, seven, type(false, int32), none, [], expr-body([], call(wrap-incr, [call(six, [])])))
		fun(false, six, type(false, int32), none, [], expr-body([], call(wrap-incr, [call(five, [])])))
		fun(false, five, type(false, int32), none, [], expr-body([], call(wrap-incr, [call(four, [])])))
		fun(false, four, type(false, int32), none, [], expr-body([], call(wrap-incr, [call(three, [])])))
		fun(false, three, type(false, int32), none, [], expr-body([], call(wrap-incr, [call(two, [])])))
		fun(
			false
			noctx-at
			type(true, vat)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(deref, [call(+, [get-field(param-ref(a), data), param-ref(index)])]))))
		fun(false, deref, type(true, vat), none, [param(p, type(false, ptr))], builtin([type(true, vat)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(true, vat)]))
		fun(
			true
			add-task
			type(false, void)
			none
			[param(v, type(true, vat)), param(t, type(false, task))]
			expr-body(
				[local(node, type(true, mut-bag-node))]
				let(
					node
					call(new-mut-bag-node, [param-ref(t)])
					seq(
						seq(
							seq(
								call(acquire-lock, [call(ref-of-val, [get-field(param-ref(v), tasks-lock)])])
								call(add, [call(ref-of-val, [get-field(param-ref(v), tasks)]), local-ref(node)]))
							call(release-lock, [call(ref-of-val, [get-field(param-ref(v), tasks-lock)])]))
						call(
							broadcast
							[call(ref-of-val, [get-field(get-field(param-ref(v), gctx), may-be-work-to-do)])])))))
		fun(
			true
			new-mut-bag-node
			type(true, mut-bag-node)
			none
			[param(value, type(false, task))]
			expr-body([], alloc(alloc, record([param-ref(value), to-union(0, call(none, []))]))))
		fun(
			false
			add
			type(false, void)
			none
			[param(bag, type(true, mut-bag)), param(node, type(true, mut-bag-node))]
			expr-body(
				[]
				seq(
					set-field(param-ref(node), next-node, get-field(param-ref(bag), head))
					set-field(param-ref(bag), head, to-union(1, call(some, [param-ref(node)]))))))
		fun(
			false
			some
			type(false, some)
			none
			[param(t, type(true, mut-bag-node))]
			expr-body([], record([param-ref(t)])))
		fun(
			false
			ref-of-val
			type(true, mut-bag)
			none
			[param(b, type(false, mut-bag))]
			builtin([type(true, mut-bag)]))
		fun(
			false
			broadcast
			type(false, void)
			none
			[param(c, type(true, condition))]
			expr-body(
				[]
				seq(
					seq(
						call(acquire-lock, [call(ref-of-val, [get-field(param-ref(c), lk)])])
						set-field(param-ref(c), value, call(noctx-incr, [get-field(param-ref(c), value)])))
					call(release-lock, [call(ref-of-val, [get-field(param-ref(c), lk)])]))))
		fun(
			false
			ref-of-val
			type(true, condition)
			none
			[param(b, type(false, condition))]
			builtin([type(true, condition)]))
		fun(
			true
			catch
			type(false, void)
			none
			[param(try, type(false, fun-mut0)), param(catcher, type(false, fun-mut1))]
			expr-body(
				[]
				call(catch-with-exception-ctx, [call(get-exception-ctx, []), param-ref(try), param-ref(catcher)])))
		fun(
			true
			catch-with-exception-ctx
			type(false, void)
			none
			[
				param(ec, type(true, exception-ctx))
				param(try, type(false, fun-mut0))
				param(catcher, type(false, fun-mut1))]
			expr-body(
				[
					local(old-thrown-exception, type(false, exception))
					local(old-jmp-buf, type(false, ptr))
					local(store, type(false, jmp-buf-tag))
					local(setjmp-result, type(false, int32))
					local(res, type(false, void))
					local(thrown-exception, type(false, exception))]
				let(
					old-thrown-exception
					get-field(param-ref(ec), thrown-exception)
					let(
						old-jmp-buf
						get-field(param-ref(ec), jmp-buf-ptr)
						let(
							store
							record([call(zero, []), call(zero, []), call(zero, [])])
							seq(
								set-field(param-ref(ec), jmp-buf-ptr, call(ptr-to, [local-ref(store)]))
								let(
									setjmp-result
									call(setjmp, [get-field(param-ref(ec), jmp-buf-ptr)])
									cond(
										call(==, [local-ref(setjmp-result), call(zero, [])])
										let(
											res
											call(call, [param-ref(try)])
											seq(
												seq(
													set-field(param-ref(ec), jmp-buf-ptr, local-ref(old-jmp-buf))
													set-field(
														param-ref(ec)
														thrown-exception
														local-ref(old-thrown-exception)))
												local-ref(res)))
										seq(
											call(
												assert
												[call(==, [local-ref(setjmp-result), call(number-to-throw, [])])])
											let(
												thrown-exception
												get-field(param-ref(ec), thrown-exception)
												seq(
													seq(
														set-field(param-ref(ec), jmp-buf-ptr, local-ref(old-jmp-buf))
														set-field(
															param-ref(ec)
															thrown-exception
															local-ref(old-thrown-exception)))
													call(call, [param-ref(catcher), local-ref(thrown-exception)]))))))))))))
		fun(false, zero, type(false, bytes64), none, [], expr-body([], record([call(zero, []), call(zero, [])])))
		fun(false, zero, type(false, bytes32), none, [], expr-body([], record([call(zero, []), call(zero, [])])))
		fun(false, zero, type(false, bytes16), none, [], expr-body([], record([call(zero, []), call(zero, [])])))
		fun(false, zero, type(false, bytes128), none, [], expr-body([], record([call(zero, []), call(zero, [])])))
		fun(
			false
			ptr-to
			type(false, ptr)
			none
			[param(t, type(false, jmp-buf-tag))]
			builtin([type(false, jmp-buf-tag)]))
		fun(false, setjmp, type(false, int32), none, [param(env, type(false, ptr))], extern(false))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut0))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut0))]
			expr-body(
				[]
				call(call, [get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure)])))
		fun(
			false
			call
			type(false, void)
			none
			[param(f, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, ptr))]
			builtin([type(false, void), type(true, ctx), type(false, ptr)]))
		fun(
			true
			call
			type(false, void)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, exception))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, void)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, exception))]
			expr-body(
				[]
				call(
					call
					[get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure), param-ref(p0)])))
		fun(
			false
			call
			type(false, void)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, exception))]
			builtin([type(false, void), type(true, ctx), type(false, ptr), type(false, exception)]))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, void))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, void))]
			expr-body(
				[]
				call(
					call
					[get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure), param-ref(p0)])))
		fun(
			false
			call
			type(true, fut)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, void))]
			builtin([type(true, fut), type(true, ctx), type(false, ptr), type(false, void)]))
		fun(
			true
			lambda(lambda(call, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 0))))
			[]
			expr-body(
				[]
				call(
					forward-to
					[
						call(
							call
							[
								get-field(get-field(param-ref("<<closure>>"), f), fun)
								get-field(param-ref("<<closure>>"), p0)])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			true
			reject
			type(false, void)
			none
			[param(f, type(true, fut)), param(e, type(false, exception))]
			expr-body([], call(resolve-or-reject, [param-ref(f), to-union(1, call(err, [param-ref(e)]))])))
		fun(
			true
			lambda(lambda(call, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 1))))
			[param(it, type(false, exception))]
			expr-body([], call(reject, [get-field(param-ref("<<closure>>"), res), param-ref(it)])))
		fun(
			true
			lambda(call, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(call, 0))))
			[]
			expr-body(
				[]
				call(
					catch
					[
						lambda(
							lambda(lambda(call, 0), 0)
							some(alloc(
								alloc
								record(
									[
										get-field(param-ref("<<closure>>"), f)
										get-field(param-ref("<<closure>>"), p0)
										get-field(param-ref("<<closure>>"), res)]))))
						lambda(
							lambda(lambda(call, 0), 1)
							some(alloc(alloc, record([get-field(param-ref("<<closure>>"), res)]))))])))
		fun(
			true
			lambda(then, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(then, 0))))
			[param(result, type(false, result))]
			expr-body(
				[local(o, type(false, ok)), local(e, type(false, err)), local("<<matched>>", type(false, result))]
				match(
					"<<matched>>"
					param-ref(result)
					[
						case(
							some(o)
							call(
								forward-to
								[
									call(
										call
										[get-field(param-ref("<<closure>>"), cb), get-field(local-ref(o), value)])
									get-field(param-ref("<<closure>>"), res)]))
						case(
							some(e)
							call(reject, [get-field(param-ref("<<closure>>"), res), get-field(local-ref(e), value)]))])))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ref0))]
			expr-body(
				[local(vat, type(true, vat)), local(res, type(true, fut))]
				let(
					vat
					call(get-vat, [get-field(get-field(param-ref(f), vat-and-actor), vat)])
					let(
						res
						call(new-unresolved-fut, [])
						seq(
							call(
								add-task
								[
									local-ref(vat)
									record(
										[
											get-field(get-field(param-ref(f), vat-and-actor), actor)
											lambda(
												lambda(call, 0)
												some(alloc(alloc, record([param-ref(f), local-ref(res)]))))])])
							local-ref(res))))))
		fun(
			true
			call
			type(true, fut)
			none
			[param(f, type(false, fun-mut0))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f)])))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut0))]
			expr-body(
				[]
				call(call, [get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure)])))
		fun(
			false
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, ptr))]
			builtin([type(true, fut), type(true, ctx), type(false, ptr)]))
		fun(
			true
			lambda(lambda(call, 0), 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 0))))
			[]
			expr-body(
				[]
				call(
					forward-to
					[
						call(call, [get-field(get-field(param-ref("<<closure>>"), f), fun)])
						get-field(param-ref("<<closure>>"), res)])))
		fun(
			true
			lambda(lambda(call, 0), 1)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(lambda(call, 0), 1))))
			[param(it, type(false, exception))]
			expr-body([], call(reject, [get-field(param-ref("<<closure>>"), res), param-ref(it)])))
		fun(
			true
			lambda(call, 0)
			type(false, void)
			some(param("<<closure>>", type(true, lambda(call, 0))))
			[]
			expr-body(
				[]
				call(
					catch
					[
						lambda(
							lambda(lambda(call, 0), 0)
							some(alloc(
								alloc
								record(
									[get-field(param-ref("<<closure>>"), f), get-field(param-ref("<<closure>>"), res)]))))
						lambda(
							lambda(lambda(call, 0), 1)
							some(alloc(alloc, record([get-field(param-ref("<<closure>>"), res)]))))])))
		fun(
			true
			lambda(then2, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(then2, 0))))
			[param(ignore, type(false, void))]
			expr-body([], call(call, [get-field(param-ref("<<closure>>"), cb)])))
		fun(
			true
			cur-actor
			type(false, vat-and-actor-id)
			none
			[]
			expr-body(
				[local(c, type(true, ctx))]
				let(c, call(get-ctx, []), record([get-field(local-ref(c), vat-id), get-field(local-ref(c), actor-id)]))))
		fun(false, as, type(true, fut), none, [param(value, type(true, fut))], builtin([type(true, fut)]))
		fun(
			true
			resolved
			type(true, fut)
			none
			[param(value, type(false, void))]
			expr-body([], alloc(alloc, record([call(new-lock, []), to-union(1, record([param-ref(value)]))]))))
		fun(
			true
			tail
			type(false, arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				[]
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(slice-starting-at, [param-ref(a), call(one, [])]))))
		fun(
			true
			forbid
			type(false, void)
			none
			[param(condition, type(false, bool))]
			expr-body([], call(forbid, [param-ref(condition), str-lit("forbid failed")])))
		fun(
			true
			forbid
			type(false, void)
			none
			[param(condition, type(false, bool)), param(message, type(false, arr))]
			expr-body([], call(if, [param-ref(condition), call(fail, [param-ref(message)]), call(pass, [])])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, arr))]
			expr-body([], call(zero?, [get-field(param-ref(a), size)])))
		fun(
			true
			slice-starting-at
			type(false, arr)
			none
			[param(a, type(false, arr)), param(begin, type(false, nat))]
			expr-body(
				[]
				seq(
					call(assert, [call(<=, [param-ref(begin), get-field(param-ref(a), size)])])
					call(
						slice
						[param-ref(a), param-ref(begin), call(-, [get-field(param-ref(a), size), param-ref(begin)])]))))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body([], call(not, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			true
			slice
			type(false, arr)
			none
			[param(a, type(false, arr)), param(begin, type(false, nat)), param(size, type(false, nat))]
			expr-body(
				[]
				seq(
					call(
						assert
						[call(<=, [call(+, [param-ref(begin), param-ref(size)]), get-field(param-ref(a), size)])])
					record([param-ref(size), call(+, [get-field(param-ref(a), data), param-ref(begin)])]))))
		fun(
			true
			+
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				[local(res, type(false, nat))]
				let(
					res
					call(wrap-add, [param-ref(a), param-ref(b)])
					seq(
						call(
							assert
							[
								call(
									and
									[call(>=, [local-ref(res), param-ref(a)]), call(>=, [local-ref(res), param-ref(b)])])])
						local-ref(res)))))
		fun(
			false
			and
			type(false, bool)
			none
			[param(a, type(false, bool)), param(b, type(false, bool))]
			builtin([]))
		fun(
			false
			>=
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body([], call(not, [call(<, [param-ref(a), param-ref(b)])])))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, ptr)]))
		fun(
			true
			-
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				[]
				seq(
					call(assert, [call(>=, [param-ref(a), param-ref(b)])])
					call(wrap-sub, [param-ref(a), param-ref(b)]))))
		fun(
			false
			wrap-sub
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(
			false
			call
			type(true, fut)
			none
			[param(f, type(false, fun-ptr2)), param(p0, type(true, ctx)), param(p1, type(false, arr))]
			builtin([type(true, fut), type(true, ctx), type(false, arr)]))
		fun(
			true
			map
			type(false, arr)
			none
			[param(a, type(false, arr)), param(mapper, type(false, fun-mut1))]
			expr-body(
				[]
				call(
					make-arr
					[
						get-field(param-ref(a), size)
						lambda(lambda(map, 0), some(alloc(alloc, record([param-ref(mapper), param-ref(a)]))))])))
		fun(
			true
			make-arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body([], call(freeze, [call(make-mut-arr, [param-ref(size), param-ref(f)])])))
		fun(
			false
			freeze
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body([], seq(set-field(param-ref(a), frozen?, call(true, [])), call(unsafe-as-arr, [param-ref(a)]))))
		fun(
			false
			unsafe-as-arr
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body([], record([get-field(param-ref(a), size), get-field(param-ref(a), data)])))
		fun(
			true
			make-mut-arr
			type(true, mut-arr)
			none
			[param(size, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body(
				[local(res, type(true, mut-arr))]
				let(
					res
					call(new-uninitialized-mut-arr, [param-ref(size)])
					seq(call(make-mut-arr-worker, [local-ref(res), call(zero, []), param-ref(f)]), local-ref(res)))))
		fun(
			true
			new-uninitialized-mut-arr
			type(true, mut-arr)
			none
			[param(size, type(false, nat))]
			expr-body(
				[]
				alloc(
					alloc
					record(
						[call(false, []), param-ref(size), param-ref(size), call(uninitialized-data, [param-ref(size)])]))))
		fun(
			true
			uninitialized-data
			type(false, ptr)
			none
			[param(size, type(false, nat))]
			expr-body(
				[local(bptr, type(false, ptr))]
				let(
					bptr
					call(alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					call(ptr-cast, [local-ref(bptr)]))))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, arr)]))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, arr), type(false, nat8)]))
		fun(
			true
			make-mut-arr-worker
			type(false, void)
			none
			[param(m, type(true, mut-arr)), param(i, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body(
				[]
				cond(
					call(==, [param-ref(i), get-field(param-ref(m), size)])
					call(pass, [])
					seq(
						call(set-at, [param-ref(m), param-ref(i), call(call, [param-ref(f), param-ref(i)])])
						call(make-mut-arr-worker, [param-ref(m), call(incr, [param-ref(i)]), param-ref(f)])))))
		fun(
			true
			set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, arr))]
			expr-body(
				[]
				seq(
					call(assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(noctx-set-at, [param-ref(a), param-ref(index), param-ref(value)]))))
		fun(
			false
			noctx-set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, arr))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(set, [call(+, [get-field(param-ref(a), data), param-ref(index)]), param-ref(value)]))))
		fun(
			false
			set
			type(false, void)
			none
			[param(p, type(false, ptr)), param(value, type(false, arr))]
			builtin([type(false, arr)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, arr)]))
		fun(
			true
			call
			type(false, arr)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, nat))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, arr)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, nat))]
			expr-body(
				[]
				call(
					call
					[get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure), param-ref(p0)])))
		fun(
			false
			call
			type(false, arr)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, nat))]
			builtin([type(false, arr), type(true, ctx), type(false, ptr), type(false, nat)]))
		fun(
			true
			incr
			type(false, nat)
			none
			[param(n, type(false, nat))]
			expr-body(
				[]
				seq(
					call(assert, [call(<, [param-ref(n), call(billion, [])])])
					call(wrap-add, [param-ref(n), call(one, [])]))))
		fun(
			true
			call
			type(false, arr)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, ptr))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, arr)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, ptr))]
			expr-body(
				[]
				call(
					call
					[get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure), param-ref(p0)])))
		fun(
			false
			call
			type(false, arr)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, ptr))]
			builtin([type(false, arr), type(true, ctx), type(false, ptr), type(false, ptr)]))
		fun(
			true
			at
			type(false, ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(noctx-at, [param-ref(a), param-ref(index)]))))
		fun(
			false
			noctx-at
			type(false, ptr)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(deref, [call(+, [get-field(param-ref(a), data), param-ref(index)])]))))
		fun(false, deref, type(false, ptr), none, [param(p, type(false, ptr))], builtin([type(false, ptr)]))
		fun(
			true
			lambda(map, 0)
			type(false, arr)
			some(param("<<closure>>", type(true, lambda(map, 0))))
			[param(i, type(false, nat))]
			expr-body(
				[]
				call(
					call
					[
						get-field(param-ref("<<closure>>"), mapper)
						call(at, [get-field(param-ref("<<closure>>"), a), param-ref(i)])])))
		fun(
			false
			to-str
			type(false, arr)
			none
			[param(a, type(false, ptr))]
			expr-body([], call(arr-from-begin-end, [param-ref(a), call(find-cstr-end, [param-ref(a)])])))
		fun(
			false
			arr-from-begin-end
			type(false, arr)
			none
			[param(begin, type(false, ptr)), param(end, type(false, ptr))]
			expr-body([], record([call(-, [param-ref(end), param-ref(begin)]), param-ref(begin)])))
		fun(
			false
			-
			type(false, nat)
			none
			[param(a, type(false, ptr)), param(b, type(false, ptr))]
			expr-body([], call(to-nat, [call(-, [param-ref(a), call(to-nat, [param-ref(b)])])])))
		fun(false, to-nat, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, char)]))
		fun(
			false
			-
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, char)]))
		fun(
			false
			find-cstr-end
			type(false, ptr)
			none
			[param(a, type(false, ptr))]
			expr-body([], call(find-char-in-cstr, [param-ref(a), call(literal, [str-lit("\0")])])))
		fun(
			false
			find-char-in-cstr
			type(false, ptr)
			none
			[param(a, type(false, ptr)), param(c, type(false, char))]
			expr-body(
				[]
				cond(
					call(==, [call(deref, [param-ref(a)]), param-ref(c)])
					param-ref(a)
					cond(
						call(==, [call(deref, [param-ref(a)]), call(literal, [str-lit("\0")])])
						call(todo, [])
						call(find-char-in-cstr, [call(incr, [param-ref(a)]), param-ref(c)])))))
		fun(
			false
			==
			type(false, bool)
			none
			[param(a, type(false, char)), param(b, type(false, char))]
			expr-body(
				[local("<<matched>>", type(false, comparison))]
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(false, [])), case(none, call(true, [])), case(none, call(false, []))])))
		fun(
			false
			<=>
			type(false, comparison)
			none
			[param(a, type(false, char)), param(b, type(false, char))]
			builtin([type(false, char)]))
		fun(false, deref, type(false, char), none, [param(p, type(false, ptr))], builtin([type(false, char)]))
		fun(
			false
			literal
			type(false, char)
			none
			[param(a, type(false, arr))]
			expr-body([], call(noctx-at, [param-ref(a), call(zero, [])])))
		fun(
			false
			noctx-at
			type(false, char)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(deref, [call(+, [get-field(param-ref(a), data), param-ref(index)])]))))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, char)]))
		fun(false, todo, type(false, ptr), none, [], expr-body([], call(hard-fail, [str-lit("TODO")])))
		fun(false, hard-fail, type(false, ptr), none, [param(reason, type(false, arr))], builtin([type(false, ptr)]))
		fun(
			false
			incr
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			expr-body([], call(+, [param-ref(p), call(one, [])])))
		fun(
			true
			lambda(lambda(add-first-task, 0), 0)
			type(false, arr)
			some(param("<<closure>>", type(false, ptr)))
			[param(it, type(false, ptr))]
			expr-body([], call(to-str, [param-ref(it)])))
		fun(
			true
			lambda(add-first-task, 0)
			type(true, fut)
			some(param("<<closure>>", type(true, lambda(add-first-task, 0))))
			[]
			expr-body(
				[local(args, type(false, arr))]
				let(
					args
					call(tail, [get-field(param-ref("<<closure>>"), all-args)])
					call(
						call
						[
							get-field(param-ref("<<closure>>"), main-ptr)
							call(get-ctx, [])
							call(
								map
								[local-ref(args), lambda(lambda(lambda(add-first-task, 0), 0), some(call(null-any, [])))])]))))
		fun(
			true
			lambda(do-main, 0)
			type(true, fut)
			some(param("<<closure>>", type(false, ptr)))
			[param(all-args, type(false, arr)), param(main-ptr, type(false, fun-ptr2))]
			expr-body([], call(add-first-task, [param-ref(all-args), param-ref(main-ptr)])))
		fun(false, unsafe-to-nat, type(false, nat), none, [param(a, type(false, int))], builtin([]))
		fun(false, to-int, type(false, int), none, [param(i, type(false, int32))], builtin([]))
		fun(
			false
			call-with-ctx
			type(true, fut)
			none
			[
				param(c, type(true, ctx))
				param(f, type(false, fun2))
				param(p0, type(false, arr))
				param(p1, type(false, fun-ptr2))]
			expr-body(
				[]
				call(
					call
					[
						get-field(param-ref(f), fun-ptr)
						param-ref(c)
						get-field(param-ref(f), closure)
						param-ref(p0)
						param-ref(p1)])))
		fun(
			false
			call
			type(true, fut)
			none
			[
				param(f, type(false, fun-ptr4))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, arr))
				param(p3, type(false, fun-ptr2))]
			builtin([type(true, fut), type(true, ctx), type(false, ptr), type(false, arr), type(false, fun-ptr2)]))
		fun(
			false
			run-threads
			type(false, void)
			none
			[param(n-threads, type(false, nat)), param(arg, type(true, global-ctx)), param(fun, type(false, fun-ptr2))]
			expr-body(
				[local(threads, type(false, ptr)), local(thread-args, type(false, ptr))]
				let(
					threads
					call(unmanaged-alloc-elements, [param-ref(n-threads)])
					let(
						thread-args
						call(unmanaged-alloc-elements, [param-ref(n-threads)])
						seq(
							seq(
								seq(
									call(
										run-threads-recur
										[
											call(zero, [])
											param-ref(n-threads)
											local-ref(threads)
											local-ref(thread-args)
											param-ref(arg)
											param-ref(fun)])
									call(join-threads-recur, [call(zero, []), param-ref(n-threads), local-ref(threads)]))
								call(unmanaged-free, [local-ref(threads)]))
							call(unmanaged-free, [local-ref(thread-args)]))))))
		fun(
			false
			unmanaged-alloc-elements
			type(false, ptr)
			none
			[param(size-elements, type(false, nat))]
			expr-body(
				[local(bytes, type(false, ptr))]
				let(
					bytes
					call(unmanaged-alloc-bytes, [call(wrap-mul, [param-ref(size-elements), call(size-of, [])])])
					call(ptr-cast, [local-ref(bytes)]))))
		fun(false, size-of, type(false, nat), none, [], builtin([type(false, thread-args)]))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, thread-args), type(false, nat8)]))
		fun(
			false
			run-threads-recur
			type(false, void)
			none
			[
				param(i, type(false, nat))
				param(n-threads, type(false, nat))
				param(threads, type(false, ptr))
				param(thread-args, type(false, ptr))
				param(arg, type(true, global-ctx))
				param(fun, type(false, fun-ptr2))]
			expr-body(
				[
					local(thread-arg-ptr, type(false, ptr))
					local(thread-ptr, type(false, ptr))
					local(fn, type(false, fun-ptr1))
					local(err, type(false, int32))]
				cond(
					call(==, [param-ref(i), param-ref(n-threads)])
					call(pass, [])
					let(
						thread-arg-ptr
						call(+, [param-ref(thread-args), param-ref(i)])
						seq(
							call(
								set
								[local-ref(thread-arg-ptr), record([param-ref(fun), param-ref(i), param-ref(arg)])])
							let(
								thread-ptr
								call(+, [param-ref(threads), param-ref(i)])
								let(
									fn
									call(as, [lambda(lambda(run-threads-recur, 0), none)])
									let(
										err
										call(
											pthread-create
											[
												call(as-cell, [local-ref(thread-ptr)])
												call(null, [])
												local-ref(fn)
												call(as-any-ptr, [local-ref(thread-arg-ptr)])])
										cond(
											call(zero?, [local-ref(err)])
											call(
												run-threads-recur
												[
													call(noctx-incr, [param-ref(i)])
													param-ref(n-threads)
													param-ref(threads)
													param-ref(thread-args)
													param-ref(arg)
													param-ref(fun)])
											cond(
												call(==, [local-ref(err), call(eagain, [])])
												call(todo, [])
												call(todo, [])))))))))))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, thread-args)]))
		fun(
			false
			set
			type(false, void)
			none
			[param(p, type(false, ptr)), param(value, type(false, thread-args))]
			builtin([type(false, thread-args)]))
		fun(
			false
			+
			type(false, ptr)
			none
			[param(p, type(false, ptr)), param(offset, type(false, nat))]
			builtin([type(false, nat)]))
		fun(
			false
			as
			type(false, fun-ptr1)
			none
			[param(value, type(false, fun-ptr1))]
			builtin([type(false, fun-ptr1)]))
		fun(
			false
			thread-fun
			type(false, ptr)
			none
			[param(args-ptr, type(false, ptr))]
			expr-body(
				[local(args, type(true, thread-args))]
				let(
					args
					call(as-ref, [param-ref(args-ptr)])
					seq(
						call(
							call
							[
								get-field(local-ref(args), fun)
								get-field(local-ref(args), thread-id)
								get-field(local-ref(args), arg)])
						call(null, [])))))
		fun(
			false
			as-ref
			type(true, thread-args)
			none
			[param(p, type(false, ptr))]
			builtin([type(true, thread-args)]))
		fun(
			false
			call
			type(false, void)
			none
			[param(f, type(false, fun-ptr2)), param(p0, type(false, nat)), param(p1, type(true, global-ctx))]
			builtin([type(false, void), type(false, nat), type(true, global-ctx)]))
		fun(
			false
			lambda(run-threads-recur, 0)
			type(false, ptr)
			none
			[param(args-ptr, type(false, ptr))]
			expr-body([], call(thread-fun, [param-ref(args-ptr)])))
		fun(
			false
			pthread-create
			type(false, int32)
			none
			[
				param(thread, type(true, cell))
				param(attr, type(false, ptr))
				param(start-routine, type(false, fun-ptr1))
				param(arg, type(false, ptr))]
			extern(false))
		fun(
			false
			as-cell
			type(true, cell)
			none
			[param(p, type(false, ptr))]
			expr-body([], call(as-ref, [call(as-any-ptr, [param-ref(p)])])))
		fun(false, as-ref, type(true, cell), none, [param(p, type(false, ptr))], builtin([type(true, cell)]))
		fun(false, as-any-ptr, type(false, ptr), none, [param(some-ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(false, as-any-ptr, type(false, ptr), none, [param(some-ref, type(false, ptr))], builtin([type(false, ptr)]))
		fun(false, eagain, type(false, int32), none, [], expr-body([], call(wrap-add, [call(ten, []), call(one, [])])))
		fun(false, ten, type(false, int32), none, [], expr-body([], call(wrap-add, [call(five, []), call(five, [])])))
		fun(
			false
			join-threads-recur
			type(false, void)
			none
			[param(i, type(false, nat)), param(n-threads, type(false, nat)), param(threads, type(false, ptr))]
			expr-body(
				[]
				cond(
					call(==, [param-ref(i), param-ref(n-threads)])
					call(pass, [])
					seq(
						call(join-one-thread, [call(deref, [call(+, [param-ref(threads), param-ref(i)])])])
						call(
							join-threads-recur
							[call(noctx-incr, [param-ref(i)]), param-ref(n-threads), param-ref(threads)])))))
		fun(
			false
			join-one-thread
			type(false, void)
			none
			[param(tid, type(false, nat))]
			expr-body(
				[local(thread-return, type(false, cell)), local(err, type(false, int32))]
				let(
					thread-return
					record([call(null, [])])
					let(
						err
						call(pthread-join, [param-ref(tid), call(ref-of-val, [local-ref(thread-return)])])
						seq(
							cond(
								call(zero?, [local-ref(err)])
								call(pass, [])
								cond(
									call(==, [local-ref(err), call(einval, [])])
									call(todo, [])
									cond(call(==, [local-ref(err), call(esrch, [])]), call(todo, []), call(todo, []))))
							call(
								hard-assert
								[call(null?, [call(get, [call(ref-of-val, [local-ref(thread-return)])])])]))))))
		fun(
			false
			pthread-join
			type(false, int32)
			none
			[param(thread, type(false, nat)), param(thread-return, type(true, cell))]
			extern(false))
		fun(false, ref-of-val, type(true, cell), none, [param(b, type(false, cell))], builtin([type(true, cell)]))
		fun(
			false
			einval
			type(false, int32)
			none
			[]
			expr-body([], call(wrap-add, [call(wrap-add, [call(ten, []), call(ten, [])]), call(two, [])])))
		fun(false, esrch, type(false, int32), none, [], expr-body([], call(three, [])))
		fun(
			false
			get
			type(false, ptr)
			none
			[param(c, type(true, cell))]
			expr-body([], get-field(param-ref(c), value)))
		fun(false, deref, type(false, nat), none, [param(p, type(false, ptr))], builtin([type(false, nat)]))
		fun(
			false
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, ptr))]
			expr-body([], call(free, [call(ptr-cast, [param-ref(p)])])))
		fun(false, free, type(false, void), none, [param(p, type(false, ptr))], extern(false))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat8), type(false, nat)]))
		fun(
			false
			unmanaged-free
			type(false, void)
			none
			[param(p, type(false, ptr))]
			expr-body([], call(free, [call(ptr-cast, [param-ref(p)])])))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, nat8), type(false, thread-args)]))
		fun(
			false
			thread-function
			type(false, void)
			none
			[param(thread-id, type(false, nat)), param(gctx, type(true, global-ctx))]
			expr-body(
				[local(ectx, type(false, exception-ctx)), local(tls, type(false, thread-local-stuff))]
				let(
					ectx
					call(new-exception-ctx, [])
					let(
						tls
						call(as, [record([call(ref-of-val, [local-ref(ectx)])])])
						call(
							thread-function-recur
							[param-ref(thread-id), param-ref(gctx), call(ref-of-val, [local-ref(tls)])])))))
		fun(
			false
			as
			type(false, thread-local-stuff)
			none
			[param(value, type(false, thread-local-stuff))]
			builtin([type(false, thread-local-stuff)]))
		fun(
			false
			thread-function-recur
			type(false, void)
			none
			[
				param(thread-id, type(false, nat))
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))]
			expr-body(
				[
					local(last-checked, type(false, nat))
					local(ok-chosen-task, type(false, ok))
					local(e, type(false, err))
					local("<<matched>>", type(false, result))]
				cond(
					get-field(param-ref(gctx), is-shut-down)
					seq(
						seq(
							seq(
								call(acquire-lock, [call(ref-of-val, [get-field(param-ref(gctx), lk)])])
								set-field(
									param-ref(gctx)
									n-live-threads
									call(noctx-decr, [get-field(param-ref(gctx), n-live-threads)])))
							call(assert-vats-are-shut-down, [call(zero, []), get-field(param-ref(gctx), vats)]))
						call(release-lock, [call(ref-of-val, [get-field(param-ref(gctx), lk)])]))
					seq(
						call(hard-assert, [call(>, [get-field(param-ref(gctx), n-live-threads), call(zero, [])])])
						let(
							last-checked
							call(get-last-checked, [call(ref-of-val, [get-field(param-ref(gctx), may-be-work-to-do)])])
							seq(
								match(
									"<<matched>>"
									call(choose-task, [param-ref(gctx)])
									[
										case(
											some(ok-chosen-task)
											call(
												do-task
												[
													param-ref(gctx)
													param-ref(tls)
													get-field(local-ref(ok-chosen-task), value)]))
										case(
											some(e)
											seq(
												seq(
													seq(
														cond(
															get-field(get-field(local-ref(e), value), last-thread-out)
															seq(
																seq(
																	call(
																		hard-forbid
																		[get-field(param-ref(gctx), is-shut-down)])
																	set-field(
																		param-ref(gctx)
																		is-shut-down
																		call(true, [])))
																call(
																	broadcast
																	[
																		call(
																			ref-of-val
																			[
																				get-field(
																					param-ref(gctx)
																					may-be-work-to-do)])]))
															call(
																wait-on
																[
																	call(
																		ref-of-val
																		[get-field(param-ref(gctx), may-be-work-to-do)])
																	local-ref(last-checked)]))
														call(
															acquire-lock
															[call(ref-of-val, [get-field(param-ref(gctx), lk)])]))
													set-field(
														param-ref(gctx)
														n-live-threads
														call(noctx-incr, [get-field(param-ref(gctx), n-live-threads)])))
												call(release-lock, [call(ref-of-val, [get-field(param-ref(gctx), lk)])])))])
								call(thread-function-recur, [param-ref(thread-id), param-ref(gctx), param-ref(tls)])))))))
		fun(
			false
			noctx-decr
			type(false, nat)
			none
			[param(n, type(false, nat))]
			expr-body(
				[]
				seq(call(hard-forbid, [call(zero?, [param-ref(n)])]), call(wrap-sub, [param-ref(n), call(one, [])]))))
		fun(
			false
			assert-vats-are-shut-down
			type(false, void)
			none
			[param(i, type(false, nat)), param(vats, type(false, arr))]
			expr-body(
				[local(vat, type(true, vat))]
				cond(
					call(==, [param-ref(i), get-field(param-ref(vats), size)])
					call(pass, [])
					let(
						vat
						call(noctx-at, [param-ref(vats), param-ref(i)])
						seq(
							seq(
								seq(
									seq(
										seq(
											call(
												acquire-lock
												[call(ref-of-val, [get-field(local-ref(vat), tasks-lock)])])
											call(
												hard-forbid
												[get-field(call(ref-of-val, [get-field(local-ref(vat), gc)]), needs-gc)]))
										call(hard-assert, [call(zero?, [get-field(local-ref(vat), n-threads-running)])]))
									call(
										hard-assert
										[call(empty?, [call(ref-of-val, [get-field(local-ref(vat), tasks)])])]))
								call(release-lock, [call(ref-of-val, [get-field(local-ref(vat), tasks-lock)])]))
							call(assert-vats-are-shut-down, [call(noctx-incr, [param-ref(i)]), param-ref(vats)]))))))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(m, type(true, mut-bag))]
			expr-body([], call(empty?, [get-field(param-ref(m), head)])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(
				[local(n, type(false, none)), local(s, type(false, some)), local("<<matched>>", type(false, opt))]
				match("<<matched>>", param-ref(a), [case(some(n), call(true, [])), case(some(s), call(false, []))])))
		fun(
			false
			>
			type(false, bool)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body([], call(not, [call(<=, [param-ref(a), param-ref(b)])])))
		fun(
			false
			get-last-checked
			type(false, nat)
			none
			[param(c, type(true, condition))]
			expr-body([], get-field(param-ref(c), value)))
		fun(
			false
			choose-task
			type(false, result)
			none
			[param(gctx, type(true, global-ctx))]
			expr-body(
				[local(s, type(false, some)), local("<<matched>>", type(false, opt)), local(res, type(false, result))]
				seq(
					call(acquire-lock, [call(ref-of-val, [get-field(param-ref(gctx), lk)])])
					let(
						res
						call(
							as
							[
								match(
									"<<matched>>"
									call(choose-task-recur, [get-field(param-ref(gctx), vats), call(zero, [])])
									[
										case(
											none
											seq(
												set-field(
													param-ref(gctx)
													n-live-threads
													call(noctx-decr, [get-field(param-ref(gctx), n-live-threads)]))
												to-union(
													1
													call(
														err
														[
															record(
																[
																	call(
																		zero?
																		[get-field(param-ref(gctx), n-live-threads)])])]))))
										case(some(s), to-union(0, call(ok, [get-field(local-ref(s), value)])))])])
						seq(call(release-lock, [call(ref-of-val, [get-field(param-ref(gctx), lk)])]), local-ref(res))))))
		fun(false, as, type(false, result), none, [param(value, type(false, result))], builtin([type(false, result)]))
		fun(
			false
			choose-task-recur
			type(false, opt)
			none
			[param(vats, type(false, arr)), param(i, type(false, nat))]
			expr-body(
				[local(vat, type(true, vat)), local(s, type(false, some)), local("<<matched>>", type(false, opt))]
				cond(
					call(==, [param-ref(i), get-field(param-ref(vats), size)])
					to-union(0, call(none, []))
					let(
						vat
						call(noctx-at, [param-ref(vats), param-ref(i)])
						match(
							"<<matched>>"
							call(choose-task-in-vat, [local-ref(vat)])
							[
								case(none, call(choose-task-recur, [param-ref(vats), call(noctx-incr, [param-ref(i)])]))
								case(
									some(s)
									to-union(1, call(some, [record([local-ref(vat), get-field(local-ref(s), value)])])))])))))
		fun(
			false
			choose-task-in-vat
			type(false, opt)
			none
			[param(vat, type(true, vat))]
			expr-body(
				[local(s, type(false, some)), local("<<matched>>", type(false, opt)), local(res, type(false, opt))]
				seq(
					call(acquire-lock, [call(ref-of-val, [get-field(param-ref(vat), tasks-lock)])])
					let(
						res
						call(
							as
							[
								cond(
									get-field(call(ref-of-val, [get-field(param-ref(vat), gc)]), needs-gc)
									cond(
										call(zero?, [get-field(param-ref(vat), n-threads-running)])
										to-union(1, call(some, [to-union(0, call(none, []))]))
										to-union(0, call(none, [])))
									match(
										"<<matched>>"
										call(find-and-remove-first-doable-task, [param-ref(vat)])
										[
											case(none, to-union(0, call(none, [])))
											case(
												some(s)
												to-union(
													1
													call(
														some
														[to-union(1, call(some, [get-field(local-ref(s), value)]))])))]))])
						seq(
							seq(
								cond(
									call(empty?, [local-ref(res)])
									call(pass, [])
									set-field(
										param-ref(vat)
										n-threads-running
										call(noctx-incr, [get-field(param-ref(vat), n-threads-running)])))
								call(release-lock, [call(ref-of-val, [get-field(param-ref(vat), tasks-lock)])]))
							local-ref(res))))))
		fun(false, as, type(false, opt), none, [param(value, type(false, opt))], builtin([type(false, opt)]))
		fun(false, some, type(false, some), none, [param(t, type(false, opt))], expr-body([], record([param-ref(t)])))
		fun(
			false
			find-and-remove-first-doable-task
			type(false, opt)
			none
			[param(vat, type(true, vat))]
			expr-body(
				[
					local(tasks, type(true, mut-bag))
					local(res, type(false, opt))
					local(s, type(false, some))
					local("<<matched>>", type(false, opt))]
				let(
					tasks
					call(ref-of-val, [get-field(param-ref(vat), tasks)])
					let(
						res
						call(
							find-and-remove-first-doable-task-recur
							[param-ref(vat), get-field(local-ref(tasks), head)])
						match(
							"<<matched>>"
							local-ref(res)
							[
								case(none, to-union(0, call(none, [])))
								case(
									some(s)
									seq(
										set-field(
											local-ref(tasks)
											head
											get-field(get-field(local-ref(s), value), nodes))
										to-union(1, call(some, [get-field(get-field(local-ref(s), value), task)]))))])))))
		fun(
			false
			find-and-remove-first-doable-task-recur
			type(false, opt)
			none
			[param(vat, type(true, vat)), param(opt-node, type(false, opt))]
			expr-body(
				[
					local(s, type(false, some))
					local(node, type(true, mut-bag-node))
					local(task, type(false, task))
					local(actors, type(true, mut-arr))
					local(task-ok, type(false, bool))
					local(ss, type(false, some))
					local(tn, type(false, task-and-nodes))
					local("<<matched>>", type(false, opt))
					local("<<matched>>", type(false, opt))]
				match(
					"<<matched>>"
					param-ref(opt-node)
					[
						case(none, to-union(0, call(none, [])))
						case(
							some(s)
							let(
								node
								get-field(local-ref(s), value)
								let(
									task
									get-field(local-ref(node), value)
									let(
										actors
										call(ref-of-val, [get-field(param-ref(vat), currently-running-actors)])
										let(
											task-ok
											cond(
												call(
													contains?
													[local-ref(actors), get-field(local-ref(task), actor-id)])
												call(false, [])
												seq(
													call(
														push-capacity-must-be-sufficient
														[local-ref(actors), get-field(local-ref(task), actor-id)])
													call(true, [])))
											cond(
												local-ref(task-ok)
												to-union(
													1
													call(
														some
														[
															record(
																[local-ref(task), get-field(local-ref(node), next-node)])]))
												match(
													"<<matched>>"
													call(
														find-and-remove-first-doable-task-recur
														[param-ref(vat), get-field(local-ref(node), next-node)])
													[
														case(none, to-union(0, call(none, [])))
														case(
															some(ss)
															let(
																tn
																call(as, [get-field(local-ref(ss), value)])
																seq(
																	set-field(
																		local-ref(node)
																		next-node
																		get-field(local-ref(tn), nodes))
																	to-union(
																		1
																		call(
																			some
																			[
																				record(
																					[
																						get-field(local-ref(tn), task)
																						to-union(
																							1
																							call(
																								some
																								[local-ref(node)]))])])))))])))))))])))
		fun(
			false
			ref-of-val
			type(true, mut-arr)
			none
			[param(b, type(false, mut-arr))]
			builtin([type(true, mut-arr)]))
		fun(
			false
			contains?
			type(false, bool)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat))]
			expr-body([], call(contains-recur?, [call(temp-as-arr, [param-ref(a)]), param-ref(value), call(zero, [])])))
		fun(
			false
			contains-recur?
			type(false, bool)
			none
			[param(a, type(false, arr)), param(value, type(false, nat)), param(i, type(false, nat))]
			expr-body(
				[]
				cond(
					call(==, [param-ref(i), get-field(param-ref(a), size)])
					call(false, [])
					call(
						or
						[
							call(==, [call(noctx-at, [param-ref(a), param-ref(i)]), param-ref(value)])
							call(contains-recur?, [param-ref(a), param-ref(value), call(noctx-incr, [param-ref(i)])])]))))
		fun(false, or, type(false, bool), none, [param(a, type(false, bool)), param(b, type(false, bool))], builtin([]))
		fun(
			false
			noctx-at
			type(false, nat)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(deref, [call(+, [get-field(param-ref(a), data), param-ref(index)])]))))
		fun(
			false
			temp-as-arr
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body([], record([get-field(param-ref(a), size), get-field(param-ref(a), data)])))
		fun(
			false
			push-capacity-must-be-sufficient
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat))]
			expr-body(
				[local(old-size, type(false, nat))]
				seq(
					call(hard-assert, [call(<, [get-field(param-ref(a), size), get-field(param-ref(a), capacity)])])
					let(
						old-size
						get-field(param-ref(a), size)
						seq(
							set-field(param-ref(a), size, call(noctx-incr, [local-ref(old-size)]))
							call(noctx-set-at, [param-ref(a), local-ref(old-size), param-ref(value)]))))))
		fun(
			false
			noctx-set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, nat))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(set, [call(+, [get-field(param-ref(a), data), param-ref(index)]), param-ref(value)]))))
		fun(
			false
			set
			type(false, void)
			none
			[param(p, type(false, ptr)), param(value, type(false, nat))]
			builtin([type(false, nat)]))
		fun(
			false
			some
			type(false, some)
			none
			[param(t, type(false, task-and-nodes))]
			expr-body([], record([param-ref(t)])))
		fun(
			false
			as
			type(false, task-and-nodes)
			none
			[param(value, type(false, task-and-nodes))]
			builtin([type(false, task-and-nodes)]))
		fun(false, some, type(false, some), none, [param(t, type(false, task))], expr-body([], record([param-ref(t)])))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(false, opt))]
			expr-body(
				[local(n, type(false, none)), local(s, type(false, some)), local("<<matched>>", type(false, opt))]
				match("<<matched>>", param-ref(a), [case(some(n), call(true, [])), case(some(s), call(false, []))])))
		fun(
			false
			some
			type(false, some)
			none
			[param(t, type(false, chosen-task))]
			expr-body([], record([param-ref(t)])))
		fun(
			false
			err
			type(false, err)
			none
			[param(t, type(false, no-chosen-task))]
			expr-body([], record([param-ref(t)])))
		fun(
			false
			ok
			type(false, ok)
			none
			[param(t, type(false, chosen-task))]
			expr-body([], record([param-ref(t)])))
		fun(
			false
			do-task
			type(false, void)
			none
			[
				param(gctx, type(true, global-ctx))
				param(tls, type(true, thread-local-stuff))
				param(chosen-task, type(false, chosen-task))]
			expr-body(
				[
					local(vat, type(true, vat))
					local(some-task, type(false, some))
					local(task, type(false, task))
					local(ctx, type(false, ctx))
					local("<<matched>>", type(false, opt))]
				let(
					vat
					get-field(param-ref(chosen-task), vat)
					seq(
						seq(
							seq(
								match(
									"<<matched>>"
									get-field(param-ref(chosen-task), task-or-gc)
									[
										case(
											none
											seq(
												call(todo, [])
												call(
													broadcast
													[call(ref-of-val, [get-field(param-ref(gctx), may-be-work-to-do)])])))
										case(
											some(some-task)
											let(
												task
												get-field(local-ref(some-task), value)
												let(
													ctx
													call(
														new-ctx
														[
															param-ref(gctx)
															param-ref(tls)
															local-ref(vat)
															get-field(local-ref(task), actor-id)])
													seq(
														seq(
															seq(
																seq(
																	call(
																		call-with-ctx
																		[
																			call(ref-of-val, [local-ref(ctx)])
																			get-field(local-ref(task), fun)])
																	call(
																		acquire-lock
																		[
																			call(
																				ref-of-val
																				[get-field(local-ref(vat), tasks-lock)])]))
																call(
																	noctx-must-remove-unordered
																	[
																		call(
																			ref-of-val
																			[
																				get-field(
																					local-ref(vat)
																					currently-running-actors)])
																		get-field(local-ref(task), actor-id)]))
															call(
																release-lock
																[
																	call(
																		ref-of-val
																		[get-field(local-ref(vat), tasks-lock)])]))
														call(return-ctx, [call(ref-of-val, [local-ref(ctx)])])))))])
								call(acquire-lock, [call(ref-of-val, [get-field(local-ref(vat), tasks-lock)])]))
							set-field(
								local-ref(vat)
								n-threads-running
								call(noctx-decr, [get-field(local-ref(vat), n-threads-running)])))
						call(release-lock, [call(ref-of-val, [get-field(local-ref(vat), tasks-lock)])])))))
		fun(
			false
			noctx-must-remove-unordered
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(value, type(false, nat))]
			expr-body([], call(noctx-must-remove-unordered-recur, [param-ref(a), call(zero, []), param-ref(value)])))
		fun(
			false
			noctx-must-remove-unordered-recur
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, nat))]
			expr-body(
				[]
				cond(
					call(==, [param-ref(index), get-field(param-ref(a), size)])
					call(hard-fail, [str-lit("Did not find the element in the mut-arr")])
					cond(
						call(==, [call(noctx-at, [param-ref(a), param-ref(index)]), param-ref(value)])
						call(drop, [call(noctx-remove-unordered-at-index, [param-ref(a), param-ref(index)])])
						call(
							noctx-must-remove-unordered-recur
							[param-ref(a), call(noctx-incr, [param-ref(index)]), param-ref(value)])))))
		fun(
			false
			noctx-at
			type(false, nat)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(deref, [call(+, [get-field(param-ref(a), data), param-ref(index)])]))))
		fun(false, drop, type(false, void), none, [param(t, type(false, nat))], expr-body([], call(pass, [])))
		fun(
			false
			noctx-remove-unordered-at-index
			type(false, nat)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat))]
			expr-body(
				[local(res, type(false, nat))]
				let(
					res
					call(noctx-at, [param-ref(a), param-ref(index)])
					seq(
						seq(
							call(noctx-set-at, [param-ref(a), param-ref(index), call(noctx-last, [param-ref(a)])])
							set-field(param-ref(a), size, call(noctx-decr, [get-field(param-ref(a), size)])))
						local-ref(res)))))
		fun(
			false
			noctx-last
			type(false, nat)
			none
			[param(a, type(true, mut-arr))]
			expr-body(
				[]
				seq(
					call(hard-forbid, [call(empty?, [param-ref(a)])])
					call(noctx-at, [param-ref(a), call(noctx-decr, [get-field(param-ref(a), size)])]))))
		fun(
			false
			empty?
			type(false, bool)
			none
			[param(a, type(true, mut-arr))]
			expr-body([], call(zero?, [get-field(param-ref(a), size)])))
		fun(
			false
			return-ctx
			type(false, void)
			none
			[param(c, type(true, ctx))]
			expr-body([], call(return-gc-ctx, [call(as-ref, [get-field(param-ref(c), gc-ctx-ptr)])])))
		fun(
			false
			return-gc-ctx
			type(false, void)
			none
			[param(gc-ctx, type(true, gc-ctx))]
			expr-body(
				[local(gc, type(true, gc))]
				let(
					gc
					get-field(param-ref(gc-ctx), gc)
					seq(
						seq(
							seq(
								call(acquire-lock, [call(ref-of-val, [get-field(local-ref(gc), lk)])])
								set-field(param-ref(gc-ctx), next-ctx, get-field(local-ref(gc), context-head)))
							set-field(local-ref(gc), context-head, to-union(1, call(some, [param-ref(gc-ctx)]))))
						call(release-lock, [call(ref-of-val, [get-field(local-ref(gc), lk)])])))))
		fun(false, some, type(false, some), none, [param(t, type(true, gc-ctx))], expr-body([], record([param-ref(t)])))
		fun(
			false
			wait-on
			type(false, void)
			none
			[param(c, type(true, condition)), param(last-checked, type(false, nat))]
			expr-body(
				[]
				cond(
					call(==, [get-field(param-ref(c), value), param-ref(last-checked)])
					seq(call(yield-thread, []), call(wait-on, [param-ref(c), param-ref(last-checked)]))
					call(pass, []))))
		fun(
			false
			lambda(rt-main, 0)
			type(false, void)
			none
			[param(thread-id, type(false, nat)), param(gctx, type(true, global-ctx))]
			expr-body([], call(thread-function, [param-ref(thread-id), param-ref(gctx)])))
		fun(
			false
			must-be-resolved
			type(false, result)
			none
			[param(f, type(true, fut))]
			expr-body(
				[
					local(r, type(false, fut-state-resolved))
					local(e, type(false, exception))
					local("<<matched>>", type(false, fut-state))]
				match(
					"<<matched>>"
					get-field(param-ref(f), state)
					[
						case(none, call(hard-unreachable, []))
						case(some(r), to-union(0, call(ok, [get-field(local-ref(r), value)])))
						case(some(e), to-union(1, call(err, [local-ref(e)])))])))
		fun(
			false
			hard-unreachable
			type(false, result)
			none
			[]
			expr-body([], call(hard-fail, [str-lit("unreachable")])))
		fun(
			false
			hard-fail
			type(false, result)
			none
			[param(reason, type(false, arr))]
			builtin([type(false, result)]))
		fun(
			true
			main
			type(true, fut)
			none
			[param(args, type(false, arr))]
			expr-body(
				[local(p, type(false, point)), local(p-x, type(false, float))]
				let(
					p
					call(create-point, [])
					let(
						p-x
						call(get-x, [local-ref(p)])
						seq(call(print-sync, [call(to-str, [local-ref(p-x)])]), call(resolved, [call(zero, [])]))))))
		fun(
			true
			create-point
			type(false, point)
			none
			[]
			expr-body([], record([call(literal, [str-lit("1")]), call(literal, [str-lit("2")])])))
		fun(
			true
			literal
			type(false, float)
			none
			[param(a, type(false, arr))]
			expr-body([], call(to-float, [call(as, [call(literal, [param-ref(a)])])])))
		fun(false, to-float, type(false, float), none, [param(a, type(false, nat))], builtin([]))
		fun(
			true
			literal
			type(false, nat)
			none
			[param(s, type(false, arr))]
			expr-body(
				[local(higher-digits, type(false, nat))]
				cond(
					call(empty?, [param-ref(s)])
					call(zero, [])
					let(
						higher-digits
						call(as, [call(literal, [call(rtail, [param-ref(s)])])])
						call(
							+
							[
								call(*, [local-ref(higher-digits), call(ten, [])])
								call(char-to-nat, [call(last, [param-ref(s)])])])))))
		fun(
			true
			rtail
			type(false, arr)
			none
			[param(a, type(false, arr))]
			expr-body(
				[]
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(slice, [param-ref(a), call(zero, []), call(decr, [get-field(param-ref(a), size)])]))))
		fun(
			true
			slice
			type(false, arr)
			none
			[param(a, type(false, arr)), param(begin, type(false, nat)), param(size, type(false, nat))]
			expr-body(
				[]
				seq(
					call(
						assert
						[call(<=, [call(+, [param-ref(begin), param-ref(size)]), get-field(param-ref(a), size)])])
					record([param-ref(size), call(+, [get-field(param-ref(a), data), param-ref(begin)])]))))
		fun(
			true
			decr
			type(false, nat)
			none
			[param(a, type(false, nat))]
			expr-body([], seq(call(forbid, [call(zero?, [param-ref(a)])]), call(wrap-decr, [param-ref(a)]))))
		fun(
			false
			wrap-decr
			type(false, nat)
			none
			[param(a, type(false, nat))]
			expr-body([], call(wrap-sub, [param-ref(a), call(one, [])])))
		fun(
			true
			*
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				[local(res, type(false, nat))]
				cond(
					call(or, [call(zero?, [param-ref(a)]), call(zero?, [param-ref(b)])])
					call(zero, [])
					let(
						res
						call(wrap-mul, [param-ref(a), param-ref(b)])
						seq(
							seq(
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(b)]), param-ref(a)])])
								call(assert, [call(==, [call(/, [local-ref(res), param-ref(a)]), param-ref(b)])]))
							local-ref(res))))))
		fun(
			true
			/
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				[]
				seq(call(forbid, [call(zero?, [param-ref(b)])]), call(unsafe-div, [param-ref(a), param-ref(b)]))))
		fun(
			false
			unsafe-div
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(
			false
			char-to-nat
			type(false, nat)
			none
			[param(c, type(false, char))]
			expr-body(
				[]
				cond(
					call(==, [param-ref(c), call(literal, [str-lit("0")])])
					call(zero, [])
					cond(
						call(==, [param-ref(c), call(literal, [str-lit("1")])])
						call(one, [])
						cond(
							call(==, [param-ref(c), call(literal, [str-lit("2")])])
							call(two, [])
							cond(
								call(==, [param-ref(c), call(literal, [str-lit("3")])])
								call(three, [])
								cond(
									call(==, [param-ref(c), call(literal, [str-lit("4")])])
									call(four, [])
									cond(
										call(==, [param-ref(c), call(literal, [str-lit("5")])])
										call(five, [])
										cond(
											call(==, [param-ref(c), call(literal, [str-lit("6")])])
											call(six, [])
											cond(
												call(==, [param-ref(c), call(literal, [str-lit("7")])])
												call(seven, [])
												cond(
													call(==, [param-ref(c), call(literal, [str-lit("8")])])
													call(eight, [])
													cond(
														call(==, [param-ref(c), call(literal, [str-lit("9")])])
														call(nine, [])
														call(todo, [])))))))))))))
		fun(false, todo, type(false, nat), none, [], expr-body([], call(hard-fail, [str-lit("TODO")])))
		fun(false, hard-fail, type(false, nat), none, [param(reason, type(false, arr))], builtin([type(false, nat)]))
		fun(
			true
			last
			type(false, char)
			none
			[param(a, type(false, arr))]
			expr-body(
				[]
				seq(
					call(forbid, [call(empty?, [param-ref(a)])])
					call(at, [param-ref(a), call(decr, [get-field(param-ref(a), size)])]))))
		fun(
			true
			at
			type(false, char)
			none
			[param(a, type(false, arr)), param(index, type(false, nat))]
			expr-body(
				[]
				seq(
					call(assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(noctx-at, [param-ref(a), param-ref(index)]))))
		fun(
			true
			get-x
			type(false, float)
			none
			[param(a, type(false, point))]
			expr-body([], get-field(param-ref(a), x)))
		fun(
			false
			print-sync
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body([], seq(call(print-sync-no-newline, [param-ref(s)]), call(print-sync-no-newline, [str-lit("\n")]))))
		fun(
			false
			print-sync-no-newline
			type(false, void)
			none
			[param(s, type(false, arr))]
			expr-body([], call(write-sync-no-newline, [call(stdout-fd, []), param-ref(s)])))
		fun(false, stdout-fd, type(false, int32), none, [], expr-body([], call(one, [])))
		fun(
			true
			to-str
			type(false, arr)
			none
			[param(a, type(false, float))]
			expr-body([], call(to-str, [call(truncate-to-int, [param-ref(a)])])))
		fun(
			true
			to-str
			type(false, arr)
			none
			[param(i, type(false, int))]
			expr-body(
				[local(a, type(false, arr))]
				let(
					a
					call(to-str, [call(abs, [param-ref(i)])])
					call(if, [call(negative?, [param-ref(i)]), call(+, [str-lit("-"), local-ref(a)]), local-ref(a)]))))
		fun(
			true
			to-str
			type(false, arr)
			none
			[param(n, type(false, nat))]
			expr-body(
				[local(hi, type(false, arr)), local(lo, type(false, arr))]
				cond(
					call(==, [param-ref(n), call(literal, [str-lit("0")])])
					str-lit("0")
					cond(
						call(==, [param-ref(n), call(literal, [str-lit("1")])])
						str-lit("1")
						cond(
							call(==, [param-ref(n), call(literal, [str-lit("2")])])
							str-lit("2")
							cond(
								call(==, [param-ref(n), call(literal, [str-lit("3")])])
								str-lit("3")
								cond(
									call(==, [param-ref(n), call(literal, [str-lit("4")])])
									str-lit("4")
									cond(
										call(==, [param-ref(n), call(literal, [str-lit("5")])])
										str-lit("5")
										cond(
											call(==, [param-ref(n), call(literal, [str-lit("6")])])
											str-lit("6")
											cond(
												call(==, [param-ref(n), call(literal, [str-lit("7")])])
												str-lit("7")
												cond(
													call(==, [param-ref(n), call(literal, [str-lit("8")])])
													str-lit("8")
													cond(
														call(==, [param-ref(n), call(literal, [str-lit("9")])])
														str-lit("9")
														let(
															hi
															call(to-str, [call(/, [param-ref(n), call(ten, [])])])
															let(
																lo
																call(to-str, [call(mod, [param-ref(n), call(ten, [])])])
																call(+, [local-ref(hi), local-ref(lo)])))))))))))))))
		fun(
			true
			mod
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			expr-body(
				[]
				seq(call(forbid, [call(zero?, [param-ref(b)])]), call(unsafe-mod, [param-ref(a), param-ref(b)]))))
		fun(
			false
			unsafe-mod
			type(false, nat)
			none
			[param(a, type(false, nat)), param(b, type(false, nat))]
			builtin([]))
		fun(
			true
			+
			type(false, arr)
			none
			[param(a, type(false, arr)), param(b, type(false, arr))]
			expr-body(
				[]
				call(
					make-arr
					[
						call(+, [get-field(param-ref(a), size), get-field(param-ref(b), size)])
						lambda(lambda(+, 0), some(alloc(alloc, record([param-ref(a), param-ref(b)]))))])))
		fun(
			true
			make-arr
			type(false, arr)
			none
			[param(size, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body([], call(freeze, [call(make-mut-arr, [param-ref(size), param-ref(f)])])))
		fun(
			false
			freeze
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body([], seq(set-field(param-ref(a), frozen?, call(true, [])), call(unsafe-as-arr, [param-ref(a)]))))
		fun(
			false
			unsafe-as-arr
			type(false, arr)
			none
			[param(a, type(true, mut-arr))]
			expr-body([], record([get-field(param-ref(a), size), get-field(param-ref(a), data)])))
		fun(
			true
			make-mut-arr
			type(true, mut-arr)
			none
			[param(size, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body(
				[local(res, type(true, mut-arr))]
				let(
					res
					call(new-uninitialized-mut-arr, [param-ref(size)])
					seq(call(make-mut-arr-worker, [local-ref(res), call(zero, []), param-ref(f)]), local-ref(res)))))
		fun(
			true
			new-uninitialized-mut-arr
			type(true, mut-arr)
			none
			[param(size, type(false, nat))]
			expr-body(
				[]
				alloc(
					alloc
					record(
						[call(false, []), param-ref(size), param-ref(size), call(uninitialized-data, [param-ref(size)])]))))
		fun(
			true
			uninitialized-data
			type(false, ptr)
			none
			[param(size, type(false, nat))]
			expr-body(
				[local(bptr, type(false, ptr))]
				let(
					bptr
					call(alloc, [call(wrap-mul, [param-ref(size), call(size-of, [])])])
					call(ptr-cast, [local-ref(bptr)]))))
		fun(
			false
			ptr-cast
			type(false, ptr)
			none
			[param(p, type(false, ptr))]
			builtin([type(false, char), type(false, nat8)]))
		fun(
			true
			make-mut-arr-worker
			type(false, void)
			none
			[param(m, type(true, mut-arr)), param(i, type(false, nat)), param(f, type(false, fun-mut1))]
			expr-body(
				[]
				cond(
					call(==, [param-ref(i), get-field(param-ref(m), size)])
					call(pass, [])
					seq(
						call(set-at, [param-ref(m), param-ref(i), call(call, [param-ref(f), param-ref(i)])])
						call(make-mut-arr-worker, [param-ref(m), call(incr, [param-ref(i)]), param-ref(f)])))))
		fun(
			true
			set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, char))]
			expr-body(
				[]
				seq(
					call(assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(noctx-set-at, [param-ref(a), param-ref(index), param-ref(value)]))))
		fun(
			false
			noctx-set-at
			type(false, void)
			none
			[param(a, type(true, mut-arr)), param(index, type(false, nat)), param(value, type(false, char))]
			expr-body(
				[]
				seq(
					call(hard-assert, [call(<, [param-ref(index), get-field(param-ref(a), size)])])
					call(set, [call(+, [get-field(param-ref(a), data), param-ref(index)]), param-ref(value)]))))
		fun(
			false
			set
			type(false, void)
			none
			[param(p, type(false, ptr)), param(value, type(false, char))]
			builtin([type(false, char)]))
		fun(
			true
			call
			type(false, char)
			none
			[param(f, type(false, fun-mut1)), param(p0, type(false, nat))]
			expr-body([], call(call-with-ctx, [call(get-ctx, []), param-ref(f), param-ref(p0)])))
		fun(
			false
			call-with-ctx
			type(false, char)
			none
			[param(c, type(true, ctx)), param(f, type(false, fun-mut1)), param(p0, type(false, nat))]
			expr-body(
				[]
				call(
					call
					[get-field(param-ref(f), fun-ptr), param-ref(c), get-field(param-ref(f), closure), param-ref(p0)])))
		fun(
			false
			call
			type(false, char)
			none
			[
				param(f, type(false, fun-ptr3))
				param(p0, type(true, ctx))
				param(p1, type(false, ptr))
				param(p2, type(false, nat))]
			builtin([type(false, char), type(true, ctx), type(false, ptr), type(false, nat)]))
		fun(
			true
			lambda(+, 0)
			type(false, char)
			some(param("<<closure>>", type(true, lambda(+, 0))))
			[param(i, type(false, nat))]
			expr-body(
				[]
				cond(
					call(<, [param-ref(i), get-field(get-field(param-ref("<<closure>>"), a), size)])
					call(at, [get-field(param-ref("<<closure>>"), a), param-ref(i)])
					call(
						at
						[
							get-field(param-ref("<<closure>>"), b)
							call(-, [param-ref(i), get-field(get-field(param-ref("<<closure>>"), a), size)])]))))
		fun(
			true
			abs
			type(false, nat)
			none
			[param(i, type(false, int))]
			expr-body(
				[local(i-abs, type(false, int))]
				let(
					i-abs
					call(if, [call(negative?, [param-ref(i)]), call(neg, [param-ref(i)]), param-ref(i)])
					call(to-nat, [local-ref(i-abs)]))))
		fun(
			false
			if
			type(false, int)
			none
			[param(cond, type(false, bool)), param(if-true, type(false, int)), param(if-false, type(false, int))]
			builtin([type(false, int)]))
		fun(
			true
			negative?
			type(false, bool)
			none
			[param(i, type(false, int))]
			expr-body([], call(<, [param-ref(i), call(zero, [])])))
		fun(
			false
			<
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(
				[local("<<matched>>", type(false, comparison))]
				match(
					"<<matched>>"
					call(<=>, [param-ref(a), param-ref(b)])
					[case(none, call(true, [])), case(none, call(false, [])), case(none, call(false, []))])))
		fun(false, zero, type(false, int), none, [], builtin([]))
		fun(
			true
			neg
			type(false, int)
			none
			[param(i, type(false, int))]
			expr-body([], call(*, [param-ref(i), call(neg-one, [])])))
		fun(
			true
			*
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body(
				[]
				seq(
					seq(
						seq(
							seq(
								call(assert, [call(>, [param-ref(a), call(neg-million, [])])])
								call(assert, [call(<, [param-ref(a), call(million, [])])]))
							call(assert, [call(>, [param-ref(b), call(neg-million, [])])]))
						call(assert, [call(<, [param-ref(b), call(million, [])])]))
					call(wrap-mul, [param-ref(a), param-ref(b)]))))
		fun(
			false
			>
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body([], call(not, [call(<=, [param-ref(a), param-ref(b)])])))
		fun(
			false
			<=
			type(false, bool)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			expr-body([], call(not, [call(<, [param-ref(b), param-ref(a)])])))
		fun(
			false
			neg-million
			type(false, int)
			none
			[]
			expr-body([], call(wrap-mul, [call(million, []), call(neg-one, [])])))
		fun(
			false
			wrap-mul
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([]))
		fun(
			false
			million
			type(false, int)
			none
			[]
			expr-body([], call(wrap-mul, [call(thousand, []), call(thousand, [])])))
		fun(
			false
			thousand
			type(false, int)
			none
			[]
			expr-body([], call(wrap-mul, [call(hundred, []), call(ten, [])])))
		fun(false, hundred, type(false, int), none, [], expr-body([], call(wrap-mul, [call(ten, []), call(ten, [])])))
		fun(false, ten, type(false, int), none, [], expr-body([], call(wrap-incr, [call(nine, [])])))
		fun(
			false
			wrap-incr
			type(false, int)
			none
			[param(a, type(false, int))]
			expr-body([], call(wrap-add, [param-ref(a), call(one, [])])))
		fun(
			false
			wrap-add
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([]))
		fun(false, one, type(false, int), none, [], builtin([]))
		fun(false, nine, type(false, int), none, [], expr-body([], call(wrap-incr, [call(eight, [])])))
		fun(false, eight, type(false, int), none, [], expr-body([], call(wrap-incr, [call(seven, [])])))
		fun(false, seven, type(false, int), none, [], expr-body([], call(wrap-incr, [call(six, [])])))
		fun(false, six, type(false, int), none, [], expr-body([], call(wrap-incr, [call(five, [])])))
		fun(false, five, type(false, int), none, [], expr-body([], call(wrap-incr, [call(four, [])])))
		fun(false, four, type(false, int), none, [], expr-body([], call(wrap-incr, [call(three, [])])))
		fun(false, three, type(false, int), none, [], expr-body([], call(wrap-incr, [call(two, [])])))
		fun(false, two, type(false, int), none, [], expr-body([], call(wrap-incr, [call(one, [])])))
		fun(false, neg-one, type(false, int), none, [], expr-body([], call(wrap-sub, [call(zero, []), call(one, [])])))
		fun(
			false
			wrap-sub
			type(false, int)
			none
			[param(a, type(false, int)), param(b, type(false, int))]
			builtin([]))
		fun(
			true
			to-nat
			type(false, nat)
			none
			[param(i, type(false, int))]
			expr-body([], seq(call(forbid, [call(negative?, [param-ref(i)])]), call(unsafe-to-nat, [param-ref(i)]))))
		fun(false, truncate-to-int, type(false, int), none, [param(a, type(false, float))], builtin([]))
		fun(
			true
			resolved
			type(true, fut)
			none
			[param(value, type(false, int32))]
			expr-body([], alloc(alloc, record([call(new-lock, []), to-union(1, record([param-ref(value)]))]))))]
	rt-main
	main
	ctx)
