import
	crow/io/file: each-child-recursive
	crow/io/path: base-name, get-extension
	crow/io/print: out, print
	crow/io/process: exit, has-error, process-result, spawn-and-wait-result, stderr, stdout
	crow/version: is-windows
	./failure:
		failure, flat-map-with-max-size, handle-output, max-failures, match-test,
		overwrite-output, print-tests, test-options, test-result

run-crow-tests test-result^(paths string[], path-to-crow string, options test-options) summon
	tests string[] = () join for path : paths
		path list-tests options.match-test
	failures <- tests flat-map-with-max-size options.max-failures, x =>
		path-to-crow run-single-crow-test x, options
	if failures is-empty
		"ran {tests size} crow tests".ok,
	else
		failures.error,

-list-tests string[](path string, match-test string) summon
	res string mut[] = ()
	path each-child-recursive child =>
		if child contains-seq match-test && child.ext-is-crow && !child.is-excluded
			res ~= child
	res move-to

# Some tests have different output on Windows
-is-excluded bool(a string)
	if trusted is-windows
		a ends-with "/fail.crow" || a ends-with "/gc.crow"

-ext-is-crow bool(a string)
	if ext ?= a.base-name get-extension
		ext == "crow"

-run-single-crow-test failure[]^(path-to-crow string, path string, options test-options) summon
	if options print-tests
		out print "crow run {path}"
	interpret-failures <- path-to-crow run-single-runnable-test path, interpret, options.overwrite-output
	if interpret-failures.is-empty && !(trusted is-windows)
		path-to-crow run-single-runnable-test path, jit, options.overwrite-output
	else
		interpret-failures,

run-kind enum
	interpret
	jit

-run-single-runnable-test failure[]^(
	path-to-crow string,
	path string,
	run-kind run-kind,
	overwrite-output bool,
) summon
	args string[] = match run-kind
	as interpret
		"run", path
	as jit
		"run", path, "--jit"
	res = path-to-crow spawn-and-wait-result args
	(path handle-output "{path}.out", res.format-output, overwrite-output),

-format-output string(a process-result)
	if a has-error
		exit-code = match a exit
		as exited x
			x
		as signaled x
			x
		"exit code: {exit-code != 0 && exit-code != 1 ? "big" : "{exit-code}"}\n{a format-stdout-stderr}"
	else
		a.stdout remove-colors

-format-stdout-stderr string(a process-result)
	stdout = a.stdout == "" ? "" : "stdout:\n{a.stdout remove-colors}"
	"{stdout}stderr:\n{a.stderr.remove-colors normalize-exceptions}"

-remove-colors string(a string)
	if pair ?= a try-split-once "\x1b"
		pair.a ~~ if pair2 ?= pair.b try-split-once "m"
			pair2.b remove-colors
	else
		a

# Interpreter has more exception info than JIT. Remove extra info so they are the same.
-normalize-exceptions string(a string)
	a update-lines line =>
		# TODO: use a function from parse.crow for this
		if rest ?= line try-remove-start "\tat "
			# Printed function names differ, so just take the name
			# (In JIT hyphens print as '__s', so don't take hyphens)
			name = rest take-while x => x is-letter
			normalized-name = if name == "pthread"
				""
			else
				name
			normalized-name == "" ? () : ("\tat {normalized-name}",)
		else
			line,

-update-lines string(a string, cb act string[](string))
	new-lines string[] = () join for line : a split "\n"
		cb[line]
	"\n" join new-lines

-is-letter bool(a char8)
	# TODO: support other alphabets
	"a"::char8.to::nat8 <= a.to && a.to::nat8 <= "z"::char8.to
