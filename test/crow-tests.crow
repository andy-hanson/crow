import
	crow/io/file: each-child-recursive
	crow/io/path: base-name, get-extension
	crow/io/print: out, print
	crow/io/process: exit-code, spawn-and-wait-result, stderr, stdout
	crow/version: is-windows
	./failure:
		failure, flat-map-with-max-size, handle-output, max-failures, match-test, new,
		overwrite-output, print-tests, test-options

run-crow-tests result<str, list failure>(path str, path-to-crow str, options test-options) summon
	tests = path list-tests options.match-test
	failures = tests flat-map-with-max-size options.max-failures, x =>
		path-to-crow run-single-crow-test x, options
	if failures is-empty
		"ran {tests size} tests in {path}" ok
	else
		failures err

.list-tests list str(path str, match-test str) summon
	res str mut[] = ()
	path each-child-recursive child =>
		if child contains-substr match-test && child.ext-is-crow && !child.is-excluded
			res ~= child
	res move-to-list

# Some tests have different output on Windows
.is-excluded bool(a str) trusted
	if is-windows
		a ends-with "/fail.crow" || a ends-with "/gc.crow"

.ext-is-crow bool(a str)
	if ext ?= a.base-name get-extension
		ext == "crow"

.run-single-crow-test list failure(path-to-crow str, path str, options test-options) summon trusted
	op list<failure>? = ("ast", "model")::list<str> find-and-get print-kind =>
		if options print-tests
			out print "crow print {print-kind} {path}"
		res = print-kind run-print-test path-to-crow, path, options.overwrite-output
		res.should-stop ? res.failures,
	if res ?= op
		res
	else
		if options print-tests
			out print "crow run {path}"
		interpret-failures = path-to-crow run-single-runnable-test path, interpret, options.overwrite-output
		if interpret-failures.is-empty && !is-windows
			path-to-crow run-single-runnable-test path, jit, options.overwrite-output
		else
			interpret-failures

.print-test-result record
	should-stop bool
	failures list failure

.run-print-test print-test-result(
	print-kind str,
	path-to-crow str,
	path str,
	overwrite-output bool,
) summon
	res = path-to-crow spawn-and-wait-result ("print", print-kind, path)
	output-path = "{path}.{print-kind}.json"
	# NOTE: compiler may have both stderr and stdout!
	output-failures list failure = if res.stdout.is-empty && res.exit-code != 0
		# Just have a file for the err
		()
	else
		path handle-output output-path, res.stdout, overwrite-output

	if !output-failures.is-empty
		true, output-failures
	elif res.exit-code == 0
		assert res.stderr == ""
		false, ()
	elif res.exit-code == 1
		stderr-no-color = res.stderr remove-colors
		# We should stop even if no test failure in handling the output
		true, (path handle-output "{output-path}.err", stderr-no-color, overwrite-output)
	else
		message = "unexpected exit code: {res exit-code}"
		true, ((path, message),)

run-kind enum
	interpret
	jit

.run-single-runnable-test list failure(
	path-to-crow str,
	path str,
	run-kind run-kind,
	overwrite-output bool,
) summon
	args list str = match run-kind
	as interpret
		"run", path
	as jit
		"run", path, "--jit"
	res = path-to-crow spawn-and-wait-result args
	stdout-failures = path handle-output "{path}.stdout", res.stdout, overwrite-output
	stderr-failures list failure = if res.exit-code != 0 || res.stderr != ""
		# Exceptions differ between interpreter and JIT
		err-path = if path ends-with "/fail.crow"
			match run-kind
			as interpret
				"{path}.stderr"
			as jit
				"{path}.jit.stderr"
		else
			"{path}.stderr"
		path handle-output err-path, res.stderr, overwrite-output
	stdout-failures ~~ stderr-failures

remove-colors str(a str)
	if pair ?= a try-split-once "\x1b"
		pair.a ~~ if pair2 ?= pair.b try-split-once "m"
			pair2.b remove-colors
	else
		a
