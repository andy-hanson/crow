import
	crow/io/file: each-child-recursive
	crow/io/path: base-name, get-extension
	crow/io/print: out, print
	crow/io/process: exit-code, process-result, spawn-and-wait-result, stderr, stdout
	crow/version: is-windows
	./failure:
		failure, flat-map-with-max-size, handle-output, max-failures, match-test,
		overwrite-output, print-tests, test-options, test-result

run-crow-tests test-result^(path string, path-to-crow string, options test-options) summon
	tests = path list-tests options.match-test
	failures <- tests flat-map-with-max-size options.max-failures, x =>
		path-to-crow run-single-crow-test x, options
	if failures is-empty
		"ran {tests size} tests in {path}".ok,
	else
		failures.err,

-list-tests string[](path string, match-test string) summon
	res string mut[] = ()
	path each-child-recursive child =>
		if child contains-seq match-test && child.ext-is-crow && !child.is-excluded
			res ~= child
	res move-to

# Some tests have different output on Windows
-is-excluded bool(a string)
	if trusted is-windows
		a ends-with "/fail.crow" || a ends-with "/gc.crow"

-ext-is-crow bool(a string)
	if ext ?= a.base-name get-extension
		ext == "crow"

-run-single-crow-test failure[]^(path-to-crow string, path string, options test-options) summon
	if options print-tests
		out print "crow run {path}"
	interpret-failures <- path-to-crow run-single-runnable-test path, interpret, options.overwrite-output
	if interpret-failures.is-empty && !(trusted is-windows)
		path-to-crow run-single-runnable-test path, jit, options.overwrite-output
	else
		interpret-failures,

run-kind enum
	interpret
	jit

-run-single-runnable-test failure[]^(
	path-to-crow string,
	path string,
	run-kind run-kind,
	overwrite-output bool,
) summon
	args string[] = match run-kind
	as interpret
		"run", path
	as jit
		"run", path, "--jit"
	res = path-to-crow spawn-and-wait-result args
	# Exceptions differ between interpreter and JIT
	out-path = if path ends-with "/fail.crow"
		match run-kind
		as interpret
			"{path}.interpret.out"
		as jit
			"{path}.jit.out"
	else
		"{path}.out"
	(path handle-output out-path, res.format-output, overwrite-output),

format-output string(a process-result)
	if a.exit-code == 0 && a.stderr == ""
		a.stdout remove-colors
	else
		stdout = a.stdout == "" ? "" : "stdout:\n{a.stdout remove-colors}"
		"exit code: {a exit-code}\n{stdout}stderr:\n{a.stderr remove-colors}"

remove-colors string(a string)
	if pair ?= a try-split-once "\x1b"
		pair.a ~~ if pair2 ?= pair.b try-split-once "m"
			pair2.b remove-colors
	else
		a
