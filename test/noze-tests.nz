import io .failure .path-utils

run-noze-tests result str arr<failure>(path str, path-to-noze str, env environ, options test-options) summon
	tests = path list-tests
	failures = tests flat-map-with-max-size options.max-failures, \test
		path-to-noze run-single-noze-test env, test, options
	when
		failures has?
			failures err
		else
			ok: "ran " + tests.size.to-str + " tests in " + path

private

list-tests arr str(path str) summon
	res = new-mut-arr<str>
	filter = as<fun-mut1<bool, str>>: \s
		true
	path each-child-recursive filter, \child
		match child.base-name.get-extension
			none
				pass
			some s
				s.value == "nz" if (res push child), pass
	res freeze

run-single-noze-test arr failure
	path-to-noze str
	env environ
	path str
	options test-options
spec
	summon
body
	op = (new-arr<str> "ast", "model", "concrete-model", "low-model") first-some<arr<failure>, str> \print-kind
		options.print-tests? if ("noze print " + print-kind + " " + path print-sync), pass
		res = print-kind run-print-test path-to-noze, env, path, options.overwrite-output?
		res.should-stop? if res.failures.some, none
	match op
		none
			options.print-tests? if ("noze run " + path print-sync), pass
			path-to-noze run-single-runnable-test env, path, options.overwrite-output?
		some s
			s value


print-test-result record
	should-stop? bool
	failures arr failure

run-print-test print-test-result
	print-kind str
	path-to-noze str
	env environ
	path str
	overwrite-output? bool
spec
	summon
body
	res = path-to-noze spawn-and-wait-result (new-arr "print", print-kind, path), env
	output-path = path + "." + print-kind + ".tata"
	| NOTE: compiler may have both stderr and stdout!
	output-failures = when
		res.stdout.empty? and: res.exit-code != 0
			| Just have a file for the err
			empty-arr<failure>
		else
			path handle-output output-path, res.stdout, overwrite-output?
	when
		output-failures.empty? not
			new true, output-failures
		res.exit-code == 0
			| TODO: test failure for this
			assert: res.stderr == ""
			new false, empty-arr
		res.exit-code == 1
			stderr-no-color = res.stderr remove-colors
			| We should stop even if no test failure in handling the output
			new true, handle-output: path, (output-path + ".err"), stderr-no-color, overwrite-output?
		else
			message = "unexpected exit code: " + res.exit-code.to-str
			new true, new-arr new path, message

run-single-runnable-test arr failure
	path-to-noze str
	env environ
	path str
	overwrite-output? bool
spec
	summon
body
	res = path-to-noze spawn-and-wait-result (new-arr "run", path), env
	when
		res.exit-code == 0 and: res.stderr == ""
			path handle-output (path + ".stdout"), res.stdout, overwrite-output?
		else
			message = "status: " + res.exit-code.to-str + "\nstdout:\n" + res.stdout + "stderr:\n" + res.stderr
			new-arr new path, message

remove-colors str(s str)
	out = new-mut-arr<char>
	s remove-colors-recur out
	out freeze

remove-colors-recur void(s str, out mut-str)
	when
		s empty?
			pass
		s.first == "\x1b"
			s.tail remove-colors-recur-2 out
		else
			out push s.first
			s.tail remove-colors-recur out

remove-colors-recur-2 void(s str, out mut-str)
	when
		s empty?
			pass
		s.first == "m"
			s.tail remove-colors-recur out
		else
			s.tail remove-colors-recur-2 out
