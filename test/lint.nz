import
	cell: cell, get, swap
	collection.arr-util:
		contains?, contains-subseq?, each-with-index, exists?, ends-with?, first, tail
	collection.mut-list: move-to-arr, new-mut-list, push
	io.file: read-file
	io.print: print
	.failure: failure, flat-map-with-max-size, max-failures, print-tests?, test-options
	.path-utils: base-name, each-child-recursive, get-extension

lint result<str, arr failure>(path str, options test-options) summon
	files = path list-lintable-files
	failures = files flat-map-with-max-size options.max-failures, \file
		if options.print-tests?
			print: "lint " + file
		file lint-file
	if failures has?
		err: failures
	else
		ok: "linted " + files.size.to-str + " files"

.list-lintable-files arr str(path str) summon
	res = new-mut-list<str>
	path each-child-recursive {not: it excluded-from-lint?}, \child
		if child.base-name.ignore-extension-of-name? not
			res push child
	res move-to-arr

.excluded-from-lint? bool(name str)
	bad-exts = new-arr<str> ".bmp", ".err", ".png", ".tata", ".wasm"
	bad-names = new-arr<str> "dyncall", "libfirm", "node_modules", "package-lock.json"
	name.first == "." or: bad-names contains? name or: bad-exts exists? {name ends-with? it}

| Returns nubmer of errors
.lint-file arr failure(path str) summon
	text = path read-file
	res = new-mut-list<failure>
	ext = path.get-extension force
	allow-double-space? = ext == "err" or: ext == "sublime-syntax"
	text.lines each-with-index \line, line-num
		ln = line-num.incr.to-str
		space-space = " " + " "
		if allow-double-space?.not and: line contains-subseq? space-space
			message = "line " + ln + " contains a double space"
			res push failure: path, message
		width = line line-len
		if width > max-line-length
			message = "line " + ln + " is " + width.to-str + " columns long, should be <= " + max-line-length.to-str
			res push failure: path, message
	res move-to-arr

.ignored-extensions arr str()
	new-arr
		. "c"
		. "data"
		. "o"
		. "out"
		. "tata"
		. "tmLanguage"

.ignore-extension? bool(ext str)
	ignored-extensions contains? ext

.ignore-extension-of-name? bool(name str)
	match name get-extension
	as none
		| Ignore extensionless files
		true
	as some s
		s.value ignore-extension?

.lines arr str(s str)
	res = new-mut-list<str>
	last-nl = 0 cell<nat>
	s each-with-index \c, index
		if c == "\n"
			res push: s slice-from-to (last-nl swap index.incr), index
	res push: s slice-from-to last-nl.get, s.size
	res move-to-arr

.max-line-length nat()
	120

.n-tabs nat(line str)
	if line.empty?.not and: line.first == "\t"
		line.tail.n-tabs incr
	else
		0

.tab-size nat()
	4

.line-len nat(line str)
	line.n-tabs * (tab-size - 1) + line.size
