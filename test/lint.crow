import
	cell: cell, swap, subscript
	collection.arr-util:
		contains?, contains-subseq?, each-with-index, exists?, ends-with?, first, tail
	collection.mut-list: ~=, move-to-arr!, mut-list
	io.file: read-file
	io.print: print
	path: base-name, each-child-recursive, get-extension
	.failure: failure, flat-map-with-max-size, max-failures, print-tests?, test-options

lint result<str, arr failure>(path str, options test-options) summon
	files = path list-lintable-files
	failures = files flat-map-with-max-size options.max-failures, \file
		if options.print-tests?
			print: "lint " ~ file
		file lint-file
	if failures has?
		err: failures
	else
		ok: "linted " ~ files.size.to-str ~ " files"

.list-lintable-files arr str(path str) summon
	res = mut-list<str>
	path each-child-recursive {not: it excluded-from-lint?}, \child
		if child.base-name.ignore-extension-of-name? not
			res ~= child
	res move-to-arr!

.excluded-from-lint? bool(name str)
	bad-exts = [".bmp", ".err", ".html", ".png", ".repr", ".svg", ".ttf", ".wasm", ".xz"]
	bad-names = ["dyncall", "libfirm", "node_modules", "package-lock.json"]
	name.first == "." or: bad-names contains? name or: bad-exts exists? {name ends-with? it}

# Returns numner of errors
.lint-file arr failure(path str) summon
	text = path read-file
	res = mut-list<failure>
	ext = path.get-extension force
	allow-double-space? = ext == "err" or: ext == "sublime-syntax"
	text.lines each-with-index \line, line-num
		ln = line-num + 1 to-str
		space-space = " " ~ " "
		if allow-double-space?.not and: line contains-subseq? space-space
			message = "line " ~ ln ~ " contains a double space"
			res ~=: failure: path, message
		width = line line-len
		if width > max-line-length
			message = "line " ~ ln ~ " is " ~ width.to-str ~ " columns long, should be <= " ~ max-line-length.to-str
			res ~=: failure: path, message
	res move-to-arr!

.ignored-extensions arr str()
	["c", "data", "o", "out", "repr", "tmLanguage"]

.ignore-extension? bool(ext str)
	ignored-extensions contains? ext

.ignore-extension-of-name? bool(name str)
	match name get-extension
	as none
		# Ignore extensionless files
		true
	as some s
		s.value ignore-extension?

.lines arr str(s str)
	res = mut-list<str>
	last-nl = 0 cell<nat>
	s each-with-index \c, index
		if c == "\n"
			nl = last-nl swap index + 1
			res ~= s[nl -> index]
	res ~= s[last-nl[] -> s.size]
	res move-to-arr!

.max-line-length nat()
	120

.n-tabs nat(line str)
	if line.empty?.not and: line.first == "\t"
		line.tail.n-tabs + 1
	else
		0

.tab-size nat()
	4

.line-len nat(line str)
	line.n-tabs * (tab-size - 1) + line.size
