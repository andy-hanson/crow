#include <math.h> // for e.g. 'sin'
#include <stddef.h> // for NULL
#include <stdint.h>
typedef uint32_t char32_t;

#pragma section(".text")
__declspec(allocate(".text"))
static unsigned char switch_fiber_code[] = {
	// https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention
	// "The x64 ABI considers registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-XMM15 nonvolatile."
	// "They must be saved and restored by a function that uses them."
	// 'from' is rcx, 'to' is rdx
	0x53, // push rbx
	0x55, // push rbp
	0x56, // push rsi
	0x57, // push rdi
	0x41, 0x54, // push r12
	0x41, 0x55, // push r13
	0x41, 0x56, // push r14
	0x41, 0x57, // push r15
	// TODO: XMM6-XMM15 ------------------------------------------------------------------------------------------------------------
	// MASM moves from the second argument to the first argument
	0x48, 0x89, 0x21, // mov [rcx], rsp
	0x48, 0x8b, 0xe2, // mov rsp, rdx
	0x41, 0x5f, // pop r15
	0x41, 0x5e, // pop r14
	0x41, 0x5d, // pop r13
	0x41, 0x5c, // pop r12
	0x5f, // pop rdi
	0x5e, // pop rsi
	0x5d, // pop rbp
	0x5b, // pop rbx
	0xc3, // ret
};
#define switch_fiber(from, to) ((void (*)(uint64_t**, uint64_t*)) switch_fiber_code)(from, to)

#pragma section(".text")
__declspec(allocate(".text"))
static unsigned char switch_fiber_initial_code[] = {
	// fiber = rcx, from = rdx, stack_high = r8, func = r9
	// First part is identical to switch_fiber (but argument registers are different)
	// Note: We just leave 'fiber' alone, since it is the first argument to 'func'
	0x53, // push rbx
	0x55, // push rbp
	0x56, // push rsi
	0x57, // push rdi
	0x41, 0x54, // push r12
	0x41, 0x55, // push r13
	0x41, 0x56, // push r14
	0x41, 0x57, // push r15
	0x48, 0x89, 0x22, // mov [rdx], rsp
	0x49, 0x8B, 0xE0, // mov rsp, r8

	// Optimized builds on Windows apparently need extra space (TODO: but I think it was 64 bytes, not 64 words)
	0x48, 0x81, 0xec, 0x00, 0x02, 0x00, 0x00, // sub rsp, 0x200
	// Make it so 'ret' will return to 'func'
	0x4C, 0x89, 0x0C, 0x24, // mov [rsp], r9
	0xC3 // ret
};
struct fiber;
#define switch_fiber_initial(fiber_arg, from, stack_high, func) ((void (*)(struct fiber*, uint64_t**, uint64_t*, void (*)(struct fiber*))) switch_fiber_initial_code)(fiber_arg, from, stack_high, func);

static uint64_t* init_stack(uint64_t* stack_low, uint64_t* stack_top, void* fiber, void (*target)()) {
	// For optimized builds on Windows, it apparently uses up to 0x40 bytes *beyond* the initial pointer.
	stack_top -= 0x40;
	stack_top[-2] = (uint64_t) target; // Use -2 because we want it 16-byte aligned
	// It will pop garbage initial values for r15, r14, r13, r12, rdi, rsi, rbp, rbx, then return to 'target'
	return stack_top - 10;
}

#pragma section(".text")
__declspec(allocate(".text"))
static unsigned char setup_catch_code[] = {
	0x48, 0x89, 0x19, // mov [rcx], rbx
	0x48, 0x89, 0x69, 0x08, // mov [rcx + 0x08], rbp
	0x48, 0x89, 0x71, 0x10, // mov [rcx + 0x10], rsi
	0x48, 0x89, 0x79, 0x18, // mov [rcx + 0x18], rdi
	0x4c, 0x89, 0x61, 0x20, // mov [rcx + 0x20], r12
	0x4c, 0x89, 0x69, 0x28, // mov [rcx + 0x28], r13
	0x4c, 0x89, 0x71, 0x30, // mov [rcx + 0x30], r14
	0x4c, 0x89, 0x79, 0x38, // mov [rcx + 0x38], r15
	0x48, 0x89, 0x61, 0x40, // mov [rcx + 0x40], rsp
	0x48, 0x8b, 0x04, 0x24, // mov rax, [rsp]
	0x48, 0x89, 0x41, 0x48, // mov [rcx + 0x48], rax
	0x0f, 0x29, 0x71, 0x50, // movaps [rcx + 0x50], xmm6
	0x0f, 0x29, 0x79, 0x60, // movaps [rcx + 0x60], xmm7
	0x44, 0x0f, 0x29, 0x41, 0x70, //movaps [rcx + 0x70], xmm8
	0x44, 0x0f, 0x29, 0x89, 0x80, 0x00, 0x00, 0x00, // movaps [rcx + 0x80], xmm9
	0x44, 0x0f, 0x29, 0x91, 0x90, 0x00, 0x00, 0x00, // movaps [rcx + 0x90], xmm10
	0x44, 0x0f, 0x29, 0x99, 0xa0, 0x00, 0x00, 0x00, // movaps [rcx + 0xa0], xmm11
	0x44, 0x0f, 0x29, 0xa1, 0xb0, 0x00, 0x00, 0x00, // movaps [rcx + 0xb0], xmm12
	0x44, 0x0f, 0x29, 0xa9, 0xc0, 0x00, 0x00, 0x00, // movaps [rcx + 0xc0], xmm13
	0x44, 0x0f, 0x29, 0xb1, 0xd0, 0x00, 0x00, 0x00, // movaps [rcx + 0xd0], xmm14
	0x44, 0x0f, 0x29, 0xb9, 0xe0, 0x00, 0x00, 0x00, // movaps [rcx + 0xe0], xmm15
	0x32, 0xc0, // xor al,al
	0xc3, // ret
};
#define setup_catch(arg) ((_Bool (*)(void*)) setup_catch_code)(arg);

#pragma section(".text")
__declspec(allocate(".text"))
static unsigned char jump_to_catch_code[] = {
	// arg is rcx
	// TOOD: use lower case hex numbers ------------------------------------------------------------------------------------------------
	0x48, 0x8B, 0x19, // mov rbx, [rcx]
	0x48, 0x8B, 0x69, 0x08, // mov rbp, [rcx + 0x08]
	0x48, 0x8B, 0x71, 0x10, // mov rsi, [rcx + 0x10]
	0x48, 0x8B, 0x79, 0x18, // mov rdi, [rcx + 0x18]
	0x4C, 0x8B, 0x61, 0x20, // mov r12, [rcx + 0x20]
	0x4C, 0x8B, 0x69, 0x28, // mov r13, [rcx + 0x28]
	0x4C, 0x8B, 0x71, 0x30, // mov r14, [rcx + 0x30]
	0x4C, 0x8B, 0x79, 0x38, // mov r15, [rcx + 0x38]
	0x48, 0x8B, 0x61, 0x40, // mov rsp, [rcx + 0x40]
	0x48, 0x8b, 0x41, 0x48, // mov rax, [rcx + 0x48]
	0x48, 0x89, 0x04, 0x24, // mov [rsp], rax
	0x0f, 0x28, 0x71, 0x50, // movaps xmm6, [rcx + 0x50]
	0x0F, 0x28, 0x79, 0x60, // movaps xmm7, [rcx + 0x60]
	0x44, 0x0F, 0x28, 0x41, 0x70, // movaps xmm8, [rcx + 0x70] 
	0x44, 0x0F, 0x28, 0x89, 0x80, 0x00, 0x00, 0x00, // movaps xmm9,  [rcx + 0x80]
	0x44, 0x0F, 0x28, 0x91, 0x90, 0x00, 0x00, 0x00, // movaps xmm10, [rcx + 0x90] 
	0x44, 0x0F, 0x28, 0x99, 0xA0, 0x00, 0x00, 0x00, // movaps xmm11, [rcx + 0xa0]
	0x44, 0x0F, 0x28, 0xA1, 0xB0, 0x00, 0x00, 0x00, // movaps xmm12, [rcx + 0xb0] 
	0x44, 0x0F, 0x28, 0xA9, 0xC0, 0x00, 0x00, 0x00, // movaps xmm13, [rcx + 0xc0]
	0x44, 0x0F, 0x28, 0xB1, 0xD0, 0x00, 0x00, 0x00, // movaps xmm14, [rcx + 0xd0] 
	0x44, 0x0F, 0x28, 0xB9, 0xE0, 0x00, 0x00, 0x00, // movaps xmm15, [rcx + 0xe0]
	0xB0, 0x01, // mov al, 1
	0xc3, // ret
	// TODO: TRY: 0xff, 0x61, 0x48, // jmp qword ptr [rcx + 0x48] -------------------------------------------------------------------------------------------
};
#define jump_to_catch(arg) ((void (*)(void*)) jump_to_catch_code)(arg)

extern int TlsAlloc();
extern void* TlsGetValue(int index);
extern _Bool TlsSetValue(int index, void* value);

static int THREAD_LOCALS_INDEX;
static struct ThreadLocals* threadLocals() {
	return TlsGetValue(THREAD_LOCALS_INDEX);
}
