module document.document;

@safe @nogc pure nothrow:

import model.model :
	body_,
	FieldMutability,
	FunDecl,
	generated,
	matchSpecBody,
	matchStructBody,
	matchStructOrAlias,
	matchType,
	Module,
	name,
	NameReferents,
	Param,
	params,
	paramsArray,
	Program,
	RecordField,
	returnType,
	Sig,
	SpecBody,
	SpecDecl,
	StructAlias,
	StructBody,
	StructDecl,
	StructInst,
	StructOrAlias,
	target,
	Type,
	typeArgs,
	TypeParam,
	typeParams,
	UnionMember;
import util.alloc.alloc : Alloc;
import util.col.arr : empty, only;
import util.col.arrUtil : findIndex;
import util.col.dict : dictEach;
import util.col.fullIndexDict : fullIndexDictGet;
import util.col.str : SafeCStr, strOfSafeCStr;
import util.opt : force, has, Opt;
import util.path : AllPaths, eachPathPart, nPathComponents, Path;
import util.ptr : Ptr, ptrTrustMe_mut;
import util.sym : AllSymbols, hashSym, Sym, symEq, writeSym;
import util.util : todo, unreachable;
import util.writer : finishWriter, Writer, writeChar, writeStatic, writeStr, writeWithCommas;

immutable(string) document(
	ref Alloc alloc,
	ref const AllSymbols allSymbols,
	ref const AllPaths allPaths,
	ref immutable Program p,
	ref immutable Module a,
) {
	Writer writer = Writer(ptrTrustMe_mut(alloc));

	writeStatic(writer, "// generated by `crow doc`\n");
	immutable Path path = fullIndexDictGet(p.filesInfo.filePaths, a.fileIndex).path;
	writeStatic(writer, "include ");
	foreach (immutable uint i; 0 .. nPathComponents(allPaths, path))
		writeStatic(writer, "../");
	writeStatic(writer, "pug-include/documentation.pug\n");
	writeStatic(writer, "+documentationPage(\"");
	writeModulePath(writer, allSymbols, allPaths, path);
	writeStatic(writer, "\")\n");
	writeStatic(writer, "\tsection");
	dictEach!(Sym, NameReferents, symEq, hashSym)(
		a.allExportedNames,
		(immutable(Sym), ref immutable NameReferents referents) {
			if (has(referents.structOrAlias))
				writeStructOrAlias(writer, allSymbols, force(referents.structOrAlias));
			if (has(referents.spec))
				writeSpec(writer, allSymbols, force(referents.spec).deref());
			foreach (immutable Ptr!FunDecl fun; referents.funs)
				if (!fun.deref().generated)
					writeFun(writer, allSymbols, fun.deref());
		});
	writeStatic(writer, "\n");
	return finishWriter(writer);
}

private:

void writeModulePath(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref const AllPaths allPaths,
	immutable Path path,
) {
	bool first = true;
	//TODO:just use pathToStr?
	eachPathPart(allPaths, path, (immutable Sym part) {
		if (first)
			first = false;
		else
			writeChar(writer, '/');
		writeSym(writer, allSymbols, part);
	});
}

void writeStructOrAlias(ref Writer writer, ref const AllSymbols allSymbols, ref immutable StructOrAlias a) {
	matchStructOrAlias!(
		void,
		(ref immutable StructAlias it) {
			writeStructAlias(writer, allSymbols, it);
		},
		(ref immutable StructDecl it) {
			writeStructDecl(writer, allSymbols, it);
		},
	)(a);
}

void writeStructAlias(ref Writer writer, ref const AllSymbols allSymbols, ref immutable StructAlias a) {
	writeStatic(writer, "\n\t\t+alias(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", ");
	immutable Opt!(Ptr!StructInst) optTarget = target(a);
	writeQuotedType(writer, allSymbols, immutable Type(force(optTarget)));
	writeChar(writer, ')');
	writeDocComment(writer, a.docComment);
}

void writeStructDecl(ref Writer writer, ref const AllSymbols allSymbols, ref immutable StructDecl a) {
	matchStructBody!(
		void,
		(ref immutable(StructBody.Bogus)) {
			unreachable!void();
		},
		(ref immutable(StructBody.Builtin)) {
			writeStatic(writer, "\n\t\t+builtinType(");
			writeQuotedSym(writer, allSymbols, a.name);
			writeTypeParams(writer, allSymbols, typeParams(a));
			writeStatic(writer, ")");
		},
		(ref immutable StructBody.Enum it) {
			writeEnum(writer, allSymbols, a, it);
		},
		(ref immutable(StructBody.Flags)) {
			todo!void("!");
		},
		(ref immutable(StructBody.ExternPtr)) {
			writeStatic(writer, "\n\t\t+externPtrType(");
			writeQuotedSym(writer, allSymbols, a.name);
			writeTypeParams(writer, allSymbols, typeParams(a));
			writeStatic(writer, ")");
		},
		(ref immutable StructBody.Record it) {
			writeRecord(writer, allSymbols, a, it);
		},
		(ref immutable StructBody.Union it) {
			writeUnion(writer, allSymbols, a, it);
		},
	)(body_(a));
	writeDocComment(writer, a.docComment);
}

void writeEnum(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref immutable StructDecl a,
	ref immutable StructBody.Enum e,
) {
	writeStatic(writer, "\n\t\t+enum(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeStatic(writer, ", [");
	writeWithCommas!(StructBody.Enum.Member)(writer, e.members, (ref immutable StructBody.Enum.Member member) {
		writeQuotedSym(writer, allSymbols, member.name);
	});
	writeStatic(writer, "])");
}

void writeRecord(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref immutable StructDecl a,
	ref immutable StructBody.Record r,
) {
	writeStatic(writer, "\n\t\t+record(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", [");
	writeWithCommas!RecordField(writer, r.fields, (ref immutable RecordField field) {
		writeChar(writer, '[');
		writeQuotedSym(writer, allSymbols, field.name);
		writeStatic(writer, ", ");
		writeQuotedType(writer, allSymbols, field.type);
		final switch (field.mutability) {
			case FieldMutability.const_:
				break;
			case FieldMutability.private_:
				writeStatic(writer, ", \".mut\"");
				break;
			case FieldMutability.public_:
				writeStatic(writer, ", \"mut\"");
				break;
		}
		writeChar(writer, ']');
	});
	writeStatic(writer, "])");
}

void writeUnion(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref immutable StructDecl a,
	ref immutable StructBody.Union u,
) {
	writeStatic(writer, "\n\t\t+union(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", [");
	writeWithCommas!UnionMember(writer, u.members, (ref immutable UnionMember member) {
		writeChar(writer, '[');
		writeQuotedSym(writer, allSymbols, member.name);
		writeStatic(writer, ", ");
		if (has(member.type))
			writeQuotedType(writer, allSymbols, force(member.type));
		else
			writeStatic(writer, "null");
		writeChar(writer, ']');
	});
	writeStatic(writer, "])");
}

void writeSpec(ref Writer writer, ref const AllSymbols allSymbols, ref immutable SpecDecl a) {
	writeStatic(writer, "\n\t\t+spec(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", ");
	matchSpecBody!(
		void,
		(ref immutable SpecBody.Builtin) {
			writeStatic(writer, "\"builtin\"");
		},
		(ref immutable Sig[] sigs) {
			writeStatic(writer, "\"TODO:WRITE SIGS\"");
			cast(void) sigs;
		},
	)(a.body_);
	writeStatic(writer, ")");
	writeDocComment(writer, a.docComment);
}

void writeFun(ref Writer writer, ref const AllSymbols allSymbols, ref immutable FunDecl a) {
	writeStatic(writer, "\n\t\t+function(");
	writeQuotedSym(writer, allSymbols, name(a));
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", ");
	writeQuotedType(writer, allSymbols, returnType(a));
	writeStatic(writer, ", [");
	//TODO: handle variadic
	writeWithCommas!Param(writer, paramsArray(params(a)), (ref immutable Param it) {
		writeChar(writer, '[');
		writeQuotedOptSym(writer, allSymbols, it.name);
		writeStatic(writer, ", ");
		writeQuotedType(writer, allSymbols, it.type);
		writeChar(writer, ']');
	});
	writeStatic(writer, "])");
	writeDocComment(writer, a.docComment);
}

void writeDocComment(ref Writer writer, immutable SafeCStr comment) {
	immutable string str = strOfSafeCStr(comment);
	if (!empty(str)) {
		// Comment may contain newlines!
		eachLine(str, (immutable string line) {
			writeStatic(writer, "\n\t\t\t|");
			writeStr(writer, line);
		});
	}
}

void writeQuotedOptSym(ref Writer writer, ref const AllSymbols allSymbols, ref immutable Opt!Sym a) {
	if (has(a))
		writeQuotedSym(writer, allSymbols, force(a));
	else
		writeStatic(writer, "\"_\"");
}

void writeQuotedSym(ref Writer writer, ref const AllSymbols allSymbols, immutable Sym a) {
	writeChar(writer, '\"');
	writeSym(writer, allSymbols, a);
	writeChar(writer, '\"');
}

void writeQuotedType(ref Writer writer, ref const AllSymbols allSymbols, immutable Type a) {
	writeChar(writer, '\"');
	writeType(writer, allSymbols, a);
	writeChar(writer, '\"');
}

void writeType(ref Writer writer, ref const AllSymbols allSymbols, immutable Type a) {
	matchType!(
		void,
		(immutable Type.Bogus) {
			unreachable!void();
		},
		(immutable Ptr!TypeParam it) {
			writeSym(writer, allSymbols, it.deref().name);
		},
		(immutable Ptr!StructInst it) {
			writeSym(writer, allSymbols, it.deref().name);
			immutable Type[] typeArgs = typeArgs(it.deref());
			if (!empty(typeArgs)) {
				if (typeArgs.length == 1) {
					writeChar(writer, ' ');
					writeType(writer, allSymbols, only(typeArgs));
				} else {
					writeChar(writer, '<');
					writeWithCommas!Type(writer, typeArgs, (ref immutable Type t) {
						writeType(writer, allSymbols, t);
					});
					writeChar(writer, '>');
				}
			}
		},
	)(a);
}

void writeTypeParams(ref Writer writer, ref const AllSymbols allSymbols, immutable TypeParam[] typeParams) {
	writeStatic(writer, ", ");
	if (empty(typeParams))
		writeStatic(writer, "[]");
	else {
		writeChar(writer, '[');
		writeWithCommas!TypeParam(writer, typeParams, (ref immutable TypeParam it) {
			writeStatic(writer, "\"?");
			writeSym(writer, allSymbols, it.name);
			writeChar(writer, '"');
		});
		writeChar(writer, ']');
	}
}

void eachLine(
	immutable string a,
	scope void delegate(immutable string) @safe @nogc pure nothrow cb
) {
	immutable Opt!size_t index = findIndex!char(a, (ref immutable char c) => c == '\n');
	if (has(index)) {
		cb(a[0..force(index)]);
		eachLine(a[force(index)+1 .. $], cb);
	} else
		cb(a);
}
