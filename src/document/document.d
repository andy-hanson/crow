module document.document;

@safe @nogc pure nothrow:

import frontend.lang : crowExtension;
import model.model :
	body_,
	FieldMutability,
	FunDecl,
	generated,
	matchSpecBody,
	matchStructBody,
	matchStructOrAlias,
	matchType,
	Module,
	name,
	NameReferents,
	Param,
	params,
	paramsArray,
	Program,
	RecordField,
	returnType,
	Sig,
	SpecBody,
	SpecDecl,
	StructAlias,
	StructBody,
	StructDecl,
	StructInst,
	StructOrAlias,
	target,
	Type,
	typeArgs,
	TypeParam,
	typeParams,
	UnionMember;
import util.alloc.alloc : Alloc;
import util.col.arr : empty, only;
import util.col.arrBuilder : add, ArrBuilder, finishArr;
import util.col.arrUtil : findIndex;
import util.col.dict : dictEach;
import util.col.fullIndexDict : fullIndexDictGet;
import util.col.str : SafeCStr, safeCStr, safeCStrIsEmpty, strOfSafeCStr;
import util.opt : force, has, Opt;
import util.path : AllPaths, eachPathPart, nPathComponents, Path, pathToStr;
import util.ptr : Ptr, ptrTrustMe_mut;
import util.repr : jsonStrOfRepr, NameAndRepr, nameAndRepr, Repr, reprArr, reprNamedRecord, reprStr, reprSym;
import util.sym : AllSymbols, hashSym, shortSym, Sym, symEq, writeSym;
import util.util : todo, unreachable, verify;
import util.writer : finishWriterToSafeCStr, Writer, writeChar, writeStatic, writeStr, writeWithCommas;

immutable(SafeCStr) documentPug(
	ref Alloc alloc,
	ref const AllSymbols allSymbols,
	ref const AllPaths allPaths,
	ref immutable Program program,
	ref immutable Module a,
) {
	Writer writer = Writer(ptrTrustMe_mut(alloc));

	writeStatic(writer, "// generated by `crow doc`\n");
	immutable Path path = fullIndexDictGet(program.filesInfo.filePaths, a.fileIndex).path;
	writeStatic(writer, "include ");
	foreach (immutable uint i; 0 .. nPathComponents(allPaths, path))
		writeStatic(writer, "../");
	writeStatic(writer, "pug-include/documentation.pug\n");
	writeStatic(writer, "+documentationPage(\"");
	writeModulePath(writer, allSymbols, allPaths, path);
	writeStatic(writer, "\")\n");
	writeStatic(writer, "\tsection");
	dictEach!(Sym, NameReferents, symEq, hashSym)(
		a.allExportedNames,
		(immutable(Sym), ref immutable NameReferents referents) {
			if (has(referents.structOrAlias))
				writeStructOrAlias(writer, allSymbols, force(referents.structOrAlias));
			if (has(referents.spec))
				writeSpec(writer, allSymbols, force(referents.spec).deref());
			foreach (immutable Ptr!FunDecl fun; referents.funs)
				if (!fun.deref().generated)
					writeFun(writer, allSymbols, fun.deref());
		});
	writeStatic(writer, "\n");
	return finishWriterToSafeCStr(writer);
}

immutable(SafeCStr) documentJSON(
	ref Alloc alloc,
	ref const AllSymbols allSymbols,
	ref const AllPaths allPaths,
	ref immutable Program program,
	ref immutable Module a,
) {
	return jsonStrOfRepr(alloc, allSymbols, documentModule(alloc, allSymbols, allPaths, program, a));
}

private:

immutable(Repr) documentModule(
	ref Alloc alloc,
	ref const AllSymbols allSymbols,
	ref const AllPaths allPaths,
	ref immutable Program program,
	ref immutable Module a,
) {
	immutable Path path = fullIndexDictGet(program.filesInfo.filePaths, a.fileIndex).path;
	immutable string pathStr = pathToStr(alloc, allPaths, safeCStr!"", path, crowExtension);
	ArrBuilder!Repr exports;
	dictEach!(Sym, NameReferents, symEq, hashSym)(
		a.allExportedNames,
		(immutable(Sym), ref immutable NameReferents referents) {
			if (has(referents.structOrAlias))
				add(alloc, exports, documentStructOrAlias(alloc, force(referents.structOrAlias)));
			if (has(referents.spec))
				add(alloc, exports, documentSpec(alloc, force(referents.spec).deref()));
			foreach (immutable Ptr!FunDecl fun; referents.funs)
				if (!fun.deref().generated)
					add(alloc, exports, documentFun(alloc, fun.deref()));
		});
	return reprNamedRecord(alloc, "module", [
		nameAndRepr("path", reprStr(pathStr)),
		nameAndRepr("exports", reprArr(finishArr(alloc, exports)))]);
}

void writeModulePath(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref const AllPaths allPaths,
	immutable Path path,
) {
	bool first = true;
	//TODO:just use pathToStr?
	eachPathPart(allPaths, path, (immutable Sym part) {
		if (first)
			first = false;
		else
			writeChar(writer, '/');
		writeSym(writer, allSymbols, part);
	});
}

immutable(Repr) documentStructOrAlias(ref Alloc alloc, immutable StructOrAlias a) {
	return matchStructOrAlias!(immutable Repr)(
		a,
		(ref immutable StructAlias x) =>
			documentStructAlias(alloc, x),
		(ref immutable StructDecl x) =>
			documentStructDecl(alloc, x));
}

void writeStructOrAlias(ref Writer writer, ref const AllSymbols allSymbols, ref immutable StructOrAlias a) {
	matchStructOrAlias!void(
		a,
		(ref immutable StructAlias it) {
			writeStructAlias(writer, allSymbols, it);
		},
		(ref immutable StructDecl it) {
			writeStructDecl(writer, allSymbols, it);
		});
}

immutable(Repr) documentStructAlias(ref Alloc alloc, ref immutable StructAlias a) {
	immutable Opt!(Ptr!StructInst) optTarget = target(a);
	return reprNamedRecord(alloc, "alias", [
		nameAndRepr("name", reprSym(a.name)),
		nameAndRepr("type-params", documentTypeParams(alloc, typeParams(a))),
		nameAndRepr("target", documentStructInst(alloc, force(optTarget).deref())),
		nameAndRepr("comment", reprStr(a.docComment))]);

}

void writeStructAlias(ref Writer writer, ref const AllSymbols allSymbols, ref immutable StructAlias a) {
	writeStatic(writer, "\n\t\t+alias(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", ");
	immutable Opt!(Ptr!StructInst) optTarget = target(a);
	writeQuotedType(writer, allSymbols, immutable Type(force(optTarget)));
	writeChar(writer, ')');
	writeDocComment(writer, a.docComment);
}

immutable(Repr) documentStructDecl(ref Alloc alloc, ref immutable StructDecl a) {
	ArrBuilder!NameAndRepr fields;
	add(alloc, fields, nameAndRepr("name", reprSym(a.name)));
	if (!empty(typeParams(a)))
		add(alloc, fields, nameAndRepr("type-params", documentTypeParams(alloc, typeParams(a))));
	if (!safeCStrIsEmpty(a.docComment))
		add(alloc, fields, nameAndRepr("comment", reprStr(a.docComment)));
	add(alloc, fields, nameAndRepr("body", matchStructBody!(immutable Repr)(
		body_(a),
		(ref immutable StructBody.Bogus) =>
			unreachable!(immutable Repr),
		(ref immutable StructBody.Builtin) =>
			reprNamedRecord(alloc, "builtin", [nameAndRepr("name", reprSym(a.name))]),
		(ref immutable StructBody.Enum it) =>
			reprNamedRecord(alloc, "enum", [nameAndRepr(
				"members",
				reprArr(alloc, it.members, (ref immutable StructBody.Enum.Member member) =>
					reprSym(member.name)))]),
		(ref immutable StructBody.Flags it) =>
			reprNamedRecord(alloc, "flags", [nameAndRepr(
				"members",
				reprArr(alloc, it.members, (ref immutable StructBody.Enum.Member member) =>
					reprSym(member.name)))]),
		(ref immutable StructBody.ExternPtr) =>
			reprNamedRecord(alloc, "extern-ptr", []),
		(ref immutable StructBody.Record it) =>
			reprNamedRecord(alloc, "record", [
				nameAndRepr("fields", reprArr(alloc, it.fields, (ref immutable RecordField field) =>
					documentRecordField(alloc, field)))]),
		(ref immutable StructBody.Union it) =>
			reprNamedRecord(alloc, "union", [
				nameAndRepr("members", reprArr(alloc, it.members, (ref immutable UnionMember member) =>
					documentUnionMember(alloc, member)))]))));
	return reprNamedRecord(alloc, "type", finishArr(alloc, fields));
}

immutable(Repr) documentRecordField(ref Alloc alloc, ref immutable RecordField a) {
	ArrBuilder!NameAndRepr fields;
	add(alloc, fields, nameAndRepr("name", reprSym(a.name)));
	add(alloc, fields, nameAndRepr("type", documentTypeRef(alloc, a.type)));
	final switch (a.mutability) {
		case FieldMutability.const_:
			break;
		case FieldMutability.private_:
			add(alloc, fields, nameAndRepr("mut", reprSym("private")));
			break;
		case FieldMutability.public_:
			add(alloc, fields, nameAndRepr("mut", reprSym("public")));
			break;
	}
	return reprNamedRecord("field", finishArr(alloc, fields));
}

immutable(Repr) documentUnionMember(ref Alloc alloc, ref immutable UnionMember a) {
	ArrBuilder!NameAndRepr fields;
	add(alloc, fields, nameAndRepr("name", reprSym(a.name)));
	if (has(a.type))
		add(alloc, fields, nameAndRepr("type", documentTypeRef(alloc, force(a.type))));
	return reprNamedRecord("member", finishArr(alloc, fields));
}

void writeStructDecl(ref Writer writer, ref const AllSymbols allSymbols, ref immutable StructDecl a) {
	matchStructBody!void(
		body_(a),
		(ref immutable(StructBody.Bogus)) {
			unreachable!void();
		},
		(ref immutable(StructBody.Builtin)) {
			writeStatic(writer, "\n\t\t+builtinType(");
			writeQuotedSym(writer, allSymbols, a.name);
			writeTypeParams(writer, allSymbols, typeParams(a));
			writeStatic(writer, ")");
		},
		(ref immutable StructBody.Enum it) {
			writeEnum(writer, allSymbols, a, it);
		},
		(ref immutable(StructBody.Flags)) {
			todo!void("!");
		},
		(ref immutable(StructBody.ExternPtr)) {
			writeStatic(writer, "\n\t\t+externPtrType(");
			writeQuotedSym(writer, allSymbols, a.name);
			writeTypeParams(writer, allSymbols, typeParams(a));
			writeStatic(writer, ")");
		},
		(ref immutable StructBody.Record it) {
			writeRecord(writer, allSymbols, a, it);
		},
		(ref immutable StructBody.Union it) {
			writeUnion(writer, allSymbols, a, it);
		});
	writeDocComment(writer, a.docComment);
}

void writeEnum(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref immutable StructDecl a,
	ref immutable StructBody.Enum e,
) {
	writeStatic(writer, "\n\t\t+enum(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeStatic(writer, ", [");
	writeWithCommas!(StructBody.Enum.Member)(writer, e.members, (ref immutable StructBody.Enum.Member member) {
		writeQuotedSym(writer, allSymbols, member.name);
	});
	writeStatic(writer, "])");
}

void writeRecord(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref immutable StructDecl a,
	ref immutable StructBody.Record r,
) {
	writeStatic(writer, "\n\t\t+record(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", [");
	writeWithCommas!RecordField(writer, r.fields, (ref immutable RecordField field) {
		writeChar(writer, '[');
		writeQuotedSym(writer, allSymbols, field.name);
		writeStatic(writer, ", ");
		writeQuotedType(writer, allSymbols, field.type);
		final switch (field.mutability) {
			case FieldMutability.const_:
				break;
			case FieldMutability.private_:
				writeStatic(writer, ", \".mut\"");
				break;
			case FieldMutability.public_:
				writeStatic(writer, ", \"mut\"");
				break;
		}
		writeChar(writer, ']');
	});
	writeStatic(writer, "])");
}

void writeUnion(
	ref Writer writer,
	ref const AllSymbols allSymbols,
	ref immutable StructDecl a,
	ref immutable StructBody.Union u,
) {
	writeStatic(writer, "\n\t\t+union(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", [");
	writeWithCommas!UnionMember(writer, u.members, (ref immutable UnionMember member) {
		writeChar(writer, '[');
		writeQuotedSym(writer, allSymbols, member.name);
		writeStatic(writer, ", ");
		if (has(member.type))
			writeQuotedType(writer, allSymbols, force(member.type));
		else
			writeStatic(writer, "null");
		writeChar(writer, ']');
	});
	writeStatic(writer, "])");
}

immutable(Repr) documentSpec(ref Alloc alloc, ref immutable SpecDecl a) {
	ArrBuilder!NameAndRepr fields;
	add(alloc, fields, nameAndRepr("name", reprSym(a.name)));
	if (!empty(typeParams(a)))
		add(alloc, fields, nameAndRepr("type-params", documentTypeParams(alloc, typeParams(a))));
	add(alloc, fields, nameAndRepr("body", matchSpecBody!(immutable Repr)(
		a.body_,
		(immutable SpecBody.Builtin) =>
			reprSym("builtin"),
		(immutable Sig[]) =>
			reprSym("TODO"))));
	return reprNamedRecord(alloc, "spec", finishArr(alloc, fields));
}

void writeSpec(ref Writer writer, ref const AllSymbols allSymbols, ref immutable SpecDecl a) {
	writeStatic(writer, "\n\t\t+spec(");
	writeQuotedSym(writer, allSymbols, a.name);
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", ");
	matchSpecBody!void(
		a.body_,
		(immutable SpecBody.Builtin) {
			writeStatic(writer, "\"builtin\"");
		},
		(immutable Sig[] sigs) {
			writeStatic(writer, "\"TODO:WRITE SIGS\"");
			cast(void) sigs;
		});
	writeStatic(writer, ")");
	writeDocComment(writer, a.docComment);
}

immutable(Repr) documentFun(ref Alloc alloc, ref immutable FunDecl a) {
	ArrBuilder!NameAndRepr fields;
	add(alloc, fields, nameAndRepr("name", reprSym(a.name)));
	add(alloc, fields, nameAndRepr("comment", reprStr(a.docComment)));
	if (!empty(typeParams(a)))
		add(alloc, fields, nameAndRepr("type-params", documentTypeParams(alloc, typeParams(a))));
	add(alloc, fields, nameAndRepr("return-type", documentTypeRef(alloc, returnType(a))));
	//TODO:handle variadic
	add(alloc, fields, nameAndRepr("params", reprArr(alloc, paramsArray(params(a)), (ref immutable Param it) =>
		reprNamedRecord(alloc, "param", [
			nameAndRepr("name", reprSym(has(it.name) ? force(it.name) : shortSym("_"))),
			nameAndRepr("type", documentTypeRef(alloc, it.type))]))));
	return reprNamedRecord(alloc, "fun", finishArr(alloc, fields));
}

void writeFun(ref Writer writer, ref const AllSymbols allSymbols, ref immutable FunDecl a) {
	writeStatic(writer, "\n\t\t+function(");
	writeQuotedSym(writer, allSymbols, name(a));
	writeTypeParams(writer, allSymbols, typeParams(a));
	writeStatic(writer, ", ");
	writeQuotedType(writer, allSymbols, returnType(a));
	writeStatic(writer, ", [");
	//TODO: handle variadic
	writeWithCommas!Param(writer, paramsArray(params(a)), (ref immutable Param it) {
		writeChar(writer, '[');
		writeQuotedOptSym(writer, allSymbols, it.name);
		writeStatic(writer, ", ");
		writeQuotedType(writer, allSymbols, it.type);
		writeChar(writer, ']');
	});
	writeStatic(writer, "])");
	writeDocComment(writer, a.docComment);
}

void writeDocComment(ref Writer writer, immutable SafeCStr comment) {
	immutable string str = strOfSafeCStr(comment);
	if (!empty(str)) {
		// Comment may contain newlines!
		eachLine(str, (immutable string line) {
			writeStatic(writer, "\n\t\t\t|");
			writeStr(writer, line);
		});
	}
}

void writeQuotedOptSym(ref Writer writer, ref const AllSymbols allSymbols, ref immutable Opt!Sym a) {
	if (has(a))
		writeQuotedSym(writer, allSymbols, force(a));
	else
		writeStatic(writer, "\"_\"");
}

void writeQuotedSym(ref Writer writer, ref const AllSymbols allSymbols, immutable Sym a) {
	writeChar(writer, '\"');
	writeSym(writer, allSymbols, a);
	writeChar(writer, '\"');
}

immutable(Repr) documentTypeRef(ref Alloc alloc, immutable Type a) {
	return matchType!(immutable Repr)(
		a,
		(immutable Type.Bogus) =>
			unreachable!(immutable Repr),
		(immutable Ptr!TypeParam it) =>
			reprSym(it.deref().name),
		(immutable Ptr!StructInst it) =>
			documentStructInst(alloc, it.deref()));
}

immutable(Repr) documentStructInst(ref Alloc alloc, ref immutable StructInst a) {
	return empty(typeArgs(a))
		? reprSym(a.name)
		: reprNamedRecord(alloc, a.name, [
			nameAndRepr("type-args", reprArr(alloc, typeArgs(a), (ref immutable Type typeArg) =>
				documentTypeRef(alloc, typeArg)))]);
}

void writeQuotedType(ref Writer writer, ref const AllSymbols allSymbols, immutable Type a) {
	writeChar(writer, '\"');
	writeType(writer, allSymbols, a);
	writeChar(writer, '\"');
}

void writeType(ref Writer writer, ref const AllSymbols allSymbols, immutable Type a) {
	matchType!(void)(
		a,
		(immutable Type.Bogus) {
			unreachable!void();
		},
		(immutable Ptr!TypeParam it) {
			writeSym(writer, allSymbols, it.deref().name);
		},
		(immutable Ptr!StructInst it) {
			writeSym(writer, allSymbols, it.deref().name);
			immutable Type[] typeArgs = typeArgs(it.deref());
			if (!empty(typeArgs)) {
				if (typeArgs.length == 1) {
					writeChar(writer, ' ');
					writeType(writer, allSymbols, only(typeArgs));
				} else {
					writeChar(writer, '<');
					writeWithCommas!Type(writer, typeArgs, (ref immutable Type t) {
						writeType(writer, allSymbols, t);
					});
					writeChar(writer, '>');
				}
			}
		});
}

immutable(Repr) documentTypeParams(ref Alloc alloc, immutable TypeParam[] xs) {
	verify(!empty(xs));
	return reprArr(alloc, xs, (ref immutable TypeParam x) =>
		reprNamedRecord(alloc, "type-param", [
			nameAndRepr("name", reprSym(x.name))]));
}

void writeTypeParams(ref Writer writer, ref const AllSymbols allSymbols, immutable TypeParam[] typeParams) {
	writeStatic(writer, ", ");
	if (empty(typeParams))
		writeStatic(writer, "[]");
	else {
		writeChar(writer, '[');
		writeWithCommas!TypeParam(writer, typeParams, (ref immutable TypeParam it) {
			writeStatic(writer, "\"?");
			writeSym(writer, allSymbols, it.name);
			writeChar(writer, '"');
		});
		writeChar(writer, ']');
	}
}

void eachLine(
	immutable string a,
	scope void delegate(immutable string) @safe @nogc pure nothrow cb
) {
	immutable Opt!size_t index = findIndex!char(a, (ref immutable char c) => c == '\n');
	if (has(index)) {
		cb(a[0..force(index)]);
		eachLine(a[force(index)+1 .. $], cb);
	} else
		cb(a);
}
