<main>
	<crow-runnable>
		import
			crow/io/print: out, print

		main nat^(_ string[]) summon
			for x : 1 .. 20
				m3 = x is-multiple-of 3
				m5 = x is-multiple-of 5
				out print if m3 && m5
					"FizzBuzz"
				elif m3
					"Fizz"
				elif m5
					"Buzz"
				else
					"{x}"
			()
	</crow-runnable>
	<p>
		Crow is an upcoming programming language for high-quality code.
		<br />
		A "luxury" language, it prioritizes your code's readability and correctness
		over the ease of implementing the language.
	</p>
	<p>Some interesting features:</p>
	<ul class="bullets">
		<li>
			Crow is garbage collected and statically typed.
			<br />
			It does not rely on an external runtime and can call into C libraries.
		</li>
		<li>
			Crow is expression-oriented instead of statement-oriented.
			<br />
			There is no <code class="keyword">return</code> keyword,
			and <code class="keyword">if</code> is an expression rather than a statement.
		</li>
		<li>
			Crow runs code directly and doesn't need a build system.
			<br />
			Ahead-of-time optimized compilation is also supported.
		</li>
		<li>
			Crow detects nesting based on indentation, so it doesn't need braces.
		</li>
		<li>
			Functions cannot perform I/O except by invoking a callback from a parameter.
			<br />
			If a function's parameters are all immutable data (not mutable objects or callbacks), it is a pure function.
			<br />
			(<code class="keyword">summon</code> functions are the exception.)
		</li>
		<li>
			Crow has a strong type system, with no subtyping, implicit conversions or <code class="keyword">null</code>.
		</li>
		<li>
			Launching tasks and getting the result back as a future is easy.
			<br />
			The type system ensures that mutable data will only be accessed by one thread at a time.
		</li>
	</ul>
	<p>
		To get started, read the <a href="/tutorial">tutorial</a>.
	</p>
</main>
