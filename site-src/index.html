<div id="side-nav-wrapper">
<main>
	<h2>The Crow programming language</h2>
	<crow-runnable>
		main void()
			for x : 1::nat .. 20
				m3 = x is-multiple-of 3
				m5 = x is-multiple-of 5
				info log if m3 && m5
					"FizzBuzz"
				elif m3
					"Fizz"
				elif m5
					"Buzz"
				else
					"{x}"
	</crow-runnable>
	<p>
		Crow is an upcoming general-purpose, high-level programming language.
		<br />
		It's currently in alpha state. There will be breaking changes.
	</p>
	<p>Some interesting features:</p>
	<ul class="bullets">
		<li>
			Crow programs can be <strong>run directly</strong> or <strong>build to a standalone executable</strong>.
		</li>
		<li>
			Crow code can <strong>directly call C</strong> functions. (But typically code is higher-level and safe.)
		</li>
		<li>
			Crow has <strong>IDE support</strong>.
			<br />
			The IDE uses the same compiler as on the command line, giving it complete information.
		</li>
		<li>
			Syntax is <strong>expression-based</strong> and <strong>uses indentation</strong>.
			Function bodies are expressions with no <code class="keyword">return</code> needed.
			<br />
			Even <code class="keyword">if</code> and <code class="keyword">for</code> are expressions.
		</li>
		<li>
			Code is <strong>flat</strong>. Declarations are not nested.
			<br />
			(For example, a function doesn't "belong" to a type and so doesn't go inside of it.)
			<br />
			A 100 character per line limit is realistic.
		</li>
		<li>
			All code goes in <strong>modules</strong>.
			There are no global declarations, and what you don't import can't hurt you.
		</li>
		<li>
			Crow is <strong>strongly typed</strong> with no subtyping, implicit conversion,
			or <code>null</code> values.
			<br />
			Overload resolution is unambiguous; there are no "better" matches.
		</li>
		<li>
			Expressions are type-checked with an <strong>expected type</strong>.
			<br />
			The same syntax <code class="keyword">1, 2</code>
			could be a list, tuple, vector, etc., inferred by where it is used.
			<br />
			This saves you from having to write something like <code>new List&lt;int&gt;(1, 2)</code>.
		</li>
		<li>
			Data is <strong>garbage collected</strong>. Don't worry about what's by-reference or by-value.
		</li>
		<li>
			<strong>Mutability is controlled.</strong>
			Types track what is safe to share between parallel tasks.
			<br />
			It's also easy to use mutable data and ensure that tasks using it wait their turn.
			<br />
			Data structures are immutable by default (with efficient immutable updates).
		</li>
		<li>
			<strong>I/O is controlled.</strong>
			Functions are pure by default and can't do I/O except through parameters.
		</li>
		<li>
			<strong>Templates</strong> are statically checked to work for all possible types.
			<br />
			<strong>Specs</strong> allow you to call functions provided by the caller's context.
		</li>
	</ul>
	<p>
		To get started, read the <a href="/tutorial">tutorial</a>.
	</p>
</main>
</div>
