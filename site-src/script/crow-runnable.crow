import
	crow/js:
		==, as-js, as-t, call-property, get, instanceof, js-any, js-global, null, set
	./crow: crow-server, make-crow-server, open-file, request, tokens-legend
	./crow-text: create-crow-text, new
	./decode-tokens: decode-tokens
	./icon: copy-icon, download-icon, link-icon, play-icon, up-icon
	./loading-spinner: create-loading-spinner
	./lsp-types: diagnostic, line-and-character, new, severity, to-js, tokens-and-diagnostics
	./util/browser-util:
		copy-text-to-clipboard, download-text, get-url-search, location, origin, pathname,
		push-history
	./util/dom-util:
		~=, as-node, attributes, child-nodes, custom-element-node, create-button, create-div,
		create-node, create-span, create-text-node, define-custom-element, node,
		remove-all-children, shadow-root, subscript
	./util/js-util: new
	./util/mutable-observable: get, mutable-observable, new, now-and-subscribe, set
	./util/util: from-base-64, reduce-indent, to-base-64

define-crow-runnable-custom-element void() summon, trusted, js extern
	crow = make-crow-server
	names names = ()
	"crow-runnable" define-custom-element (x => x.is-play.css), x => x connected crow, names

-names record(seen string mut-set, next-index mut nat) mut
-new names()
	(), 0
-get-default-name string(a names) unsafe
	res string = "demo{a.next-index}.crow"
	a.next-index +:= 1
	res

-get-crow-runnable-name string(a names, name-attr string?) unsafe, js extern
	name = name-attr ?? a.get-default-name
	assert name ends-with ".crow"
	unless a.seen try-add name
		error log "Two CrowRunnable have the same name {name}"
	name

-get-crow-runnable-initial-text string(play bool, node node) summon, unsafe, js extern
	(play ? get-code-from-url) ?? node.get-child-text
-get-code-from-url string?() summon, unsafe, js extern
	if code ?= "code" get-url-search
		code.from-base-64,
-get-child-text string(node node) trusted, js extern
	child-nodes = node child-nodes
	assert child-nodes.size == 1
	child-nodes[0] get-text-from-node
-get-text-from-node string(node node) trusted, js extern
	assert node.as-js instanceof "Text".js-global
	(node.as-js get "data").as-t reduce-indent

-copy-play-link-from-text void(text string) summon, unsafe, js extern
	url string = "{location origin}{location pathname}?code={text to-base-64}"
	url push-history
	url copy-text-to-clipboard

-is-play bool(a custom-element-node) unsafe, js extern
	!a.attributes["play"].is-empty

-connected void(a custom-element-node, crow crow-server, names names) summon, unsafe, js extern
	name = names get-crow-runnable-name a.attributes["name"]
	no-run = (a.as-js call-property "getAttribute", "no-run"::string) != null
	play = a is-play
	initial-text = play get-crow-runnable-initial-text a.as-node
	main-uri string = "file:///{name}"
	text string mutable-observable = initial-text,
	tokens-and-diagnostics tokens-and-diagnostics mutable-observable = ()

	get-hover string mut(x line-and-character) = position =>
		args js-any = (("textDocument", (("uri", main-uri.as-js),)), ("position", position.to-js))
		hover = crow request "textDocument/hover", args
		if hover != null
			hover get "contents" get "value" as-t

	crow-text = (get-hover, tokens-and-diagnostics, text) create-crow-text

	text now-and-subscribe shared value =>
		diagnostics = crow open-file main-uri, value
		args js-any = ("textDocument", (("uri", main-uri.as-js),)),
		encoded-tokens = crow request "textDocument/semanticTokens/full", args get "data"
		tokens = encoded-tokens decode-tokens crow.tokens-legend
		error-diagnostics diagnostic array = diagnostics filter x => x.severity <= 1
		tokens-and-diagnostics set (tokens, error-diagnostics)

	output = make-output

	collapse-button mut node = gc-safe-value
	collapse-button := "Hide output" create-button "collapsed", (up-icon,), () =>
		output hide
		_ = collapse-button.as-js get "class-list" call-property "add", "collapsed"::string
	_ = collapse-button.as-js get "style" set "float", "right"::string

	run-button node? = unless no-run
		button = "Run" create-button "run", (play-icon,), () =>
			if false
				output start-running # TODO: REMOVE ---------------------------------------------------------------------------------
			yield-fiber # Allow to show loading first
			_ = collapse-button.as-js get "classList" call-property "remove", "collapsed"::string
			args js-any = (("uri", main-uri.as-js), ("diagnosticsOnlyForUris", (main-uri.as-js,)::(js-any array).as-js))
			res = crow request "custom/run", args
			output finish-running res
		button,

	copy-button = "Copy to clipboard" create-button "", (copy-icon,), () =>
		text.get copy-text-to-clipboard
	download-button = "Download" create-button "", (download-icon,), () =>
		name download-text text.get
	link-button node? = if play
		button = "Copy link to clipboard" create-button "", (link-icon,), () =>
			text.get copy-play-link-from-text
		button,

	buttons node[] = run-button.to ~~ (copy-button, download-button) ~~ link-button.to ~~ (collapse-button,)
	bottom = "bottom" create-div buttons
	container = "outer-container" create-div (crow-text, output.container, bottom)
	a.shadow-root ~= container

-output record(container node) mut

-make-output output() trusted, js extern
	res output = ("output" create-div ()),
	res hide
	res

-hide void(a output) trusted, js extern
	a.container.as-js get "style" set "height", "0"::string
-start-running void(a output) trusted, js extern
	container = a.container as-js
	container set "className", "output"::string
	_ = container get "classList" call-property "add", "running"::string # TODO: why do we add classes in 2 different ways?
	container get "style" set "height", "2em"::string
	a.container remove-all-children
	_ = container call-property "append", create-loading-spinner
	_ = container call-property "append", (create-div, create-div, create-div, create-div)::(node array) # What was this for again??????????
-finish-running void(a output, run-output js-any) unsafe, js extern
	writes write array = for x : (run-output get "writes").as-t::(js-any array); x to
	exit-code nat = (run-output get "exitCode").as-t::float to

	_ = a.container.as-js get "classList" call-property "remove", "running"::string
	a.container.as-js get "style" set "height", ""::string
	a.container remove-all-children
	a.container add-spans-for-writes writes, exit-code

-write record(pipe pipe, text string)
-to write(a js-any) unsafe, js extern
	(a get "pipe" to), (a get "text" as-t)
-pipe enum(stdout, stderr)
-to pipe(a js-any) unsafe, js extern
	a.as-t::string to

-css string(play bool)
	"""
.outer-container \{
	max-width: {play ? 60::nat : 40}em;
	margin-left: auto;
	margin-right: auto;
}
.output \{
	width: 100%;
	color: #fdf9f3;
	background: #161517;
	font-family: "hack";
	white-space: pre-wrap;
	tab-size: 4;
	overflow: hidden;
}
.output.running \{ transition: none; }
.output > .stderr \{ color: #ff6622; }
.output > .exit-code \{ color: #ff4444; }
button \{
	border: none;
	outline: none;
	color: #ffebbd;
	background: #00000000;
	cursor: pointer;
}
.run \{ color: #ffd866; }
.bottom \{
	border-bottom-left-radius: 1.5em;
	border-bottom-right-radius: 1.5em;
	background: #423e44;
	margin: 0;
	padding-left: 0.5em;
	padding-right: 0.5em;
}
div.icon svg \{ height: 1.5em; }
button.collapsed \{ display: none; }
"""

-add-spans-for-writes void(container node, writes write array, exit-code nat) js extern
	cur-pipe mut string? = ()
	cur-line mut string = ""
	finish-line void mut() = () =>
		unless trusted (container.as-js get "textContent").as-t::string is-empty
			container ~= "br".create-node
		container ~= cur-pipe!.to create-span (cur-line.create-text-node,)
		cur-line := ""
	
	for write : writes
		pipe = write.pipe
		text = write.text
		if x ?= cur-pipe
			if x != pipe.to && cur-line != ""
				finish-line[]

		cur-pipe := pipe.to,
		parts = text split "\n"
		cur-line ~~:= parts[0]
		for part : parts[1 .. end]
			finish-line[]
			cur-line ~~:= part
	if cur-line != ""
		finish-line[]
	
	if exit-code != 0
		cur-pipe := "exit-code",
		cur-line := "Exit code: {exit-code}"
		finish-line[]
	elif writes.is-empty
		cur-pipe := "stdout",
		cur-line := "<<no output>>"
		finish-line[]
