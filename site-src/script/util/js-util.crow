import
	crow/js:
		==, call, call-new, cast, call-property, js-any, js-global, null, set-subscript, subscript,
		typeof

new js-any(...properties (symbol, js-any) array) trusted, js extern
	res = "Object".js-global call-new
	for key, value : properties
		res[key] := value
	res
to-js-object js-any(properties js-any[symbol]) trusted, js extern
	res = "Object".js-global call-new
	for key, value : properties
		res[key] := value
	res

json-from-js-object json(a js-any) unsafe, js extern
	match a typeof
	as string
		a.cast::string to
	as object
		if a == null
			null
		else
			entries js-any array = "Object".js-global call-property "entries", a cast
			map json[symbol] = for entry : entries
				entry[0::nat].cast::string.to, entry[1::nat].json-from-js-object
			map to
	else
		throw todo

eval js-any(source string) unsafe, js extern
	"eval".js-global call source

method alias
	js-any mut(this js-any, args js-any array)

-make-method js-any(fn method) unsafe, js extern
	make-method = """
		fn => function(...args) \{
			return fn(\{ "f_a": this, "f_b": args })
		}
	""" eval
	make-method call fn

make-class js-any(
	super-class js-any,
	constructor method,
	methods method[symbol],
) unsafe, js extern
	make = """
		(ctor, Super) => class extends Super \{
			constructor(...args) \{
				super()
				ctor(\{ "f_a": this, "f_b": args })
			}
		}
	""" eval
	res = make call constructor, super-class
	for name, method : methods
		res["prototype"][name] := method make-method
	res

json-parse js-any(a string) unsafe, js extern
	"JSON".js-global call-property "parse", a

json-stringify string(a js-any) unsafe, js extern
	"JSON".js-global call-property "stringify", a cast
