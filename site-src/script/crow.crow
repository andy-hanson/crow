import
	crow/js: ==, as-js, as-t, await, call, call-new, call-property, get, js-any, js-global, null
	./lsp-types: diagnostic, new, text-document-item, to, tokens-legend
	./util/js-util: new, to-js-object
	./util/util: fetch-js-object

-math-keys symbol[]()
	"acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2",
	"ceil", "cos", "cosh", "floor", "log", "sin", "sinh", "sqrt", "tan", "tanh"

# WASM uses JS 'number' for 32 bit numbers
-wasm32 alias
	float
-c-str alias
	float

-imports js-any() summon, trusted, js extern
	res js-any mut[symbol] = ()
	res["getTimeNanos"] := (&get-time-nanos)::(nat function()) as-js
	res["perfLogMeasure"] := (&perf-log-measure)::(void function(name c-str, count wasm32, nanos nat, bytes wasm32)) as-js
	res["perfLogFinish"] := (&perf-log-finish)::(void function(name c-str, total-nanos nat)) as-js
	res["debugLog"] := (&debug-log)::(void function(text c-str)) as-js
	for key : math-keys
		value = "Math".js-global get key
		res[key] := value
		res["{key}f"] := value
	res["round"] := (&round)::(float function(x float)) as-js
	res["roundf"] := (&round)::(float32 function(x float32)) as-js
	res["__assert"] := (&__assert)::(void function(asserted c-str, file c-str, line float)) as-js
	res.move-to to-js-object

-get-time-nanos nat() summon, trusted, js extern
	msec float = "performance".js-global call-property "now" as-t
	msec * 1000000 to

-perf-measure record(name string, count nat, msec nat, bytes-allocated nat)
-to json(a perf-measure)

-perf-measures global(perf-measure mut[])
-perf-log-measure void(name-ptr c-str, count wasm32, nanoseconds nat, bytes-allocated wasm32) trusted, summon, js extern
	m perf-measure = name-ptr.read-c-string, count.to, nanoseconds.to-msec,  bytes-allocated.to
	perf-measures ~= m
-perf-log-finish void(name c-str, total-nanos nat) trusted, summon, js extern
	info log "performance for {name read-c-string}"
	info log "TOTAL: {total-nanos.to-msec}"
	for measure : perf-measures
		info log measure.to::json.to
	perf-measures := ()

-debug-log void(text c-str) summon, trusted, js extern
	info log text.read-c-string

-__assert void(asserted c-str, file c-str, line float) summon, js extern
	throw "Assertion {asserted read-c-string} failed on {file read-c-string} line {line}" error

-view global(js-any)

-read-c-string string(begin c-str) summon, trusted, js extern
	end mut = begin
	while end < (view get "byteLength").as-t && (view call-property "getUint8", end).as-t::float != 0
		end +:= 1
	begin read-string-from-range end
-read-string-from-range string(begin c-str, end c-str) summon, trusted, js extern
	bytes = "Uint8Array".js-global call-new (view get "buffer"), begin, end - begin
	"TextDecoder".js-global.call-new call-property "decode", bytes as-t

-bytes-in-range js-any(begin wasm32, length nat) summon, trusted, js extern
	"Uint8Array".js-global call-new (view get "buffer"), begin, length.to::wasm32

-write-c-string c-str(begin c-str, length nat, content string) summon, trusted, js extern
	res = "TextEncoder".js-global.call-new call-property "encodeInto", content, (begin bytes-in-range length)
	# read float = res get "read" as-t
	written float = res get "written" as-t
	# assert read.to::nat == content.size # this assertion is slow ...........................................................
	assert written.to::nat < length
	_ = view call-property "setUint8", begin + written, 0::float
	# assert begin.read-c-string == content # this assertion is slow ................................................................
	begin

-to-msec nat(nsec nat)
	nsec / 1000000

-wasm-exports record mut
	getParameterBufferPointer c-str function()
	getParameterBufferLength float function()
	newServer wasm32 mut(params c-str)
	handleLspMessage c-str mut(server wasm32, params c-str)
	memory js-any

-as-wasm-exports wasm-exports(a js-any) unsafe, js extern
	(a get "getParameterBufferPointer" as-t), \
	(a get "getParameterBufferLength" as-t),
	(a get "newServer" as-t),
	(a get "handleLspMessage" as-fun2),
	a get "memory"
-as-fun2 c-str mut(server wasm32, params c-str)(a js-any) unsafe, js extern # this is a big gotcha. We need to untuple the args.
	(server, params) =>
		a call server, params as-t

-server-params record
	includeDir string
	cwd string
-to json(a server-params)

-make-lsp-server crow-lsp-server() summon, trusted, js extern
	wasm-stream = "fetch".js-global call "../bin/crow.wasm"::string
	options js-any = ("env", imports),
	result = "WebAssembly".js-global call-property "instantiateStreaming", wasm-stream, options await
	wasm wasm-exports = result get "instance" get "exports" as-wasm-exports
	view := "DataView".js-global call-new (wasm.memory get "buffer")
	parameters-begin float = (wasm.getParameterBufferPointer::(float function()))[] # TODO: type annotation should not be necessary
	parameters-length nat  = (wasm.getParameterBufferLength::(float function()))[] to
	server-params server-params = include-dir, "file:///"
	server = wasm.newServer[parameters-begin write-c-string parameters-length, server-params.to::json.to]
	parameters-begin, parameters-length, wasm, server

-crow-lsp-server record mut
	parameters-begin float
	parameters-length nat
	wasm wasm-exports
	server wasm32

-handle-message response(a crow-lsp-server, message js-any) summon, unsafe, js extern
	message-str string = "JSON".js-global call-property "stringify", message as-t
	message-c-str c-str = a.parameters-begin write-c-string a.parameters-length, message-str
	response-str = a.wasm.handleLspMessage[a.server, message-c-str] read-c-string
	response = "JSON".js-global call-property "parse", response-str
	messages js-any array = response get "messages" as-t
	exit-code js-any = response get "exitCode"
	messages, unless exit-code == null
		exit-code.as-t::float.to,

-request js-any(a crow-lsp-server, method symbol, params js-any) summon, unsafe, js extern
	res = a handle-message (("id", 1::float.as-js), ("method", method.as-js), ("params", params)).to-js-object
	assert res.exitCode is-empty
	res.messages.size is 1
	message = res.messages[0]
	(message get "id").as-t::float is 1
	message get "result"

-response record
	messages js-any array
	exitCode nat?

-include-dir string()
	"file:///include"

crow-server record mut
	lsp-server crow-lsp-server
	tokens-legend tokens-legend

make-crow-server crow-server() summon, trusted, js extern
	diagnostics-per-uri := ()
	lsp = make-lsp-server
	tokens-legend tokens-legend = lsp request "initialize", () get "capabilities" get "semanticTokensProvider" get "legend" to
	res crow-server = lsp, tokens-legend
	res init
	res

request js-any(a crow-server, method symbol, params js-any) summon, unsafe, js extern
	a.lsp-server request method, params

# TODO: Can't I just put this on the crow-server to ensure it's initialized? --------------------------------------------------------------------------
-diagnostics-per-uri global(diagnostic[] mut[uri])

uri alias
	string

-init void(a crow-server) trusted, summon, js extern
	include-all = "/include-all.json" fetch-js-object
	for entry : ("Object".js-global call-property "entries", include-all).as-t::(js-any array)
		path string = entry get 0 as-t
		text string = entry get 1 as-t
		_ = a open-file "{include-dir}/{path}", text
	_ = a open-file "file:///crow-config.json", "\{}"
	_ = a open-file "file:///hello.txt", "Hello, world!"
	a mark-unknown-files-not-found

get-diagnostics diagnostic[](_ crow-server, uri uri, response response) summon, trusted, js extern
	for message : response.messages
		method string = message get "method" as-t
		if method == "custom/unknownUris"
			()
		else
			method is "textDocument/publishDiagnostics"
			params = message get "params"
			diagnostics-per-uri[params get "uri" as-t] := for x : (params get "diagnostics").as-t::(js-any array); x to
	diagnostics-per-uri[uri] ?? ()

open-file diagnostic[](a crow-server, uri uri, text string) summon, trusted, js extern
	params js-any = (("textDocument", (uri, text)::text-document-item.as-js),)
	response = a.lsp-server handle-message ("textDocument/didOpen" make-message params)
	a get-diagnostics uri, response
change-file diagnostic[](a crow-server, uri uri, text string) summon, trusted, js extern
	textDocument js-any = ("uri", uri.as-js),
	contentChanges js-any array = (("text", text.as-js),),
	params js-any = ("textDocument", textDocument), ("contentChanges", contentChanges.as-js)
	response = a.lsp-server handle-message ("textDocument/didChange" make-message params)
	a get-diagnostics uri, response
mark-unknown-files-not-found void(a crow-server) summon, trusted, js extern
	for uri : a get-unloaded-uris
		assert uri ends-with "/crow-config.json"
		params js-any = ("uri", uri.as-js), ("type", "notFound"::string.as-js)
		_ = a.lsp-server handle-message ("custom/readFileResult" make-message params)
	assert a.get-unloaded-uris is-empty

-make-message js-any(method string, params js-any) trusted, js extern
	("method", method.as-js), ("params", params)

-get-unloaded-uris uri array(a crow-server) summon, trusted, js extern
	response = a.lsp-server request "custom/unloadedUris", ()
	response get "unloadedUris" as-t
