<section>
	<h2>calling external libraries</h2>
	<p>
		Crow code can call functions defined in external libraries.
		<br />
		In this example, we use the <code>regex.h</code> library.
	</p>

	<crow-runnable no-run name="regex.crow">
		import
			crow/c-types: c-int, size_t, u-long

		main nat^(_ string[]) summon
			"cro\\+w" test-regex ("crow", "crooow", "duck")
			"[0-9" test-regex ("42",)
			()

		test-regex void(source string, candidates string[]) summon
			trusted match source parse
			as ok regex
				for x : candidates
					info log "{source} matches {x}? {regex matches x}"
				regex free
			as err e
				error log "bad regex {source}: {e}"

		regex record mut by-ref
			wrapped mut regex_t

		# Unsafe because the caller must 'free' the regex
		parse (regex, string) result(source string) unsafe
			res regex = (),
			err = &res.wrapped regcomp source.to, ()
			if err == REG_NOERROR
				res ok
			else
				buf char8 mut[] = 1000 n-of "\0"
				_ = err regerror &res.wrapped, buf.begin-pointer, buf.size
				res free
				"{buf.begin-pointer.as-const}" err

		free void(a regex) unsafe
			&a.wrapped regfree

		matches bool(a regex, candidate string)
			err = trusted &a.wrapped regexec candidate.to, (), (), ()
			if err == REG_NOERROR
				true
			elif err == REG_NOMATCH
				false
			else
				trusted
					buf char8 mut[] = 1000 n-of "\0"
					_ = err regerror &a.wrapped, buf.begin-pointer, buf.size
					throw buf.begin-pointer.as-const

		regex_t record mut extern
			buffer void mut*
			allocated size_t
			used size_t
			syntax u-long
			fastmap char8 mut*
			translate nat8 mut*
			re_nsub size_t
			re_flags nat8

		new regex_t() unsafe
			(), (), (), (), (), (), (), ()

		regoff_t alias
			c-int

		regmatch_t record extern
			rm_so regoff_t
			rm_eo regoff_t

		reg_errcode_t enum(c-int) extern
			REG_ENOSYS = -1
			REG_NOERROR
			REG_NOMATCH
			_REG_BADPAT
			_REG_ECOLLATE
			_REG_ECTYPE
			_REG_EESCAPE
			_REG_ESUBREG
			_REG_EBRACK
			_REG_EPAREN
			_REG_EBRACE
			_REG_BADBR
			_REG_ERANGE
			_REG_ESPACE
			_REG_BADRPT

		regcomp reg_errcode_t(regex regex_t mut*, pattern c-string, cflags c-int) c extern

		regfree void(preg regex_t mut*) c extern

		regexec reg_errcode_t(
			preg regex_t*,
			string c-string,
			nmatch size_t,
			pmatch regmatch_t mut*,
			eflags c-int,
		) c extern

		regerror size_t(
			errcode reg_errcode_t,
			preg regex_t*,
			errbuff char8 mut*,
			errbuf_size size_t,
		) c extern
	</crow-runnable>

	<p>
		Since this needs to link to libraries on your system,
		you need to download and run <code>crow run regex.crow</code>.
	</p>
</section>
<section>
	<h3>extern functions</h3>

	<p>
		<code>regfree void(preg regex_t mut*) unsafe noctx extern</code> declares an
		<code class="keyword">extern</code> function,
		based on the function of the same name in <code>/usr/include/regex.h</code>.
		<br />
		<br />
		All <code class="keyword">extern</code> functions must be <code class="keyword">noctx</code>.
		<code class="keyword">noctx</code> means that it does not use crow's facilities
		for allocating memory, launching tasks, or throwing exceptions.
		<br />
		Since this function takes a pointer but has no way to validate it, it is <code class="keyword">unsafe</code>.
	</p>
	<p>
		The other <code class="keyword">extern</code> functions
		<code class="fun">regcomp</code>, <code class="fun">regexec</code>, and <code class="fun">regerror</code>
		are spread out over multiple lines for readability; this is a different syntax for the same thing.
	</p>

	<h3>extern types</h3>

	<p>
		Any type, such as <code class="struct">regex_t</code>,
		referenced by an <code class="keyword">extern</code> function
		must be marked <code class="keyword">extern</code> too.
		<br />
		Similarly, <code class="keyword">extern</code> types can only reference other
		<code class="keyword">extern</code> types.
		<br />
		(Non-<code class="keyword">extern</code> types can reference anything.)
	</p>

	<p>
		<code class="keyword">extern</code> ensures that the type has a layout like it would in C.
		<br />
		Types like <code class="keyword">nat64</code> with C analogs are <code class="keyword">extern</code>,
		but not crow-specific types like <code class="keyword">str</code>.
	</p>

	<p>
		A <code class="keyword">union</code> in crow is different from one in C,
		so those can't be <code class="keyword">extern</code>.
		<br />
		(Crow unions are discriminated; they know which member they store.
		C unions are undiscriminated, meaning they store some member but can't tell you which one.)
		<br />
		There is currently no way to declare a C <code class="keyword">union</code>
		in crow; most libraries don't expose these directly.
	</p>

	<h3>by-ref and by-val</h3>
	<p>
		An <code class="keyword">extern</code> type must be explicitly
		<code class="keyword">by-ref</code> (<em>by reference</em>) or
		<code class="keyword">by-val</code> (<em>by value</em>).
		<br />
		If a type <code class="struct">foo</code> is <code class="keyword">by-ref</code>,
		a <code class="struct">foo</code> value is equivalent to a <code>struct foo*</code> in C,
		meaning it is passed using a pointer.
		<br />
		If it is <code class="keyword">by-val</code>, it is equivalent to a <code>struct foo</code> in C,
		meaning it is be passed by value.
		<br />
		Since a <code class="keyword">by-val</code> type is copied every time it's passed, it can't have mutable fields.
	</p>
	<p>
		<code class="keyword">by-ref</code> and <code class="keyword">by-val</code> apply everywhere the type is used:
		parameters, return values, fields in a record, etc.
	</p>
	<p>
		A non-<code class="keyword">extern</code> type will have a default choice of
		<code class="keyword">by-ref</code> or <code class="keyword">by-val</code> based on heuristics.
		<br />
		You might improve performance by choosing one explicitly.
		<br />
		Currently, the compiler chooses <code class="keyword">by-ref</code> most of the time but
		<code class="keyword">by-val</code> for small, immutable types.
	</p>
	<p>
		For an <code class="keyword">extern</code> type, choose
		<code class="keyword">by-ref</code> or <code class="keyworD">by-val</code>
		based on how the type is typically used in the library.
		<br />
		You can override the default:
	</p>

	<ul class="bullets">
		<li>
			For a <code class="keyword">by-ref</code> type:
			<br />
			In the <a href="/doc/crow/ptr.html"><code class="module">crow/ptr</code></a> module,
			there is a special <code class="struct">by-val</code> template
			that lets you pass any type by value, even if it would normally be by reference.
		</li>
		<li>
			For a <code class="keyword">by-val</code> type:
			<br />
			Use a pointer to pass it by reference.
		</li>
	</ul>
</section>
<section>
	<h3>pointers</h3>

	<p>
		<code>regex_t mut*</code> declares a mutable pointer type, equivalent to <code>regex_t*</code> in C.
		<br />
		<code>regex_t*</code> is an immutable pointer type, equivalent to <code>const regex_t*</code> in C.
		<br />
		Unlike in C, a const pointer isn't a subtype of a mutable one,
		so you must call <code class="fun">as-const</code>.
	</p>
	<p>
		Accessing a pointer works like with <code class="struct">cell</code>;
		<code>*x</code> gets the value and <code>*x := v</code> sets it.
	</p>
	<p>
		The function <code>as-ptr</code> converts a cell to a pointer.
		<br />
		Be sure to maintain a reference to the <code class="struct">cell</code>,
		since the garbage collector traces that, but not pointers.
	</p>
</section>
<section>
	<h3>C types</h3>

	<p>
		A C <code class="keyword">int</code> is not the same as a crow <code class="struct">int</code>.
		<br />
		A crow <code class="struct">int</code> is always 64 bits,
		but a C <code class="keyword">int</code> is usually shorter.
		<br />
		Always use <code class="struct">c-int</code> when translating cooe from C.
	</p>
	<p>
		The <code>crow/c-types</code> module has other useful types from C like <code class="struct">size_t</code>.
	</p>
	<p>
		<code class="struct">c-str</code> is equivalent to <code>char*</code>,
		and implies (but does not enforce) that it should end in a <code>"\0"</code> character.
	</p>
</section>
<section>
	<h2>patterns for using C libraries</h2>

	<section>
		<h3>pointer to one: cell</h3>
		<p>
			Many C libraries expect to receive a pointer to data to fill in.
			<br />
			C examples will often declare an uninitialized variable and
			get a pointer to it with <code>&x</code>; that's not supported in crow.
			<br />
			Instead, create a <code class="struct">cell</code> and use <code class="fun">as-ptr</code>.
			That's what <code>new regex(source str)</code> does.
			<br />
			This function can be marked <code class="keyword">trusted</code> despite calling the unsafe function
			<code class="fun">regcomp</code> because it knows that the pointer will be valid.
		</p>
		<p>
			Unlike a variable in C, a <code class="struct">cell</code> needs an initial value;
			since it doesn't really matter, <code>new regex_t() unsafe</code> just uses an empty value for every field.
		</p>
	</section>

	<section>
		<h3>pointer to many: mut[]</h3>
		<p>
			In the <code class="keyword">else</code> branch of <code class="fun">matches</code>,
			we need to call <code class="fun">regerror</code>, which takes a buffer to write its output.
			<br />
			Such a buffer would typically be allocated on the stack, which is not allowed in crow.
			<br />
			Instead, create a <code class="keyword">mut[]</code> and use its <code class="fun">begin-pointer</code>.
			<br />
			<code>to-str</code> here converts a C string to a crow string.
		</p>
	</section>
</section>


