<section>
	<h2>"Extern" functions</h2>
	<p>
		Crow functions can call C functions directly.
		<br />
		To declare an external function, write the function header normally,
		then write <code>c extern</code> in spec position.
		<br />
		Simply omit the function body.
	</p>
	<p>
		<code class="keyword">extern</code> functions are <code class="keyword">bare</code> and
		<code class="keyword">unsafe</code> by default.
		<br />
		You can mark the function <code class="keyword">trusted</code>
		if you don't want it to be <code class="keyword">unsafe</code>.
		That indicates an external function that never does bad things no matter how you call it.
	</p>
	<aside class="danger small">
		<code class="keyword">extern</code> functions are <em>not</em> implicitly <code class="keyword">summon</code>,
		so add that if appropriate.
	</aside>

	<crow-runnable no-run name="regex.crow">
		import
			crow/c-types: c-int, size_t, u-long

		main nat^(_ string[]) summon
			"cro\\+w" test-regex ("crow", "crooow", "duck")
			"[0-9" test-regex ("42",)
			()

		test-regex void(source string, candidates string[]) summon
			trusted match source parse
			as ok regex
				for x : candidates
					info log "{source} matches {x}? {regex matches x}"
				regex free
			as error e
				error log "bad regex {source}: {e}"

		regex record mut by-ref
			wrapped mut regex_t

		# Unsafe because the caller must 'free' the regex
		parse (regex, string) result(source string) unsafe
			res regex = (),
			err = &res.wrapped regcomp source.to, ()
			if err == REG_NOERROR
				res ok
			else
				buf char8 mut[] = 1000 n-of "\0"
				_ = err regerror &res.wrapped, buf.begin-pointer, buf.size
				res free
				"{buf.begin-pointer.as-const}" error

		free void(a regex) unsafe
			&a.wrapped regfree

		matches bool(a regex, candidate string)
			err = trusted &a.wrapped regexec candidate.to, (), (), ()
			if err == REG_NOERROR
				true
			elif err == REG_NOMATCH
				false
			else
				buf char8 mut[] = 1000 n-of "\0"
				trusted
					_ = err regerror &a.wrapped, buf.begin-pointer, buf.size
					throw buf.begin-pointer.as-const

		regex_t record mut extern
			buffer void mut*
			allocated size_t
			used size_t
			syntax u-long
			fastmap char8 mut*
			translate nat8 mut*
			re_nsub size_t
			re_flags nat8

		new regex_t() unsafe
			(), (), (), (), (), (), (), ()

		regoff_t alias
			c-int

		regmatch_t record extern
			rm_so regoff_t
			rm_eo regoff_t

		reg_errcode_t enum(c-int) extern
			REG_ENOSYS = -1
			REG_NOERROR
			REG_NOMATCH
			_REG_BADPAT
			_REG_ECOLLATE
			_REG_ECTYPE
			_REG_EESCAPE
			_REG_ESUBREG
			_REG_EBRACK
			_REG_EPAREN
			_REG_EBRACE
			_REG_BADBR
			_REG_ERANGE
			_REG_ESPACE
			_REG_BADRPT

		regcomp reg_errcode_t(
			regex regex_t mut*,
			pattern c-string,
			cflags c-int,
		) c extern

		regfree void(preg regex_t mut*) c extern

		regexec reg_errcode_t(
			preg regex_t*,
			string c-string,
			nmatch size_t,
			pmatch regmatch_t mut*,
			eflags c-int,
		) c extern

		regerror size_t(
			errcode reg_errcode_t,
			preg regex_t*,
			errbuff char8 mut*,
			errbuf_size size_t,
		) c extern
	</crow-runnable>

	<p>
		This example can't be run on the web;
		you'll have to download and run it with <code>crow run ~/Downloads/regex.crow</code>.
		<br />
		This uses the <code>regex.h</code> library available on Linux.
		For an example on Windows, see <code>libraries/SDL2/SDL.crow</code> from where you downloaded Crow.
	</p>

	<aside>
		<h4>Specifying the library</h4>
		<p>
			<code>crow build</code> and <code>crow run</code> don't take linker options;
			these are inferred from your code.
			<br />
			If the library needs to be linked to with <code>-lfoo</code>,
			you could write <code>foo extern</code> instead of <code>c extern</code>.
			<br />
			For example, SDL functions are declared with <code>SDL2 extern</code>.
			<br />
			If that function is included in the compile, the library name gets added to the linker options.
		</p>
	</aside>

</section>
<section>
	<h2>Extern types</h2>
	<p>
		Notice that <code class="struct">regmatch_t</code> is marked
		<code class="keyword">extern</code>.
		This is required to use the type in an <code class="keyword">extern</code> function.
		<br />
		Otherwise, Crow would be free to layout the type any way it wants.
	</p>
	<p>
		Basic types like <code class="struct">nat64</code> that have C equivalents
		are all <code class="keyword">extern</code>.
		<br />
		<code class="struct">string</code> is not.
	</p>

	<aside class="small">
		<code class="keyword">extern</code> types are always <code class="keyword">by-val</code>,
		just like C <code class="keyword">struct</code>s.
	</aside>

	<aside class="danger">
		<h4>C equivalent types</h4>
		<p>
			In Crow, <code class="struct">int</code> always means <code class="struct">int64</code> on all systems.
			<br />
			This is not the case in C, so when declaring a C function,
			use an alias from {{doc/c-types}} like <code class="struct">c-int</code>.
		</p>
	</aside>
</section>
<section>
	<h2>Version differences</h2>
	<p>
		Sometimes you need to do different things on different platforms.
		{{doc/version}} has functions to help with that.
	</p>
	<crow-runnable>
		import
			crow/version: is-windows
			stdio: stdout
			unistd: write
			win32: DWORD, GetStdHandle, STD_OUTPUT_HANDLE, WriteFile

		main nat^(_ string[]) summon
			text nat8 array = "hello\n" to-bytes
			trusted if is-windows
				out = STD_OUTPUT_HANDLE.GetStdHandle
				written mut DWORD = 0
				_ = out WriteFile text.begin-pointer, text.size.to, &written, null
			else
				_ = stdout write text.begin-pointer, text.size
			()
	</crow-runnable>

	<p>
		Both branches of <code>if is-windows</code> are type-checked on all systems.
		But after that, the compiler keeps only the branch that matches your system.
		<br />
		On Windows, the <code>false</code> branch won't be compiled.
		On Linux, the <code>true</code> branch won't be compiled.
	</p>
	<p>
		Notice how all functions are imported unconditionally.
		Importing a function does <em>not</em> cause it to be included in the compilation.
		<br />
		Crow chooses what functions to include by starting with <code class="fun">main</code>,
		then repeatedly adding any function called by an included function.
		<br />
		If a function call is in the unused branch of a version check like <code>if is-windows</code>,
		it won't be included in that process.
	</p>

	<aside class="small">
		There's currently no way to make the contents of a type conditional on the system.
		<br />
		You can use a <code class="keyword">union</code> and use different parts of the union
		depending on the system.
	</aside>
</section>
