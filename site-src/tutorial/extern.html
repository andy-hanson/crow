<section>
	<h2>calling external libraries</h2>
	<p>
		Crow code can call functions defined in external libraries.
		<br />
		In this example, we use the <code>regex.h</code> library.
	</p>

	<crow-runnable no-run src="regex"></crow-runnable>

	<p>
		Since this needs to link to libraries on your system,
		you need to download and run <code>crow run regex.crow</code>.
	</p>
</section>
<section>
	<h3>extern functions</h3>

	<p>
		<code>regfree void(preg regex_t mut*) unsafe noctx extern</code> declares an
		<code class="keyword">extern</code> function,
		based on the function of the same name in <code>/usr/include/regex.h</code>.
		<br />
		<br />
		All <code class="keyword">extern</code> functions must be <code class="keyword">noctx</code>.
		<code class="keyword">noctx</code> means that it does not use crow's facilities
		for allocating memory, launching tasks, or throwing exceptions.
		<br />
		Since this function takes a pointer but has no way to validate it, it is <code class="keyword">unsafe</code>.
	</p>
	<p>
		The other <code class="keyword">extern</code> functions
		<code class="fun">regcomp</code>, <code class="fun">regexec</code>, and <code class="fun">regerror</code>
		are spread out over multiple lines for readability; this is a different syntax for the same thing.
	</p>

	<h3>extern types</h3>

	<p>
		Any type, such as <code class="struct">regex_t</code>,
		referenced by an <code class="keyword">extern</code> function
		must be marked <code class="keyword">extern</code> too.
		<br />
		Similarly, <code class="keyword">extern</code> types can only reference other
		<code class="keyword">extern</code> types.
		<br />
		(Non-<code class="keyword">extern</code> types can reference anything.)
	</p>

	<p>
		<code class="keyword">extern</code> ensures that the type has a layout like it would in C.
		<br />
		Types like <code class="keyword">nat64</code> with C analogs are <code class="keyword">extern</code>,
		but not crow-specific types like <code class="keyword">str</code>.
	</p>

	<p>
		A <code class="keyword">union</code> in crow is different from one in C,
		so those can't be <code class="keyword">extern</code>.
		<br />
		(Crow unions are discriminated; they know which member they store.
		C unions are undiscriminated, meaning they store some member but can't tell you which one.)
		<br />
		There is currently no way to declare a C <code class="keyword">union</code>
		in crow; most libraries don't expose these directly.
	</p>

	<h3>by-ref and by-val</h3>
	<p>
		An <code class="keyword">extern</code> type must be explicitly
		<code class="keyword">by-ref</code> (<em>by reference</em>) or
		<code class="keyword">by-val</code> (<em>by value</em>).
		<br />
		If a type <code class="struct">foo</code> is <code class="keyword">by-ref</code>,
		a <code class="struct">foo</code> value is equivalent to a <code>struct foo*</code> in C,
		meaning it is passed using a pointer.
		<br />
		If it is <code class="keyword">by-val</code>, it is equivalent to a <code>struct foo</code> in C,
		meaning it is be passed by value.
		<br />
		Since a <code class="keyword">by-val</code> type is copied every time it's passed, it can't have mutable fields.
	</p>
	<p>
		<code class="keyword">by-ref</code> and <code class="keyword">by-val</code> apply everywhere the type is used:
		parameters, return values, fields in a record, etc.
	</p>
	<p>
		A non-<code class="keyword">extern</code> type will have a default choice of
		<code class="keyword">by-ref</code> or <code class="keyword">by-val</code> based on heuristics.
		<br />
		You might improve performance by choosing one explicitly.
		<br />
		Currently, the compiler chooses <code class="keyword">by-ref</code> most of the time but
		<code class="keyword">by-val</code> for small, immutable types.
	</p>
	<p>
		For an <code class="keyword">extern</code> type, choose
		<code class="keyword">by-ref</code> or <code class="keyworD">by-val</code>
		based on how the type is typically used in the library.
		<br />
		You can override the default:
	</p>

	<ul class="bullets">
		<li>
			For a <code class="keyword">by-ref</code> type:
			<br />
			In the <a href="/doc/crow/ptr.html"><code class="module">crow/ptr</code></a> module,
			there is a special <code class="struct">by-val</code> template
			that lets you pass any type by value, even if it would normally be by reference.
		</li>
		<li>
			For a <code class="keyword">by-val</code> type:
			<br />
			Use a pointer to pass it by reference.
		</li>
	</ul>
</section>
<section>
	<h3>pointers</h3>

	<p>
		<code>regex_t mut*</code> declares a mutable pointer type, equivalent to <code>regex_t*</code> in C.
		<br />
		<code>regex_t*</code> is an immutable pointer type, equivalent to <code>const regex_t*</code> in C.
		<br />
		Unlike in C, a const pointer isn't a subtype of a mutable one,
		so you must call <code class="fun">as-const</code>.
	</p>
	<p>
		Accessing a pointer works like with <code class="struct">cell</code>;
		<code>*x</code> gets the value and <code>*x := v</code> sets it.
	</p>
	<p>
		The function <code>as-ptr</code> converts a cell to a pointer.
		<br />
		Be sure to maintain a reference to the <code class="struct">cell</code>,
		since the garbage collector traces that, but not pointers.
	</p>
</section>
<section>
	<h3>C types</h3>

	<p>
		A C <code class="keyword">int</code> is not the same as a crow <code class="struct">int</code>.
		<br />
		A crow <code class="struct">int</code> is always 64 bits,
		but a C <code class="keyword">int</code> is usually shorter.
		<br />
		Always use <code class="struct">c-int</code> when translating cooe from C.
	</p>
	<p>
		The <code>crow/c-types</code> module has other useful types from C like <code class="struct">size_t</code>.
	</p>
	<p>
		<code class="struct">c-str</code> is equivalent to <code>char*</code>,
		and implies (but does not enforce) that it should end in a <code>"\0"</code> character.
	</p>
</section>
<section>
	<h2>patterns for using C libraries</h2>

	<section>
		<h3>pointer to one: cell</h3>
		<p>
			Many C libraries expect to receive a pointer to data to fill in.
			<br />
			C examples will often declare an uninitialized variable and
			get a pointer to it with <code>&x</code>; that's not supported in crow.
			<br />
			Instead, create a <code class="struct">cell</code> and use <code class="fun">as-ptr</code>.
			That's what <code>new regex(source str)</code> does.
			<br />
			This function can be marked <code class="keyword">trusted</code> despite calling the unsafe function
			<code class="fun">regcomp</code> because it knows that the pointer will be valid.
		</p>
		<p>
			Unlike a variable in C, a <code class="struct">cell</code> needs an initial value;
			since it doesn't really matter, <code>new regex_t() unsafe</code> just uses an empty value for every field.
		</p>
	</section>

	<section>
		<h3>pointer to many: mut[]</h3>
		<p>
			In the <code class="keyword">else</code> branch of <code class="fun">matches</code>,
			we need to call <code class="fun">regerror</code>, which takes a buffer to write its output.
			<br />
			Such a buffer would typically be allocated on the stack, which is not allowed in crow.
			<br />
			Instead, create a <code class="keyword">mut[]</code> and use its <code class="fun">begin-pointer</code>.
			<br />
			<code>to-str</code> here converts a C string to a crow string.
		</p>
	</section>
</section>


