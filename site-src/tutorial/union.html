<section>
	<h2>Unions</h2>
	<p>While a record stores many values,
		a union stores exactly one of several possible values.</p>
	<p>Unlike a union in C, a union in crow remembers which value it stores,
		so you can't accidentally access the wrong one.
	</p>
	<crow-runnable src="union"></crow-runnable>
	<p>Here we define a <code class="struct-ref">hitbox</code> union which is either a
		<code class="struct-ref">circle</code>, <code class="struct-ref">rect</code>,
		or <code class="struct-ref">empty</code>.

		A union doesn't need any cooperation from the member types to work.
		(You can even put <code class="struct-ref">nat</code> in a union.)
	</p>
	<h4>Implicit conversion to union</h4>
	<p>Unlike a record, a union doesn't generate any functions for creating the union.
		<br />
		Instead, it introduces crow's only kind of implicit conversion:
		a member of a union implicitly converts to the union.
	</p>
	<p>In <code>c contains? (1.7 vec-2 1.8)</code>, <code>c</code> is a <code
			class="struct-ref">circle</code>
		but is implicitly converted to a <code class="struct-ref">hitbox</code>
		because that's what <code class="fun-ref">contains?</code> expects.
	</p>
	<h4>match</h4>
	<p>There are no functions generated for getting the members of a union.
		The only thing you can do with a union is <code class="keyword">match</code> it.
		This means you do a different thing depending which value is stored in the union.</p>
	<p>The syntax <code>as circle c</code> means this is the case for <code
			class="struct-ref">circle</code>,
		and introduces a local variable <code>c</code> which is the
		<code class="struct-ref">circle</code> that the union contained.
		The local is optional, as in the <code>as empty</code> case.
	</p>
	<p>The cases of a <code class="keyword">match</code> must have the same order as the members of the
		union.
		<br />
		(You can't write <code>as rect</code> before <code>as circle</code>.)
	</p>
</section>
<a id="next" href="template.html">Next: Templates and specs</a>
