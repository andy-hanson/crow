<section>
	<h2>fun</h2>
	<p>A <em>function value</em> is a value that implements a function.</p>

	<crow-runnable>
		main nat^(_ string[]) summon
			xs string[] = "crow", "bar", "sea", "weed"
			ys = xs map-pairs (x, y) => "{x}-{y}"
			zs = ys map-pairs (x, y) =>
				"{x}, {y}"
			info log ("; " join zs)
			()

		# converts (a, b, c, d, ...) to (f[a, b], f[c, d], ...)
		map-pairs string[](xs string[], f fun string(string, string))
			if xs.size >= 2
				f[xs[0], xs[1]] ~ (xs[2 .. end] map-pairs f)
	</crow-runnable>

	<h3>syntax for function values</h3>
	<p>
		<code>(x, y) => "{x}-{y}"</code> creates a function value with two parameters
		<code class="param">x</code> and <code class="param">y</code>.
		<br />
		If there is a single parameter, the parentheses can be ommitted, as in <code>x => x + 1</code>.
	</p>
	<p>
		Parameter types of a function value are always inferred.
	</p>
	<p>
		The result of the function value can be written inline or in an indented block.
	</p>

	<h3>function type syntax</h3>
	<p>
		<code>fun str(str, str)</code> means a function that returns a 	<code class="struct">str</code> given a
		<code class="struct">str</code> and <code class="struct">str</code>.
		<br />
		For another example, <code>fun bool(nat)</code> is a function returning a <code class="struct">bool</code>
		given a <code class="struct">nat</code>.
	</p>

	<h3>calling function values</h3>

	<p>
		The function value is called like <code>f[xs[0], xs[1]]</code>.
		<br />
		<code>f[a, b]</code> is shorthand for <code>f subscript a, b</code>,
		so the sholw expression is <code>f subscript (xs subscript 0), (xs subscript 1)</code>.
		<br />
		(<code class="fun">subscript</code> is overloaded for both arrays and function values.)
	</p>
</section>

<section>
	<h2>closures</h2>

	<p>
		Unlike a top-level function, a function value can refer to run-time data.
		<br />
		This is called a <em>closure</em>.
	</p>

	<crow-runnable>
		main nat^(_ string[]) summon
			fryer = "fried" make-cooker
			baker = "baked" make-cooker
			info log fryer["plaintain"]
			info log baker["potato"]
			()

		make-cooker fun string(string)(type string)
			b => "{type} {b}"
	</crow-runnable>

	<p>
		In this example, the <code class="param">type</code> variable becomes part of the closure
		returned by <code class="fun">make-cooker</code>.
	</p>
</section>

<section>
	<h2>act</h2>

	<p>
		Most types in crow are immutable, such as <code class="struct">nat</code>,
		<code class="struct">str</code>, or even <code class="struct">nat[]</code>.
		<br />
		Exceptions include <code class="struct">cell</code>, <code class="struct">nat mut[]</code>,
		or a record with a <code class="keyword">mut</code> field.
	</p>
	<p>
		The closure of a <code class="struct">fun</code> can't be mutable.
		<br />
		For that, there is <code class="struct">act</code>,
		which works the same way as <code class="struct">fun</code>,
		but can have a mutable closure.
		<br />
	</p>

	<p>
		Most functions that take a function value take an <code class="struct">act</code>
		to give the caller more flexibility.
	</p>

	<crow-runnable>
		main nat^(_ string[]) summon
			xs string[] = "crow", "raven"
			count mut nat = 0
			ys string[] = for x : xs
				count +:= 1
				"{count}: {x}"
			info log ("; " join ys)
			()
	</crow-runnable>

	<p>
		In the next section we'll see why the difference between
		<code class="keyword">fun</code> and <code class="keyword">act</code> matters.
	</p>
</section>
