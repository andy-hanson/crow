<section>
	<h2>declaring templates</h2>
	<p>
		We've seen many templates so far; for example,
		<code>fut nat</code> instantiates the <code class="struct">fut</code> template, and
		<code>nat[]</code> instantiates the <code class="struct">arr</code> template.
		Dictionary and function types are also just syntax for templates.
	</p>
	<p>
		A <em>template</em> is any function or type that has type parameters.
		<br />
		When the type is used, those type parameters are filled in with actual types,
		which are called the type arguments.
		<br />
		A <em>concrete</em> function or type is one with all type arguments filled in;
		<code>fut</code> is a template and <code>fut nat</code> is a concrete type.
	</p>
	<p>
		The example below declares a <code class="struct">list</code> type
		that uses a type parameter for the element type.
	</p>
	<crow-runnable>
		main nat^(_ string[]) summon
			nats nat linked-list = 1 ~ (2 ~ ())
			floats float linked-list = 0.5 ~ ()
			info log "nats size: {nats size}"
			info log "floats size: {floats size}"
			0,

		linked-list[t] record
			head t list-node?

		list-node[t] record
			value t
			next t linked-list

		new[t] t linked-list()
			(),

		~ ~[t] t linked-list(head t, tail t linked-list)
			((head, tail),),

		size[t] nat(a t linked-list)
			res mut = 0
			for _ : a
				res +:= 1
			res

		iterate[t] bool(list t linked-list, f act bool(t))
			if node ?= list head
				f[node.value] || node.next iterate f
	</crow-runnable>
</section>
<section>
	<h3>template syntax</h3>
	<p>
		<code>list&lt;a> record</code> declares a type parameter <code class="tparam">a</code>,
		making <code class="struct">list</code> a type template.
		<br />
		Similarly, <code>fold&lt;a, b></code> declares two type parameters,
		<code class="tparam">a</code> and <code class="tparam">b</code>,
		making <code class="fun">fold</code> a function template.
	</p>
	<p>
		When using (not declaring) a type template,
		the <code>&lt;></code> may be omitted if there is only one type argument.
		<br />
		That lets you write <code>list a</code> instead of <code>list&lt;a></code>.
		<br />
		Sometimes you still need the <code>&lt;></code>;
		since <code>node a?</code> would mean <code>node&lt;a?></code>,
		you must write <code>node&lt;a>?</code> instead.
	</p>
</section>
<section>
	<h3>type inference</h3>
	<p>
		When calling a function template like <code class="fun">size</code>,
		you don't need to supply the type arguments; they are inferred.
		<br />
		In the rare case you need to supply a type argument, you can write this like <code>size@&lt;nat></code>.
		<br />
		(There's no syntax to do this for operators like <code class="fun">~</code>.)
	</p>
</section>
