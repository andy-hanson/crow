import
	crow/parse:
		/, ~~, and-return, exact, grammar, grammar-skip, many, map, nat, parse, text-delimited,
		text-not-containing-any, to-string
	./module:
		body_, doc-comment, exports, fields, has-private-fields, is-mut, members, module,
		module-export, module-export-value, name, param, params, path, purity, record-field,
		return-type, spec-ref, spec-sig, specs, target, type-param, type-params, type, type-args,
		type-ref, union-member, value, variadic

module-content string(a module)
	exports = "" join for x : a exports
		x export-content
	doc = unless a.doc-comment is-empty
		"""\n<section class="module-doc">{a.doc-comment format-comment}</section>"""
	"{a.path module-top}{doc}\n{exports}"

module-top string(path string)
	url = "https://github.com/andy-hanson/crow/blob/master/include/{path}.crow"
	"""<h1><code class="module">{path}</code> <a class="source-link" href="{url}">(source)</a></h1>"""

.export-content string(a module-export)
	type-params = a.type-params type-params-content
	header-extra = a.value export-header-extra
	"""<section class="doc {a.value section-class}">
		<h4><code class="{a.value name-class}">{a name}</code>{type-params} {header-extra}</h4>
		{a.value export-body}
		{a.doc-comment format-comment}
	</section>
	"""

.section-class string(a module-export-value)
	match a
	as alias-decl _
		"alias"
	as builtin-decl
		"builtin"
	as enum-decl _
		"enum"
	as extern-decl
		"extern"
	as flags-decl _
		"flags"
	as fun-decl _
		"function"
	as record-decl _
		"record"
	as spec-decl _
		"spec"
	as union-decl _
		"union"

.name-class string(a module-export-value)
	match a
	as alias-decl _
		"struct"
	as builtin-decl
		"struct"
	as enum-decl _
		"struct"
	as extern-decl
		"struct"
	as flags-decl _
		"struct"
	as fun-decl _
		"fun"
	as record-decl _
		"struct"
	as spec-decl _
		"spec"
	as union-decl _
		"struct"

.type-params-content string(a type-param[])
	unless a is-empty
		type-params = ", " join for x : a
			"""<code class="type-param">{x name}</code>"""
		"""<span class="type-params">[{type-params}]</span>"""

.export-header-extra string(a module-export-value)
	match a
	as alias-decl _
		"alias" keyword
	as builtin-decl
		"builtin" keyword
	as enum-decl _
		"enum" keyword
	as extern-decl
		"extern" keyword
	as flags-decl _
		"flags" keyword
	as fun-decl f
		f.return-type return-type-and-params-and-specs f.variadic, f.params, f.specs
	as record-decl r
		"{"record" keyword}{r.purity purity-content}"
	as spec-decl s
		match s body_
		as spec-builtin
			"spec builtin" keyword
		as spec-sigs _
			"spec" keyword
	as union-decl u
		"{"union" keyword}{u.purity purity-content}"

.purity-content string(a purity)
	match a
	as p-data
		""
	as p-sendable
		" sendable" keyword
	as p-mut
		" mut" keyword

.export-body string(a module-export-value)
	match a
	as alias-decl al
		"""<div class="alias-target">{al.target type-ref-content}</div>"""
	as builtin-decl
		()
	as enum-decl e
		e.members enum-flags-members-content
	as extern-decl
		()
	as flags-decl f
		f.members enum-flags-members-content
	as fun-decl _
		()
	as record-decl r
		pre = if r.has-private-fields
			"""<p class="has-private">(has private fields)</p>"""
		fields = "" join for x : r fields
			x field-content
		"""{pre}<ul class="members">{fields}</ul>"""
	as spec-decl s
		match s body_
		as spec-builtin
			""
		as spec-sigs sigs
			sigs-content = "" join for x : sigs
				x spec-sig-li
			"""<ul class="sigs">{sigs-content}</ul>"""
	as union-decl u
		members = "" join for x : u members
			x union-member-content
		"""<ul class="members">{members}</ul>"""

.enum-flags-members-content string(a symbol[])
	members = "" join for x : a
		"""<li><code class="member">{x}</code></li>"""
	"""<ul class="members">{members}</ul>"""

.field-content string(a record-field)
	name = """<code class="member">{a name}</code>"""
	mut-kw = a.is-mut ? """ <code class="keyword">mut</code>"""
	"<li>{name}{mut-kw} {a.type type-ref-content}</li>"

.union-member-content string(a union-member)
	name = """<code class="member">{a name}</code>"""
	type = if t ?= a type
		" {t type-ref-content}"
	"<li>{name}{type}</li>"

.spec-sig-li string(a spec-sig)
	rt = a.return-type return-type-and-params-and-specs false, a.params, ()
	"""<li class="sig"><code class="fun">{a name}</code> {rt}</li>"""

.return-type-and-params-and-specs string(return-type type-ref, variadic bool, params param[], specs spec-ref[])
	params-content = ", " join for x : params
		x param-content variadic
	specs-span = unless specs is-empty
		contents = ", " join for x : specs
			x spec-ref-content
		""" <span class="specs">{contents}</span>"""
	"""{return-type type-ref-content}<span class="params">({params-content})</span>{specs-span}"""

.param-content string(a param, variadic bool)
	var = variadic ? """<code class="keyword">...</code>"""
	"""<span class="param">{var}<code class="param">{a name}</code> {a.type type-ref-content}</span>"""

.type-ref-content string(a type-ref)
	name = a name
	if name == "option"
		a type-ref-suffix "?"
	elif name == "list"
		a type-ref-suffix "[]"
	elif name == "mut-list"
		a type-ref-suffix " mut[]"
	elif name == "dict"
		a type-ref-dict "["
	elif name == "mut-dict"
		a type-ref-dict " mut["
	elif name == "const-pointer"
		a type-ref-suffix "*"
	elif name == "mut-pointer"
		a type-ref-suffix " mut*"
	elif type ?= name get-fun-type
		a type-ref-fun type
	else
		"""{a.type-args type-args-content}<code class="struct">{name}</code>"""
.type-ref-suffix string(a type-ref, suffix string)
	"{a.type-args.only type-ref-content}{suffix keyword}"
.type-ref-dict string(a type-ref, open string)
	assert a.type-args.size == 2
	"{a.type-args[0] type-ref-content}{open keyword}{a.type-args[1] type-ref-content}{"]" keyword}"
.type-ref-fun string(a type-ref, type string)
	params = ", " join for x : a.type-args tail
		x type-ref-content
	kw = " {type}" keyword
	"{kw} {a.type-args[0] type-ref-content}({params})"

.get-fun-type string?(name symbol)
	("fun", "fun-act", "fun-ref") find type =>
		if rest ?= name.to-string try-remove-start type
			nat parse rest is-ok

.spec-ref-content string(a spec-ref)
	"""<span class="spec">{a.type-args type-args-content}<code class="spec">{a name}</code></span>"""

.type-args-content string(a type-ref[])
	if a.size == 0
		""
	elif a.size == 1
		"{a.only type-ref-content} "
	else
		"({", " join for x : a; x type-ref-content}) "

.keyword string(a string)
	"""<code class="keyword">{a}</code>"""

.only[t] t(a t[])
	assert a.size == 1
	a[0]

format-comment string(a string)
	match comment-part.many parse a.strip
	as ok parts
		parts format-comment-parts
	as err e
		throw "Could not parse doc comment:\n{a}\n\nReason: {e}"

.format-comment-parts string(parts comment-part[])
	res mut string = "<p>"
	for part : parts
		res := res ~~ match part
		as text t
			t
		as multi-newline
			"</p><p>"
		as newline
			"<br/>"
		as code-short code
			"<code>{code html-escape}</code>"
		as code-block code
			"</p><div class=\"code-block\">{code html-escape}</div><p>"
	"{res}</p>"

test
	"".format-comment is "<p></p>"
	" a\nb ".format-comment is "<p>a<br/>b</p>"
	"a\n\nb".format-comment is "<p>a</p><p>b</p>"
	"a\n\n\nb".format-comment is "<p>a</p><p>b</p>"
	"Use `x`\nNot `y`".format-comment is "<p>Use <code>x</code><br/>Not <code>y</code></p>"
	actual = "It is:\n\n```\nfoo\n```\nGot it?".format-comment
	actual is "<p>It is:</p><div class=\"code-block\">foo</div><p>Got it?</p>"

.html-escape string(a string)
	a replace "<", "&lt;"

.comment-part union
	text string
	multi-newline
	newline
	code-short string
	code-block string

.comment-part comment-part grammar()
	code-block / newlines / code-short / text
.newlines comment-part grammar()
	(("\n\n" ~~ skip-newlines) and-return multi-newline) / ("\n" exact newline)
.code-block comment-part grammar()
	block = "```" text-delimited "```"
	skip-newlines ~~ block ~~ skip-newlines map x => x.strip code-block
.skip-newlines grammar-skip()
	"\n".exact many
.code-short comment-part grammar()
	"`" text-delimited "`" map x => x code-short
.text comment-part grammar()
	("\n", "`").text-not-containing-any map x => x text
