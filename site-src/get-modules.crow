import
	crow/io/process: exit-code, spawn-and-wait-result, stderr, stdout
	crow/parse: !, ~~, parse, spaces
	crow/version: is-windows
	./module:
		alias-decl, builtin-decl, enum-decl, extern-decl, flags-decl, fun-decl, module,
		module-export, module-export-value, new, param, p-data, p-mut, p-sendable, purity,
		spec-decl, spec-ref, type-param, type-ref, record-decl, record-field, spec-builtin,
		spec-sig, spec-sigs, union-decl, union-member

get-modules module[](paths string[], remove-prefix string) summon
	result = crow-path spawn-and-wait-result "doc" ~ paths
	unless result.exit-code == 0 && result.stderr.is-empty
		throw "Could not get documentation: exit code {result exit-code}, stderr: {result stderr}"
	((json ~~ spaces) parse result.stdout)! to-modules remove-prefix

.crow-path string()
	if trusted is-windows
		"bin\\crow.exe"
	else
		"bin/crow"

.to-modules module[](a json, remove-prefix string)
	a.get-node-type is "root"
	for x : a["modules"]!.as-list!
		x to-module remove-prefix

.to-module module(a json, remove-prefix string)
	a.get-node-type is "module"
	path = (a["path"]!.as-string! try-remove-start remove-prefix)!
	path, a.get-comment, for x : a["exports"]!.as-list!
		x to-export

.get-comment string(a json)
	if c ?= a["comment"]
		c.as-string!

.get-node-type string(a json)
	a["_type"]!.as-string!

.to-export module-export(a json)
	a.get-node-type is "export"
	type-params type-param[] = if t ?= a["type-params"]
		for x : t.as-list!
			x to-type-param
	value = a["value"]! to-export-value
	a.get-name, a.get-comment, type-params, value

.to-export-value module-export-value(a json)
	type = a get-node-type
	if type == "alias"
		a.to-alias-decl alias-decl
	elif type == "builtin"
		builtin-decl
	elif type == "enum"
		a.to-enum-decl enum-decl
	elif type == "extern"
		extern-decl
	elif type == "flags"
		a.to-flags-decl flags-decl
	elif type == "fun"
		a.to-fun-decl fun-decl
	elif type == "spec"
		a.to-spec-decl spec-decl
	elif type == "record"
		a.to-record-decl record-decl
	elif type == "union"
		a.to-union-decl union-decl
	else
		throw "unexpected export type {type}"

.to-alias-decl alias-decl(a json)
	target = a["target"]! to-type-ref
	target,

.to-enum-decl enum-decl(a json)
	a.get-enum-flags-members,

.to-flags-decl flags-decl(a json)
	a.get-enum-flags-members,

.get-enum-flags-members symbol[](a json)
	for x : a["members"]!.as-list!
		x.as-string! string-to-symbol

.to-record-decl record-decl(a json)
	has-private = if h ?= a["has-private"]
		h.as-bool!
	a.get-purity, has-private, for x : a["fields"]!.as-list!
		x to-record-field

.get-purity purity(a json)
	if p ?= a["purity"]
		s = p.as-string!
		if s == "sendable"
			p-sendable
		else
			s is "mut"
			p-mut
	else
		p-data

.to-record-field record-field(a json)
	a.get-node-type is "field"
	is-mut = if m ?= a["mut"]
		m.as-bool!
	a.get-name, a.get-type, is-mut

.to-union-decl union-decl(a json)
	a.get-purity, for x : a["members"]!.as-list!
		x to-union-member

.to-union-member union-member(a json)
	a.get-node-type is "member"
	type type-ref? = if t ?= a["type"]
		t.to-type-ref,
	a.get-name, type

.get-name symbol(a json)
	a["name"]!.as-string! string-to-symbol

.to-type-param type-param(a json)
	a.get-name,

.get-type type-ref(a json)
	a["type"]! to-type-ref

.get-type-args type-ref[](a json)
	if args ?= a["type-args"]
		for x : args.as-list!
			x to-type-ref

.to-fun-decl fun-decl(a json)
	variadic = if v ?= a["variadic"]
		v.as-bool!
	a.get-return-type, variadic, a.get-params, if s ?= a["specs"]
		for x : s.as-list!
			x to-spec-ref

.to-spec-decl spec-decl(a json)
	parents spec-ref[] = for x : a["parents"]!.as-list!
		x to-spec-ref
	body-json = a["body"]!
	type = body-json get-node-type
	body_ = if type == "builtin"
		spec-builtin
	elif type == "sigs"
		sigs spec-sig[] = for x : body-json["sigs"]!.as-list!
			x to-sig
		sigs spec-sigs
	else
		throw "unexpected spec type {type}"
	parents, body_

.to-sig spec-sig(a json)
	a.get-comment, a.get-name, a.get-return-type, a.get-params

.get-return-type type-ref(a json)
	a["return-type"]! to-type-ref

.get-params param[](a json)
	for x : a["params"]!.as-list!
		x to-param

.to-param param(a json)
	a.get-node-type is "param"
	a.get-name, a.get-type

.to-type-ref type-ref(a json)
	node-type = a get-node-type
	name = a["name"]!.as-string! string-to-symbol
	if node-type == "type-param"
		name, ()
	else
		node-type is "struct"
		name, a.get-type-args

.to-spec-ref spec-ref(a json)
	node-type = a get-node-type
	name = a["name"]!.as-string! string-to-symbol
	if node-type == "special"
		name, ()
	else
		node-type is "spec"
		name, a.get-type-args
