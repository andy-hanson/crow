<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="utf-8">
	<title>The Noze Programming Language</title>
	<link rel="icon" href="./icon.png" type="image/x-icon"/>
	<link rel="stylesheet" href="./index.css" />
	<script type="module" async src="./script/Compiler.js"></script>
	<script type="module" async src="./script/index.js"></script>
	</head>
	<body class="language-noze">

		I <span data-tooltip="I mean really, really" class="diag">really</span> like pie.

		<!--<section>
			<h2>Installation</h2>

			Noze has the following dependencies:

			<ul>
			<li><a href="https://dlang.org/download.html">DMD</a>: install version 2.093 or greater.</li>
			<li><a href="https://www.libsdl.org/">SDL2: Install this from your package manager.</a></li>
			</ul>

			Then to install Noze:

			<ul>
			<li>Download the repo <b>(TODO: HOW?)</b></li>
			<li>Run <code>./build</code> to build.</li>
			<li>You may add the <code>bin</code> directory to your path, or just write the path explicitly.</li>
			</ul>
		</section>

		<section>
			<h2>Types</h2>
			Noze has only a few kinds of types:
			<ul>
			<li>
				<span class='list-item-bold'><code class='keyword'>builtin</code></span>:
				Things like <code>bool</code> that can't be expressed in terms of other types.
			</li>
			<li>
				<span class='list-item-bold'><code class='keyword'>extern-ptr</code></span>:
				A pointer to data from an external library that can only be used through that library.
			</li>
			<li>
				<span class='list-item-bold'><code class='keyword'>record</code></span>:
				Type of a value that contains several named values.
				An example would be a <code>point</code> with <code>x</code> and <code>y</code> fields.</li>
			<li>
				<span class='list-item-bold'><code class='keyword'>union</code></span>:
				Type of a value that is one of several possibilities.
				An example would be a <code>shape</code> with <code>circle</code> or <code>square</code> choices.
			</li>
			</ul>

			<code class='keyword'>record</code> and <code class='keyword'>union</code> types
			can each have primitive operations for using them.
			<code class='keyword'>builtin</code> and <code class='keyword'>union</code> types
			can only be used through certain functions and are otherwise inscrutable.
		</section>-->

		<section>
			<h2>Records</h2>

			<noze-runnable></noze-runnable>

			<!--<pre><code data-src="example-record.nz">
import
	io

| Declare a record type.
point record
	x float
	y float

| Declare a function returning a point and taking no arguments.
create-point point()
	| The type is usually inferred from the context.
	| If not you can write `new<point>`.
	new 1, 2

| Declare a function named 'get-x' returning a float and taking a point named 'a'.
get-x float(a point)
	| Accessing a record member uses the same syntax as calling a function.
	a x

| Ignore this header for now; just know that this is the main function.
main fut exit-code(args arr str) summon
	| Calls the function 'create-point' and names the result 'p'
	p = create-point
	| Calls the function 'get-x' on 'p'
	p-x = p get-x
	| This shows the prefix syntax for function calls (in addition to the usual syntax for `to-str`).
	| This is equivalent to `print_sync(to_str(p_x))` in C.
	| The syntax choice is not tied to the function; you can use any call syntax for any function.
	print-sync: p-x to-str
	zero resolved
			</code></pre>-->
		</section>



	</body>
</html>
