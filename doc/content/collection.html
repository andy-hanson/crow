<section>
	<h2>Collections</h2>

	<h3>opt</h3>

	<code class="struct-ref">opt ?t</code> is like a collection with 0 or 1 value in it.

	<code class="struct-ref">opt ?t</code> is
	<code class="struct-ref">none</code> or <code class="struct-ref">some ?t</code>.

	<code class="struct-ref">none</code> is an empty record,
	and <code class="struct-ref">some</code> is a record with a single field <code class="fun-ref">value</code>.

	<crow-runnable src="opt"></crow-runnable>

	<code class="struct-ref">opt</code> is useful for values
	that might be null or a special code like -1 in other languages.

	For example, it shows up when attempting to find something in a dict.

	<h3>arr</h3>

	The <code class="struct-ref">arr</code> type, short for "array", stores multiple values contiguously in memory.
	An <code class="struct-ref">arr</code> is immutable, though it can store values with internal mutability.
	For a type template, the purity is affected by the type arguments,
	so <code>arr nat</code> is <code class="spec-ref">data</code> but <code>arr fut nat</code> is not.

	<crow-runnable src="arr"></crow-runnable>

	An array literal is specified inside of <code>[]</code>.
	<br/>

	<code>a[i]</code> gets the <code>i</code>th member of the array (0-indexed).
	<br />
	This syntax is equivalent to writing <code>a subscript i</code>; it's not particular to arrays.
	<br />

	<code class="fun-ref">-></code> is an operator, so <code>1 -> 4</code> is a function call.
	The <code class="fun-ref">-></code> function just constructs a templated record type <code>arrow</code>
	which has <code class="fun-ref">from</code> and <code class="fun-ref">to</code> fields of arbitrary type.

	Then, there is a function <code>subscript arr ?t(a arr ?t, range arrow&lt;nat, nat>)</code> that slices an array.
	The beginning of the range is inclusive and the end is exclusive.
	Slicing an array doesn't allocate a new array.
	In low-level terms, an array is just a pointer and size,
	and slicing it changes the pointer and size without changing the data.

	<h3>mut-arr</h3>

	The <code class="struct-ref">mut-arr</code> type is like <code class="struct-ref">arr</code>
	but <code class="keyword">mut</code>.

	<crow-runnable src="mut-arr"></crow-runnable>

	<code class="struct-ref">opt</code> and <code class="struct-ref">arr</code> are the only aut-imported collections,
	all others need to be explicitly imported.

	<code>mut-arr</code> has mutable contents, but the size is not mutable, so it's limited in use.

	The syntax <code>ingredients[2] := "chocolate"</code> is short for
	<code>ingredients set-subscript 2, "chocoloate"</code>.

	The <code class="fun-ref">arr</code> function imported from <code class="import">collection.mut-arr</code>
	converts to an <code class="struct-ref">arr</code>.
	<code class="struct-ref">arr</code> is immutable, so this creates a copy.

	Since it's also just a pointer and size, <code class="struct-ref">mut-arr</code> can be sliced just like
	<code class="struct-ref">arr</code>, and the slice will share the same mutable data.

	<h3>mut-list</h3>

	<code class="struct-ref">mut-list</code> is like <code class="struct-ref">mut-arr</code> but with mutable size.
	(It retains an excess capacity, so not every increase to the size requires a new allocation.)

	<crow-runnable src="mut-list"></crow-runnable>

	(TODO: mention that slicing it creates a copy)

</section>
