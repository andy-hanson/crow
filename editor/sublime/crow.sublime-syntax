%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
# https://www.sublimetext.com/docs/3/scope_naming.html

# DEVELOPING:
# In a '.crow' file, use ctrl-alt-shift-p to see the scope at the cursor.

variables:
  name: '(([a-z][a-z0-9\-\?\!]*)|[\=\!\<\>\+\-\*\/\^\~]+)'
  type_name: '\??{{name}}'
  # Declarations end at the next unindented line.
  # We don't want to consume any characters at that line,
  # so use lookahead to match the beginning of a line, then any non-whitespace character.
  unindented_line: '(?=^\S)'
  spec_use_keyword: 'builtin|extern|global|noctx|summon|trusted|unsafe'

name: crow
file_extensions:
  - crow
scope: source.crow
contexts:
  prototype:
    # This is a part of every context
    # type argument
    - match: '(?<=[a-z0-9\-\?])<'
      scope: comment # punctuation.definition.generic.begin
      push: type_args
    - match: "[A-Z]"
      scope: invalid
    - match: '^###\n'
      scope: comment
      push: block_comment
    - match: '#.*'
      scope: comment
    - match: '^\s*region[^\n]*\n'
      scope: comment

  block_comment:
    - match: '^###'
      scope: comment
      pop: true
    - match: '.*'
      scope: comment

  type_args:
    # TODO: this shouldn't be necessary to explicitly include the prototype, right?
    - include: prototype
    - match: ','
      scope: comment # punctuation.separator
    - match: '>|\)'
      scope: comment # punctuation.definition.generic.end
      pop: true
    # string in type arg: this happens with extern<"mangledName">
    - match: '"'
      push: string
    - match: '{{type_name}}'
      scope: storage.type

  main:
    - match: '\#\!.*$'
      scope: comment
    - match: (?=.)
      push: top_level

  top_level:
    - match: no-std
      scope: keyword
    - match: export|import
      scope: keyword
      push: after_export_or_import_keyword
    - match: test
      scope: keyword
      push: expression
    - match: '(\.)?{{name}}'
      # NOTE: Of course these won't all be functions.
      # But we don't know what kind of declaration it is yet unfortunately.
      # But luckily goto-definition will work even coming from a 'storage.type'.
      scope: entity.name.function.crow
      push: decl_after_name
      captures:
        1: comment

  decl_after_name:
    - match: '{{unindented_line}}'
      pop: true
    - match: alias
      scope: comment
      push: alias
    - match: builtin
      scope: comment
      pop: true
    - match: extern-ptr
      scope: comment
      pop: true
    - match: record
      scope: comment
      push: record
    - match: spec
      scope: comment
      push: spec
    - match: builtin-spec
      scope: comment
    - match: union
      scope: comment
      push: union
    - match: '{{type_name}}'
      scope: storage.type
      push: function

  after_export_or_import_keyword:
    - meta_scope: entity.name.namespace
    - match: ' '
      push: one_line_exports_or_imports
    - match: $
      push: multi_line_exports_or_imports
    - match: '{{unindented_line}}'
      pop: true

  one_line_exports_or_imports:
    - match: \.
      scope: punctuation
    - match: $
      pop: true

  multi_line_exports_or_imports:
    - match: \.
      scope: punctuation
    - match: '{{unindented_line}}'
      pop: true

  alias:
    - match: '{{unindented_line}}'
      pop: true
    - match: '{{name}}'
      scope: storage.type
      push: type_ending_in_nl

  record:
    - match: '{{unindented_line}}'
      pop: true
    - match: 'data|force-sendable|mut|sendable'
      scope: keyword
    - match: $
      push: record_body

  record_body:
    - match: '{{unindented_line}}'
      pop: true
    - match: 'by-ref|by-val'
      scope: keyword
    - match: '{{name}}'
      scope: identifier
      push: type_ending_in_nl

  spec:
    - match: '{{unindented_line}}'
      pop: true
    # Each line is a signature
    - match: '{{name}}'
      scope: entity.name.function.crow
      push: spec_signature

  spec_signature:
    - match: '{{type_name}}'
      scope: storage.type
    - match: '\('
      scope: comment
      push: parameters
    - match: '$'
      pop: true

  union:
    - meta_scope: storage.type
    - match: '{{unindented_line}}'
      pop: true

  type_ending_in_nl:
    - match: '\smut\s'
      scope: keyword
    - match: '{{type_name}}'
      scope: storage.type
    - match: $
      pop: true

  function:
    - match: '\s+{{type_name}}'
      scope: storage.type
    - match: '(?=\()'
      push: fun_signature_starting_at_l_paren
    # If we didn't see '(', this is a multiline function
    - match: $
      push: multiline_params
    - match: '{{unindented_line}}'
      pop: true

  multiline_params:
    - match: '^spec'
      scope: comment
      push: multiline_spec_uses
    - match: '^body'
      scope: comment
      push: expression
    - match: '{{unindented_line}}'
      pop: true
    - match: '{{name}}'
      scope: identifier
      push: type_ending_in_nl

  spec_common:
    - match: '{{unindented_line}}'
      pop: true
    - match: '{{spec_use_keyword}}'
      scope: keyword
    - match: '{{name}}'
      scope: entity.name

  multiline_spec_uses:
    - match: '^body'
      scope: comment
      push: expression
    - include: spec_common

  fun_signature_starting_at_l_paren:
    - match: '\('
      scope: comment # punctuation.section.group.begin
      push: parameters
    # The signature ends at the end of the line, then the body follows.
    - match: (?=$)
      push: expression
    - include: spec_common

  parameters:
    - match: '[a-z0-9\-]+'
      scope: identifier
      push: parameter_type
    - match: '\)'
      scope: comment # punctuation.section.group.end
      pop: true

  parameter_type:
    - match: '{{type_name}}'
      scope: storage.type
    - match: '\('
      scope: comment
      push: type_args
    - match: ','
      scope: comment # punctuation.separator
      pop: true
    # If the next character is a ')' -- don't consume it, pop and let 'parameters' do that.
    - match: '(?=\))'
      pop: true

  expression:
    - match: '{{unindented_line}}'
      pop: true
    # Skip beginning-of-line indent
    - match: ^\s+
    # '<-' at beginning of line
    - match: '<-'
      scope: keyword
    # `foo:`
    - match: '{{name}}(\:)\s+'
      scope: variable.function.crow
      captures:
        3: comment
    # `.foo`
    - match: (\.){{name}}
      scope: variable.function.crow
      captures:
        1: comment # punctuation.accessor
    # numbers
    - match: '[\+\-]?((0((b[01]+)|(o[0-8]+)|(x[\da-f]+)))|(\d+(\.\d+)?))'
      scope: constant.numeric

    # `foo. ` in a multiline new record
    - match: '{{name}}(\.)\s+'
      scope: comment

    # Keywords that are followed by a space
    - match: '(elif|if|match)\s+'
      scope: keyword
    # Other keywords
    - match: '(as|else|it)(?=$|<|\,|\s|\}|\.)'
      scope: keyword
    - match: '{{name}}'
      scope: identifier
    # FunAsLambda (&foo)
    - match: '\&{{name}}'
      scope: variable.function.crow
    # Lambda `\x y`
    - match: '(\\).*$'
      # parameters are identifiers
      scope: identifier
      captures:
        1: comment
    # `x = y` or `x <- y`
    - match: '\s+(\=|<-)\s+'
      scope: keyword
    # `"foo"`
    - match: '"'
      push: string
    - match: '[\(\[\]\)\{\}]'
      scope: comment # punctuation.section.embedded
    # Making sure that when we eat a comma, we eat the space after it too.
    - match: '\,\s+'
      scope: comment # punctuation.separator
    # `?=` in `if x ?= opt`
    - match: '\s+\?=\s+'
      scope: keyword
    # Call ` foo ` or ` foo: `
    - match: '\s+{{name}}(\:)?\s+'
      scope: variable.function.crow
      captures:
        3: comment
    - match: '\s+(:=)\s+'
      scope: keyword

  # Give 'new-arr' a scope to ensure that after type arguments are parsed (from 'prototype' scope), we eat a space
  new:
    - match: \s+
      pop: true

  string:
    - meta_scope: string.quoted
    - meta_include_prototype: false
    - match: '"'
      pop: true
    - match: ASS
      scope: constant.character.escape
    - match: \\.
      scope: constant.character.escape
    #- match: '\{'
    #  scope: constant.character.escape
    - match: \{([^}]*)\}
      scope: constant.character.escape
      captures:
        1: string.interpolated
