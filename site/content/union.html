<section>
	<h2>unions</h2>

	<p>
		While a record combines several values by storing all of them,
		a union combines several values by storing only one of them.
		Unlike a union in C, a union in crow remembers which value it stores,
		so you can't accidentally access the wrong one.
	</p>

	<crow-runnable src="union"></crow-runnable>

	Here we define a <code class="struct-ref">hitbox</code> union which is either a
	<code class="struct-ref">circle</code> or <code class="struct-ref">rect</code>.

	There is no subtyping, so a union is distinct from its members.

	The member types are separate types that exist independently of the union.
	They can be any kind of type except other unions.

	<h4>Implicit conversion to union</h4>

	Unlike a record, a union doesn't generate any functions for creating the union.
	Instead, it introduces crow's only kind of implicit conversion:
	a member of a union implicitly converts to the union.

	In <code>c contains? ...</code>, <code>c</code> is a <code class="struct-ref">circle</code>
	but is implicitly converted to a <code class="struct-ref">hitbox</code>
	because that's what <code class="fun-ref">contains?</code> expects.

	<h4>match</h4>

	There are similarly no getter functions generated.
	The only thing you can do with a union is <code class="keyword">match</code> it.
	This takes the code down a different branch depending on the type stored in the union.
	<br />
	The cases of a <code class="keyword">match</code> have to have the same order as the members of the union.
	<br />
	The syntax <code>as circle c</code> means this is the case for <code class="struct-ref">circle</code>,
	and introduces a local <code>c</code> which is the <code class="struct-ref">circle</code> that the union contained.
	The local is optional, as in the <code>empty</code> case.

</section>
