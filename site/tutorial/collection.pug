include ../pug-include/tutorial.pug
+tutorialPage("collection")
	section
		h2 Collections

		h3 opt

		p.
			<code class="struct-ref">opt ?a</code> is like a collection with 0 or 1 value in it.
			<code class="struct-ref">opt ?a</code> is
			<code class="struct-ref">none</code> or <code class="struct-ref">some ?a</code>.

			<br />
			<code class="struct-ref">none</code> is an empty record,
			and <code class="struct-ref">some</code> is a record with a single field <code class="fun-ref">value</code>.

		crow-runnable(src="opt")

		p.
			<code class="struct-ref">opt</code> is useful for values
			that might be null or a special code like -1 in other languages.

			For example, it shows up when attempting to find something in a dict.

	section
		h3 arr

		p.
			The <code class="struct-ref">arr</code> type, short for "array",
			stores multiple values contiguously in memory.
			An <code class="struct-ref">arr</code> is immutable, though it can store values with internal mutability.
			For a type template, the purity is affected by the type arguments,
			so <code>arr nat</code> is <code class="spec-ref">data</code> but <code>arr fut nat</code> is not.

		crow-runnable(src="arr")

		h4 array literals
		p An array literal is specified inside of <code>[]</code>.

		h4 Element access
		p.
			<code>a[i]</code> gets the <code>i</code>th member of the array (0-indexed).
			This syntax is equivalent to writing <code>a subscript i</code>; it's not particular to arrays.

		h4 Concatenation
		p.
			The <code class="fun-ref">~</code> function concatenates two arrays.
			<code class="struct-ref">str</code> is <code class="struct-ref">arr char</code>, so this works on them, too.

		h4 slicing
		p.
			<code>1 -> 4</code> calls the <code class="fun-ref">-></code> function,
			which just constructs a templated record type <code>arrow</code>
			which has <code class="fun-ref">from</code> and <code class="fun-ref">to</code> fields of arbitrary type.

			Then, there is a function <code>subscript arr ?a(a arr ?a, range arrow&lt;nat, nat>)</code>
			that slices an array.
			The beginning of the range is inclusive and the end is exclusive.
			Slicing an array doesn't allocate a new array.
			In low-level terms, an array is just a pointer and size,
			and slicing it changes the pointer and size without changing the data.

	section
		h3 mut-arr

		p.
			The <code class="struct-ref">mut-arr</code> type is like <code class="struct-ref">arr</code>
			but <code class="keyword">mut</code>.
			It has mutable contents, but the size is not mutable,
			so it's mostly useful for implementing other data structures.

		crow-runnable(src="mut-arr")
		p.
			<code class="struct-ref">opt</code> and <code class="struct-ref">arr</code>
			are the only auto-imported collections; all others need to be explicitly imported.

		h4 set-subscript
		p.
			The syntax <code>ingredients[2] := "chocolate"</code> is short for
			<code>ingredients set-subscript 2, "chocoloate"</code>.

		h4 conversion
		p.
			The <code class="fun-ref">arr</code> function imported from <code class="import">collection.mut-arr</code>
			converts to an <code class="struct-ref">arr</code>.
			<code class="struct-ref">arr</code> is immutable, so this creates a copy.

			Since it's also just a pointer and size, <code class="struct-ref">mut-arr</code> can be sliced just like
			<code class="struct-ref">arr</code>, and the slice will share the same mutable data.
			(If you don't want that, there's a <code class="fun-ref">copy</code> function.)

	section
		h3 mut-list

		p.
			<code class="struct-ref">mut-list</code> is like <code class="struct-ref">mut-arr</code>
			but with mutable size.
			(It retains an excess capacity, so not every increase to the size requires a new allocation.)

		crow-runnable(src="mut-list")

		p.
			Like all collections, there's a function <code class="fun-ref">mut-list</code>
			to conert from <code class="struct-ref">arr</code>;
			it can also take no arguments for an empty <code class="fun-ref">mut-arr</code>.

			The <code class="fun-ref">~=</code> operator pushes elements; it can take one or multiple.

			In addition to being useful for mutable data,
			<code class="struct-ref">mut-arr</code> is a more efficient alternative to building an
			<code class="struct-ref">arr</code> by concatenation.

			The <code class="fun-ref">move-to-arr!</code> function converts to an immutable array.
			To ensure it is immutable, the original <code class="fun-ref">mut-arr</code>
			loses its reference to it and becomes empty.

	section
		h3 set and mut-set
		p.
			A <code class="struct-ref">set</code> is like an <code class="struct-ref">arr</code>
			that only stores each element once.
			You can test for whether a value is in the set using the syntax <code>set[value]</code>.

		crow-runnable(src="set")
		p.
			Following the usual pattern, there's a <code class="struct-ref">mut-set</code> type,
			a <code class="fun-ref">~=</code> function to add values,
			and <code class="run-ref">move-to-set!</code> to make it immutable.

	section
		h3 dict and mut-dict
		p.
			A <code class="struct-ref">dict</code> gets you from a <em>key</em> to a value <em>value</em>.
			A <code class="struct-ref">mut-dict</code> is a mutable version.

		crow-runnable(src="dict")

		p.
			Creating a literal <code class="struct-ref">dict</code> reuses
			<code class="fun-ref">-></code> as a key-value pair.
			<br />

			The keys must be <code class="spec-ref">data</code> (even for a <code class="struct-ref">mut-dict</code>);
			the values may be any type.

			Other than that, these follow the usual pattern for collections.
